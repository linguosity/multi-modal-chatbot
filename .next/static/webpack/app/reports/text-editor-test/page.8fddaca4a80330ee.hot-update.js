"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/reports/text-editor-test/page",{

/***/ "(app-pages-browser)/./src/lib/docx-generator.ts":
/*!***********************************!*\
  !*** ./src/lib/docx-generator.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateDocxFromTemplate: () => (/* binding */ generateDocxFromTemplate),\n/* harmony export */   generateReportDocx: () => (/* binding */ generateReportDocx)\n/* harmony export */ });\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! docxtemplater */ \"(app-pages-browser)/./node_modules/docxtemplater/js/docxtemplater.js\");\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(docxtemplater__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pizzip */ \"(app-pages-browser)/./node_modules/pizzip/js/index.js\");\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pizzip__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! file-saver */ \"(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n/**\n * Generate a docx file from a template and data\n * @param templateBuffer - The binary template file as an ArrayBuffer\n * @param data - The data to inject into the template\n * @param outputFilename - The name of the file to save\n * @param debugMode - Whether to enable extra debugging information\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateDocxFromTemplate(templateBuffer, data) {\n    let outputFilename = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'report.docx', debugMode = arguments.length > 3 && arguments[3] !== void 0 // Enable debug mode by default to help diagnose template issues\n     ? arguments[3] : true;\n    try {\n        console.log(\"Attempting to create PizZip instance with buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n        // Output debug information if debug mode is enabled\n        if (debugMode) {\n            console.log('Data being passed to template:', JSON.stringify(data, null, 2));\n            console.log('Template buffer size:', templateBuffer.byteLength);\n            // Log the first 20 bytes of the template to verify it's a proper DOCX file\n            const firstBytes = new Uint8Array(templateBuffer.slice(0, 20));\n            console.log('First 20 bytes of template (hex):', Array.from(firstBytes).map((b)=>b.toString(16).padStart(2, '0')).join(' '));\n        }\n        // Validate that we have a proper buffer\n        if (!templateBuffer || templateBuffer.byteLength === 0) {\n            throw new Error('Invalid template buffer: Empty or undefined');\n        }\n        // Verify the buffer has a ZIP signature (first bytes of a proper DOCX/ZIP file)\n        const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n        if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n            console.error('Invalid ZIP file signature in template. First bytes:', Array.from(firstBytes));\n            throw new Error('The template does not appear to be a valid ZIP/DOCX file (missing PK signature)');\n        }\n        // Create a new PizZip instance with the template content\n        // Use a try-catch specifically for the PizZip instantiation\n        let zip;\n        try {\n            // Convert ArrayBuffer to Uint8Array to ensure proper binary handling\n            const arrayBuffer = new Uint8Array(templateBuffer);\n            zip = new (pizzip__WEBPACK_IMPORTED_MODULE_1___default())(arrayBuffer);\n            // If in debug mode, examine the structure of the document\n            if (debugMode) {\n                console.log('PizZip opened successfully, inspecting contents:');\n                // List all files in the DOCX (which is a ZIP)\n                const files = Object.keys(zip.files);\n                console.log(\"DOCX contains \".concat(files.length, \" files:\"));\n                // Log the document structure (first 10 files)\n                files.slice(0, 10).forEach((file)=>{\n                    const fileEntry = zip.files[file];\n                    console.log(\" - \".concat(file, \" (\").concat(fileEntry.name, \", size: \").concat(fileEntry._data ? fileEntry._data.length : 'unknown', \" bytes)\"));\n                });\n                // Specifically check for document.xml (main content file)\n                if (zip.files['word/document.xml']) {\n                    try {\n                        const documentContent = zip.files['word/document.xml'].asText();\n                        // Log a snippet of the document.xml for template debugging\n                        const snippet = documentContent.substring(0, 500) + '... [truncated]';\n                        console.log('Document content preview:', snippet);\n                        // Look for template tag patterns\n                        const tagMatches = documentContent.match(/\\{[^{}]+\\}/g);\n                        if (tagMatches && tagMatches.length > 0) {\n                            console.log(\"Found \".concat(tagMatches.length, \" template tags:\"), tagMatches.slice(0, 20));\n                        } else {\n                            console.warn('No template tags found in document.xml - template may not be properly set up!');\n                        }\n                    } catch (documentError) {\n                        console.error('Error examining document.xml:', documentError);\n                    }\n                } else {\n                    console.warn('No word/document.xml found in the template - invalid DOCX structure!');\n                }\n            }\n        } catch (zipError) {\n            console.error('Error creating PizZip instance:', zipError);\n            throw new Error(\"Failed to create ZIP from template: \".concat(zipError instanceof Error ? zipError.message : 'Unknown error'));\n        }\n        console.log('PizZip instance created successfully');\n        // Create a new Docxtemplater instance with improved error handling\n        let doc;\n        try {\n            // Add modules and options for better error handling and debugging\n            doc = new (docxtemplater__WEBPACK_IMPORTED_MODULE_0___default())(zip, {\n                paragraphLoop: true,\n                linebreaks: true,\n                errorLogging: true,\n                // Better handling of missing/null values\n                nullGetter: function(part) {\n                    if (debugMode) {\n                        console.log('Null value encountered for tag:', part);\n                    }\n                    if (!part.module) {\n                        return \"\";\n                    }\n                    if (part.module === \"rawxml\") {\n                        return \"\";\n                    }\n                    return \"\";\n                },\n                // Parse options for more flexibility\n                delimiters: {\n                    start: '{',\n                    end: '}' // Default closing delimiter\n                },\n                // Track detailed tag information for debugging\n                parser: (tag)=>{\n                    if (debugMode) {\n                        console.log('Parsing tag:', tag);\n                    }\n                    return {\n                        get: (scope)=>{\n                            var _scope_tag;\n                            const result = (_scope_tag = scope[tag]) !== null && _scope_tag !== void 0 ? _scope_tag : '';\n                            if (debugMode && (result === undefined || result === null)) {\n                                console.warn(\"Tag '\".concat(tag, \"' resolved to undefined/null value\"));\n                            }\n                            return result;\n                        }\n                    };\n                }\n            });\n            console.log('Docxtemplater instance created successfully');\n        } catch (docxError) {\n            console.error('Error creating Docxtemplater instance:', docxError);\n            // Special handling for Multi error (which contains multiple errors)\n            if (docxError && docxError.properties && docxError.properties.errors) {\n                var _firstError_properties;\n                console.log('Docxtemplater reported multiple errors:');\n                // Log each individual error for debugging\n                docxError.properties.errors.forEach((error, index)=>{\n                    console.log(\"Error \".concat(index + 1, \":\"), error);\n                    // Log detailed information if available\n                    if (error.properties) {\n                        if (error.properties.explanation) {\n                            console.log(\"Explanation: \".concat(error.properties.explanation));\n                        }\n                        if (error.properties.id) {\n                            console.log(\"Error ID: \".concat(error.properties.id));\n                        }\n                        if (error.properties.xtag) {\n                            console.log(\"Tag with error: \".concat(error.properties.xtag));\n                        }\n                        if (error.properties.postparsed) {\n                            console.log('Template structure around error:');\n                            console.log(error.properties.postparsed.slice(Math.max(0, error.properties.offset - 5), error.properties.offset + 5));\n                        }\n                    }\n                });\n                // Throw a more detailed error\n                const firstError = docxError.properties.errors[0] || {};\n                const explanation = ((_firstError_properties = firstError.properties) === null || _firstError_properties === void 0 ? void 0 : _firstError_properties.explanation) || 'Unknown template issues';\n                throw new Error(\"Template errors detected: \".concat(explanation, \" (See console for full details)\"));\n            }\n            throw new Error(\"Failed to create Docxtemplater: \".concat(docxError instanceof Error ? docxError.message : 'Unknown error'));\n        }\n        try {\n            // Render the document with the provided data\n            doc.render(data);\n            console.log('Template rendered with data');\n        } catch (renderError) {\n            console.error('Error rendering template:', renderError);\n            // Special handling for Multi error (which contains multiple errors)\n            if (renderError && renderError.properties && renderError.properties.errors) {\n                var _firstError_properties1;\n                console.log('Docxtemplater reported multiple render errors:');\n                // Log each individual error for debugging\n                renderError.properties.errors.forEach((error, index)=>{\n                    console.log(\"Render Error \".concat(index + 1, \":\"), error);\n                    // Log detailed information if available\n                    if (error.properties) {\n                        if (error.properties.explanation) {\n                            console.log(\"Explanation: \".concat(error.properties.explanation));\n                        }\n                        if (error.properties.id) {\n                            console.log(\"Error ID: \".concat(error.properties.id));\n                        }\n                        if (error.properties.xtag) {\n                            console.log(\"Tag with error: \".concat(error.properties.xtag));\n                        }\n                        // Log the data path that caused the issue if known\n                        if (error.properties.tag) {\n                            console.log(\"Template tag: \".concat(error.properties.tag));\n                            console.log(\"Raw tag: \".concat(error.properties.raw));\n                        }\n                    }\n                });\n                // Throw a more detailed error\n                const firstError = renderError.properties.errors[0] || {};\n                const explanation = ((_firstError_properties1 = firstError.properties) === null || _firstError_properties1 === void 0 ? void 0 : _firstError_properties1.explanation) || 'Unknown template rendering issues';\n                throw new Error(\"Template rendering errors: \".concat(explanation, \" (See console for full details)\"));\n            }\n            // Special handling for individual Docxtemplater errors with properties\n            if (renderError instanceof Error && 'properties' in renderError) {\n                const props = renderError.properties || {};\n                console.log('Detailed render error properties:', props);\n                throw new Error(\"Template render error: \".concat(props.explanation || renderError.message));\n            }\n            throw new Error(\"Failed to render template: \".concat(renderError instanceof Error ? renderError.message : 'Unknown error'));\n        }\n        // Generate the output document\n        let output;\n        try {\n            output = doc.getZip().generate({\n                type: 'blob',\n                compression: 'DEFLATE',\n                mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n            });\n            console.log(\"Output document generated successfully (\".concat(output.size, \" bytes)\"));\n        } catch (genError) {\n            console.error('Error generating output document:', genError);\n            throw new Error(\"Failed to generate output: \".concat(genError instanceof Error ? genError.message : 'Unknown error'));\n        }\n        // If running in browser, save the file\n        if (true) {\n            try {\n                (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(output, outputFilename);\n                console.log(\"File saved as \".concat(outputFilename));\n            } catch (saveError) {\n                console.error('Error saving file:', saveError);\n                throw new Error(\"Failed to save file: \".concat(saveError instanceof Error ? saveError.message : 'Unknown error'));\n            }\n        }\n        return output;\n    } catch (error) {\n        console.error('Error in generateDocxFromTemplate:', error);\n        // If it's a PizZip error (likely invalid template)\n        if (error instanceof Error && error.message.includes('zip')) {\n            console.error('PizZip error - invalid template file structure');\n            throw new Error(\"Template file is not a valid DOCX/ZIP file: \".concat(error.message));\n        }\n        // Rethrow the error\n        throw error;\n    }\n}\n/**\n * Generate a fallback HTML report when DOCX template fails\n * @param reportData - The report data to export\n * @returns A blob with HTML content\n */ function generateFallbackHtmlReport(reportData) {\n    var _reportData_header_studentInformation, _reportData_header, _reportData_header_studentInformation1, _reportData_header1, _reportData_header_studentInformation2, _reportData_header2, _reportData_header3, _reportData_assessmentResults, _reportData_conclusion;\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \" \").concat(reportData.header.studentInformation.lastName) : 'Student';\n    // Create a simple HTML representation of the report\n    let html = '\\n    <!DOCTYPE html>\\n    <html>\\n    <head>\\n      <meta charset=\"utf-8\">\\n      <title>Report for '.concat(studentName, \"</title>\\n      <style>\\n        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }\\n        h1, h2, h3 { color: #444; }\\n        .section { margin-bottom: 30px; }\\n        .domain { margin-bottom: 20px; padding: 15px; border: 1px solid #eee; }\\n        .domain-header { display: flex; justify-content: space-between; align-items: center; }\\n        .concern { color: #f59e0b; font-size: 14px; }\\n        .no-concern { color: #10b981; font-size: 14px; }\\n        ul { margin-top: 5px; }\\n        @media print {\\n          body { margin: 0.5in; }\\n          .domain { break-inside: avoid; }\\n        }\\n      </style>\\n    </head>\\n    <body>\\n      <h1>Report for \").concat(studentName, '</h1>\\n      <div class=\"section\">\\n        <h2>Student Information</h2>\\n        <p><strong>DOB:</strong> ').concat(((_reportData_header1 = reportData.header) === null || _reportData_header1 === void 0 ? void 0 : (_reportData_header_studentInformation1 = _reportData_header1.studentInformation) === null || _reportData_header_studentInformation1 === void 0 ? void 0 : _reportData_header_studentInformation1.DOB) || 'N/A', \"</p>\\n        <p><strong>Report Date:</strong> \").concat(((_reportData_header2 = reportData.header) === null || _reportData_header2 === void 0 ? void 0 : (_reportData_header_studentInformation2 = _reportData_header2.studentInformation) === null || _reportData_header_studentInformation2 === void 0 ? void 0 : _reportData_header_studentInformation2.reportDate) || 'N/A', \"</p>\\n        <p><strong>Reason for Referral:</strong> \").concat(((_reportData_header3 = reportData.header) === null || _reportData_header3 === void 0 ? void 0 : _reportData_header3.reasonForReferral) || 'N/A', \"</p>\\n      </div>\\n  \");\n    // Add domains section\n    if ((_reportData_assessmentResults = reportData.assessmentResults) === null || _reportData_assessmentResults === void 0 ? void 0 : _reportData_assessmentResults.domains) {\n        html += '<div class=\"section\"><h2>Assessment Results</h2>';\n        Object.entries(reportData.assessmentResults.domains).forEach((param)=>{\n            let [domainName, domain] = param;\n            var _domain_strengths, _domain_needs;\n            if (domain.topicSentence || ((_domain_strengths = domain.strengths) === null || _domain_strengths === void 0 ? void 0 : _domain_strengths.length) || ((_domain_needs = domain.needs) === null || _domain_needs === void 0 ? void 0 : _domain_needs.length)) {\n                var _domain_strengths1, _domain_needs1;\n                html += '\\n          <div class=\"domain\">\\n            <div class=\"domain-header\">\\n              <h3>'.concat(domainName.charAt(0).toUpperCase() + domainName.slice(1), \" Language</h3>\\n              \").concat(domain.isConcern !== undefined ? '<span class=\"'.concat(domain.isConcern ? 'concern' : 'no-concern', '\">').concat(domain.isConcern ? 'Area of Concern' : 'No Concern', \"</span>\") : '', \"\\n            </div>\\n            \").concat(domain.topicSentence ? \"<p>\".concat(domain.topicSentence, \"</p>\") : '', \"\\n            \\n            \").concat(((_domain_strengths1 = domain.strengths) === null || _domain_strengths1 === void 0 ? void 0 : _domain_strengths1.length) ? \"\\n              <h4>Strengths:</h4>\\n              <ul>\\n                \".concat(domain.strengths.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(((_domain_needs1 = domain.needs) === null || _domain_needs1 === void 0 ? void 0 : _domain_needs1.length) ? \"\\n              <h4>Needs:</h4>\\n              <ul>\\n                \".concat(domain.needs.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(domain.impactStatement ? \"\\n              <h4>Educational Impact:</h4>\\n              <p>\".concat(domain.impactStatement, \"</p>\\n            \") : '', \"\\n          </div>\\n        \");\n            }\n        });\n        html += \"</div>\";\n    }\n    // Add recommendations\n    if ((_reportData_conclusion = reportData.conclusion) === null || _reportData_conclusion === void 0 ? void 0 : _reportData_conclusion.recommendations) {\n        var _reportData_conclusion_recommendations_accommodations, _reportData_conclusion_recommendations_facilitationStrategies;\n        html += '\\n      <div class=\"section\">\\n        <h2>Recommendations</h2>\\n        '.concat(((_reportData_conclusion_recommendations_accommodations = reportData.conclusion.recommendations.accommodations) === null || _reportData_conclusion_recommendations_accommodations === void 0 ? void 0 : _reportData_conclusion_recommendations_accommodations.length) ? \"\\n          <h3>Accommodations:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.accommodations.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n        \\n        \").concat(((_reportData_conclusion_recommendations_facilitationStrategies = reportData.conclusion.recommendations.facilitationStrategies) === null || _reportData_conclusion_recommendations_facilitationStrategies === void 0 ? void 0 : _reportData_conclusion_recommendations_facilitationStrategies.length) ? \"\\n          <h3>Facilitation Strategies:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.facilitationStrategies.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n      </div>\\n    \");\n    }\n    html += \"\\n      <footer>\\n        <p><em>This is a fallback HTML report generated because the DOCX template could not be processed. \\n        You can print this HTML file to create a PDF.</em></p>\\n      </footer>\\n    </body>\\n    </html>\\n  \";\n    return new Blob([\n        html\n    ], {\n        type: 'text/html'\n    });\n}\n/**\n * Create a simple empty DOCX template programmatically\n * This is a last-resort fallback when all template files fail to load\n */ function createEmptyTemplate() {\n    // Define a minimal valid DOCX file structure as a base64 string\n    // This is a simplified empty DOCX file with minimal content\n    const minimalDocxBase64 = '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';\n    // Convert base64 to ArrayBuffer\n    const binaryString = window.atob(minimalDocxBase64);\n    const bytes = new Uint8Array(binaryString.length);\n    for(let i = 0; i < binaryString.length; i++){\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n/**\n * Generate a report docx from the report data\n * @param reportData - The report data from the application\n * @param templateBuffer - The binary template file as an ArrayBuffer (optional)\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateReportDocx(reportData, templateBuffer) {\n    var _reportData_header_studentInformation, _reportData_header;\n    // Generate the filename based on report data\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \"_\").concat(reportData.header.studentInformation.lastName) : 'student';\n    const timestamp = new Date().toISOString().split('T')[0];\n    const filename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".docx\");\n    try {\n        // If no template buffer is provided, use a default template\n        if (!templateBuffer) {\n            // Use fetch to get the template if we're in the browser\n            if (true) {\n                try {\n                    console.log('No template buffer provided, fetching default template');\n                    // Try to use response.arrayBuffer() which ensures binary data handling\n                    // Use las-assessment-report-template.docx instead of report-template.docx (which is a text file, not a DOCX)\n                    const response = await fetch('/templates/las-assessment-report-template.docx', {\n                        method: 'GET',\n                        cache: 'no-cache',\n                        headers: {\n                            'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                            'Cache-Control': 'no-cache'\n                        }\n                    });\n                    if (!response.ok) {\n                        throw new Error(\"Failed to fetch default template: \".concat(response.status));\n                    }\n                    console.log('Default template fetched successfully');\n                    templateBuffer = await response.arrayBuffer();\n                    console.log(\"Default template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                    if (templateBuffer.byteLength === 0) {\n                        throw new Error('Default template file is empty');\n                    }\n                    // Verify the template has a proper DOCX signature\n                    const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                    if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n                        console.error('Invalid DOCX file signature in default template. First bytes:', Array.from(firstBytes));\n                        throw new Error('Default template is not a valid DOCX file');\n                    }\n                } catch (error) {\n                    console.error('Error loading default template:', error);\n                    // Try alternative template as a last resort\n                    try {\n                        console.log('Attempting to load alternative template: las-assessment-report-template-fixed.docx');\n                        const altResponse = await fetch('/templates/las-assessment-report-template-fixed.docx', {\n                            cache: 'no-cache',\n                            headers: {\n                                'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                                'Cache-Control': 'no-cache'\n                            }\n                        });\n                        if (!altResponse.ok) {\n                            throw new Error(\"Failed to fetch alternative template: \".concat(altResponse.status));\n                        }\n                        templateBuffer = await altResponse.arrayBuffer();\n                        console.log(\"Alternative template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        // Verify the alternative template\n                        const altFirstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                        if (!(altFirstBytes[0] === 0x50 && altFirstBytes[1] === 0x4B)) {\n                            console.error('Invalid DOCX file signature in alternative template');\n                            throw new Error('Alternative template is not a valid DOCX file');\n                        }\n                    } catch (altError) {\n                        console.error('Error loading alternative template:', altError);\n                        // As a last resort, create a minimal valid DOCX template\n                        console.log('Creating minimal empty DOCX template');\n                        templateBuffer = createEmptyTemplate();\n                        console.log(\"Created minimal template with size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        if (!templateBuffer || templateBuffer.byteLength === 0) {\n                            // All template attempts failed, fall back to HTML\n                            throw new Error('All template attempts failed');\n                        }\n                    }\n                }\n            } else {}\n        }\n        // Format and prepare data for the template\n        const formattedData = formatReportDataForDocx(reportData);\n        console.log('Data formatted for DOCX template');\n        // First try with the provided template\n        try {\n            // Try with the provided/fetched template\n            console.log('Attempting to generate DOCX with primary template');\n            return await generateDocxFromTemplate(templateBuffer, formattedData, filename);\n        } catch (templateError) {\n            console.error('Error using the provided template:', templateError);\n            // If there's a Multi error or other template parsing issue, \n            // try with a minimal template that doesn't rely on complex formatting\n            if (templateError instanceof Error && (templateError.message.includes('Multi error') || templateError.message.includes('template') || templateError.message.includes('parsing'))) {\n                console.warn('Template has parsing errors, attempting to use minimal template...');\n                // Use the createEmptyTemplate function to generate a minimal template\n                try {\n                    console.log('Creating minimal empty DOCX template');\n                    const minimalTemplateBuffer = createEmptyTemplate();\n                    console.log(\"Minimal template created (\".concat(minimalTemplateBuffer.byteLength, \" bytes)\"));\n                    // Try again with the minimal template\n                    return await generateDocxFromTemplate(minimalTemplateBuffer, formattedData, filename);\n                } catch (minimalError) {\n                    console.error('Error with minimal template:', minimalError);\n                    // Let the outer catch handle the fallback to HTML\n                    throw minimalError;\n                }\n            } else {\n                // Rethrow to let the outer catch handle it\n                throw templateError;\n            }\n        }\n    } catch (error) {\n        console.error('Error in generateReportDocx:', error);\n        // If all DOCX generation attempts failed, fall back to HTML\n        console.warn('All DOCX generation attempts failed, falling back to HTML export');\n        const htmlBlob = generateFallbackHtmlReport(reportData);\n        const htmlFilename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".html\");\n        if (true) {\n            (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(htmlBlob, htmlFilename);\n        }\n        return htmlBlob;\n    }\n}\n/**\n * Format the report data for docx template rendering\n * @param reportData - The raw report data from the application\n * @returns Formatted data ready for docx template\n */ function formatReportDataForDocx(reportData) {\n    var _formattedData_assessmentResults, _formattedData_conclusion_recommendations, _formattedData_conclusion, _formattedData_conclusion1, _formattedData_conclusion_recommendations1, _formattedData_conclusion2, _formattedData_conclusion3, _formattedData_header_studentInformation, _formattedData_header, _formattedData_header1, _formattedData_header_studentInformation1, _formattedData_header2, _formattedData_header3;\n    // Create a deep copy of the report data\n    const formattedData = JSON.parse(JSON.stringify(reportData));\n    // Format arrays to be more docx-template friendly\n    // Arrays in docxtemplater are typically handled with loops, so we'll format them\n    // to be ready for the template syntax\n    // Process strength and needs lists for each domain\n    Object.keys(((_formattedData_assessmentResults = formattedData.assessmentResults) === null || _formattedData_assessmentResults === void 0 ? void 0 : _formattedData_assessmentResults.domains) || {}).forEach((domain)=>{\n        const domainData = formattedData.assessmentResults.domains[domain];\n        // Format strengths as bullet points for DOCX\n        if (Array.isArray(domainData.strengths) && domainData.strengths.length > 0) {\n            domainData.strengthsList = domainData.strengths.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.strengthsList = [];\n        }\n        // Format needs as bullet points for DOCX\n        if (Array.isArray(domainData.needs) && domainData.needs.length > 0) {\n            domainData.needsList = domainData.needs.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.needsList = [];\n        }\n    });\n    // Format accommodation and facilitation strategies\n    if (Array.isArray((_formattedData_conclusion = formattedData.conclusion) === null || _formattedData_conclusion === void 0 ? void 0 : (_formattedData_conclusion_recommendations = _formattedData_conclusion.recommendations) === null || _formattedData_conclusion_recommendations === void 0 ? void 0 : _formattedData_conclusion_recommendations.accommodations)) {\n        formattedData.conclusion.recommendations.accommodationsList = formattedData.conclusion.recommendations.accommodations.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion1 = formattedData.conclusion) === null || _formattedData_conclusion1 === void 0 ? void 0 : _formattedData_conclusion1.recommendations) {\n        formattedData.conclusion.recommendations.accommodationsList = [];\n    }\n    if (Array.isArray((_formattedData_conclusion2 = formattedData.conclusion) === null || _formattedData_conclusion2 === void 0 ? void 0 : (_formattedData_conclusion_recommendations1 = _formattedData_conclusion2.recommendations) === null || _formattedData_conclusion_recommendations1 === void 0 ? void 0 : _formattedData_conclusion_recommendations1.facilitationStrategies)) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = formattedData.conclusion.recommendations.facilitationStrategies.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion3 = formattedData.conclusion) === null || _formattedData_conclusion3 === void 0 ? void 0 : _formattedData_conclusion3.recommendations) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = [];\n    }\n    // Convert parents array to string if needed\n    if (Array.isArray((_formattedData_header = formattedData.header) === null || _formattedData_header === void 0 ? void 0 : (_formattedData_header_studentInformation = _formattedData_header.studentInformation) === null || _formattedData_header_studentInformation === void 0 ? void 0 : _formattedData_header_studentInformation.parents)) {\n        formattedData.header.studentInformation.parentsString = formattedData.header.studentInformation.parents.join(', ');\n    } else if ((_formattedData_header1 = formattedData.header) === null || _formattedData_header1 === void 0 ? void 0 : _formattedData_header1.studentInformation) {\n        formattedData.header.studentInformation.parentsString = '';\n    }\n    // Add full student name for convenience\n    if ((_formattedData_header2 = formattedData.header) === null || _formattedData_header2 === void 0 ? void 0 : (_formattedData_header_studentInformation1 = _formattedData_header2.studentInformation) === null || _formattedData_header_studentInformation1 === void 0 ? void 0 : _formattedData_header_studentInformation1.firstName) {\n        formattedData.header.studentInformation.fullName = \"\".concat(formattedData.header.studentInformation.firstName, \" \").concat(formattedData.header.studentInformation.lastName || '');\n    } else if ((_formattedData_header3 = formattedData.header) === null || _formattedData_header3 === void 0 ? void 0 : _formattedData_header3.studentInformation) {\n        formattedData.header.studentInformation.fullName = 'Student';\n    }\n    return formattedData;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZG9jeC1nZW5lcmF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMEM7QUFDZDtBQUNRO0FBRXBDOzs7Ozs7O0NBT0MsR0FDTSxlQUFlRyx5QkFDcEJDLGNBQTJCLEVBQzNCQyxJQUF5QjtRQUN6QkMsaUJBQUFBLGlFQUF5QixlQUN6QkMsWUFBQUEsZ0RBQTBCLGdFQUFnRTtzQkFBckU7SUFFckIsSUFBSTtRQUNGQyxRQUFRQyxHQUFHLENBQUMsMERBQW9GLE9BQTFCTCxlQUFlTSxVQUFVLEVBQUM7UUFFaEcsb0RBQW9EO1FBQ3BELElBQUlILFdBQVc7WUFDYkMsUUFBUUMsR0FBRyxDQUFDLGtDQUFrQ0UsS0FBS0MsU0FBUyxDQUFDUCxNQUFNLE1BQU07WUFDekVHLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJMLGVBQWVNLFVBQVU7WUFDOUQsMkVBQTJFO1lBQzNFLE1BQU1HLGFBQWEsSUFBSUMsV0FBV1YsZUFBZVcsS0FBSyxDQUFDLEdBQUc7WUFDMURQLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUNPLE1BQU1DLElBQUksQ0FBQ0osWUFBWUssR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDO1FBQ3pIO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQ2xCLGtCQUFrQkEsZUFBZU0sVUFBVSxLQUFLLEdBQUc7WUFDdEQsTUFBTSxJQUFJYSxNQUFNO1FBQ2xCO1FBRUEsZ0ZBQWdGO1FBQ2hGLE1BQU1WLGFBQWEsSUFBSUMsV0FBV1YsZUFBZVcsS0FBSyxDQUFDLEdBQUc7UUFDMUQsSUFBSSxDQUFFRixDQUFBQSxVQUFVLENBQUMsRUFBRSxLQUFLLFFBQVFBLFVBQVUsQ0FBQyxFQUFFLEtBQUssSUFBRyxHQUFJO1lBQ3ZETCxRQUFRZ0IsS0FBSyxDQUFDLHdEQUF3RFIsTUFBTUMsSUFBSSxDQUFDSjtZQUNqRixNQUFNLElB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RCxjQUFjcEQsTUFBTSxDQUFDQyxrQkFBa0IsQ0FBQ0UsUUFBUSxJQUFJO0lBQ2hILE9BQU8sS0FBSWlELHlCQUFBQSxjQUFjcEQsTUFBTSxjQUFwQm9ELDZDQUFBQSx1QkFBc0JuRCxrQkFBa0IsRUFBRTtRQUNuRG1ELGNBQWNwRCxNQUFNLENBQUNDLGtCQUFrQixDQUFDb0UsUUFBUSxHQUFHO0lBQ3JEO0lBRUEsT0FBT2pCO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvc3JjL2xpYi9kb2N4LWdlbmVyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRG9jeHRlbXBsYXRlciBmcm9tICdkb2N4dGVtcGxhdGVyJztcbmltcG9ydCBQaXpaaXAgZnJvbSAncGl6emlwJztcbmltcG9ydCB7IHNhdmVBcyB9IGZyb20gJ2ZpbGUtc2F2ZXInO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZG9jeCBmaWxlIGZyb20gYSB0ZW1wbGF0ZSBhbmQgZGF0YVxuICogQHBhcmFtIHRlbXBsYXRlQnVmZmVyIC0gVGhlIGJpbmFyeSB0ZW1wbGF0ZSBmaWxlIGFzIGFuIEFycmF5QnVmZmVyXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIGluamVjdCBpbnRvIHRoZSB0ZW1wbGF0ZVxuICogQHBhcmFtIG91dHB1dEZpbGVuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gc2F2ZVxuICogQHBhcmFtIGRlYnVnTW9kZSAtIFdoZXRoZXIgdG8gZW5hYmxlIGV4dHJhIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGdlbmVyYXRlZCBmaWxlIGFzIGEgQmxvYlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVEb2N4RnJvbVRlbXBsYXRlKFxuICB0ZW1wbGF0ZUJ1ZmZlcjogQXJyYXlCdWZmZXIsXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIG91dHB1dEZpbGVuYW1lOiBzdHJpbmcgPSAncmVwb3J0LmRvY3gnLFxuICBkZWJ1Z01vZGU6IGJvb2xlYW4gPSB0cnVlIC8vIEVuYWJsZSBkZWJ1ZyBtb2RlIGJ5IGRlZmF1bHQgdG8gaGVscCBkaWFnbm9zZSB0ZW1wbGF0ZSBpc3N1ZXNcbik6IFByb21pc2U8QmxvYj4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIGNyZWF0ZSBQaXpaaXAgaW5zdGFuY2Ugd2l0aCBidWZmZXIgc2l6ZTogJHt0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlc2ApO1xuICAgIFxuICAgIC8vIE91dHB1dCBkZWJ1ZyBpbmZvcm1hdGlvbiBpZiBkZWJ1ZyBtb2RlIGlzIGVuYWJsZWRcbiAgICBpZiAoZGVidWdNb2RlKSB7XG4gICAgICBjb25zb2xlLmxvZygnRGF0YSBiZWluZyBwYXNzZWQgdG8gdGVtcGxhdGU6JywgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xuICAgICAgY29uc29sZS5sb2coJ1RlbXBsYXRlIGJ1ZmZlciBzaXplOicsIHRlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgLy8gTG9nIHRoZSBmaXJzdCAyMCBieXRlcyBvZiB0aGUgdGVtcGxhdGUgdG8gdmVyaWZ5IGl0J3MgYSBwcm9wZXIgRE9DWCBmaWxlXG4gICAgICBjb25zdCBmaXJzdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGVtcGxhdGVCdWZmZXIuc2xpY2UoMCwgMjApKTtcbiAgICAgIGNvbnNvbGUubG9nKCdGaXJzdCAyMCBieXRlcyBvZiB0ZW1wbGF0ZSAoaGV4KTonLCBBcnJheS5mcm9tKGZpcnN0Qnl0ZXMpLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJyAnKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIHRoYXQgd2UgaGF2ZSBhIHByb3BlciBidWZmZXJcbiAgICBpZiAoIXRlbXBsYXRlQnVmZmVyIHx8IHRlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0ZW1wbGF0ZSBidWZmZXI6IEVtcHR5IG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIGJ1ZmZlciBoYXMgYSBaSVAgc2lnbmF0dXJlIChmaXJzdCBieXRlcyBvZiBhIHByb3BlciBET0NYL1pJUCBmaWxlKVxuICAgIGNvbnN0IGZpcnN0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlci5zbGljZSgwLCA0KSk7XG4gICAgaWYgKCEoZmlyc3RCeXRlc1swXSA9PT0gMHg1MCAmJiBmaXJzdEJ5dGVzWzFdID09PSAweDRCKSkge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBaSVAgZmlsZSBzaWduYXR1cmUgaW4gdGVtcGxhdGUuIEZpcnN0IGJ5dGVzOicsIEFycmF5LmZyb20oZmlyc3RCeXRlcykpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdGVtcGxhdGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgdmFsaWQgWklQL0RPQ1ggZmlsZSAobWlzc2luZyBQSyBzaWduYXR1cmUpJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyBQaXpaaXAgaW5zdGFuY2Ugd2l0aCB0aGUgdGVtcGxhdGUgY29udGVudFxuICAgIC8vIFVzZSBhIHRyeS1jYXRjaCBzcGVjaWZpY2FsbHkgZm9yIHRoZSBQaXpaaXAgaW5zdGFudGlhdGlvblxuICAgIGxldCB6aXA7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnQgQXJyYXlCdWZmZXIgdG8gVWludDhBcnJheSB0byBlbnN1cmUgcHJvcGVyIGJpbmFyeSBoYW5kbGluZ1xuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlcik7XG4gICAgICB6aXAgPSBuZXcgUGl6WmlwKGFycmF5QnVmZmVyKTtcbiAgICAgIFxuICAgICAgLy8gSWYgaW4gZGVidWcgbW9kZSwgZXhhbWluZSB0aGUgc3RydWN0dXJlIG9mIHRoZSBkb2N1bWVudFxuICAgICAgaWYgKGRlYnVnTW9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnUGl6WmlwIG9wZW5lZCBzdWNjZXNzZnVsbHksIGluc3BlY3RpbmcgY29udGVudHM6Jyk7XG4gICAgICAgIFxuICAgICAgICAvLyBMaXN0IGFsbCBmaWxlcyBpbiB0aGUgRE9DWCAod2hpY2ggaXMgYSBaSVApXG4gICAgICAgIGNvbnN0IGZpbGVzID0gT2JqZWN0LmtleXMoemlwLmZpbGVzKTtcbiAgICAgICAgY29uc29sZS5sb2coYERPQ1ggY29udGFpbnMgJHtmaWxlcy5sZW5ndGh9IGZpbGVzOmApO1xuICAgICAgICBcbiAgICAgICAgLy8gTG9nIHRoZSBkb2N1bWVudCBzdHJ1Y3R1cmUgKGZpcnN0IDEwIGZpbGVzKVxuICAgICAgICBmaWxlcy5zbGljZSgwLCAxMCkuZm9yRWFjaChmaWxlID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlRW50cnkgPSB6aXAuZmlsZXNbZmlsZV07XG4gICAgICAgICAgY29uc29sZS5sb2coYCAtICR7ZmlsZX0gKCR7ZmlsZUVudHJ5Lm5hbWV9LCBzaXplOiAke2ZpbGVFbnRyeS5fZGF0YSA/IGZpbGVFbnRyeS5fZGF0YS5sZW5ndGggOiAndW5rbm93bid9IGJ5dGVzKWApO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNwZWNpZmljYWxseSBjaGVjayBmb3IgZG9jdW1lbnQueG1sIChtYWluIGNvbnRlbnQgZmlsZSlcbiAgICAgICAgaWYgKHppcC5maWxlc1snd29yZC9kb2N1bWVudC54bWwnXSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudENvbnRlbnQgPSB6aXAuZmlsZXNbJ3dvcmQvZG9jdW1lbnQueG1sJ10uYXNUZXh0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIExvZyBhIHNuaXBwZXQgb2YgdGhlIGRvY3VtZW50LnhtbCBmb3IgdGVtcGxhdGUgZGVidWdnaW5nXG4gICAgICAgICAgICBjb25zdCBzbmlwcGV0ID0gZG9jdW1lbnRDb250ZW50LnN1YnN0cmluZygwLCA1MDApICsgJy4uLiBbdHJ1bmNhdGVkXSc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRG9jdW1lbnQgY29udGVudCBwcmV2aWV3OicsIHNuaXBwZXQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBMb29rIGZvciB0ZW1wbGF0ZSB0YWcgcGF0dGVybnNcbiAgICAgICAgICAgIGNvbnN0IHRhZ01hdGNoZXMgPSBkb2N1bWVudENvbnRlbnQubWF0Y2goL1xce1tee31dK1xcfS9nKTtcbiAgICAgICAgICAgIGlmICh0YWdNYXRjaGVzICYmIHRhZ01hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHt0YWdNYXRjaGVzLmxlbmd0aH0gdGVtcGxhdGUgdGFnczpgLCB0YWdNYXRjaGVzLnNsaWNlKDAsIDIwKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIHRlbXBsYXRlIHRhZ3MgZm91bmQgaW4gZG9jdW1lbnQueG1sIC0gdGVtcGxhdGUgbWF5IG5vdCBiZSBwcm9wZXJseSBzZXQgdXAhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZG9jdW1lbnRFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZXhhbWluaW5nIGRvY3VtZW50LnhtbDonLCBkb2N1bWVudEVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdObyB3b3JkL2RvY3VtZW50LnhtbCBmb3VuZCBpbiB0aGUgdGVtcGxhdGUgLSBpbnZhbGlkIERPQ1ggc3RydWN0dXJlIScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoemlwRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIFBpelppcCBpbnN0YW5jZTonLCB6aXBFcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgWklQIGZyb20gdGVtcGxhdGU6ICR7emlwRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHppcEVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdQaXpaaXAgaW5zdGFuY2UgY3JlYXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBuZXcgRG9jeHRlbXBsYXRlciBpbnN0YW5jZSB3aXRoIGltcHJvdmVkIGVycm9yIGhhbmRsaW5nXG4gICAgbGV0IGRvYztcbiAgICB0cnkge1xuICAgICAgLy8gQWRkIG1vZHVsZXMgYW5kIG9wdGlvbnMgZm9yIGJldHRlciBlcnJvciBoYW5kbGluZyBhbmQgZGVidWdnaW5nXG4gICAgICBkb2MgPSBuZXcgRG9jeHRlbXBsYXRlcih6aXAsIHtcbiAgICAgICAgcGFyYWdyYXBoTG9vcDogdHJ1ZSxcbiAgICAgICAgbGluZWJyZWFrczogdHJ1ZSxcbiAgICAgICAgZXJyb3JMb2dnaW5nOiB0cnVlLFxuICAgICAgICAvLyBCZXR0ZXIgaGFuZGxpbmcgb2YgbWlzc2luZy9udWxsIHZhbHVlc1xuICAgICAgICBudWxsR2V0dGVyOiBmdW5jdGlvbihwYXJ0OiBhbnkpIHtcbiAgICAgICAgICBpZiAoZGVidWdNb2RlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTnVsbCB2YWx1ZSBlbmNvdW50ZXJlZCBmb3IgdGFnOicsIHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXBhcnQubW9kdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnQubW9kdWxlID09PSBcInJhd3htbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFBhcnNlIG9wdGlvbnMgZm9yIG1vcmUgZmxleGliaWxpdHlcbiAgICAgICAgZGVsaW1pdGVyczoge1xuICAgICAgICAgIHN0YXJ0OiAneycsICAvLyBEZWZhdWx0IG9wZW5pbmcgZGVsaW1pdGVyXG4gICAgICAgICAgZW5kOiAnfScgICAgIC8vIERlZmF1bHQgY2xvc2luZyBkZWxpbWl0ZXJcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVHJhY2sgZGV0YWlsZWQgdGFnIGluZm9ybWF0aW9uIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgcGFyc2VyOiAodGFnOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICBpZiAoZGVidWdNb2RlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUGFyc2luZyB0YWc6JywgdGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogKHNjb3BlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gc2NvcGVbdGFnXSA/PyAnJztcbiAgICAgICAgICAgICAgaWYgKGRlYnVnTW9kZSAmJiAocmVzdWx0ID09PSB1bmRlZmluZWQgfHwgcmVzdWx0ID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGFnICcke3RhZ30nIHJlc29sdmVkIHRvIHVuZGVmaW5lZC9udWxsIHZhbHVlYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKCdEb2N4dGVtcGxhdGVyIGluc3RhbmNlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgfSBjYXRjaCAoZG9jeEVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIERvY3h0ZW1wbGF0ZXIgaW5zdGFuY2U6JywgZG9jeEVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgTXVsdGkgZXJyb3IgKHdoaWNoIGNvbnRhaW5zIG11bHRpcGxlIGVycm9ycylcbiAgICAgIGlmIChkb2N4RXJyb3IgJiYgZG9jeEVycm9yLnByb3BlcnRpZXMgJiYgZG9jeEVycm9yLnByb3BlcnRpZXMuZXJyb3JzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdEb2N4dGVtcGxhdGVyIHJlcG9ydGVkIG11bHRpcGxlIGVycm9yczonKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExvZyBlYWNoIGluZGl2aWR1YWwgZXJyb3IgZm9yIGRlYnVnZ2luZ1xuICAgICAgICBkb2N4RXJyb3IucHJvcGVydGllcy5lcnJvcnMuZm9yRWFjaCgoZXJyb3I6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciAke2luZGV4ICsgMX06YCwgZXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEV4cGxhbmF0aW9uOiAke2Vycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcy5pZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgSUQ6ICR7ZXJyb3IucHJvcGVydGllcy5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLnh0YWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFRhZyB3aXRoIGVycm9yOiAke2Vycm9yLnByb3BlcnRpZXMueHRhZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLnBvc3RwYXJzZWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlbXBsYXRlIHN0cnVjdHVyZSBhcm91bmQgZXJyb3I6Jyk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yLnByb3BlcnRpZXMucG9zdHBhcnNlZC5zbGljZShNYXRoLm1heCgwLCBlcnJvci5wcm9wZXJ0aWVzLm9mZnNldCAtIDUpLCBlcnJvci5wcm9wZXJ0aWVzLm9mZnNldCArIDUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhyb3cgYSBtb3JlIGRldGFpbGVkIGVycm9yXG4gICAgICAgIGNvbnN0IGZpcnN0RXJyb3IgPSBkb2N4RXJyb3IucHJvcGVydGllcy5lcnJvcnNbMF0gfHwge307XG4gICAgICAgIGNvbnN0IGV4cGxhbmF0aW9uID0gZmlyc3RFcnJvci5wcm9wZXJ0aWVzPy5leHBsYW5hdGlvbiB8fCAnVW5rbm93biB0ZW1wbGF0ZSBpc3N1ZXMnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIGVycm9ycyBkZXRlY3RlZDogJHtleHBsYW5hdGlvbn0gKFNlZSBjb25zb2xlIGZvciBmdWxsIGRldGFpbHMpYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBEb2N4dGVtcGxhdGVyOiAke2RvY3hFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZG9jeEVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBSZW5kZXIgdGhlIGRvY3VtZW50IHdpdGggdGhlIHByb3ZpZGVkIGRhdGFcbiAgICAgIGRvYy5yZW5kZXIoZGF0YSk7XG4gICAgICBjb25zb2xlLmxvZygnVGVtcGxhdGUgcmVuZGVyZWQgd2l0aCBkYXRhJyk7XG4gICAgfSBjYXRjaCAocmVuZGVyRXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVuZGVyaW5nIHRlbXBsYXRlOicsIHJlbmRlckVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgTXVsdGkgZXJyb3IgKHdoaWNoIGNvbnRhaW5zIG11bHRpcGxlIGVycm9ycylcbiAgICAgIGlmIChyZW5kZXJFcnJvciAmJiByZW5kZXJFcnJvci5wcm9wZXJ0aWVzICYmIHJlbmRlckVycm9yLnByb3BlcnRpZXMuZXJyb3JzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdEb2N4dGVtcGxhdGVyIHJlcG9ydGVkIG11bHRpcGxlIHJlbmRlciBlcnJvcnM6Jyk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2cgZWFjaCBpbmRpdmlkdWFsIGVycm9yIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgcmVuZGVyRXJyb3IucHJvcGVydGllcy5lcnJvcnMuZm9yRWFjaCgoZXJyb3I6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBSZW5kZXIgRXJyb3IgJHtpbmRleCArIDF9OmAsIGVycm9yKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBMb2cgZGV0YWlsZWQgaW5mb3JtYXRpb24gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLmV4cGxhbmF0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFeHBsYW5hdGlvbjogJHtlcnJvci5wcm9wZXJ0aWVzLmV4cGxhbmF0aW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMuaWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVycm9yIElEOiAke2Vycm9yLnByb3BlcnRpZXMuaWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcy54dGFnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUYWcgd2l0aCBlcnJvcjogJHtlcnJvci5wcm9wZXJ0aWVzLnh0YWd9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb2cgdGhlIGRhdGEgcGF0aCB0aGF0IGNhdXNlZCB0aGUgaXNzdWUgaWYga25vd25cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLnRhZykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVGVtcGxhdGUgdGFnOiAke2Vycm9yLnByb3BlcnRpZXMudGFnfWApO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmF3IHRhZzogJHtlcnJvci5wcm9wZXJ0aWVzLnJhd31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhyb3cgYSBtb3JlIGRldGFpbGVkIGVycm9yXG4gICAgICAgIGNvbnN0IGZpcnN0RXJyb3IgPSByZW5kZXJFcnJvci5wcm9wZXJ0aWVzLmVycm9yc1swXSB8fCB7fTtcbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSBmaXJzdEVycm9yLnByb3BlcnRpZXM/LmV4cGxhbmF0aW9uIHx8ICdVbmtub3duIHRlbXBsYXRlIHJlbmRlcmluZyBpc3N1ZXMnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIHJlbmRlcmluZyBlcnJvcnM6ICR7ZXhwbGFuYXRpb259IChTZWUgY29uc29sZSBmb3IgZnVsbCBkZXRhaWxzKWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBpbmRpdmlkdWFsIERvY3h0ZW1wbGF0ZXIgZXJyb3JzIHdpdGggcHJvcGVydGllc1xuICAgICAgaWYgKHJlbmRlckVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3Byb3BlcnRpZXMnIGluIHJlbmRlckVycm9yKSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gcmVuZGVyRXJyb3IucHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgY29uc29sZS5sb2coJ0RldGFpbGVkIHJlbmRlciBlcnJvciBwcm9wZXJ0aWVzOicsIHByb3BzKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW1wbGF0ZSByZW5kZXIgZXJyb3I6ICR7cHJvcHMuZXhwbGFuYXRpb24gfHwgcmVuZGVyRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVuZGVyIHRlbXBsYXRlOiAke3JlbmRlckVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyByZW5kZXJFcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZW5lcmF0ZSB0aGUgb3V0cHV0IGRvY3VtZW50XG4gICAgbGV0IG91dHB1dDtcbiAgICB0cnkge1xuICAgICAgb3V0cHV0ID0gZG9jLmdldFppcCgpLmdlbmVyYXRlKHtcbiAgICAgICAgdHlwZTogJ2Jsb2InLFxuICAgICAgICBjb21wcmVzc2lvbjogJ0RFRkxBVEUnLFxuICAgICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50JyxcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coYE91dHB1dCBkb2N1bWVudCBnZW5lcmF0ZWQgc3VjY2Vzc2Z1bGx5ICgke291dHB1dC5zaXplfSBieXRlcylgKTtcbiAgICB9IGNhdGNoIChnZW5FcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBvdXRwdXQgZG9jdW1lbnQ6JywgZ2VuRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgb3V0cHV0OiAke2dlbkVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBnZW5FcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiBydW5uaW5nIGluIGJyb3dzZXIsIHNhdmUgdGhlIGZpbGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNhdmVBcyhvdXRwdXQsIG91dHB1dEZpbGVuYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coYEZpbGUgc2F2ZWQgYXMgJHtvdXRwdXRGaWxlbmFtZX1gKTtcbiAgICAgIH0gY2F0Y2ggKHNhdmVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgZmlsZTonLCBzYXZlRXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzYXZlIGZpbGU6ICR7c2F2ZUVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBzYXZlRXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZW5lcmF0ZURvY3hGcm9tVGVtcGxhdGU6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIElmIGl0J3MgYSBQaXpaaXAgZXJyb3IgKGxpa2VseSBpbnZhbGlkIHRlbXBsYXRlKVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3ppcCcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdQaXpaaXAgZXJyb3IgLSBpbnZhbGlkIHRlbXBsYXRlIGZpbGUgc3RydWN0dXJlJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIGZpbGUgaXMgbm90IGEgdmFsaWQgRE9DWC9aSVAgZmlsZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXRocm93IHRoZSBlcnJvclxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBmYWxsYmFjayBIVE1MIHJlcG9ydCB3aGVuIERPQ1ggdGVtcGxhdGUgZmFpbHNcbiAqIEBwYXJhbSByZXBvcnREYXRhIC0gVGhlIHJlcG9ydCBkYXRhIHRvIGV4cG9ydFxuICogQHJldHVybnMgQSBibG9iIHdpdGggSFRNTCBjb250ZW50XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRmFsbGJhY2tIdG1sUmVwb3J0KHJlcG9ydERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBCbG9iIHtcbiAgY29uc3Qgc3R1ZGVudE5hbWUgPSByZXBvcnREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5maXJzdE5hbWUgXG4gICAgPyBgJHtyZXBvcnREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZmlyc3ROYW1lfSAke3JlcG9ydERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5sYXN0TmFtZX1gXG4gICAgOiAnU3R1ZGVudCc7XG4gIFxuICAvLyBDcmVhdGUgYSBzaW1wbGUgSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVwb3J0XG4gIGxldCBodG1sID0gYFxuICAgIDwhRE9DVFlQRSBodG1sPlxuICAgIDxodG1sPlxuICAgIDxoZWFkPlxuICAgICAgPG1ldGEgY2hhcnNldD1cInV0Zi04XCI+XG4gICAgICA8dGl0bGU+UmVwb3J0IGZvciAke3N0dWRlbnROYW1lfTwvdGl0bGU+XG4gICAgICA8c3R5bGU+XG4gICAgICAgIGJvZHkgeyBmb250LWZhbWlseTogQXJpYWwsIHNhbnMtc2VyaWY7IG1hcmdpbjogNDBweDsgbGluZS1oZWlnaHQ6IDEuNjsgfVxuICAgICAgICBoMSwgaDIsIGgzIHsgY29sb3I6ICM0NDQ7IH1cbiAgICAgICAgLnNlY3Rpb24geyBtYXJnaW4tYm90dG9tOiAzMHB4OyB9XG4gICAgICAgIC5kb21haW4geyBtYXJnaW4tYm90dG9tOiAyMHB4OyBwYWRkaW5nOiAxNXB4OyBib3JkZXI6IDFweCBzb2xpZCAjZWVlOyB9XG4gICAgICAgIC5kb21haW4taGVhZGVyIHsgZGlzcGxheTogZmxleDsganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOyBhbGlnbi1pdGVtczogY2VudGVyOyB9XG4gICAgICAgIC5jb25jZXJuIHsgY29sb3I6ICNmNTllMGI7IGZvbnQtc2l6ZTogMTRweDsgfVxuICAgICAgICAubm8tY29uY2VybiB7IGNvbG9yOiAjMTBiOTgxOyBmb250LXNpemU6IDE0cHg7IH1cbiAgICAgICAgdWwgeyBtYXJnaW4tdG9wOiA1cHg7IH1cbiAgICAgICAgQG1lZGlhIHByaW50IHtcbiAgICAgICAgICBib2R5IHsgbWFyZ2luOiAwLjVpbjsgfVxuICAgICAgICAgIC5kb21haW4geyBicmVhay1pbnNpZGU6IGF2b2lkOyB9XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9oZWFkPlxuICAgIDxib2R5PlxuICAgICAgPGgxPlJlcG9ydCBmb3IgJHtzdHVkZW50TmFtZX08L2gxPlxuICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb25cIj5cbiAgICAgICAgPGgyPlN0dWRlbnQgSW5mb3JtYXRpb248L2gyPlxuICAgICAgICA8cD48c3Ryb25nPkRPQjo8L3N0cm9uZz4gJHtyZXBvcnREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5ET0IgfHwgJ04vQSd9PC9wPlxuICAgICAgICA8cD48c3Ryb25nPlJlcG9ydCBEYXRlOjwvc3Ryb25nPiAke3JlcG9ydERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24/LnJlcG9ydERhdGUgfHwgJ04vQSd9PC9wPlxuICAgICAgICA8cD48c3Ryb25nPlJlYXNvbiBmb3IgUmVmZXJyYWw6PC9zdHJvbmc+ICR7cmVwb3J0RGF0YS5oZWFkZXI/LnJlYXNvbkZvclJlZmVycmFsIHx8ICdOL0EnfTwvcD5cbiAgICAgIDwvZGl2PlxuICBgO1xuICBcbiAgLy8gQWRkIGRvbWFpbnMgc2VjdGlvblxuICBpZiAocmVwb3J0RGF0YS5hc3Nlc3NtZW50UmVzdWx0cz8uZG9tYWlucykge1xuICAgIGh0bWwgKz0gYDxkaXYgY2xhc3M9XCJzZWN0aW9uXCI+PGgyPkFzc2Vzc21lbnQgUmVzdWx0czwvaDI+YDtcbiAgICBcbiAgICBPYmplY3QuZW50cmllcyhyZXBvcnREYXRhLmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnMpLmZvckVhY2goKFtkb21haW5OYW1lLCBkb21haW5dOiBbc3RyaW5nLCBhbnldKSA9PiB7XG4gICAgICBpZiAoZG9tYWluLnRvcGljU2VudGVuY2UgfHwgZG9tYWluLnN0cmVuZ3Rocz8ubGVuZ3RoIHx8IGRvbWFpbi5uZWVkcz8ubGVuZ3RoKSB7XG4gICAgICAgIGh0bWwgKz0gYFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJkb21haW5cIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkb21haW4taGVhZGVyXCI+XG4gICAgICAgICAgICAgIDxoMz4ke2RvbWFpbk5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBkb21haW5OYW1lLnNsaWNlKDEpfSBMYW5ndWFnZTwvaDM+XG4gICAgICAgICAgICAgICR7ZG9tYWluLmlzQ29uY2VybiAhPT0gdW5kZWZpbmVkID8gXG4gICAgICAgICAgICAgICAgYDxzcGFuIGNsYXNzPVwiJHtkb21haW4uaXNDb25jZXJuID8gJ2NvbmNlcm4nIDogJ25vLWNvbmNlcm4nfVwiPiR7ZG9tYWluLmlzQ29uY2VybiA/ICdBcmVhIG9mIENvbmNlcm4nIDogJ05vIENvbmNlcm4nfTwvc3Bhbj5gIDogXG4gICAgICAgICAgICAgICAgJyd9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICR7ZG9tYWluLnRvcGljU2VudGVuY2UgPyBgPHA+JHtkb21haW4udG9waWNTZW50ZW5jZX08L3A+YCA6ICcnfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAke2RvbWFpbi5zdHJlbmd0aHM/Lmxlbmd0aCA/IGBcbiAgICAgICAgICAgICAgPGg0PlN0cmVuZ3Roczo8L2g0PlxuICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgJHtkb21haW4uc3RyZW5ndGhzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgPGxpPiR7aXRlbX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgYCA6ICcnfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAke2RvbWFpbi5uZWVkcz8ubGVuZ3RoID8gYFxuICAgICAgICAgICAgICA8aDQ+TmVlZHM6PC9oND5cbiAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICR7ZG9tYWluLm5lZWRzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgPGxpPiR7aXRlbX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgYCA6ICcnfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAke2RvbWFpbi5pbXBhY3RTdGF0ZW1lbnQgPyBgXG4gICAgICAgICAgICAgIDxoND5FZHVjYXRpb25hbCBJbXBhY3Q6PC9oND5cbiAgICAgICAgICAgICAgPHA+JHtkb21haW4uaW1wYWN0U3RhdGVtZW50fTwvcD5cbiAgICAgICAgICAgIGAgOiAnJ31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuICB9XG4gIFxuICAvLyBBZGQgcmVjb21tZW5kYXRpb25zXG4gIGlmIChyZXBvcnREYXRhLmNvbmNsdXNpb24/LnJlY29tbWVuZGF0aW9ucykge1xuICAgIGh0bWwgKz0gYFxuICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb25cIj5cbiAgICAgICAgPGgyPlJlY29tbWVuZGF0aW9uczwvaDI+XG4gICAgICAgICR7cmVwb3J0RGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9ucz8ubGVuZ3RoID8gYFxuICAgICAgICAgIDxoMz5BY2NvbW1vZGF0aW9uczo8L2gzPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICR7cmVwb3J0RGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9ucy5tYXAoKGl0ZW06IHN0cmluZykgPT4gYDxsaT4ke2l0ZW19PC9saT5gKS5qb2luKCcnKX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgICBgIDogJyd9XG4gICAgICAgIFxuICAgICAgICAke3JlcG9ydERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llcz8ubGVuZ3RoID8gYFxuICAgICAgICAgIDxoMz5GYWNpbGl0YXRpb24gU3RyYXRlZ2llczo8L2gzPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICR7cmVwb3J0RGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgPGxpPiR7aXRlbX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIGAgOiAnJ31cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cbiAgXG4gIGh0bWwgKz0gYFxuICAgICAgPGZvb3Rlcj5cbiAgICAgICAgPHA+PGVtPlRoaXMgaXMgYSBmYWxsYmFjayBIVE1MIHJlcG9ydCBnZW5lcmF0ZWQgYmVjYXVzZSB0aGUgRE9DWCB0ZW1wbGF0ZSBjb3VsZCBub3QgYmUgcHJvY2Vzc2VkLiBcbiAgICAgICAgWW91IGNhbiBwcmludCB0aGlzIEhUTUwgZmlsZSB0byBjcmVhdGUgYSBQREYuPC9lbT48L3A+XG4gICAgICA8L2Zvb3Rlcj5cbiAgICA8L2JvZHk+XG4gICAgPC9odG1sPlxuICBgO1xuICBcbiAgcmV0dXJuIG5ldyBCbG9iKFtodG1sXSwgeyB0eXBlOiAndGV4dC9odG1sJyB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzaW1wbGUgZW1wdHkgRE9DWCB0ZW1wbGF0ZSBwcm9ncmFtbWF0aWNhbGx5XG4gKiBUaGlzIGlzIGEgbGFzdC1yZXNvcnQgZmFsbGJhY2sgd2hlbiBhbGwgdGVtcGxhdGUgZmlsZXMgZmFpbCB0byBsb2FkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5VGVtcGxhdGUoKTogQXJyYXlCdWZmZXIge1xuICAvLyBEZWZpbmUgYSBtaW5pbWFsIHZhbGlkIERPQ1ggZmlsZSBzdHJ1Y3R1cmUgYXMgYSBiYXNlNjQgc3RyaW5nXG4gIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGVtcHR5IERPQ1ggZmlsZSB3aXRoIG1pbmltYWwgY29udGVudFxuICBjb25zdCBtaW5pbWFsRG9jeEJhc2U2NCA9ICdVRXNEQkJRQUJnQUlBQUFBSVFBOThFRXVUZ0VBQU9JQ0FBQUxBQUFBWDNKbGJITXZMbkpsYkhPa2tzRnF3ekFNUU8rRC9ZZlJ2VkZhR0lOaHV6Qkc3emIyQTR4c1RJdmIyWlRhVHZyM09aQ3dyUzVaR0xyYVNYejZBVW5rZXY3ejl1TmxrQ2F4ekRoNjFNQWdlY3NFMjlNVTNNRmp4K2xxK1N0eVNxWHV5MlZjMkpVYk1KeExGQmFsU1hNUXBKTGh3UFNONDFTU2RpMHhwczh2clIxb1ByU2JMdUFnd2x4QXFqa1RZbTNQOSsvL21mZlZRaEIwcmc1NXNhVWN5L01ZcXFCTFYvejFnK1NmNmk4cVhscnBlWU1Qc0lYcFgweEdibTdBZkNCeHo5SFhkQ0tYRXpqTjVYOE9oM1A2ZUJhTVovWUpyQXN3dk5heTFQTEZ4b2Q1SVFUbWFEUVNNdlpVaWRWckJ2OVhLalRTZWxUSlJ5WXpveWNCS0JISnhCYWU5SlRjc0tNcVhOWXYrMW9XenhmaXN3UVhvTUxYY1BoN1hma0dVRXNEQkJRQUJnQUlBQUFBSVFBQm50OGZSd0VBQU9ZRUFBQWNBQUFBZDI5eVpDOWZjbVZzY3k5a2IyTjFiV1Z1ZEM1NGJXd3VjbVZzYzdTVTMwckRNQkRHNzRQZEllUys2Y3FpMUhSZGlBcDdKYmdIMktRblcyeVRrS1RxM3Bza1hTdFRPOHAvTnczNVB0NzNKV1IxYzlQSFlnczVlNHdOTFV0VlFIUklQdllOZkg0OHJHNUFaQmF4Slk4UkFsOGcxbVJlUHIrdG50QVM1V0xPcy9WQkZFRHNZQVBXMnQxUzVZV0ZuckpTNzlBVjBHbnNLVk9kbTB6amwyekk5bFN2ZEwxV094Wm5QSUFaQk5WT0dzaFY3R3FRdWRoOEFLL2MyYVhRR3JxRHVQSVlqM2VRTUJ5aU5mZkVENVNaOHk2N3Vwams4UmwrY3VLN3VjUkRDUmtqcHNMNEpNVnh4dWM1aHVQQkZtRS83RzBoZk9KTFFPU2lHR3FVSUpubmxDNXA2NEV5eVlmVXFKbjNrVGh6aFZ6WURrTUpBa05Pdy8wc2ZnRlFTd01FRkFBR0FBZ0FBQUFoQU5aa3MxSDBBQUFBTVFNQUFCRUFBQUJrYjJOUWNtOXdjeTlqYjNKbExuaHRiSFBNa2sxUHd6QU1odTlJL0ljb2x3bGlJMmlsS3RadHdnbHBpTU9RMERndFdwdXNTUjFWL2ZmWVZEUUp3WW5MK1BYek9uWjJ1bXVWdUlNUHhya0NwVW1HRURobGNhWHJBbjI4YjhZcmhJTjJxalRhT1NqUUF3SmFsZmV6bmM5TjY3YjBKdDZjQjBJaUxoU29OeVkwR2NlUWUxQTJKRTZENUpjbUtCdmxHT3JlNDBDWlBiTTNwWGlWWlF1OHNVQ1ZEV09JYlVFTFhESWx2MEJ2Zjl6VzJHWnFCdVdJMkhzaS9KdmRieG5GeHZXR2lWK2FacVJJa2oyOW1KVkUzVlhRNDMwSlBZa1JKM0xNcWM3WTRLWExxS2RKa296NXFCK2NXcGttb2FKWTMzRDRGdFVYQmdHU01yMmtHWSsyYUh4ZE1wWEhGR1ZaUWZDbjl2K01aelBDWFR0VTEyN3ZMYTFkVlhNb0o5bkV2NXcycXo4cEt2bkpKNGwrZDU2ajhqK1VuVXVkWGwzVzIvSjFneTdISVlySHhXUTVDVlVmL0ZXK0FFYlI0VWRRY3VKL1RUNEJVRXNEQkJRQUJnQUlBQUFBSVFEVDVPUGg4Z29BQUxHVEFBQVRBQUFBVzBOdmJuUmxiblJmVkhsd1pYTmRMbmh0YkxXYVhXL2JPQmFHN3dmc2YxRG9lbTlsMmM2SGd6WXoyTWJKZElObUpoczdjMGVKdEVWRUpqV2tuSGgrL1ZJaVpWdUpRaE4xZk5FQ0JpMCtQUHdrOHZDaGZQT3Z1MnlhWFVWYjExVzVDT2JMUlpERnNxcnFTYmw3RWZ5NmY3UDVJY2pxblNncmtsYVg4U0s0ajNYd3IrZS8vdkxtOW1uZHhrd3NMK3RGME8vNzI5TmlVWmRkdkszTFpiV1BwY25rdFd4RmJYN0szYUlXOVYzY2JSZGIyOFd5V0p3MmkwbFpuZ1h2NDFpOHVLMHJrOEsyMjNKY3ZvblZOTmF6alZjeExrMWtLOWR4WHAwWDUrSSs3WXA2SXQrK1htZFpiNTkvdkNoM1g1UGJ1OHVwaU10bkpoMFR6bVpUL0diamYxeDR1M3ZBbTFUN2FiSTZLcTh2KzhEdVhMWUtjM1paMzlmcHVHNGtwZ1ZQeHRJa3VvemxxTXJubDZQN0w3YzVaMWNYMHcvMlg2TXpzK09UTW51VmJMVjJKYXJiblY1L1hKd3R5OFZsMWVYSmpyYmJ0ckcydjk1a1JTdHVnMnl6bVpsLzkyV1Z0dE9pS0hlaU41bFdsMnA2L2JMYjJ5VHZkdVVpS1BORjhPS3Fyc3M0N2VlSGI5cUxxcFc5RUsxcElFYTZEZE5TVWNuWll1OWxiSjdaalhXMWpjL2E3cVlSZFNVYjBkL0VQb3U3Sk9Wd1pOcU9vVU5YcTJvL3BTRjdJZlhEZnRIRWNtZnFGMlZzYnZsK3M5MU9kcTAzaGM2eUczTjFPOUZIVTdrd0xVUE9VdXV1RmQxVnYrMHpQeDVkNysvWGsva09nZFpKZnIxUHl2RzZEcWVvNVhMeGp6bERDWVA2eEorUURJNkJvenRmTG5PTzhQZ29qZ3dPOVM0M2Y5dFhoNy9lWXJnMkxmV3B6SmRqSFRKNkpDZU9LeU5wclMremwvUE54NUc0TXZkNFhNa0p6MHR4QlZ1L3NIcG5HOUl1L2lXTmNyVWNyYjNSZE81NGIyWWZySTZMaC96dzQrNkhHVi9HYlV3ZmZEQnVEdmxCWFJ5dnJsZkZvZU10N2U0L3pLTnlYdzhQdTlJY1ViWEwxeXpGdzl3WSs5M2pWdlRWWk53UkZ4bG1IK2EwYzNPS1JQcW9Vd3pYajUxaVg3WlhzUjhuU2ZSUjRHOW5Oek9PN1lmazF3OERkcjJPWlpuc2NxVXFadlBGdldnVGI1T1R4czlxR0crTngyc1oyOC9SajhaMVc4N1NpdTVuL1ZFL2ZXUlE5UHAySExTakwrTmswbXduMnpuR3dRRFhwcVp3VER2TXhqUGpiek1weWhrMy9tRnYrckpNL0RuSG1mYlNSVzlkSExkdGZ3ajBRNDd4OUVVZmVQVkdwUGk4VlhjcE9weVBxTFlYVng5cWNVYWlqY0UvS1ZFSHNKNWNqRlBDZm5KNWNUY2R4Mk9TRFhQS1F6WDJGYlY1UisrYVdNVkpkWFRBSmZuaW1EYWRCZzgwS3RRbmZKenBabktZM0gxTzBTZWllUFppUzZFdlIybk01bVBYYytVeExhZEJuQ2xTcnB3UVMyQTdndmw0WjZiUnFIekpYUXBNUWtyQ3JKZ1E1OHE1Zi90NmQ1c0xEc3ZVMXlST1FrckNMSndRNThycHZXM3Y3WHhtalpjbnZadHdIOWtHa0pJd3F6SWh6cFhidHZ1K3luWjNhWFhRQ1BzcTRaY3YzeHZRQmpDVHhQVjFRaHdDK0x6YXovSm1WLzRIczdLSEZ6eExhSU1rcVZkL0piUWhoSWVyVTIvenkvdCsyNWwza1lldW9xY1huTzNRQnBDU09MVkthRU1JRDFlbkhoYnE2Lzdxdk1xbTk0ZFRXRmN2ZExhR05vQWtjZXBWUWhzQytMeDYrSTdwSXVuRzd6Y1A0VjI5ME5rWjJnQlNFcWRXQ1cwSTRlSHExRHRyVE92YjhYM05OUUwzcklNVEtFbk4raUtoRFNGOFhKMTZiNjNKM00wVzFJNmQzbmtkMmlCSnpZMENRaHNDK0x4NllnVXpSSUt6MVJkV01HaURKSEZxbFVKSXpLdVRBWWVYa2M5K0ZPN29oYWVRYUFOSVNaeDhwbENESU8rZlF3NmpQRzNGa043K1F6eElrcHIxUlFvMUNQSis5Y1FTcGc4RFp5c3NwTXN3N09SRnJCUklrdFFzTHhLb1FRUWZWNmNlRmpFMkM1eXR0TWh1UjZrVTd1WkZMR0pJa3RRc0x4S29RUVFmVjZkKzhLNkp2Ylh0eExrSlBHeFEwM2NVejdab0EwaEpuSHlsVUlOQUhxK2VXTWJZZE83a1puWTdPdCtoRFNBbGNmS1ZRZzBDZWJ4NlloMWo4OERaNmdzN0dyUUJwQ1JPdmxLb1FTQ1BWKzhlM3Y3YU1xMDd1Ym5kRDM2RlFMSjFXcnRTcUVFZ2oxY2YzVUIzY1RkZjhuQ2RZUFppdzlzTmtpUjErNWQ2aVZubDFjTnc5YUEzMS9Na1hUSUpQOUk3ejFIUUJ0aVpwRzc5TnVZRWdhUWVWazVONC8xdHhYMDJQYmJUejFNTkxBM3ZPVWlXUkdyWHVCUEVrdnF4R3hCSFBVaUtwbjdVUWtGSVpsSzd4cDBnbHRSUExFcUdnWEMydXNUU1dpQ3BXZU1Pa0V2cWlXWEpNQkZjcnU2K2h4UllHdDZDQUtSbWpUdEFMcWtubGlYRFJIQzZ1c1Q2V2lDcFdlTU9rRXZxaVdYSk1CRmNycjU2V0Y3a0VzSDEyd3RxcFlDeXBFNnQ4WGRCQUo5WFQzdzQ2YVF1L3paK1AvN3hOTllKUHIxQTN3VllsdFNwN2V3RkFYeGVQZkY1YWVaZG5QM205SnZ1cE42ZlR5UHZIcjA3Umo5QkRSSzdOYytTQndqbTFqN3h2V2xXcEdjMzJHMW5UdEgrYm5Ydzd1SGRNWG94QWhLN05jK1NCd2ptMWo3eHptbm90VWZGSkN2djAybEp6ZWRwM3ZUbWFIWlJqOS9zb0VEaTFLbDVsanhBTUxQMjRYUFQvYllhanRtRm1BNmQrVERSTURoOGE0d0NpYjE2MDhvMDFoSDh2THBMcW9hRy9EWWJlaEw0ZE1QSjIwTVVTQnc2dFowOUlvQTc3L0IxLzNBeFRPQ1B0dzFucnc5UklISG8xTHplSXNKNGMwOS9MZm04dS9rMUd4N0pwM25EMmZ0M0ZFZ2NPald2dDRndzN0ejljSksxWTRQNGZrVDFYR2x1RUZBZ3NWZnZXcG5HT29LZlY4OCtuSmpBdzNUMjlMMGlDaVFPblpyWFcwUVliKzU0T0srdmZqeGZGK3ZwL2xQMjRCYzhjamg3SDRjQ2lVT241dlVXRWNhYmUrS2I5ZFhSamNYVnpmakhLUjZtY21mdjQxQWdjZWpVdk40aXduaHpMeDV1S0hyUlgreUdoNHM2bTViRHIvRGs1M204N2NlSlBOU0ducnhuU1lIRW9WTzdFVVdFY2VZZXVkeFA5T1hod2NkSzdPdEpkWnNOWmVMN1RjR1JuOTNnN0VWR0NpcjJhcDNheGtlRThlWWU1ejNoMmRXaDFrL0s3RDhTbGZnZitkbk40ZXdsU2dvcTltcWQyc1pIaFBIbWZuU3QvOGpmWDE1ZlhHL2QzejU4WFlzNi8zeXlBYzF6OHVQeU5qNWZZT0ZUVUJ2TW4vOEhVRXNEQkJRQUJnQUlBQUFBSVFCbWhiNnR5d01BQURvTkFBQVBBQUFBZDI5eVpDOXpkSGxzWlhNdWVHMXNwSmJiYnRzd0RJYnZCK3c5Q04xblNwckdhWUxXV1pBbTYyWFFyb3ZhZGpjd050c1Jwa09HcENUTjIrL0l5Y214QzFUdFJhSkkvdncrRXA0dlAvWlM4SzJ4bG1zMUkvR1FFYzZVMEhXcmRqZU0vSHhZQkJQQ3JhTlZTNFZXWmtZT3hwSVBzNjlmNXUxQld1Mk40UllqREsxbXRMRnVkNVVrVmpSR1VqdlVPNlBnUzZPTnBBNUVzMHRhamRhNkMxS3BrekVqVjhuWGIxa040YXZYR2l6NXZsVUwxZEdOTmtKWUhkcnlWQm1JYnJrd0hPelpwREhDUnhNSm5aZ1FYeE1sK2JPNW4zSGV3VDVlcEx1ZllydmZUUlNObjBFOUlQanAydnhPL2UrcnA3dDNtTE4weDg1NGNIVlY3bXc2TnRwSDE1YkZXb21WTnA3NHdZaUwxSkY3d3kvRjN0WTY4eVRYb3ZNVmJtKzFVVStCYUd4N2g2NU5heDhiWjBVL0Y2V2d6cG95WWlSSVFySWdUa2hhSkhIQlY1dm1uQ3FPRmtHU3pOTXNMOUppbVljSkwxNks4REpKWUkwc0RZSjR2ZzdEVlRLUGkwV3hLTkkwWGlUSllyWEtpalNPbDJtUnBrWHhEcHpMbGZackpRNnFoZGdYZW5Nd1Q0aDg4ZVU4blJySUhpSi8zSEUyZFhBSS9MSFRxNm1EdytpUC9UWjFNSWo5TVozdWpZU3AzTzZCdXB2UkdMcTlJSXFzTEtRUEx0QkZxZjFyWi9IRFhQOHpOenhiMHhhMUowK1NrWnNtTmhWTlRZMGsxK1JNdzAvT3o2MkMrQVF2UGRqSEVnMFpQNzFsU1FxbkR3WjloN0FaZVZndmtoekwwYUh6RERtNnI4ZzdKS21wY1plYXdWcFBLN3dBL0tJelREVmR2NHBLblYyekZwQ1ZxVnZiMzdPMFcwTW5oR2FFMTl5U0RWSzRSYjVYajd6MjJjSlh1dU1WMXJqbVcvRTRrYzBadGNOcEwwZ1R3ZjJ6ME1GRVk1cjNyTGREbHAyWndZNktUQllXN0pwandYWEhvVkRCdG1tZ1F3QTZGZ0xjWlBkMEM5T1B2ZE1XL250Y2F5RmNJK0dYZTRPajVBSGpHemYyKzY3RlhydURYbm5nTDdVdzllYU9tblpRYjA4a3pqdDdRU1p2b1E5dkpvL01kTTJ4VUdxSmRFVmE5VFFkdlFVWXBCaGlKZ3puMEJkR1AzRU8vOVZPMkgxMWpDeEhFNmtOVE5mN0Raa0xqWTI3TVhaVHR6dGw4UlBaOWVJQmpUSFVPSFBkZ3RrZHc5UllSUmJQMEpmSVhXZE9RNHhSUGVCOXJPSHFtcUp3OXVDN2dObjBCMEUrQjJHZzB3M2RhamRVTXJ3QzUvSndoZ05sY0F3L0d2VnNPN2dwd2pUTjhtTXZoS1hjcTBjNFFMQk1SL000Q1ZZL0I5TTBLWlpKOFhZdzNKLysvbFh5MmQ0UThRTHY5N0ExWUsvQmxkUktxVHpNNGp6Tzh1SitwMmtPRHhDeDVSc29wVy9HMEErSCs0TVdlUHRDYk9DdUtSKzFnUXZrYkZSNmI2RUpRRExETFpFUFR2MEJVRXNEQkJRQUJnQUlBQUFBSVFBNnFCQ0V1UVlBQURRYkFBQVJBQUFBZDI5eVpDOWtiMk4xYldWdWRDNTRiV3kwV050dTJ6Z1FmUy9RZnlEMDNqcHhia2lkaUVsYlpMUFpvbGh2UDBDV21GaUlMSUtVNCtUdk8wTktkcDN1TnNnKzFKQkZjY2lkbVRObk9PcnJsL3Y3eFBJVVZjV2sySmlEZnRkeUNXU29JaWJpalhuejQySm5ZMWxWRG9ub1hVcGNHL05jeXVybHpkZGYvejJJcTFoVkhFV0ZySENSRy9PK3F0TE5WcXRrZmpHd3VyU2w1MVo4K3JrL0huVHQ1OG50OXJ2RG0wSi93TFRhZHIrMy9sKzBDWSt1eUMyTzNtVUJ4WWs4NWdrVmhUNGtERm1LWW9ZRHZacEZlY1oxTW5QQ2s5RjN6Z0szRDJGemFSVVhmL1k5TjlNL3Z0WDV3OWNqZGpROHNaZW9DcG5YRDBsSDZnOFRsWEw5V1hwWllJK0Q0WWFLVWE5dmpicWU5UzV2RXpoOHpiL0pKRWtsMUdjWCtoMnpmTWZybUJXblcxWWRhYVRERmp0MVY2MkxrWEpWWkxKTVdhRFhEdnM5eTJOamZiVnUrYUZYWDY4ZHpCRjFHYVNkbU1aMHNPdDVwOTFVc2p5bWdjUUo1NmJqOWM1Y09na1VGUkV2VkIzU3dhM1lKUnpIYk5jdkNVZXhBKzNhLytQRUNSR2xURUl1R2RQTDJjaGhPKy9NWGdLZHZqT2J1ZVRuOHB1LzVmS3cyK251N3U1dUc2dlB1ODdPZzJsbnB6L283WDUvUDl2Um9SNUR4ZTRQQ0RHK3I4VzlVWkdkSHlhWDZSSGJ2em81djVyZG5wM05ycWJqbXpGY1hZMm41MmZubDVPcm84bnNmekZZUUNuekczbDl4U0t4cVhvaGhJem56OEtuNjZxMlp6ZkVaUnIybVdhWjBuKzdPQkxCYk14dXVuTFV4bDNDMWJ3K1l2TFB4Z2szTEhPdU5QdTB3RGxmRlNVSlZaeHBwcnFqcXhKcEl1UVRMMkpaYVBKdW9MWXhCNzFCcDc4eGcvNVFqNU9VWlhEa0hONWNucnhPS1M0UzJiUzhZNUZLQkxtUFQzK284cERraDVMNXhlek1IY2ZSM1IvejJmbVYrL3YwZW5lMFU0ZUNQbTh5dlR0NWNuVnhEOU4wdFZpcG53cE5Tcll6dHpRZFJReFZjdytKa0ZXWVBPWEtDZElpNFZXNDB2SGtWa2FoTzZwQ3FtTEpDMXJXenA1M3BBVVFya1FZTzJ3VmE5NEpiRlhlcS9rNFg5RDBZWFlhM1htbmdmM0Z3NWZXSFgwNy92WitkSFI1WU84L2gwVHZSdTlIbDhING56KysrNGYyRCtkL1B3YW5QT1pGeGZJcWQ1SjBKWG51VU5FWFZXVitZcEd6S2ozM2dEdU9xUWlwZHZNOGUwTnBlNGJNTTNmUFJjZy94YktvOWkwb0xQTUpsN2xhUHdxWnFnQWhscWpsTnhWVjJWSi9LUm1tQkt0bSt5cW1MQXFLdGJuUld5N1RsY2ZTSDNSbURpV2dJTFFJcVRxTTZ5blRuNW1MTVJnekZ6OWtSRkdJYzFnOW9NekJwOHlCMExtRmk2SjRwOTR6Uy92TmMrWFdzK1FKSlVtR2Q1eFVqajFRY0pEcVlJMlZCaXBTWEJ3dlVoYnFsS21McHlMMXNGMDVXWlFVSjAwVmdFaXBpaGhVSktBWkRRbWl0Tm1EbE9sMHhtSVhiZnBTSnJwZFEwdUxuWVphMVlrMFU2VWlzMVd0c2FyVEdlNjJ5ckNtSlZ2V09pdWFNWE0xWjlyQUZ3K0lxdERxZUwzVno2Nlk5U3laOC91V0IxK3Q5cVZZRFJXbEhNcGpRdFZvWGRFRVU4NUtielMwRzVkTEt0UFdpR2dmUWJ4c0gvRVZPalFoemJRdFdQUWFKTG40MERUUFhLZEJKVWZQd05xNUdrYjY0NGZVWlVTVDdtVnZFem1USkpGS3JiWE15L3lCUERwWFVMTEtTZ1V4THBKRm5FZE1CS1h1MExvbDlSQ24rUUpsSUNGc1laNVZNWlJWeVhYdUc5Q1FzbnVDYVFVZytxS2R5UW5SeGFxditxZkxZRkJHYUF6V3lNc0pRMU4wcTZvckxkN1dLaExhd2piQ2ZiWExvbE05Um51S3JUeWxzS05NMTJxOVJkUzdHVVR4Vm5xcFZaRnJWY09sRDBsMmpVcUNZMGZFWWk1aDdQNktnMloxdytTbTFxRkp6UEZUbUZRNGtSTU83VWIxeGJacTFCZmJhTklYZThBWE8yd0tjbU4ycXpXVjVWR3JKVnpNWlJFTGJmSE4xMUZmeVkrUGpDL1l4dTZwS0dYZFhXOWxKVHIwblc5ZDBEekpPcVlKYloxTG5yTEdwWkVyM2hYaHZHMnZOQWk5Wk5GeEExclFVelVjNkhadExScWdOUHdEMXozMTBabk95RkV0R1FVMGdFV21HanlFdU1kVk4wZ0tzc1ROdmhrVmpPTENza0QzSTM5VkVYZmJZNHBOMTNsUUxVdUpUWGdUak40cFIvTy9sMU04YlZPb1J4cnpBOHNDNWQ2blBHREVIRUJCOXlOV0ZHTXRFMVM2RjU2cHhWbUtDNy9EdXFTdjlHbFNZVE5KbFRiMXNJcWZFWXo0UnVISVR3NUY0Q20vT0JQNUhGSGdDcUZiQWNYR1RYZlE3YStxT2FUZGgvUjZHdEsxMENLc3lMMXZiY0huOGpEUWVFeUFhSHYzL3R3RkRmL0ZJNFlsRHlod2pRV3BmVmhqM2RLd09iN0ZFK0pZM0tBOTFWcDdPL1FHTW5KUmJQSkwxRFpzNmkzc09YV25GazRxOEpDcE5lM00yWEZNdERrbTNlOVFucnk2NHBSR0R4VG1Nb3E1dE5RaFBMQVl6RExOOUxUR2JxVHZLQnhNTkFrL0l6U1E1T1lmVUVzREJCUUFCZ0FJQUFBQUlRQlBRSUZucGdJQUFMSUdBQUFjQUFBQWQyOXlaQzlmY21Wc2N5OXpaWFIwYVc1bmN5NTRiV3d1Y21Wc2N5MlUyMjdiTUJCRlh3ZjBId1M5TzdybElzYWdLQkxZeUxwQm02QWZRRWlVSkp1WGdxVHN1UDllbEhTVHR4bk9IbkptWjhobkw3OWw2MzFQYlV3eFY2WlFtbG1wSThaTnJrd3VlWHIrOS9qYktsMyt2YkhpM0hLaFRUSG5hdnNMRXNudGJoemFJUWtCRjlPRlVWWFpORUlZWHl1djQyS3N2ZXBqend4NmI2SHJzS25XcG1wQTdIUlp5S2RLcmFXVW5KcFFwQmEwTU9XVVk3VlZGZjF0SkRlUnpiRTA2SlhrVEJXMVVsTEdQWFZwTlF4RE1mQXU5aHZ3ZDNIRE1CK2o0U0hvNG9Nc0Q5L1FUMEJXTEM1VzdZRFFXcW5FaFFmaldtbTJWZ3BOZTNEQmEyVmNxUmlHVVZDTUg0eXZzTlFtaE9Ed3JmQmtYQ0Y3TUJWa01DVnlCeGRNeHNSNEFuY0FINHlMSmVSUllEeDRZYXlLTXJxRmNSK1YrdUcwcElyVEk3WEw1dlBvR1VmUDlvUFRuNmU5K1BLUHpmNEFVRXNCQWkwQUZBQUdBQWdBQUFBaEFEM3dRUzVPQVFBQXppWUFBQXNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRjl5Wld4ekx5NXlaV3h6VUVzQkFpMEFGQUFHQUFnQUFBQWhBQUdlM3g5SEFRQUF6UVFBQUJ3QUFBQUFBQUFBQUFBQUFBQUFrUVFBQUhkdmNtUXZYM0psYkhNdlpHOWpkVzFsYm5RdWVHMXNMbkpsYkhOUVN3RUNMUUFVQUFZQUNBQUFBQ0VBMW1TelVmUUFBQUF4QXdBQUVRQUFBQUFBQUFBQUFBQUFBQUFDQmdBQVpHOWpVSEp2Y0hNdlkyOXlaUzU0Yld4UVN3RUNMUUFVQUFZQUNBQUFBQ0VBMCtUajRmSUtBQUN4a3dBQUV3QUFBQUFBQUFBQUFBQUFBQUFzQlFBQVcwTnZiblJsYm5SZlZIbHdaWE5kTG5odGJGQkxBUUl0QUJRQUJnQUlBQUFBSVFCbWhiNnR5d01BQURvTkFBQVBBQUFBQUFBQUFBQUFBQUFBQUY4VEFBQjNiM0prTDNOMGVXeGxjeTU0Yld4UVN3RUNMUUFVQUFZQUNBQUFBQ0VBT3FnUWhMa0dBQUF2SGdBQUVRQUFBQUFBQUFBQUFBQUFBQUJURndBQWQyOXlaQzlrYjJOMWJXVnVkQzU0Yld4UVN3RUNMUUFVQUFZQUNBQUFBQ0VBVDBDQlo2WUNBQUMzQmdBQUhBQUFBQUFBQUFBQUFBQUFBQUJTSGdBQWQyOXlaQzlmY21Wc2N5OXpaWFIwYVc1bmN5NTRiV3d1Y21Wc2MxQkxCUVlBQUFBQUJ3QUhBUDBCQUFCV0lnQUFBQUFBJztcbiAgXG4gIC8vIENvbnZlcnQgYmFzZTY0IHRvIEFycmF5QnVmZmVyXG4gIGNvbnN0IGJpbmFyeVN0cmluZyA9IHdpbmRvdy5hdG9iKG1pbmltYWxEb2N4QmFzZTY0KTtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIFxuICByZXR1cm4gYnl0ZXMuYnVmZmVyO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmVwb3J0IGRvY3ggZnJvbSB0aGUgcmVwb3J0IGRhdGFcbiAqIEBwYXJhbSByZXBvcnREYXRhIC0gVGhlIHJlcG9ydCBkYXRhIGZyb20gdGhlIGFwcGxpY2F0aW9uXG4gKiBAcGFyYW0gdGVtcGxhdGVCdWZmZXIgLSBUaGUgYmluYXJ5IHRlbXBsYXRlIGZpbGUgYXMgYW4gQXJyYXlCdWZmZXIgKG9wdGlvbmFsKVxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGdlbmVyYXRlZCBmaWxlIGFzIGEgQmxvYlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVSZXBvcnREb2N4KFxuICByZXBvcnREYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICB0ZW1wbGF0ZUJ1ZmZlcj86IEFycmF5QnVmZmVyXG4pOiBQcm9taXNlPEJsb2I+IHtcbiAgLy8gR2VuZXJhdGUgdGhlIGZpbGVuYW1lIGJhc2VkIG9uIHJlcG9ydCBkYXRhXG4gIGNvbnN0IHN0dWRlbnROYW1lID0gcmVwb3J0RGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbj8uZmlyc3ROYW1lIFxuICAgID8gYCR7cmVwb3J0RGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmZpcnN0TmFtZX1fJHtyZXBvcnREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ubGFzdE5hbWV9YFxuICAgIDogJ3N0dWRlbnQnO1xuICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgY29uc3QgZmlsZW5hbWUgPSBgJHtzdHVkZW50TmFtZS5yZXBsYWNlKC9cXHMrL2csICdfJyl9X3JlcG9ydF8ke3RpbWVzdGFtcH0uZG9jeGA7XG4gIFxuICB0cnkge1xuICAgIC8vIElmIG5vIHRlbXBsYXRlIGJ1ZmZlciBpcyBwcm92aWRlZCwgdXNlIGEgZGVmYXVsdCB0ZW1wbGF0ZVxuICAgIGlmICghdGVtcGxhdGVCdWZmZXIpIHtcbiAgICAgIC8vIFVzZSBmZXRjaCB0byBnZXQgdGhlIHRlbXBsYXRlIGlmIHdlJ3JlIGluIHRoZSBicm93c2VyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnTm8gdGVtcGxhdGUgYnVmZmVyIHByb3ZpZGVkLCBmZXRjaGluZyBkZWZhdWx0IHRlbXBsYXRlJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIHVzZSByZXNwb25zZS5hcnJheUJ1ZmZlcigpIHdoaWNoIGVuc3VyZXMgYmluYXJ5IGRhdGEgaGFuZGxpbmdcbiAgICAgICAgICAvLyBVc2UgbGFzLWFzc2Vzc21lbnQtcmVwb3J0LXRlbXBsYXRlLmRvY3ggaW5zdGVhZCBvZiByZXBvcnQtdGVtcGxhdGUuZG9jeCAod2hpY2ggaXMgYSB0ZXh0IGZpbGUsIG5vdCBhIERPQ1gpXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL3RlbXBsYXRlcy9sYXMtYXNzZXNzbWVudC1yZXBvcnQtdGVtcGxhdGUuZG9jeCcsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBjYWNoZTogJ25vLWNhY2hlJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGRlZmF1bHQgdGVtcGxhdGU6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygnRGVmYXVsdCB0ZW1wbGF0ZSBmZXRjaGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgIHRlbXBsYXRlQnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRGVmYXVsdCB0ZW1wbGF0ZSBidWZmZXIgc2l6ZTogJHt0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgdGVtcGxhdGUgZmlsZSBpcyBlbXB0eScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZXJpZnkgdGhlIHRlbXBsYXRlIGhhcyBhIHByb3BlciBET0NYIHNpZ25hdHVyZVxuICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlci5zbGljZSgwLCA0KSk7XG4gICAgICAgICAgaWYgKCEoZmlyc3RCeXRlc1swXSA9PT0gMHg1MCAmJiBmaXJzdEJ5dGVzWzFdID09PSAweDRCKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBET0NYIGZpbGUgc2lnbmF0dXJlIGluIGRlZmF1bHQgdGVtcGxhdGUuIEZpcnN0IGJ5dGVzOicsIEFycmF5LmZyb20oZmlyc3RCeXRlcykpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IHRlbXBsYXRlIGlzIG5vdCBhIHZhbGlkIERPQ1ggZmlsZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGRlZmF1bHQgdGVtcGxhdGU6JywgZXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZSBhcyBhIGxhc3QgcmVzb3J0XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGxvYWQgYWx0ZXJuYXRpdmUgdGVtcGxhdGU6IGxhcy1hc3Nlc3NtZW50LXJlcG9ydC10ZW1wbGF0ZS1maXhlZC5kb2N4Jyk7XG4gICAgICAgICAgICBjb25zdCBhbHRSZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvdGVtcGxhdGVzL2xhcy1hc3Nlc3NtZW50LXJlcG9ydC10ZW1wbGF0ZS1maXhlZC5kb2N4Jywge1xuICAgICAgICAgICAgICBjYWNoZTogJ25vLWNhY2hlJyxcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICAgICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFhbHRSZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZTogJHthbHRSZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRlbXBsYXRlQnVmZmVyID0gYXdhaXQgYWx0UmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBbHRlcm5hdGl2ZSB0ZW1wbGF0ZSBidWZmZXIgc2l6ZTogJHt0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGFsdGVybmF0aXZlIHRlbXBsYXRlXG4gICAgICAgICAgICBjb25zdCBhbHRGaXJzdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGVtcGxhdGVCdWZmZXIuc2xpY2UoMCwgNCkpO1xuICAgICAgICAgICAgaWYgKCEoYWx0Rmlyc3RCeXRlc1swXSA9PT0gMHg1MCAmJiBhbHRGaXJzdEJ5dGVzWzFdID09PSAweDRCKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIERPQ1ggZmlsZSBzaWduYXR1cmUgaW4gYWx0ZXJuYXRpdmUgdGVtcGxhdGUnKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHRlcm5hdGl2ZSB0ZW1wbGF0ZSBpcyBub3QgYSB2YWxpZCBET0NYIGZpbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH0gY2F0Y2ggKGFsdEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGFsdGVybmF0aXZlIHRlbXBsYXRlOicsIGFsdEVycm9yKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXMgYSBsYXN0IHJlc29ydCwgY3JlYXRlIGEgbWluaW1hbCB2YWxpZCBET0NYIHRlbXBsYXRlXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbWluaW1hbCBlbXB0eSBET0NYIHRlbXBsYXRlJyk7XG4gICAgICAgICAgICB0ZW1wbGF0ZUJ1ZmZlciA9IGNyZWF0ZUVtcHR5VGVtcGxhdGUoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIG1pbmltYWwgdGVtcGxhdGUgd2l0aCBzaXplOiAke3RlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghdGVtcGxhdGVCdWZmZXIgfHwgdGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBBbGwgdGVtcGxhdGUgYXR0ZW1wdHMgZmFpbGVkLCBmYWxsIGJhY2sgdG8gSFRNTFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCB0ZW1wbGF0ZSBhdHRlbXB0cyBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNlcnZlci1zaWRlIGhhbmRsaW5nIHdvdWxkIGJlIGRpZmZlcmVudFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbXBsYXRlIGJ1ZmZlciBpcyByZXF1aXJlZCB3aGVuIHJ1bm5pbmcgb24gc2VydmVyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IGFuZCBwcmVwYXJlIGRhdGEgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgIGNvbnN0IGZvcm1hdHRlZERhdGEgPSBmb3JtYXRSZXBvcnREYXRhRm9yRG9jeChyZXBvcnREYXRhKTtcbiAgICBjb25zb2xlLmxvZygnRGF0YSBmb3JtYXR0ZWQgZm9yIERPQ1ggdGVtcGxhdGUnKTtcblxuICAgIC8vIEZpcnN0IHRyeSB3aXRoIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZVxuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgd2l0aCB0aGUgcHJvdmlkZWQvZmV0Y2hlZCB0ZW1wbGF0ZVxuICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gZ2VuZXJhdGUgRE9DWCB3aXRoIHByaW1hcnkgdGVtcGxhdGUnKTtcbiAgICAgIHJldHVybiBhd2FpdCBnZW5lcmF0ZURvY3hGcm9tVGVtcGxhdGUodGVtcGxhdGVCdWZmZXIsIGZvcm1hdHRlZERhdGEsIGZpbGVuYW1lKTtcbiAgICB9IGNhdGNoICh0ZW1wbGF0ZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1c2luZyB0aGUgcHJvdmlkZWQgdGVtcGxhdGU6JywgdGVtcGxhdGVFcnJvcik7XG4gICAgICBcbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBNdWx0aSBlcnJvciBvciBvdGhlciB0ZW1wbGF0ZSBwYXJzaW5nIGlzc3VlLCBcbiAgICAgIC8vIHRyeSB3aXRoIGEgbWluaW1hbCB0ZW1wbGF0ZSB0aGF0IGRvZXNuJ3QgcmVseSBvbiBjb21wbGV4IGZvcm1hdHRpbmdcbiAgICAgIGlmICh0ZW1wbGF0ZUVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgXG4gICAgICAgICAgKHRlbXBsYXRlRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnTXVsdGkgZXJyb3InKSB8fCBcbiAgICAgICAgICAgdGVtcGxhdGVFcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd0ZW1wbGF0ZScpIHx8XG4gICAgICAgICAgIHRlbXBsYXRlRXJyb3IubWVzc2FnZS5pbmNsdWRlcygncGFyc2luZycpKSkge1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS53YXJuKCdUZW1wbGF0ZSBoYXMgcGFyc2luZyBlcnJvcnMsIGF0dGVtcHRpbmcgdG8gdXNlIG1pbmltYWwgdGVtcGxhdGUuLi4nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSB0aGUgY3JlYXRlRW1wdHlUZW1wbGF0ZSBmdW5jdGlvbiB0byBnZW5lcmF0ZSBhIG1pbmltYWwgdGVtcGxhdGVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbWluaW1hbCBlbXB0eSBET0NYIHRlbXBsYXRlJyk7XG4gICAgICAgICAgY29uc3QgbWluaW1hbFRlbXBsYXRlQnVmZmVyID0gY3JlYXRlRW1wdHlUZW1wbGF0ZSgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBNaW5pbWFsIHRlbXBsYXRlIGNyZWF0ZWQgKCR7bWluaW1hbFRlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGh9IGJ5dGVzKWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSBhZ2FpbiB3aXRoIHRoZSBtaW5pbWFsIHRlbXBsYXRlXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGdlbmVyYXRlRG9jeEZyb21UZW1wbGF0ZShtaW5pbWFsVGVtcGxhdGVCdWZmZXIsIGZvcm1hdHRlZERhdGEsIGZpbGVuYW1lKTtcbiAgICAgICAgfSBjYXRjaCAobWluaW1hbEVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igd2l0aCBtaW5pbWFsIHRlbXBsYXRlOicsIG1pbmltYWxFcnJvcik7XG4gICAgICAgICAgLy8gTGV0IHRoZSBvdXRlciBjYXRjaCBoYW5kbGUgdGhlIGZhbGxiYWNrIHRvIEhUTUxcbiAgICAgICAgICB0aHJvdyBtaW5pbWFsRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldGhyb3cgdG8gbGV0IHRoZSBvdXRlciBjYXRjaCBoYW5kbGUgaXRcbiAgICAgICAgdGhyb3cgdGVtcGxhdGVFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2VuZXJhdGVSZXBvcnREb2N4OicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBJZiBhbGwgRE9DWCBnZW5lcmF0aW9uIGF0dGVtcHRzIGZhaWxlZCwgZmFsbCBiYWNrIHRvIEhUTUxcbiAgICBjb25zb2xlLndhcm4oJ0FsbCBET0NYIGdlbmVyYXRpb24gYXR0ZW1wdHMgZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSFRNTCBleHBvcnQnKTtcbiAgICBjb25zdCBodG1sQmxvYiA9IGdlbmVyYXRlRmFsbGJhY2tIdG1sUmVwb3J0KHJlcG9ydERhdGEpO1xuICAgIGNvbnN0IGh0bWxGaWxlbmFtZSA9IGAke3N0dWRlbnROYW1lLnJlcGxhY2UoL1xccysvZywgJ18nKX1fcmVwb3J0XyR7dGltZXN0YW1wfS5odG1sYDtcbiAgICBcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNhdmVBcyhodG1sQmxvYiwgaHRtbEZpbGVuYW1lKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGh0bWxCbG9iO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IHRoZSByZXBvcnQgZGF0YSBmb3IgZG9jeCB0ZW1wbGF0ZSByZW5kZXJpbmdcbiAqIEBwYXJhbSByZXBvcnREYXRhIC0gVGhlIHJhdyByZXBvcnQgZGF0YSBmcm9tIHRoZSBhcHBsaWNhdGlvblxuICogQHJldHVybnMgRm9ybWF0dGVkIGRhdGEgcmVhZHkgZm9yIGRvY3ggdGVtcGxhdGVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UmVwb3J0RGF0YUZvckRvY3gocmVwb3J0RGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAvLyBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgdGhlIHJlcG9ydCBkYXRhXG4gIGNvbnN0IGZvcm1hdHRlZERhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlcG9ydERhdGEpKTtcblxuICAvLyBGb3JtYXQgYXJyYXlzIHRvIGJlIG1vcmUgZG9jeC10ZW1wbGF0ZSBmcmllbmRseVxuICAvLyBBcnJheXMgaW4gZG9jeHRlbXBsYXRlciBhcmUgdHlwaWNhbGx5IGhhbmRsZWQgd2l0aCBsb29wcywgc28gd2UnbGwgZm9ybWF0IHRoZW1cbiAgLy8gdG8gYmUgcmVhZHkgZm9yIHRoZSB0ZW1wbGF0ZSBzeW50YXhcblxuICAvLyBQcm9jZXNzIHN0cmVuZ3RoIGFuZCBuZWVkcyBsaXN0cyBmb3IgZWFjaCBkb21haW5cbiAgT2JqZWN0LmtleXMoZm9ybWF0dGVkRGF0YS5hc3Nlc3NtZW50UmVzdWx0cz8uZG9tYWlucyB8fCB7fSkuZm9yRWFjaChkb21haW4gPT4ge1xuICAgIGNvbnN0IGRvbWFpbkRhdGEgPSBmb3JtYXR0ZWREYXRhLmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXTtcbiAgICBcbiAgICAvLyBGb3JtYXQgc3RyZW5ndGhzIGFzIGJ1bGxldCBwb2ludHMgZm9yIERPQ1hcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkb21haW5EYXRhLnN0cmVuZ3RocykgJiYgZG9tYWluRGF0YS5zdHJlbmd0aHMubGVuZ3RoID4gMCkge1xuICAgICAgZG9tYWluRGF0YS5zdHJlbmd0aHNMaXN0ID0gZG9tYWluRGF0YS5zdHJlbmd0aHMubWFwKChpdGVtOiBzdHJpbmcpID0+ICh7IHRleHQ6IGl0ZW0gfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgZW1wdHkgYXJyYXkgaGFzIHJpZ2h0IGZvcm1hdCBmb3IgdGVtcGxhdGVzIHRoYXQgZXhwZWN0IGl0XG4gICAgICBkb21haW5EYXRhLnN0cmVuZ3Roc0xpc3QgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgbmVlZHMgYXMgYnVsbGV0IHBvaW50cyBmb3IgRE9DWFxuICAgIGlmIChBcnJheS5pc0FycmF5KGRvbWFpbkRhdGEubmVlZHMpICYmIGRvbWFpbkRhdGEubmVlZHMubGVuZ3RoID4gMCkge1xuICAgICAgZG9tYWluRGF0YS5uZWVkc0xpc3QgPSBkb21haW5EYXRhLm5lZWRzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiAoeyB0ZXh0OiBpdGVtIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRW5zdXJlIGVtcHR5IGFycmF5IGhhcyByaWdodCBmb3JtYXQgZm9yIHRlbXBsYXRlcyB0aGF0IGV4cGVjdCBpdFxuICAgICAgZG9tYWluRGF0YS5uZWVkc0xpc3QgPSBbXTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEZvcm1hdCBhY2NvbW1vZGF0aW9uIGFuZCBmYWNpbGl0YXRpb24gc3RyYXRlZ2llc1xuICBpZiAoQXJyYXkuaXNBcnJheShmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24/LnJlY29tbWVuZGF0aW9ucz8uYWNjb21tb2RhdGlvbnMpKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9uc0xpc3QgPSBcbiAgICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuYWNjb21tb2RhdGlvbnMubWFwKChpdGVtOiBzdHJpbmcpID0+ICh7IHRleHQ6IGl0ZW0gfSkpO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbj8ucmVjb21tZW5kYXRpb25zKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9uc0xpc3QgPSBbXTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbj8ucmVjb21tZW5kYXRpb25zPy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzKSkge1xuICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llc0xpc3QgPSBcbiAgICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llcy5tYXAoKGl0ZW06IHN0cmluZykgPT4gKHsgdGV4dDogaXRlbSB9KSk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uPy5yZWNvbW1lbmRhdGlvbnMpIHtcbiAgICBmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmZhY2lsaXRhdGlvblN0cmF0ZWdpZXNMaXN0ID0gW107XG4gIH1cblxuICAvLyBDb252ZXJ0IHBhcmVudHMgYXJyYXkgdG8gc3RyaW5nIGlmIG5lZWRlZFxuICBpZiAoQXJyYXkuaXNBcnJheShmb3JtYXR0ZWREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5wYXJlbnRzKSkge1xuICAgIGZvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5wYXJlbnRzU3RyaW5nID0gXG4gICAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ucGFyZW50cy5qb2luKCcsICcpO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlZERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24pIHtcbiAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ucGFyZW50c1N0cmluZyA9ICcnO1xuICB9XG5cbiAgLy8gQWRkIGZ1bGwgc3R1ZGVudCBuYW1lIGZvciBjb252ZW5pZW5jZVxuICBpZiAoZm9ybWF0dGVkRGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbj8uZmlyc3ROYW1lKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmZ1bGxOYW1lID0gXG4gICAgICBgJHtmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZmlyc3ROYW1lfSAke2Zvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5sYXN0TmFtZSB8fCAnJ31gO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlZERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24pIHtcbiAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZnVsbE5hbWUgPSAnU3R1ZGVudCc7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0dGVkRGF0YTtcbn0iXSwibmFtZXMiOlsiRG9jeHRlbXBsYXRlciIsIlBpelppcCIsInNhdmVBcyIsImdlbmVyYXRlRG9jeEZyb21UZW1wbGF0ZSIsInRlbXBsYXRlQnVmZmVyIiwiZGF0YSIsIm91dHB1dEZpbGVuYW1lIiwiZGVidWdNb2RlIiwiY29uc29sZSIsImxvZyIsImJ5dGVMZW5ndGgiLCJKU09OIiwic3RyaW5naWZ5IiwiZmlyc3RCeXRlcyIsIlVpbnQ4QXJyYXkiLCJzbGljZSIsIkFycmF5IiwiZnJvbSIsIm1hcCIsImIiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwiam9pbiIsIkVycm9yIiwiZXJyb3IiLCJ6aXAiLCJhcnJheUJ1ZmZlciIsImZpbGVzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImZvckVhY2giLCJmaWxlIiwiZmlsZUVudHJ5IiwibmFtZSIsIl9kYXRhIiwiZG9jdW1lbnRDb250ZW50IiwiYXNUZXh0Iiwic25pcHBldCIsInN1YnN0cmluZyIsInRhZ01hdGNoZXMiLCJtYXRjaCIsIndhcm4iLCJkb2N1bWVudEVycm9yIiwiemlwRXJyb3IiLCJtZXNzYWdlIiwiZG9jIiwicGFyYWdyYXBoTG9vcCIsImxpbmVicmVha3MiLCJlcnJvckxvZ2dpbmciLCJudWxsR2V0dGVyIiwicGFydCIsIm1vZHVsZSIsImRlbGltaXRlcnMiLCJzdGFydCIsImVuZCIsInBhcnNlciIsInRhZyIsImdldCIsInNjb3BlIiwicmVzdWx0IiwidW5kZWZpbmVkIiwiZG9jeEVycm9yIiwicHJvcGVydGllcyIsImVycm9ycyIsImZpcnN0RXJyb3IiLCJpbmRleCIsImV4cGxhbmF0aW9uIiwiaWQiLCJ4dGFnIiwicG9zdHBhcnNlZCIsIk1hdGgiLCJtYXgiLCJvZmZzZXQiLCJyZW5kZXIiLCJyZW5kZXJFcnJvciIsInJhdyIsInByb3BzIiwib3V0cHV0IiwiZ2V0WmlwIiwiZ2VuZXJhdGUiLCJ0eXBlIiwiY29tcHJlc3Npb24iLCJtaW1lVHlwZSIsInNpemUiLCJnZW5FcnJvciIsInNhdmVFcnJvciIsImluY2x1ZGVzIiwiZ2VuZXJhdGVGYWxsYmFja0h0bWxSZXBvcnQiLCJyZXBvcnREYXRhIiwic3R1ZGVudE5hbWUiLCJoZWFkZXIiLCJzdHVkZW50SW5mb3JtYXRpb24iLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImh0bWwiLCJET0IiLCJyZXBvcnREYXRlIiwicmVhc29uRm9yUmVmZXJyYWwiLCJhc3Nlc3NtZW50UmVzdWx0cyIsImRvbWFpbnMiLCJlbnRyaWVzIiwiZG9tYWluTmFtZSIsImRvbWFpbiIsInRvcGljU2VudGVuY2UiLCJzdHJlbmd0aHMiLCJuZWVkcyIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiaXNDb25jZXJuIiwiaXRlbSIsImltcGFjdFN0YXRlbWVudCIsImNvbmNsdXNpb24iLCJyZWNvbW1lbmRhdGlvbnMiLCJhY2NvbW1vZGF0aW9ucyIsImZhY2lsaXRhdGlvblN0cmF0ZWdpZXMiLCJCbG9iIiwiY3JlYXRlRW1wdHlUZW1wbGF0ZSIsIm1pbmltYWxEb2N4QmFzZTY0IiwiYmluYXJ5U3RyaW5nIiwid2luZG93IiwiYXRvYiIsImJ5dGVzIiwiaSIsImNoYXJDb2RlQXQiLCJidWZmZXIiLCJnZW5lcmF0ZVJlcG9ydERvY3giLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImZpbGVuYW1lIiwicmVwbGFjZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJjYWNoZSIsImhlYWRlcnMiLCJvayIsInN0YXR1cyIsImFsdFJlc3BvbnNlIiwiYWx0Rmlyc3RCeXRlcyIsImFsdEVycm9yIiwiZm9ybWF0dGVkRGF0YSIsImZvcm1hdFJlcG9ydERhdGFGb3JEb2N4IiwidGVtcGxhdGVFcnJvciIsIm1pbmltYWxUZW1wbGF0ZUJ1ZmZlciIsIm1pbmltYWxFcnJvciIsImh0bWxCbG9iIiwiaHRtbEZpbGVuYW1lIiwicGFyc2UiLCJkb21haW5EYXRhIiwiaXNBcnJheSIsInN0cmVuZ3Roc0xpc3QiLCJ0ZXh0IiwibmVlZHNMaXN0IiwiYWNjb21tb2RhdGlvbnNMaXN0IiwiZmFjaWxpdGF0aW9uU3RyYXRlZ2llc0xpc3QiLCJwYXJlbnRzIiwicGFyZW50c1N0cmluZyIsImZ1bGxOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/docx-generator.ts\n"));

/***/ })

});