"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/reports/text-editor-test/page",{

/***/ "(app-pages-browser)/./src/lib/docx-generator.ts":
/*!***********************************!*\
  !*** ./src/lib/docx-generator.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateDocxFromTemplate: () => (/* binding */ generateDocxFromTemplate),\n/* harmony export */   generateReportDocx: () => (/* binding */ generateReportDocx)\n/* harmony export */ });\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! docxtemplater */ \"(app-pages-browser)/./node_modules/docxtemplater/js/docxtemplater.js\");\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(docxtemplater__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pizzip */ \"(app-pages-browser)/./node_modules/pizzip/js/index.js\");\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pizzip__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! file-saver */ \"(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n/**\n * Generate a docx file from a template and data\n * @param templateBuffer - The binary template file as an ArrayBuffer\n * @param data - The data to inject into the template\n * @param outputFilename - The name of the file to save\n * @param debugMode - Whether to enable extra debugging information\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateDocxFromTemplate(templateBuffer, data) {\n    let outputFilename = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'report.docx', debugMode = arguments.length > 3 && arguments[3] !== void 0 // Enable debug mode by default to help diagnose template issues\n     ? arguments[3] : true;\n    try {\n        console.log(\"Attempting to create PizZip instance with buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n        // Output debug information if debug mode is enabled\n        if (debugMode) {\n            console.log('Data being passed to template:', JSON.stringify(data, null, 2));\n            console.log('Template buffer size:', templateBuffer.byteLength);\n            // Log the first 20 bytes of the template to verify it's a proper DOCX file\n            const firstBytes = new Uint8Array(templateBuffer.slice(0, 20));\n            console.log('First 20 bytes of template (hex):', Array.from(firstBytes).map((b)=>b.toString(16).padStart(2, '0')).join(' '));\n        }\n        // Validate that we have a proper buffer\n        if (!templateBuffer || templateBuffer.byteLength === 0) {\n            throw new Error('Invalid template buffer: Empty or undefined');\n        }\n        // Verify the buffer has a ZIP signature (first bytes of a proper DOCX/ZIP file)\n        const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n        if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n            console.error('Invalid ZIP file signature in template. First bytes:', Array.from(firstBytes));\n            throw new Error('The template does not appear to be a valid ZIP/DOCX file (missing PK signature)');\n        }\n        // Create a new PizZip instance with the template content\n        // Use a try-catch specifically for the PizZip instantiation\n        let zip;\n        try {\n            // Convert ArrayBuffer to Uint8Array to ensure proper binary handling\n            const arrayBuffer = new Uint8Array(templateBuffer);\n            zip = new (pizzip__WEBPACK_IMPORTED_MODULE_1___default())(arrayBuffer);\n            // If in debug mode, examine the structure of the document\n            if (debugMode) {\n                console.log('PizZip opened successfully, inspecting contents:');\n                // List all files in the DOCX (which is a ZIP)\n                const files = Object.keys(zip.files);\n                console.log(\"DOCX contains \".concat(files.length, \" files:\"));\n                // Log the document structure (first 10 files)\n                files.slice(0, 10).forEach((file)=>{\n                    const fileEntry = zip.files[file];\n                    console.log(\" - \".concat(file, \" (\").concat(fileEntry.name, \", size: \").concat(fileEntry._data ? fileEntry._data.length : 'unknown', \" bytes)\"));\n                });\n                // Specifically check for document.xml (main content file)\n                if (zip.files['word/document.xml']) {\n                    try {\n                        const documentContent = zip.files['word/document.xml'].asText();\n                        // Log a snippet of the document.xml for template debugging\n                        const snippet = documentContent.substring(0, 500) + '... [truncated]';\n                        console.log('Document content preview:', snippet);\n                        // Look for template tag patterns\n                        const tagMatches = documentContent.match(/\\{[^{}]+\\}/g);\n                        if (tagMatches && tagMatches.length > 0) {\n                            console.log(\"Found \".concat(tagMatches.length, \" template tags:\"), tagMatches.slice(0, 20));\n                        } else {\n                            console.warn('No template tags found in document.xml - template may not be properly set up!');\n                        }\n                    } catch (documentError) {\n                        console.error('Error examining document.xml:', documentError);\n                    }\n                } else {\n                    console.warn('No word/document.xml found in the template - invalid DOCX structure!');\n                }\n            }\n        } catch (zipError) {\n            console.error('Error creating PizZip instance:', zipError);\n            throw new Error(\"Failed to create ZIP from template: \".concat(zipError instanceof Error ? zipError.message : 'Unknown error'));\n        }\n        console.log('PizZip instance created successfully');\n        // Create a new Docxtemplater instance with improved error handling\n        let doc;\n        try {\n            // Add modules and options for better error handling and debugging\n            doc = new (docxtemplater__WEBPACK_IMPORTED_MODULE_0___default())(zip, {\n                paragraphLoop: true,\n                linebreaks: true,\n                errorLogging: true,\n                // Better handling of missing/null values\n                nullGetter: function(part) {\n                    if (debugMode) {\n                        console.log('Null value encountered for tag:', part);\n                    }\n                    if (!part.module) {\n                        return \"\";\n                    }\n                    if (part.module === \"rawxml\") {\n                        return \"\";\n                    }\n                    return \"\";\n                },\n                // Delimiter options - support both underscore and dot notation\n                delimiters: {\n                    start: '{',\n                    end: '}' // Default closing delimiter\n                }\n            });\n            // Log the template tags found in the document for debugging\n            if (debugMode) {\n                try {\n                    const docXml = zip.files['word/document.xml'];\n                    if (docXml) {\n                        const content = docXml.asText();\n                        const tagPattern = /\\{([^{}]+)\\}/g;\n                        const tags = [];\n                        let match;\n                        while((match = tagPattern.exec(content)) !== null){\n                            tags.push(match[1]);\n                        }\n                        if (tags.length > 0) {\n                            console.log(\"Found \".concat(tags.length, \" tags in template:\"), tags.slice(0, 10), tags.length > 10 ? '... and more' : '');\n                            // Check if tags use underscore notation\n                            const underscorePattern = /_/;\n                            const hasUnderscoreTags = tags.some((tag)=>underscorePattern.test(tag));\n                            console.log(\"Template uses \".concat(hasUnderscoreTags ? 'underscore' : 'dot', \" notation.\"));\n                        } else {\n                            console.warn('No tags found in template document.xml');\n                        }\n                    }\n                } catch (e) {\n                    console.error('Error analyzing template tags:', e);\n                }\n            }\n            console.log('Docxtemplater instance created successfully');\n        } catch (docxError) {\n            console.error('Error creating Docxtemplater instance:', docxError);\n            // Special handling for Multi error (which contains multiple errors)\n            if (docxError && docxError.properties && docxError.properties.errors) {\n                var _firstError_properties;\n                console.log('Docxtemplater reported multiple errors:');\n                // Log each individual error for debugging\n                docxError.properties.errors.forEach((error, index)=>{\n                    console.log(\"Error \".concat(index + 1, \":\"), error);\n                    // Log detailed information if available\n                    if (error.properties) {\n                        if (error.properties.explanation) {\n                            console.log(\"Explanation: \".concat(error.properties.explanation));\n                        }\n                        if (error.properties.id) {\n                            console.log(\"Error ID: \".concat(error.properties.id));\n                        }\n                        if (error.properties.xtag) {\n                            console.log(\"Tag with error: \".concat(error.properties.xtag));\n                        }\n                        if (error.properties.postparsed) {\n                            console.log('Template structure around error:');\n                            console.log(error.properties.postparsed.slice(Math.max(0, error.properties.offset - 5), error.properties.offset + 5));\n                        }\n                    }\n                });\n                // Throw a more detailed error\n                const firstError = docxError.properties.errors[0] || {};\n                const explanation = ((_firstError_properties = firstError.properties) === null || _firstError_properties === void 0 ? void 0 : _firstError_properties.explanation) || 'Unknown template issues';\n                throw new Error(\"Template errors detected: \".concat(explanation, \" (See console for full details)\"));\n            }\n            throw new Error(\"Failed to create Docxtemplater: \".concat(docxError instanceof Error ? docxError.message : 'Unknown error'));\n        }\n        try {\n            // Render the document with the provided data\n            doc.render(data);\n            console.log('Template rendered with data');\n        } catch (renderError) {\n            console.error('Error rendering template:', renderError);\n            // Special handling for Multi error (which contains multiple errors)\n            if (renderError && renderError.properties && renderError.properties.errors) {\n                var _firstError_properties1;\n                console.log('Docxtemplater reported multiple render errors:');\n                // Log each individual error for debugging\n                renderError.properties.errors.forEach((error, index)=>{\n                    console.log(\"Render Error \".concat(index + 1, \":\"), error);\n                    // Log detailed information if available\n                    if (error.properties) {\n                        if (error.properties.explanation) {\n                            console.log(\"Explanation: \".concat(error.properties.explanation));\n                        }\n                        if (error.properties.id) {\n                            console.log(\"Error ID: \".concat(error.properties.id));\n                        }\n                        if (error.properties.xtag) {\n                            console.log(\"Tag with error: \".concat(error.properties.xtag));\n                        }\n                        // Log the data path that caused the issue if known\n                        if (error.properties.tag) {\n                            console.log(\"Template tag: \".concat(error.properties.tag));\n                            console.log(\"Raw tag: \".concat(error.properties.raw));\n                        }\n                    }\n                });\n                // Throw a more detailed error\n                const firstError = renderError.properties.errors[0] || {};\n                const explanation = ((_firstError_properties1 = firstError.properties) === null || _firstError_properties1 === void 0 ? void 0 : _firstError_properties1.explanation) || 'Unknown template rendering issues';\n                throw new Error(\"Template rendering errors: \".concat(explanation, \" (See console for full details)\"));\n            }\n            // Special handling for individual Docxtemplater errors with properties\n            if (renderError instanceof Error && 'properties' in renderError) {\n                const props = renderError.properties || {};\n                console.log('Detailed render error properties:', props);\n                throw new Error(\"Template render error: \".concat(props.explanation || renderError.message));\n            }\n            throw new Error(\"Failed to render template: \".concat(renderError instanceof Error ? renderError.message : 'Unknown error'));\n        }\n        // Generate the output document\n        let output;\n        try {\n            output = doc.getZip().generate({\n                type: 'blob',\n                compression: 'DEFLATE',\n                mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n            });\n            console.log(\"Output document generated successfully (\".concat(output.size, \" bytes)\"));\n        } catch (genError) {\n            console.error('Error generating output document:', genError);\n            throw new Error(\"Failed to generate output: \".concat(genError instanceof Error ? genError.message : 'Unknown error'));\n        }\n        // If running in browser, save the file\n        if (true) {\n            try {\n                (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(output, outputFilename);\n                console.log(\"File saved as \".concat(outputFilename));\n            } catch (saveError) {\n                console.error('Error saving file:', saveError);\n                throw new Error(\"Failed to save file: \".concat(saveError instanceof Error ? saveError.message : 'Unknown error'));\n            }\n        }\n        return output;\n    } catch (error) {\n        console.error('Error in generateDocxFromTemplate:', error);\n        // If it's a PizZip error (likely invalid template)\n        if (error instanceof Error && error.message.includes('zip')) {\n            console.error('PizZip error - invalid template file structure');\n            throw new Error(\"Template file is not a valid DOCX/ZIP file: \".concat(error.message));\n        }\n        // Rethrow the error\n        throw error;\n    }\n}\n/**\n * Generate a fallback HTML report when DOCX template fails\n * @param reportData - The report data to export\n * @returns A blob with HTML content\n */ function generateFallbackHtmlReport(reportData) {\n    var _reportData_header_studentInformation, _reportData_header, _reportData_header_studentInformation1, _reportData_header1, _reportData_header_studentInformation2, _reportData_header2, _reportData_header3, _reportData_assessmentResults, _reportData_conclusion;\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \" \").concat(reportData.header.studentInformation.lastName) : 'Student';\n    // Create a simple HTML representation of the report\n    let html = '\\n    <!DOCTYPE html>\\n    <html>\\n    <head>\\n      <meta charset=\"utf-8\">\\n      <title>Report for '.concat(studentName, \"</title>\\n      <style>\\n        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }\\n        h1, h2, h3 { color: #444; }\\n        .section { margin-bottom: 30px; }\\n        .domain { margin-bottom: 20px; padding: 15px; border: 1px solid #eee; }\\n        .domain-header { display: flex; justify-content: space-between; align-items: center; }\\n        .concern { color: #f59e0b; font-size: 14px; }\\n        .no-concern { color: #10b981; font-size: 14px; }\\n        ul { margin-top: 5px; }\\n        @media print {\\n          body { margin: 0.5in; }\\n          .domain { break-inside: avoid; }\\n        }\\n      </style>\\n    </head>\\n    <body>\\n      <h1>Report for \").concat(studentName, '</h1>\\n      <div class=\"section\">\\n        <h2>Student Information</h2>\\n        <p><strong>DOB:</strong> ').concat(((_reportData_header1 = reportData.header) === null || _reportData_header1 === void 0 ? void 0 : (_reportData_header_studentInformation1 = _reportData_header1.studentInformation) === null || _reportData_header_studentInformation1 === void 0 ? void 0 : _reportData_header_studentInformation1.DOB) || 'N/A', \"</p>\\n        <p><strong>Report Date:</strong> \").concat(((_reportData_header2 = reportData.header) === null || _reportData_header2 === void 0 ? void 0 : (_reportData_header_studentInformation2 = _reportData_header2.studentInformation) === null || _reportData_header_studentInformation2 === void 0 ? void 0 : _reportData_header_studentInformation2.reportDate) || 'N/A', \"</p>\\n        <p><strong>Reason for Referral:</strong> \").concat(((_reportData_header3 = reportData.header) === null || _reportData_header3 === void 0 ? void 0 : _reportData_header3.reasonForReferral) || 'N/A', \"</p>\\n      </div>\\n  \");\n    // Add domains section\n    if ((_reportData_assessmentResults = reportData.assessmentResults) === null || _reportData_assessmentResults === void 0 ? void 0 : _reportData_assessmentResults.domains) {\n        html += '<div class=\"section\"><h2>Assessment Results</h2>';\n        Object.entries(reportData.assessmentResults.domains).forEach((param)=>{\n            let [domainName, domain] = param;\n            var _domain_strengths, _domain_needs;\n            if (domain.topicSentence || ((_domain_strengths = domain.strengths) === null || _domain_strengths === void 0 ? void 0 : _domain_strengths.length) || ((_domain_needs = domain.needs) === null || _domain_needs === void 0 ? void 0 : _domain_needs.length)) {\n                var _domain_strengths1, _domain_needs1;\n                html += '\\n          <div class=\"domain\">\\n            <div class=\"domain-header\">\\n              <h3>'.concat(domainName.charAt(0).toUpperCase() + domainName.slice(1), \" Language</h3>\\n              \").concat(domain.isConcern !== undefined ? '<span class=\"'.concat(domain.isConcern ? 'concern' : 'no-concern', '\">').concat(domain.isConcern ? 'Area of Concern' : 'No Concern', \"</span>\") : '', \"\\n            </div>\\n            \").concat(domain.topicSentence ? \"<p>\".concat(domain.topicSentence, \"</p>\") : '', \"\\n            \\n            \").concat(((_domain_strengths1 = domain.strengths) === null || _domain_strengths1 === void 0 ? void 0 : _domain_strengths1.length) ? \"\\n              <h4>Strengths:</h4>\\n              <ul>\\n                \".concat(domain.strengths.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(((_domain_needs1 = domain.needs) === null || _domain_needs1 === void 0 ? void 0 : _domain_needs1.length) ? \"\\n              <h4>Needs:</h4>\\n              <ul>\\n                \".concat(domain.needs.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(domain.impactStatement ? \"\\n              <h4>Educational Impact:</h4>\\n              <p>\".concat(domain.impactStatement, \"</p>\\n            \") : '', \"\\n          </div>\\n        \");\n            }\n        });\n        html += \"</div>\";\n    }\n    // Add recommendations\n    if ((_reportData_conclusion = reportData.conclusion) === null || _reportData_conclusion === void 0 ? void 0 : _reportData_conclusion.recommendations) {\n        var _reportData_conclusion_recommendations_accommodations, _reportData_conclusion_recommendations_facilitationStrategies;\n        html += '\\n      <div class=\"section\">\\n        <h2>Recommendations</h2>\\n        '.concat(((_reportData_conclusion_recommendations_accommodations = reportData.conclusion.recommendations.accommodations) === null || _reportData_conclusion_recommendations_accommodations === void 0 ? void 0 : _reportData_conclusion_recommendations_accommodations.length) ? \"\\n          <h3>Accommodations:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.accommodations.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n        \\n        \").concat(((_reportData_conclusion_recommendations_facilitationStrategies = reportData.conclusion.recommendations.facilitationStrategies) === null || _reportData_conclusion_recommendations_facilitationStrategies === void 0 ? void 0 : _reportData_conclusion_recommendations_facilitationStrategies.length) ? \"\\n          <h3>Facilitation Strategies:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.facilitationStrategies.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n      </div>\\n    \");\n    }\n    html += \"\\n      <footer>\\n        <p><em>This is a fallback HTML report generated because the DOCX template could not be processed. \\n        You can print this HTML file to create a PDF.</em></p>\\n      </footer>\\n    </body>\\n    </html>\\n  \";\n    return new Blob([\n        html\n    ], {\n        type: 'text/html'\n    });\n}\n/**\n * Create a simple empty DOCX template programmatically\n * This is a last-resort fallback when all template files fail to load\n */ function createEmptyTemplate() {\n    // Define a minimal valid DOCX file structure as a base64 string\n    // This is a simplified empty DOCX file with minimal content\n    const minimalDocxBase64 = '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';\n    // Convert base64 to ArrayBuffer\n    const binaryString = window.atob(minimalDocxBase64);\n    const bytes = new Uint8Array(binaryString.length);\n    for(let i = 0; i < binaryString.length; i++){\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n/**\n * Generate a report docx from the report data\n * @param reportData - The report data from the application\n * @param templateBuffer - The binary template file as an ArrayBuffer (optional)\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateReportDocx(reportData, templateBuffer) {\n    var _reportData_header_studentInformation, _reportData_header;\n    // Generate the filename based on report data\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \"_\").concat(reportData.header.studentInformation.lastName) : 'student';\n    const timestamp = new Date().toISOString().split('T')[0];\n    const filename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".docx\");\n    try {\n        // If no template buffer is provided, use a default template\n        if (!templateBuffer) {\n            // Use fetch to get the template if we're in the browser\n            if (true) {\n                try {\n                    console.log('No template buffer provided, fetching default template');\n                    // Try to use response.arrayBuffer() which ensures binary data handling\n                    // Use las-assessment-report-template.docx instead of report-template.docx (which is a text file, not a DOCX)\n                    const response = await fetch('/templates/las-assessment-report-template.docx', {\n                        method: 'GET',\n                        cache: 'no-cache',\n                        headers: {\n                            'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                            'Cache-Control': 'no-cache'\n                        }\n                    });\n                    if (!response.ok) {\n                        throw new Error(\"Failed to fetch default template: \".concat(response.status));\n                    }\n                    console.log('Default template fetched successfully');\n                    templateBuffer = await response.arrayBuffer();\n                    console.log(\"Default template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                    if (templateBuffer.byteLength === 0) {\n                        throw new Error('Default template file is empty');\n                    }\n                    // Verify the template has a proper DOCX signature\n                    const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                    if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n                        console.error('Invalid DOCX file signature in default template. First bytes:', Array.from(firstBytes));\n                        throw new Error('Default template is not a valid DOCX file');\n                    }\n                } catch (error) {\n                    console.error('Error loading default template:', error);\n                    // Try alternative template as a last resort\n                    try {\n                        console.log('Attempting to load alternative template: las-assessment-report-template-fixed.docx');\n                        const altResponse = await fetch('/templates/las-assessment-report-template-fixed.docx', {\n                            cache: 'no-cache',\n                            headers: {\n                                'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                                'Cache-Control': 'no-cache'\n                            }\n                        });\n                        if (!altResponse.ok) {\n                            throw new Error(\"Failed to fetch alternative template: \".concat(altResponse.status));\n                        }\n                        templateBuffer = await altResponse.arrayBuffer();\n                        console.log(\"Alternative template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        // Verify the alternative template\n                        const altFirstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                        if (!(altFirstBytes[0] === 0x50 && altFirstBytes[1] === 0x4B)) {\n                            console.error('Invalid DOCX file signature in alternative template');\n                            throw new Error('Alternative template is not a valid DOCX file');\n                        }\n                    } catch (altError) {\n                        console.error('Error loading alternative template:', altError);\n                        // As a last resort, create a minimal valid DOCX template\n                        console.log('Creating minimal empty DOCX template');\n                        templateBuffer = createEmptyTemplate();\n                        console.log(\"Created minimal template with size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        if (!templateBuffer || templateBuffer.byteLength === 0) {\n                            // All template attempts failed, fall back to HTML\n                            throw new Error('All template attempts failed');\n                        }\n                    }\n                }\n            } else {}\n        }\n        // Format and prepare data for the template\n        const formattedData = formatReportDataForDocx(reportData);\n        console.log('Data formatted for DOCX template');\n        // First try with the provided template\n        try {\n            // Try with the provided/fetched template\n            console.log('Attempting to generate DOCX with primary template');\n            return await generateDocxFromTemplate(templateBuffer, formattedData, filename);\n        } catch (templateError) {\n            console.error('Error using the provided template:', templateError);\n            // For any error when processing the template, try with a minimal template\n            // that doesn't rely on complex formatting or tags\n            if (templateError instanceof Error) {\n                // Log the full error to help diagnose template issues\n                console.warn('Template error details:');\n                console.log('Error message:', templateError.message);\n                // Log detailed error properties if available\n                if ('properties' in templateError) {\n                    const errorProps = templateError.properties;\n                    if (errorProps && errorProps.errors) {\n                        console.log('Template contains multiple errors:');\n                        errorProps.errors.forEach((err, i)=>{\n                            console.log(\"Error \".concat(i + 1, \":\"), err);\n                            if (err.properties) {\n                                console.log('Properties:', err.properties);\n                            }\n                        });\n                    }\n                }\n                console.warn('Attempting to use minimal template without complex formatting...');\n                // Use the createEmptyTemplate function to generate a minimal template\n                try {\n                    console.log('Creating minimal empty DOCX template');\n                    const minimalTemplateBuffer = createEmptyTemplate();\n                    console.log(\"Minimal template created (\".concat(minimalTemplateBuffer.byteLength, \" bytes)\"));\n                    // Try again with the minimal template\n                    return await generateDocxFromTemplate(minimalTemplateBuffer, formattedData, filename);\n                } catch (minimalError) {\n                    console.error('Error with minimal template:', minimalError);\n                    // Let the outer catch handle the fallback to HTML\n                    throw minimalError;\n                }\n            } else {\n                // Rethrow to let the outer catch handle it\n                throw templateError;\n            }\n        }\n    } catch (error) {\n        console.error('Error in generateReportDocx:', error);\n        // If all DOCX generation attempts failed, fall back to HTML\n        console.warn('All DOCX generation attempts failed, falling back to HTML export');\n        const htmlBlob = generateFallbackHtmlReport(reportData);\n        const htmlFilename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".html\");\n        if (true) {\n            (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(htmlBlob, htmlFilename);\n        }\n        return htmlBlob;\n    }\n}\n/**\n * Flattens a nested object structure, converting nested properties to underscore notation\n * This ensures compatibility with docxtemplater templates that use underscore notation\n * \n * @param obj - The object to flatten\n * @param prefix - Optional prefix for the current level of nesting (used in recursion)\n * @param result - Accumulator for the flattened object (used in recursion)\n * @returns A flattened object with underscore notation keys\n */ function flattenObject(obj) {\n    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '', result = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    // Skip null or undefined objects\n    if (obj == null) return result;\n    // Process each key in the object\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            const value = obj[key];\n            const newKey = prefix ? \"\".concat(prefix, \"_\").concat(key) : key;\n            // Recursively flatten nested objects\n            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n                flattenObject(value, newKey, result);\n            } else {\n                // For arrays, keep them as is (docxtemplater can handle arrays)\n                result[newKey] = value;\n                // If this is an array, add a _list version for template loop compatibility\n                if (Array.isArray(value) && key.toLowerCase().endsWith('s') && !key.endsWith('List') && !key.endsWith('list')) {\n                    // Create a list version with objects containing a text property\n                    const singularKey = key.slice(0, -1); // Remove trailing 's'\n                    const listKey = \"\".concat(newKey, \"List\");\n                    result[listKey] = value.map((item)=>{\n                        // If the item is already an object, use it; otherwise wrap it\n                        if (typeof item === 'object' && item !== null) {\n                            return item;\n                        }\n                        return {\n                            text: item\n                        };\n                    });\n                }\n            }\n        }\n    }\n    return result;\n}\n/**\n * Format the report data for docx template rendering\n * @param reportData - The raw report data from the application\n * @returns Formatted data ready for docx template\n */ function formatReportDataForDocx(reportData) {\n    var _formattedData_assessmentResults, _formattedData_conclusion_recommendations, _formattedData_conclusion, _formattedData_conclusion1, _formattedData_conclusion_recommendations1, _formattedData_conclusion2, _formattedData_conclusion3, _formattedData_header_studentInformation, _formattedData_header, _formattedData_header1, _formattedData_header_studentInformation1, _formattedData_header2, _formattedData_header3;\n    // Create a deep copy of the report data\n    const formattedData = JSON.parse(JSON.stringify(reportData));\n    // Format arrays to be more docx-template friendly\n    // Arrays in docxtemplater are typically handled with loops, so we'll format them\n    // to be ready for the template syntax\n    // Process strength and needs lists for each domain\n    Object.keys(((_formattedData_assessmentResults = formattedData.assessmentResults) === null || _formattedData_assessmentResults === void 0 ? void 0 : _formattedData_assessmentResults.domains) || {}).forEach((domain)=>{\n        const domainData = formattedData.assessmentResults.domains[domain];\n        // Format strengths as bullet points for DOCX\n        if (Array.isArray(domainData.strengths) && domainData.strengths.length > 0) {\n            domainData.strengthsList = domainData.strengths.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.strengthsList = [];\n        }\n        // Format needs as bullet points for DOCX\n        if (Array.isArray(domainData.needs) && domainData.needs.length > 0) {\n            domainData.needsList = domainData.needs.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.needsList = [];\n        }\n    });\n    // Format accommodation and facilitation strategies\n    if (Array.isArray((_formattedData_conclusion = formattedData.conclusion) === null || _formattedData_conclusion === void 0 ? void 0 : (_formattedData_conclusion_recommendations = _formattedData_conclusion.recommendations) === null || _formattedData_conclusion_recommendations === void 0 ? void 0 : _formattedData_conclusion_recommendations.accommodations)) {\n        formattedData.conclusion.recommendations.accommodationsList = formattedData.conclusion.recommendations.accommodations.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion1 = formattedData.conclusion) === null || _formattedData_conclusion1 === void 0 ? void 0 : _formattedData_conclusion1.recommendations) {\n        formattedData.conclusion.recommendations.accommodationsList = [];\n    }\n    if (Array.isArray((_formattedData_conclusion2 = formattedData.conclusion) === null || _formattedData_conclusion2 === void 0 ? void 0 : (_formattedData_conclusion_recommendations1 = _formattedData_conclusion2.recommendations) === null || _formattedData_conclusion_recommendations1 === void 0 ? void 0 : _formattedData_conclusion_recommendations1.facilitationStrategies)) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = formattedData.conclusion.recommendations.facilitationStrategies.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion3 = formattedData.conclusion) === null || _formattedData_conclusion3 === void 0 ? void 0 : _formattedData_conclusion3.recommendations) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = [];\n    }\n    // Convert parents array to string if needed\n    if (Array.isArray((_formattedData_header = formattedData.header) === null || _formattedData_header === void 0 ? void 0 : (_formattedData_header_studentInformation = _formattedData_header.studentInformation) === null || _formattedData_header_studentInformation === void 0 ? void 0 : _formattedData_header_studentInformation.parents)) {\n        formattedData.header.studentInformation.parentsString = formattedData.header.studentInformation.parents.join(', ');\n    } else if ((_formattedData_header1 = formattedData.header) === null || _formattedData_header1 === void 0 ? void 0 : _formattedData_header1.studentInformation) {\n        formattedData.header.studentInformation.parentsString = '';\n    }\n    // Add full student name for convenience\n    if ((_formattedData_header2 = formattedData.header) === null || _formattedData_header2 === void 0 ? void 0 : (_formattedData_header_studentInformation1 = _formattedData_header2.studentInformation) === null || _formattedData_header_studentInformation1 === void 0 ? void 0 : _formattedData_header_studentInformation1.firstName) {\n        formattedData.header.studentInformation.fullName = \"\".concat(formattedData.header.studentInformation.firstName, \" \").concat(formattedData.header.studentInformation.lastName || '');\n    } else if ((_formattedData_header3 = formattedData.header) === null || _formattedData_header3 === void 0 ? void 0 : _formattedData_header3.studentInformation) {\n        formattedData.header.studentInformation.fullName = 'Student';\n    }\n    // Flatten the data structure to match underscore-formatted template tags\n    // For example: header.studentInformation.firstName becomes header_studentInformation_firstName\n    const flattenedData = flattenObject(formattedData);\n    // Log the flattened data structure for debugging\n    console.log('Flattened data ready for template:');\n    console.log('Keys:', Object.keys(flattenedData).slice(0, 10), '... and more');\n    return flattenedData;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZG9jeC1nZW5lcmF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMEM7QUFDZDtBQUNRO0FBRXBDOzs7Ozs7O0NBT0MsR0FDTSxlQUFlRyx5QkFDcEJDLGNBQTJCLEVBQzNCQyxJQUF5QjtRQUN6QkMsaUJBQUFBLGlFQUF5QixlQUN6QkMsWUFBQUEsZ0RBQTBCLGdFQUFnRTtzQkFBckU7SUFFckIsSUFBSTtRQUNGQyxRQUFRQyxHQUFHLENBQUMsMERBQW9GLE9BQTFCTCxlQUFlTSxVQUFVLEVBQUM7UUFFaEcsb0RBQW9EO1FBQ3BELElBQUlILFdBQVc7WUFDYkMsUUFBUUMsR0FBRyxDQUFDLGtDQUFrQ0UsS0FBS0MsU0FBUyxDQUFDUCxNQUFNLE1BQU07WUFDekVHLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJMLGVBQWVNLFVBQVU7WUFDOUQsMkVBQTJFO1lBQzNFLE1BQU1HLGFBQWEsSUFBSUMsV0FBV1YsZUFBZVcsS0FBSyxDQUFDLEdBQUc7WUFDMURQLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUNPLE1BQU1DLElBQUksQ0FBQ0osWUFBWUssR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDO1FBQ3pIO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQ2xCLGtCQUFrQkEsZUFBZU0sVUFBVSxLQUFLLEdBQUc7WUFDdEQsTUFBTSxJQUFJYSxNQUFNO1FBQ2xCO1FBRUEsZ0ZBQWdGO1FBQ2hGLE1BQU1WLGFBQWEsSUFBSUMsV0FBV1YsZUFBZVcsS0FBSyxDQUFDLEdBQUc7UUFDMUQsSUFBSSxDQUFFRixDQUFBQSxVQUFVLENBQUMsRUFBRSxLQUFLLFFBQVFBLFVBQVUsQ0FBQyxFQUFFLEtBQUssSUFBRyxHQUFJO1lBQ3ZETCxRQUFRZ0IsS0FBSyxDQUFDLHdEQUF3RFIsTUFBTUMsSUFBSSxDQUFDSjtZQUNqRixNQUFNLElB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QUc7SUFDckQ7SUFFQSx5RUFBeUU7SUFDekUsK0ZBQStGO0lBQy9GLE1BQU1DLGdCQUFnQnpCLGNBQWNUO0lBRXBDLGlEQUFpRDtJQUNqRDlJLFFBQVFDLEdBQUcsQ0FBQztJQUNaRCxRQUFRQyxHQUFHLENBQUMsU0FBU21CLE9BQU9DLElBQUksQ0FBQzJKLGVBQWV6SyxLQUFLLENBQUMsR0FBRyxLQUFLO0lBRTlELE9BQU95SztBQUNUIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L3NyYy9saWIvZG9jeC1nZW5lcmF0b3IudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERvY3h0ZW1wbGF0ZXIgZnJvbSAnZG9jeHRlbXBsYXRlcic7XG5pbXBvcnQgUGl6WmlwIGZyb20gJ3BpenppcCc7XG5pbXBvcnQgeyBzYXZlQXMgfSBmcm9tICdmaWxlLXNhdmVyJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGRvY3ggZmlsZSBmcm9tIGEgdGVtcGxhdGUgYW5kIGRhdGFcbiAqIEBwYXJhbSB0ZW1wbGF0ZUJ1ZmZlciAtIFRoZSBiaW5hcnkgdGVtcGxhdGUgZmlsZSBhcyBhbiBBcnJheUJ1ZmZlclxuICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSB0byBpbmplY3QgaW50byB0aGUgdGVtcGxhdGVcbiAqIEBwYXJhbSBvdXRwdXRGaWxlbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIHNhdmVcbiAqIEBwYXJhbSBkZWJ1Z01vZGUgLSBXaGV0aGVyIHRvIGVuYWJsZSBleHRyYSBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBnZW5lcmF0ZWQgZmlsZSBhcyBhIEJsb2JcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlRG9jeEZyb21UZW1wbGF0ZShcbiAgdGVtcGxhdGVCdWZmZXI6IEFycmF5QnVmZmVyLFxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBvdXRwdXRGaWxlbmFtZTogc3RyaW5nID0gJ3JlcG9ydC5kb2N4JyxcbiAgZGVidWdNb2RlOiBib29sZWFuID0gdHJ1ZSAvLyBFbmFibGUgZGVidWcgbW9kZSBieSBkZWZhdWx0IHRvIGhlbHAgZGlhZ25vc2UgdGVtcGxhdGUgaXNzdWVzXG4pOiBQcm9taXNlPEJsb2I+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyB0byBjcmVhdGUgUGl6WmlwIGluc3RhbmNlIHdpdGggYnVmZmVyIHNpemU6ICR7dGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aH0gYnl0ZXNgKTtcbiAgICBcbiAgICAvLyBPdXRwdXQgZGVidWcgaW5mb3JtYXRpb24gaWYgZGVidWcgbW9kZSBpcyBlbmFibGVkXG4gICAgaWYgKGRlYnVnTW9kZSkge1xuICAgICAgY29uc29sZS5sb2coJ0RhdGEgYmVpbmcgcGFzc2VkIHRvIHRlbXBsYXRlOicsIEpTT04uc3RyaW5naWZ5KGRhdGEsIG51bGwsIDIpKTtcbiAgICAgIGNvbnNvbGUubG9nKCdUZW1wbGF0ZSBidWZmZXIgc2l6ZTonLCB0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIC8vIExvZyB0aGUgZmlyc3QgMjAgYnl0ZXMgb2YgdGhlIHRlbXBsYXRlIHRvIHZlcmlmeSBpdCdzIGEgcHJvcGVyIERPQ1ggZmlsZVxuICAgICAgY29uc3QgZmlyc3RCeXRlcyA9IG5ldyBVaW50OEFycmF5KHRlbXBsYXRlQnVmZmVyLnNsaWNlKDAsIDIwKSk7XG4gICAgICBjb25zb2xlLmxvZygnRmlyc3QgMjAgYnl0ZXMgb2YgdGVtcGxhdGUgKGhleCk6JywgQXJyYXkuZnJvbShmaXJzdEJ5dGVzKS5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcgJykpO1xuICAgIH1cbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IHdlIGhhdmUgYSBwcm9wZXIgYnVmZmVyXG4gICAgaWYgKCF0ZW1wbGF0ZUJ1ZmZlciB8fCB0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUgYnVmZmVyOiBFbXB0eSBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSBidWZmZXIgaGFzIGEgWklQIHNpZ25hdHVyZSAoZmlyc3QgYnl0ZXMgb2YgYSBwcm9wZXIgRE9DWC9aSVAgZmlsZSlcbiAgICBjb25zdCBmaXJzdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGVtcGxhdGVCdWZmZXIuc2xpY2UoMCwgNCkpO1xuICAgIGlmICghKGZpcnN0Qnl0ZXNbMF0gPT09IDB4NTAgJiYgZmlyc3RCeXRlc1sxXSA9PT0gMHg0QikpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgWklQIGZpbGUgc2lnbmF0dXJlIGluIHRlbXBsYXRlLiBGaXJzdCBieXRlczonLCBBcnJheS5mcm9tKGZpcnN0Qnl0ZXMpKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRlbXBsYXRlIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHZhbGlkIFpJUC9ET0NYIGZpbGUgKG1pc3NpbmcgUEsgc2lnbmF0dXJlKScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgYSBuZXcgUGl6WmlwIGluc3RhbmNlIHdpdGggdGhlIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAvLyBVc2UgYSB0cnktY2F0Y2ggc3BlY2lmaWNhbGx5IGZvciB0aGUgUGl6WmlwIGluc3RhbnRpYXRpb25cbiAgICBsZXQgemlwO1xuICAgIHRyeSB7XG4gICAgICAvLyBDb252ZXJ0IEFycmF5QnVmZmVyIHRvIFVpbnQ4QXJyYXkgdG8gZW5zdXJlIHByb3BlciBiaW5hcnkgaGFuZGxpbmdcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGVtcGxhdGVCdWZmZXIpO1xuICAgICAgemlwID0gbmV3IFBpelppcChhcnJheUJ1ZmZlcik7XG4gICAgICBcbiAgICAgIC8vIElmIGluIGRlYnVnIG1vZGUsIGV4YW1pbmUgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZG9jdW1lbnRcbiAgICAgIGlmIChkZWJ1Z01vZGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1BpelppcCBvcGVuZWQgc3VjY2Vzc2Z1bGx5LCBpbnNwZWN0aW5nIGNvbnRlbnRzOicpO1xuICAgICAgICBcbiAgICAgICAgLy8gTGlzdCBhbGwgZmlsZXMgaW4gdGhlIERPQ1ggKHdoaWNoIGlzIGEgWklQKVxuICAgICAgICBjb25zdCBmaWxlcyA9IE9iamVjdC5rZXlzKHppcC5maWxlcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBET0NYIGNvbnRhaW5zICR7ZmlsZXMubGVuZ3RofSBmaWxlczpgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExvZyB0aGUgZG9jdW1lbnQgc3RydWN0dXJlIChmaXJzdCAxMCBmaWxlcylcbiAgICAgICAgZmlsZXMuc2xpY2UoMCwgMTApLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgY29uc3QgZmlsZUVudHJ5ID0gemlwLmZpbGVzW2ZpbGVdO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGAgLSAke2ZpbGV9ICgke2ZpbGVFbnRyeS5uYW1lfSwgc2l6ZTogJHtmaWxlRW50cnkuX2RhdGEgPyBmaWxlRW50cnkuX2RhdGEubGVuZ3RoIDogJ3Vua25vd24nfSBieXRlcylgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTcGVjaWZpY2FsbHkgY2hlY2sgZm9yIGRvY3VtZW50LnhtbCAobWFpbiBjb250ZW50IGZpbGUpXG4gICAgICAgIGlmICh6aXAuZmlsZXNbJ3dvcmQvZG9jdW1lbnQueG1sJ10pIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnRDb250ZW50ID0gemlwLmZpbGVzWyd3b3JkL2RvY3VtZW50LnhtbCddLmFzVGV4dCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBMb2cgYSBzbmlwcGV0IG9mIHRoZSBkb2N1bWVudC54bWwgZm9yIHRlbXBsYXRlIGRlYnVnZ2luZ1xuICAgICAgICAgICAgY29uc3Qgc25pcHBldCA9IGRvY3VtZW50Q29udGVudC5zdWJzdHJpbmcoMCwgNTAwKSArICcuLi4gW3RydW5jYXRlZF0nO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0RvY3VtZW50IGNvbnRlbnQgcHJldmlldzonLCBzbmlwcGV0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTG9vayBmb3IgdGVtcGxhdGUgdGFnIHBhdHRlcm5zXG4gICAgICAgICAgICBjb25zdCB0YWdNYXRjaGVzID0gZG9jdW1lbnRDb250ZW50Lm1hdGNoKC9cXHtbXnt9XStcXH0vZyk7XG4gICAgICAgICAgICBpZiAodGFnTWF0Y2hlcyAmJiB0YWdNYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7dGFnTWF0Y2hlcy5sZW5ndGh9IHRlbXBsYXRlIHRhZ3M6YCwgdGFnTWF0Y2hlcy5zbGljZSgwLCAyMCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyB0ZW1wbGF0ZSB0YWdzIGZvdW5kIGluIGRvY3VtZW50LnhtbCAtIHRlbXBsYXRlIG1heSBub3QgYmUgcHJvcGVybHkgc2V0IHVwIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGRvY3VtZW50RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4YW1pbmluZyBkb2N1bWVudC54bWw6JywgZG9jdW1lbnRFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignTm8gd29yZC9kb2N1bWVudC54bWwgZm91bmQgaW4gdGhlIHRlbXBsYXRlIC0gaW52YWxpZCBET0NYIHN0cnVjdHVyZSEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKHppcEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBQaXpaaXAgaW5zdGFuY2U6JywgemlwRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIFpJUCBmcm9tIHRlbXBsYXRlOiAke3ppcEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyB6aXBFcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygnUGl6WmlwIGluc3RhbmNlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgbmV3IERvY3h0ZW1wbGF0ZXIgaW5zdGFuY2Ugd2l0aCBpbXByb3ZlZCBlcnJvciBoYW5kbGluZ1xuICAgIGxldCBkb2M7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEFkZCBtb2R1bGVzIGFuZCBvcHRpb25zIGZvciBiZXR0ZXIgZXJyb3IgaGFuZGxpbmcgYW5kIGRlYnVnZ2luZ1xuICAgICAgZG9jID0gbmV3IERvY3h0ZW1wbGF0ZXIoemlwLCB7XG4gICAgICAgIHBhcmFncmFwaExvb3A6IHRydWUsXG4gICAgICAgIGxpbmVicmVha3M6IHRydWUsXG4gICAgICAgIGVycm9yTG9nZ2luZzogdHJ1ZSxcbiAgICAgICAgLy8gQmV0dGVyIGhhbmRsaW5nIG9mIG1pc3NpbmcvbnVsbCB2YWx1ZXNcbiAgICAgICAgbnVsbEdldHRlcjogZnVuY3Rpb24ocGFydDogYW55KSB7XG4gICAgICAgICAgaWYgKGRlYnVnTW9kZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ051bGwgdmFsdWUgZW5jb3VudGVyZWQgZm9yIHRhZzonLCBwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwYXJ0Lm1vZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0Lm1vZHVsZSA9PT0gXCJyYXd4bWxcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9LFxuICAgICAgICAvLyBEZWxpbWl0ZXIgb3B0aW9ucyAtIHN1cHBvcnQgYm90aCB1bmRlcnNjb3JlIGFuZCBkb3Qgbm90YXRpb25cbiAgICAgICAgZGVsaW1pdGVyczoge1xuICAgICAgICAgIHN0YXJ0OiAneycsICAvLyBEZWZhdWx0IG9wZW5pbmcgZGVsaW1pdGVyXG4gICAgICAgICAgZW5kOiAnfScgICAgIC8vIERlZmF1bHQgY2xvc2luZyBkZWxpbWl0ZXJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIExvZyB0aGUgdGVtcGxhdGUgdGFncyBmb3VuZCBpbiB0aGUgZG9jdW1lbnQgZm9yIGRlYnVnZ2luZ1xuICAgICAgaWYgKGRlYnVnTW9kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRvY1htbCA9IHppcC5maWxlc1snd29yZC9kb2N1bWVudC54bWwnXTtcbiAgICAgICAgICBpZiAoZG9jWG1sKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jWG1sLmFzVGV4dCgpO1xuICAgICAgICAgICAgY29uc3QgdGFnUGF0dGVybiA9IC9cXHsoW157fV0rKVxcfS9nO1xuICAgICAgICAgICAgY29uc3QgdGFncyA9IFtdO1xuICAgICAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGFnUGF0dGVybi5leGVjKGNvbnRlbnQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0YWdzLnB1c2gobWF0Y2hbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke3RhZ3MubGVuZ3RofSB0YWdzIGluIHRlbXBsYXRlOmAsIHRhZ3Muc2xpY2UoMCwgMTApLCB0YWdzLmxlbmd0aCA+IDEwID8gJy4uLiBhbmQgbW9yZScgOiAnJyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0YWdzIHVzZSB1bmRlcnNjb3JlIG5vdGF0aW9uXG4gICAgICAgICAgICAgIGNvbnN0IHVuZGVyc2NvcmVQYXR0ZXJuID0gL18vO1xuICAgICAgICAgICAgICBjb25zdCBoYXNVbmRlcnNjb3JlVGFncyA9IHRhZ3Muc29tZSh0YWcgPT4gdW5kZXJzY29yZVBhdHRlcm4udGVzdCh0YWcpKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUZW1wbGF0ZSB1c2VzICR7aGFzVW5kZXJzY29yZVRhZ3MgPyAndW5kZXJzY29yZScgOiAnZG90J30gbm90YXRpb24uYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIHRhZ3MgZm91bmQgaW4gdGVtcGxhdGUgZG9jdW1lbnQueG1sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYW5hbHl6aW5nIHRlbXBsYXRlIHRhZ3M6JywgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnNvbGUubG9nKCdEb2N4dGVtcGxhdGVyIGluc3RhbmNlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgfSBjYXRjaCAoZG9jeEVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIERvY3h0ZW1wbGF0ZXIgaW5zdGFuY2U6JywgZG9jeEVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgTXVsdGkgZXJyb3IgKHdoaWNoIGNvbnRhaW5zIG11bHRpcGxlIGVycm9ycylcbiAgICAgIGlmIChkb2N4RXJyb3IgJiYgZG9jeEVycm9yLnByb3BlcnRpZXMgJiYgZG9jeEVycm9yLnByb3BlcnRpZXMuZXJyb3JzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdEb2N4dGVtcGxhdGVyIHJlcG9ydGVkIG11bHRpcGxlIGVycm9yczonKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExvZyBlYWNoIGluZGl2aWR1YWwgZXJyb3IgZm9yIGRlYnVnZ2luZ1xuICAgICAgICBkb2N4RXJyb3IucHJvcGVydGllcy5lcnJvcnMuZm9yRWFjaCgoZXJyb3I6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciAke2luZGV4ICsgMX06YCwgZXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEV4cGxhbmF0aW9uOiAke2Vycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcy5pZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgSUQ6ICR7ZXJyb3IucHJvcGVydGllcy5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLnh0YWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFRhZyB3aXRoIGVycm9yOiAke2Vycm9yLnByb3BlcnRpZXMueHRhZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLnBvc3RwYXJzZWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlbXBsYXRlIHN0cnVjdHVyZSBhcm91bmQgZXJyb3I6Jyk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yLnByb3BlcnRpZXMucG9zdHBhcnNlZC5zbGljZShNYXRoLm1heCgwLCBlcnJvci5wcm9wZXJ0aWVzLm9mZnNldCAtIDUpLCBlcnJvci5wcm9wZXJ0aWVzLm9mZnNldCArIDUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhyb3cgYSBtb3JlIGRldGFpbGVkIGVycm9yXG4gICAgICAgIGNvbnN0IGZpcnN0RXJyb3IgPSBkb2N4RXJyb3IucHJvcGVydGllcy5lcnJvcnNbMF0gfHwge307XG4gICAgICAgIGNvbnN0IGV4cGxhbmF0aW9uID0gZmlyc3RFcnJvci5wcm9wZXJ0aWVzPy5leHBsYW5hdGlvbiB8fCAnVW5rbm93biB0ZW1wbGF0ZSBpc3N1ZXMnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIGVycm9ycyBkZXRlY3RlZDogJHtleHBsYW5hdGlvbn0gKFNlZSBjb25zb2xlIGZvciBmdWxsIGRldGFpbHMpYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBEb2N4dGVtcGxhdGVyOiAke2RvY3hFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZG9jeEVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBSZW5kZXIgdGhlIGRvY3VtZW50IHdpdGggdGhlIHByb3ZpZGVkIGRhdGFcbiAgICAgIGRvYy5yZW5kZXIoZGF0YSk7XG4gICAgICBjb25zb2xlLmxvZygnVGVtcGxhdGUgcmVuZGVyZWQgd2l0aCBkYXRhJyk7XG4gICAgfSBjYXRjaCAocmVuZGVyRXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVuZGVyaW5nIHRlbXBsYXRlOicsIHJlbmRlckVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgTXVsdGkgZXJyb3IgKHdoaWNoIGNvbnRhaW5zIG11bHRpcGxlIGVycm9ycylcbiAgICAgIGlmIChyZW5kZXJFcnJvciAmJiByZW5kZXJFcnJvci5wcm9wZXJ0aWVzICYmIHJlbmRlckVycm9yLnByb3BlcnRpZXMuZXJyb3JzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdEb2N4dGVtcGxhdGVyIHJlcG9ydGVkIG11bHRpcGxlIHJlbmRlciBlcnJvcnM6Jyk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2cgZWFjaCBpbmRpdmlkdWFsIGVycm9yIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgcmVuZGVyRXJyb3IucHJvcGVydGllcy5lcnJvcnMuZm9yRWFjaCgoZXJyb3I6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBSZW5kZXIgRXJyb3IgJHtpbmRleCArIDF9OmAsIGVycm9yKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBMb2cgZGV0YWlsZWQgaW5mb3JtYXRpb24gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLmV4cGxhbmF0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFeHBsYW5hdGlvbjogJHtlcnJvci5wcm9wZXJ0aWVzLmV4cGxhbmF0aW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMuaWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVycm9yIElEOiAke2Vycm9yLnByb3BlcnRpZXMuaWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcy54dGFnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUYWcgd2l0aCBlcnJvcjogJHtlcnJvci5wcm9wZXJ0aWVzLnh0YWd9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb2cgdGhlIGRhdGEgcGF0aCB0aGF0IGNhdXNlZCB0aGUgaXNzdWUgaWYga25vd25cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLnRhZykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVGVtcGxhdGUgdGFnOiAke2Vycm9yLnByb3BlcnRpZXMudGFnfWApO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmF3IHRhZzogJHtlcnJvci5wcm9wZXJ0aWVzLnJhd31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhyb3cgYSBtb3JlIGRldGFpbGVkIGVycm9yXG4gICAgICAgIGNvbnN0IGZpcnN0RXJyb3IgPSByZW5kZXJFcnJvci5wcm9wZXJ0aWVzLmVycm9yc1swXSB8fCB7fTtcbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSBmaXJzdEVycm9yLnByb3BlcnRpZXM/LmV4cGxhbmF0aW9uIHx8ICdVbmtub3duIHRlbXBsYXRlIHJlbmRlcmluZyBpc3N1ZXMnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIHJlbmRlcmluZyBlcnJvcnM6ICR7ZXhwbGFuYXRpb259IChTZWUgY29uc29sZSBmb3IgZnVsbCBkZXRhaWxzKWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBpbmRpdmlkdWFsIERvY3h0ZW1wbGF0ZXIgZXJyb3JzIHdpdGggcHJvcGVydGllc1xuICAgICAgaWYgKHJlbmRlckVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3Byb3BlcnRpZXMnIGluIHJlbmRlckVycm9yKSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gcmVuZGVyRXJyb3IucHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgY29uc29sZS5sb2coJ0RldGFpbGVkIHJlbmRlciBlcnJvciBwcm9wZXJ0aWVzOicsIHByb3BzKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW1wbGF0ZSByZW5kZXIgZXJyb3I6ICR7cHJvcHMuZXhwbGFuYXRpb24gfHwgcmVuZGVyRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVuZGVyIHRlbXBsYXRlOiAke3JlbmRlckVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyByZW5kZXJFcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZW5lcmF0ZSB0aGUgb3V0cHV0IGRvY3VtZW50XG4gICAgbGV0IG91dHB1dDtcbiAgICB0cnkge1xuICAgICAgb3V0cHV0ID0gZG9jLmdldFppcCgpLmdlbmVyYXRlKHtcbiAgICAgICAgdHlwZTogJ2Jsb2InLFxuICAgICAgICBjb21wcmVzc2lvbjogJ0RFRkxBVEUnLFxuICAgICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50JyxcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coYE91dHB1dCBkb2N1bWVudCBnZW5lcmF0ZWQgc3VjY2Vzc2Z1bGx5ICgke291dHB1dC5zaXplfSBieXRlcylgKTtcbiAgICB9IGNhdGNoIChnZW5FcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBvdXRwdXQgZG9jdW1lbnQ6JywgZ2VuRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgb3V0cHV0OiAke2dlbkVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBnZW5FcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiBydW5uaW5nIGluIGJyb3dzZXIsIHNhdmUgdGhlIGZpbGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNhdmVBcyhvdXRwdXQsIG91dHB1dEZpbGVuYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coYEZpbGUgc2F2ZWQgYXMgJHtvdXRwdXRGaWxlbmFtZX1gKTtcbiAgICAgIH0gY2F0Y2ggKHNhdmVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgZmlsZTonLCBzYXZlRXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzYXZlIGZpbGU6ICR7c2F2ZUVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBzYXZlRXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZW5lcmF0ZURvY3hGcm9tVGVtcGxhdGU6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIElmIGl0J3MgYSBQaXpaaXAgZXJyb3IgKGxpa2VseSBpbnZhbGlkIHRlbXBsYXRlKVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3ppcCcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdQaXpaaXAgZXJyb3IgLSBpbnZhbGlkIHRlbXBsYXRlIGZpbGUgc3RydWN0dXJlJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIGZpbGUgaXMgbm90IGEgdmFsaWQgRE9DWC9aSVAgZmlsZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXRocm93IHRoZSBlcnJvclxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBmYWxsYmFjayBIVE1MIHJlcG9ydCB3aGVuIERPQ1ggdGVtcGxhdGUgZmFpbHNcbiAqIEBwYXJhbSByZXBvcnREYXRhIC0gVGhlIHJlcG9ydCBkYXRhIHRvIGV4cG9ydFxuICogQHJldHVybnMgQSBibG9iIHdpdGggSFRNTCBjb250ZW50XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRmFsbGJhY2tIdG1sUmVwb3J0KHJlcG9ydERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBCbG9iIHtcbiAgY29uc3Qgc3R1ZGVudE5hbWUgPSByZXBvcnREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5maXJzdE5hbWUgXG4gICAgPyBgJHtyZXBvcnREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZmlyc3ROYW1lfSAke3JlcG9ydERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5sYXN0TmFtZX1gXG4gICAgOiAnU3R1ZGVudCc7XG4gIFxuICAvLyBDcmVhdGUgYSBzaW1wbGUgSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVwb3J0XG4gIGxldCBodG1sID0gYFxuICAgIDwhRE9DVFlQRSBodG1sPlxuICAgIDxodG1sPlxuICAgIDxoZWFkPlxuICAgICAgPG1ldGEgY2hhcnNldD1cInV0Zi04XCI+XG4gICAgICA8dGl0bGU+UmVwb3J0IGZvciAke3N0dWRlbnROYW1lfTwvdGl0bGU+XG4gICAgICA8c3R5bGU+XG4gICAgICAgIGJvZHkgeyBmb250LWZhbWlseTogQXJpYWwsIHNhbnMtc2VyaWY7IG1hcmdpbjogNDBweDsgbGluZS1oZWlnaHQ6IDEuNjsgfVxuICAgICAgICBoMSwgaDIsIGgzIHsgY29sb3I6ICM0NDQ7IH1cbiAgICAgICAgLnNlY3Rpb24geyBtYXJnaW4tYm90dG9tOiAzMHB4OyB9XG4gICAgICAgIC5kb21haW4geyBtYXJnaW4tYm90dG9tOiAyMHB4OyBwYWRkaW5nOiAxNXB4OyBib3JkZXI6IDFweCBzb2xpZCAjZWVlOyB9XG4gICAgICAgIC5kb21haW4taGVhZGVyIHsgZGlzcGxheTogZmxleDsganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOyBhbGlnbi1pdGVtczogY2VudGVyOyB9XG4gICAgICAgIC5jb25jZXJuIHsgY29sb3I6ICNmNTllMGI7IGZvbnQtc2l6ZTogMTRweDsgfVxuICAgICAgICAubm8tY29uY2VybiB7IGNvbG9yOiAjMTBiOTgxOyBmb250LXNpemU6IDE0cHg7IH1cbiAgICAgICAgdWwgeyBtYXJnaW4tdG9wOiA1cHg7IH1cbiAgICAgICAgQG1lZGlhIHByaW50IHtcbiAgICAgICAgICBib2R5IHsgbWFyZ2luOiAwLjVpbjsgfVxuICAgICAgICAgIC5kb21haW4geyBicmVhay1pbnNpZGU6IGF2b2lkOyB9XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9oZWFkPlxuICAgIDxib2R5PlxuICAgICAgPGgxPlJlcG9ydCBmb3IgJHtzdHVkZW50TmFtZX08L2gxPlxuICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb25cIj5cbiAgICAgICAgPGgyPlN0dWRlbnQgSW5mb3JtYXRpb248L2gyPlxuICAgICAgICA8cD48c3Ryb25nPkRPQjo8L3N0cm9uZz4gJHtyZXBvcnREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5ET0IgfHwgJ04vQSd9PC9wPlxuICAgICAgICA8cD48c3Ryb25nPlJlcG9ydCBEYXRlOjwvc3Ryb25nPiAke3JlcG9ydERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24/LnJlcG9ydERhdGUgfHwgJ04vQSd9PC9wPlxuICAgICAgICA8cD48c3Ryb25nPlJlYXNvbiBmb3IgUmVmZXJyYWw6PC9zdHJvbmc+ICR7cmVwb3J0RGF0YS5oZWFkZXI/LnJlYXNvbkZvclJlZmVycmFsIHx8ICdOL0EnfTwvcD5cbiAgICAgIDwvZGl2PlxuICBgO1xuICBcbiAgLy8gQWRkIGRvbWFpbnMgc2VjdGlvblxuICBpZiAocmVwb3J0RGF0YS5hc3Nlc3NtZW50UmVzdWx0cz8uZG9tYWlucykge1xuICAgIGh0bWwgKz0gYDxkaXYgY2xhc3M9XCJzZWN0aW9uXCI+PGgyPkFzc2Vzc21lbnQgUmVzdWx0czwvaDI+YDtcbiAgICBcbiAgICBPYmplY3QuZW50cmllcyhyZXBvcnREYXRhLmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnMpLmZvckVhY2goKFtkb21haW5OYW1lLCBkb21haW5dOiBbc3RyaW5nLCBhbnldKSA9PiB7XG4gICAgICBpZiAoZG9tYWluLnRvcGljU2VudGVuY2UgfHwgZG9tYWluLnN0cmVuZ3Rocz8ubGVuZ3RoIHx8IGRvbWFpbi5uZWVkcz8ubGVuZ3RoKSB7XG4gICAgICAgIGh0bWwgKz0gYFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJkb21haW5cIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkb21haW4taGVhZGVyXCI+XG4gICAgICAgICAgICAgIDxoMz4ke2RvbWFpbk5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBkb21haW5OYW1lLnNsaWNlKDEpfSBMYW5ndWFnZTwvaDM+XG4gICAgICAgICAgICAgICR7ZG9tYWluLmlzQ29uY2VybiAhPT0gdW5kZWZpbmVkID8gXG4gICAgICAgICAgICAgICAgYDxzcGFuIGNsYXNzPVwiJHtkb21haW4uaXNDb25jZXJuID8gJ2NvbmNlcm4nIDogJ25vLWNvbmNlcm4nfVwiPiR7ZG9tYWluLmlzQ29uY2VybiA/ICdBcmVhIG9mIENvbmNlcm4nIDogJ05vIENvbmNlcm4nfTwvc3Bhbj5gIDogXG4gICAgICAgICAgICAgICAgJyd9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICR7ZG9tYWluLnRvcGljU2VudGVuY2UgPyBgPHA+JHtkb21haW4udG9waWNTZW50ZW5jZX08L3A+YCA6ICcnfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAke2RvbWFpbi5zdHJlbmd0aHM/Lmxlbmd0aCA/IGBcbiAgICAgICAgICAgICAgPGg0PlN0cmVuZ3Roczo8L2g0PlxuICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgJHtkb21haW4uc3RyZW5ndGhzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgPGxpPiR7aXRlbX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgYCA6ICcnfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAke2RvbWFpbi5uZWVkcz8ubGVuZ3RoID8gYFxuICAgICAgICAgICAgICA8aDQ+TmVlZHM6PC9oND5cbiAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICR7ZG9tYWluLm5lZWRzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgPGxpPiR7aXRlbX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgYCA6ICcnfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAke2RvbWFpbi5pbXBhY3RTdGF0ZW1lbnQgPyBgXG4gICAgICAgICAgICAgIDxoND5FZHVjYXRpb25hbCBJbXBhY3Q6PC9oND5cbiAgICAgICAgICAgICAgPHA+JHtkb21haW4uaW1wYWN0U3RhdGVtZW50fTwvcD5cbiAgICAgICAgICAgIGAgOiAnJ31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuICB9XG4gIFxuICAvLyBBZGQgcmVjb21tZW5kYXRpb25zXG4gIGlmIChyZXBvcnREYXRhLmNvbmNsdXNpb24/LnJlY29tbWVuZGF0aW9ucykge1xuICAgIGh0bWwgKz0gYFxuICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb25cIj5cbiAgICAgICAgPGgyPlJlY29tbWVuZGF0aW9uczwvaDI+XG4gICAgICAgICR7cmVwb3J0RGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9ucz8ubGVuZ3RoID8gYFxuICAgICAgICAgIDxoMz5BY2NvbW1vZGF0aW9uczo8L2gzPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICR7cmVwb3J0RGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9ucy5tYXAoKGl0ZW06IHN0cmluZykgPT4gYDxsaT4ke2l0ZW19PC9saT5gKS5qb2luKCcnKX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgICBgIDogJyd9XG4gICAgICAgIFxuICAgICAgICAke3JlcG9ydERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llcz8ubGVuZ3RoID8gYFxuICAgICAgICAgIDxoMz5GYWNpbGl0YXRpb24gU3RyYXRlZ2llczo8L2gzPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICR7cmVwb3J0RGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgPGxpPiR7aXRlbX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIGAgOiAnJ31cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cbiAgXG4gIGh0bWwgKz0gYFxuICAgICAgPGZvb3Rlcj5cbiAgICAgICAgPHA+PGVtPlRoaXMgaXMgYSBmYWxsYmFjayBIVE1MIHJlcG9ydCBnZW5lcmF0ZWQgYmVjYXVzZSB0aGUgRE9DWCB0ZW1wbGF0ZSBjb3VsZCBub3QgYmUgcHJvY2Vzc2VkLiBcbiAgICAgICAgWW91IGNhbiBwcmludCB0aGlzIEhUTUwgZmlsZSB0byBjcmVhdGUgYSBQREYuPC9lbT48L3A+XG4gICAgICA8L2Zvb3Rlcj5cbiAgICA8L2JvZHk+XG4gICAgPC9odG1sPlxuICBgO1xuICBcbiAgcmV0dXJuIG5ldyBCbG9iKFtodG1sXSwgeyB0eXBlOiAndGV4dC9odG1sJyB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzaW1wbGUgZW1wdHkgRE9DWCB0ZW1wbGF0ZSBwcm9ncmFtbWF0aWNhbGx5XG4gKiBUaGlzIGlzIGEgbGFzdC1yZXNvcnQgZmFsbGJhY2sgd2hlbiBhbGwgdGVtcGxhdGUgZmlsZXMgZmFpbCB0byBsb2FkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5VGVtcGxhdGUoKTogQXJyYXlCdWZmZXIge1xuICAvLyBEZWZpbmUgYSBtaW5pbWFsIHZhbGlkIERPQ1ggZmlsZSBzdHJ1Y3R1cmUgYXMgYSBiYXNlNjQgc3RyaW5nXG4gIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGVtcHR5IERPQ1ggZmlsZSB3aXRoIG1pbmltYWwgY29udGVudFxuICBjb25zdCBtaW5pbWFsRG9jeEJhc2U2NCA9ICdVRXNEQkJRQUJnQUlBQUFBSVFBOThFRXVUZ0VBQU9JQ0FBQUxBQUFBWDNKbGJITXZMbkpsYkhPa2tzRnF3ekFNUU8rRC9ZZlJ2VkZhR0lOaHV6Qkc3emIyQTR4c1RJdmIyWlRhVHZyM09aQ3dyUzVaR0xyYVNYejZBVW5rZXY3ejl1TmxrQ2F4ekRoNjFNQWdlY3NFMjlNVTNNRmp4K2xxK1N0eVNxWHV5MlZjMkpVYk1KeExGQmFsU1hNUXBKTGh3UFNONDFTU2RpMHhwczh2clIxb1ByU2JMdUFnd2x4QXFqa1RZbTNQOSsvL21mZlZRaEIwcmc1NXNhVWN5L01ZcXFCTFYvejFnK1NmNmk4cVhscnBlWU1Qc0lYcFgweEdibTdBZkNCeHo5SFhkQ0tYRXpqTjVYOE9oM1A2ZUJhTVovWUpyQXN3dk5heTFQTEZ4b2Q1SVFUbWFEUVNNdlpVaWRWckJ2OVhLalRTZWxUSlJ5WXpveWNCS0JISnhCYWU5SlRjc0tNcVhOWXYrMW9XenhmaXN3UVhvTUxYY1BoN1hma0dVRXNEQkJRQUJnQUlBQUFBSVFBQm50OGZSd0VBQU9ZRUFBQWNBQUFBZDI5eVpDOWZjbVZzY3k5a2IyTjFiV1Z1ZEM1NGJXd3VjbVZzYzdTVTMwckRNQkRHNzRQZEllUys2Y3FpMUhSZGlBcDdKYmdIMktRblcyeVRrS1RxM3Bza1hTdFRPOHAvTnczNVB0NzNKV1IxYzlQSFlnczVlNHdOTFV0VlFIUklQdllOZkg0OHJHNUFaQmF4Slk4UkFsOGcxbVJlUHIrdG50QVM1V0xPcy9WQkZFRHNZQVBXMnQxUzVZV0ZuckpTNzlBVjBHbnNLVk9kbTB6amwyekk5bFN2ZEwxV094Wm5QSUFaQk5WT0dzaFY3R3FRdWRoOEFLL2MyYVhRR3JxRHVQSVlqM2VRTUJ5aU5mZkVENVNaOHk2N3Vwams4UmwrY3VLN3VjUkRDUmtqcHNMNEpNVnh4dWM1aHVQQkZtRS83RzBoZk9KTFFPU2lHR3FVSUpubmxDNXA2NEV5eVlmVXFKbjNrVGh6aFZ6WURrTUpBa05Pdy8wc2ZnRlFTd01FRkFBR0FBZ0FBQUFoQU5aa3MxSDBBQUFBTVFNQUFCRUFBQUJrYjJOUWNtOXdjeTlqYjNKbExuaHRiSFBNa2sxUHd6QU1odTlJL0ljb2x3bGlJMmlsS3RadHdnbHBpTU9RMERndFdwdXNTUjFWL2ZmWVZEUUp3WW5MK1BYek9uWjJ1bXVWdUlNUHhya0NwVW1HRURobGNhWHJBbjI4YjhZcmhJTjJxalRhT1NqUUF3SmFsZmV6bmM5TjY3YjBKdDZjQjBJaUxoU29OeVkwR2NlUWUxQTJKRTZENUpjbUtCdmxHT3JlNDBDWlBiTTNwWGlWWlF1OHNVQ1ZEV09JYlVFTFhESWx2MEJ2Zjl6VzJHWnFCdVdJMkhzaS9KdmRieG5GeHZXR2lWK2FacVJJa2oyOW1KVkUzVlhRNDMwSlBZa1JKM0xNcWM3WTRLWExxS2RKa296NXFCK2NXcGttb2FKWTMzRDRGdFVYQmdHU01yMmtHWSsyYUh4ZE1wWEhGR1ZaUWZDbjl2K01aelBDWFR0VTEyN3ZMYTFkVlhNb0o5bkV2NXcycXo4cEt2bkpKNGwrZDU2ajhqK1VuVXVkWGwzVzIvSjFneTdISVlySHhXUTVDVlVmL0ZXK0FFYlI0VWRRY3VKL1RUNEJVRXNEQkJRQUJnQUlBQUFBSVFEVDVPUGg4Z29BQUxHVEFBQVRBQUFBVzBOdmJuUmxiblJmVkhsd1pYTmRMbmh0YkxXYVhXL2JPQmFHN3dmc2YxRG9lbTlsMmM2SGd6WXoyTWJKZElObUpoczdjMGVKdEVWRUpqV2tuSGgrL1ZJaVpWdUpRaE4xZk5FQ0JpMCtQUHdrOHZDaGZQT3Z1MnlhWFVWYjExVzVDT2JMUlpERnNxcnFTYmw3RWZ5NmY3UDVJY2pxblNncmtsYVg4U0s0ajNYd3IrZS8vdkxtOW1uZHhrd3NMK3RGME8vNzI5TmlVWmRkdkszTFpiV1BwY25rdFd4RmJYN0szYUlXOVYzY2JSZGIyOFd5V0p3MmkwbFpuZ1h2NDFpOHVLMHJrOEsyMjNKY3ZvblZOTmF6alZjeExrMWtLOWR4WHAwWDUrSSs3WXA2SXQrK1htZFpiNTkvdkNoM1g1UGJ1OHVwaU10bkpoMFR6bVpUL0diamYxeDR1M3ZBbTFUN2FiSTZLcTh2KzhEdVhMWUtjM1paMzlmcHVHNGtwZ1ZQeHRJa3VvemxxTXJubDZQN0w3YzVaMWNYMHcvMlg2TXpzK09UTW51VmJMVjJKYXJiblY1L1hKd3R5OFZsMWVYSmpyYmJ0ckcydjk1a1JTdHVnMnl6bVpsLzkyV1Z0dE9pS0hlaU41bFdsMnA2L2JMYjJ5VHZkdVVpS1BORjhPS3Fyc3M0N2VlSGI5cUxxcFc5RUsxcElFYTZEZE5TVWNuWll1OWxiSjdaalhXMWpjL2E3cVlSZFNVYjBkL0VQb3U3Sk9Wd1pOcU9vVU5YcTJvL3BTRjdJZlhEZnRIRWNtZnFGMlZzYnZsK3M5MU9kcTAzaGM2eUczTjFPOUZIVTdrd0xVUE9VdXV1RmQxVnYrMHpQeDVkNysvWGsva09nZFpKZnIxUHl2RzZEcWVvNVhMeGp6bERDWVA2eEorUURJNkJvenRmTG5PTzhQZ29qZ3dPOVM0M2Y5dFhoNy9lWXJnMkxmV3B6SmRqSFRKNkpDZU9LeU5wclMremwvUE54NUc0TXZkNFhNa0p6MHR4QlZ1L3NIcG5HOUl1L2lXTmNyVWNyYjNSZE81NGIyWWZySTZMaC96dzQrNkhHVi9HYlV3ZmZEQnVEdmxCWFJ5dnJsZkZvZU10N2U0L3pLTnlYdzhQdTlJY1ViWEwxeXpGdzl3WSs5M2pWdlRWWk53UkZ4bG1IK2EwYzNPS1JQcW9Vd3pYajUxaVg3WlhzUjhuU2ZSUjRHOW5Oek9PN1lmazF3OERkcjJPWlpuc2NxVXFadlBGdldnVGI1T1R4czlxR0crTngyc1oyOC9SajhaMVc4N1NpdTVuL1ZFL2ZXUlE5UHAySExTakwrTmswbXduMnpuR3dRRFhwcVp3VER2TXhqUGpiek1weWhrMy9tRnYrckpNL0RuSG1mYlNSVzlkSExkdGZ3ajBRNDd4OUVVZmVQVkdwUGk4VlhjcE9weVBxTFlYVng5cWNVYWlqY0UvS1ZFSHNKNWNqRlBDZm5KNWNUY2R4Mk9TRFhQS1F6WDJGYlY1UisrYVdNVkpkWFRBSmZuaW1EYWRCZzgwS3RRbmZKenBabktZM0gxTzBTZWllUFppUzZFdlIybk01bVBYYytVeExhZEJuQ2xTcnB3UVMyQTdndmw0WjZiUnFIekpYUXBNUWtyQ3JKZ1E1OHE1Zi90NmQ1c0xEc3ZVMXlST1FrckNMSndRNThycHZXM3Y3WHhtalpjbnZadHdIOWtHa0pJd3F6SWh6cFhidHZ1K3luWjNhWFhRQ1BzcTRaY3YzeHZRQmpDVHhQVjFRaHdDK0x6YXovSm1WLzRIczdLSEZ6eExhSU1rcVZkL0piUWhoSWVyVTIvenkvdCsyNWwza1lldW9xY1huTzNRQnBDU09MVkthRU1JRDFlbkhoYnE2Lzdxdk1xbTk0ZFRXRmN2ZExhR05vQWtjZXBWUWhzQytMeDYrSTdwSXVuRzd6Y1A0VjI5ME5rWjJnQlNFcWRXQ1cwSTRlSHExRHRyVE92YjhYM05OUUwzcklNVEtFbk4raUtoRFNGOFhKMTZiNjNKM00wVzFJNmQzbmtkMmlCSnpZMENRaHNDK0x4NllnVXpSSUt6MVJkV01HaURKSEZxbFVKSXpLdVRBWWVYa2M5K0ZPN29oYWVRYUFOSVNaeDhwbENESU8rZlF3NmpQRzNGa043K1F6eElrcHIxUlFvMUNQSis5Y1FTcGc4RFp5c3NwTXN3N09SRnJCUklrdFFzTHhLb1FRUWZWNmNlRmpFMkM1eXR0TWh1UjZrVTd1WkZMR0pJa3RRc0x4S29RUVFmVjZkKzhLNkp2Ylh0eExrSlBHeFEwM2NVejdab0EwaEpuSHlsVUlOQUhxK2VXTWJZZE83a1puWTdPdCtoRFNBbGNmS1ZRZzBDZWJ4NlloMWo4OERaNmdzN0dyUUJwQ1JPdmxLb1FTQ1BWKzhlM3Y3YU1xMDd1Ym5kRDM2RlFMSjFXcnRTcUVFZ2oxY2YzVUIzY1RkZjhuQ2RZUFppdzlzTmtpUjErNWQ2aVZubDFjTnc5YUEzMS9Na1hUSUpQOUk3ejFIUUJ0aVpwRzc5TnVZRWdhUWVWazVONC8xdHhYMDJQYmJUejFNTkxBM3ZPVWlXUkdyWHVCUEVrdnF4R3hCSFBVaUtwbjdVUWtGSVpsSzd4cDBnbHRSUExFcUdnWEMydXNUU1dpQ3BXZU1Pa0V2cWlXWEpNQkZjcnU2K2h4UllHdDZDQUtSbWpUdEFMcWtubGlYRFJIQzZ1c1Q2V2lDcFdlTU9rRXZxaVdYSk1CRmNycjU2V0Y3a0VzSDEyd3RxcFlDeXBFNnQ4WGRCQUo5WFQzdzQ2YVF1L3paK1AvN3hOTllKUHIxQTN3VllsdFNwN2V3RkFYeGVQZkY1YWVaZG5QM205SnZ1cE42ZlR5UHZIcjA3Umo5QkRSSzdOYytTQndqbTFqN3h2V2xXcEdjMzJHMW5UdEgrYm5Ydzd1SGRNWG94QWhLN05jK1NCd2ptMWo3eHptbm90VWZGSkN2djAybEp6ZWRwM3ZUbWFIWlJqOS9zb0VEaTFLbDVsanhBTUxQMjRYUFQvYllhanRtRm1BNmQrVERSTURoOGE0d0NpYjE2MDhvMDFoSDh2THBMcW9hRy9EWWJlaEw0ZE1QSjIwTVVTQnc2dFowOUlvQTc3L0IxLzNBeFRPQ1B0dzFucnc5UklISG8xTHplSXNKNGMwOS9MZm04dS9rMUd4N0pwM25EMmZ0M0ZFZ2NPald2dDRndzN0ejljSksxWTRQNGZrVDFYR2x1RUZBZ3NWZnZXcG5HT29LZlY4OCtuSmpBdzNUMjlMMGlDaVFPblpyWFcwUVliKzU0T0srdmZqeGZGK3ZwL2xQMjRCYzhjamg3SDRjQ2lVT241dlVXRWNhYmUrS2I5ZFhSamNYVnpmakhLUjZtY21mdjQxQWdjZWpVdk40aXduaHpMeDV1S0hyUlgreUdoNHM2bTViRHIvRGs1M204N2NlSlBOU0ducnhuU1lIRW9WTzdFVVdFY2VZZXVkeFA5T1hod2NkSzdPdEpkWnNOWmVMN1RjR1JuOTNnN0VWR0NpcjJhcDNheGtlRThlWWU1ejNoMmRXaDFrL0s3RDhTbGZnZitkbk40ZXdsU2dvcTltcWQyc1pIaFBIbWZuU3QvOGpmWDE1ZlhHL2QzejU4WFlzNi8zeXlBYzF6OHVQeU5qNWZZT0ZUVUJ2TW4vOEhVRXNEQkJRQUJnQUlBQUFBSVFCbWhiNnR5d01BQURvTkFBQVBBQUFBZDI5eVpDOXpkSGxzWlhNdWVHMXNwSmJiYnRzd0RJYnZCK3c5Q04xblNwckdhWUxXV1pBbTYyWFFyb3ZhZGpjd050c1Jwa09HcENUTjIrL0l5Y214QzFUdFJhSkkvdncrRXA0dlAvWlM4SzJ4bG1zMUkvR1FFYzZVMEhXcmRqZU0vSHhZQkJQQ3JhTlZTNFZXWmtZT3hwSVBzNjlmNXUxQld1Mk40UllqREsxbXRMRnVkNVVrVmpSR1VqdlVPNlBnUzZPTnBBNUVzMHRhamRhNkMxS3BrekVqVjhuWGIxa040YXZYR2l6NXZsVUwxZEdOTmtKWUhkcnlWQm1JYnJrd0hPelpwREhDUnhNSm5aZ1FYeE1sK2JPNW4zSGV3VDVlcEx1ZllydmZUUlNObjBFOUlQanAydnhPL2UrcnA3dDNtTE4weDg1NGNIVlY3bXc2TnRwSDE1YkZXb21WTnA3NHdZaUwxSkY3d3kvRjN0WTY4eVRYb3ZNVmJtKzFVVStCYUd4N2g2NU5heDhiWjBVL0Y2V2d6cG95WWlSSVFySWdUa2hhSkhIQlY1dm1uQ3FPRmtHU3pOTXNMOUppbVljSkwxNks4REpKWUkwc0RZSjR2ZzdEVlRLUGkwV3hLTkkwWGlUSllyWEtpalNPbDJtUnBrWHhEcHpMbGZackpRNnFoZGdYZW5Nd1Q0aDg4ZVU4blJySUhpSi8zSEUyZFhBSS9MSFRxNm1EdytpUC9UWjFNSWo5TVozdWpZU3AzTzZCdXB2UkdMcTlJSXFzTEtRUEx0QkZxZjFyWi9IRFhQOHpOenhiMHhhMUowK1NrWnNtTmhWTlRZMGsxK1JNdzAvT3o2MkMrQVF2UGRqSEVnMFpQNzFsU1FxbkR3WjloN0FaZVZndmtoekwwYUh6RERtNnI4ZzdKS21wY1plYXdWcFBLN3dBL0tJelREVmR2NHBLblYyekZwQ1ZxVnZiMzdPMFcwTW5oR2FFMTl5U0RWSzRSYjVYajd6MjJjSlh1dU1WMXJqbVcvRTRrYzBadGNOcEwwZ1R3ZjJ6ME1GRVk1cjNyTGREbHAyWndZNktUQllXN0pwandYWEhvVkRCdG1tZ1F3QTZGZ0xjWlBkMEM5T1B2ZE1XL250Y2F5RmNJK0dYZTRPajVBSGpHemYyKzY3RlhydURYbm5nTDdVdzllYU9tblpRYjA4a3pqdDdRU1p2b1E5dkpvL01kTTJ4VUdxSmRFVmE5VFFkdlFVWXBCaGlKZ3puMEJkR1AzRU8vOVZPMkgxMWpDeEhFNmtOVE5mN0Raa0xqWTI3TVhaVHR6dGw4UlBaOWVJQmpUSFVPSFBkZ3RrZHc5UllSUmJQMEpmSVhXZE9RNHhSUGVCOXJPSHFtcUp3OXVDN2dObjBCMEUrQjJHZzB3M2RhamRVTXJ3QzUvSndoZ05sY0F3L0d2VnNPN2dwd2pUTjhtTXZoS1hjcTBjNFFMQk1SL000Q1ZZL0I5TTBLWlpKOFhZdzNKLysvbFh5MmQ0UThRTHY5N0ExWUsvQmxkUktxVHpNNGp6Tzh1SitwMmtPRHhDeDVSc29wVy9HMEErSCs0TVdlUHRDYk9DdUtSKzFnUXZrYkZSNmI2RUpRRExETFpFUFR2MEJVRXNEQkJRQUJnQUlBQUFBSVFBNnFCQ0V1UVlBQURRYkFBQVJBQUFBZDI5eVpDOWtiMk4xYldWdWRDNTRiV3kwV050dTJ6Z1FmUy9RZnlEMDNqcHhia2lkaUVsYlpMUFpvbGh2UDBDV21GaUlMSUtVNCtUdk8wTktkcDN1TnNnKzFKQkZjY2lkbVRObk9PcnJsL3Y3eFBJVVZjV2sySmlEZnRkeUNXU29JaWJpalhuejQySm5ZMWxWRG9ub1hVcGNHL05jeXVybHpkZGYvejJJcTFoVkhFV0ZySENSRy9PK3F0TE5WcXRrZmpHd3VyU2w1MVo4K3JrL0huVHQ1OG50OXJ2RG0wSi93TFRhZHIrMy9sKzBDWSt1eUMyTzNtVUJ4WWs4NWdrVmhUNGtERm1LWW9ZRHZacEZlY1oxTW5QQ2s5RjN6Z0szRDJGemFSVVhmL1k5TjlNL3Z0WDV3OWNqZGpROHNaZW9DcG5YRDBsSDZnOFRsWEw5V1hwWllJK0Q0WWFLVWE5dmpicWU5UzV2RXpoOHpiL0pKRWtsMUdjWCtoMnpmTWZybUJXblcxWWRhYVRERmp0MVY2MkxrWEpWWkxKTVdhRFhEdnM5eTJOamZiVnUrYUZYWDY4ZHpCRjFHYVNkbU1aMHNPdDVwOTFVc2p5bWdjUUo1NmJqOWM1Y09na1VGUkV2VkIzU3dhM1lKUnpIYk5jdkNVZXhBKzNhLytQRUNSR2xURUl1R2RQTDJjaGhPKy9NWGdLZHZqT2J1ZVRuOHB1LzVmS3cyK251N3U1dUc2dlB1ODdPZzJsbnB6L283WDUvUDl2Um9SNUR4ZTRQQ0RHK3I4VzlVWkdkSHlhWDZSSGJ2em81djVyZG5wM05ycWJqbXpGY1hZMm41MmZubDVPcm84bnNmekZZUUNuekczbDl4U0t4cVhvaGhJem56OEtuNjZxMlp6ZkVaUnIybVdhWjBuKzdPQkxCYk14dXVuTFV4bDNDMWJ3K1l2TFB4Z2szTEhPdU5QdTB3RGxmRlNVSlZaeHBwcnFqcXhKcEl1UVRMMkpaYVBKdW9MWXhCNzFCcDc4eGcvNVFqNU9VWlhEa0hONWNucnhPS1M0UzJiUzhZNUZLQkxtUFQzK284cERraDVMNXhlek1IY2ZSM1IvejJmbVYrL3YwZW5lMFU0ZUNQbTh5dlR0NWNuVnhEOU4wdFZpcG53cE5Tcll6dHpRZFJReFZjdytKa0ZXWVBPWEtDZElpNFZXNDB2SGtWa2FoTzZwQ3FtTEpDMXJXenA1M3BBVVFya1FZTzJ3VmE5NEpiRlhlcS9rNFg5RDBZWFlhM1htbmdmM0Z3NWZXSFgwNy92WitkSFI1WU84L2gwVHZSdTlIbDhING56KysrNGYyRCtkL1B3YW5QT1pGeGZJcWQ1SjBKWG51VU5FWFZXVitZcEd6S2ozM2dEdU9xUWlwZHZNOGUwTnBlNGJNTTNmUFJjZy94YktvOWkwb0xQTUpsN2xhUHdxWnFnQWhscWpsTnhWVjJWSi9LUm1tQkt0bSt5cW1MQXFLdGJuUld5N1RsY2ZTSDNSbURpV2dJTFFJcVRxTTZ5blRuNW1MTVJnekZ6OWtSRkdJYzFnOW9NekJwOHlCMExtRmk2SjRwOTR6Uy92TmMrWFdzK1FKSlVtR2Q1eFVqajFRY0pEcVlJMlZCaXBTWEJ3dlVoYnFsS21McHlMMXNGMDVXWlFVSjAwVmdFaXBpaGhVSktBWkRRbWl0Tm1EbE9sMHhtSVhiZnBTSnJwZFEwdUxuWVphMVlrMFU2VWlzMVd0c2FyVEdlNjJ5ckNtSlZ2V09pdWFNWE0xWjlyQUZ3K0lxdERxZUwzVno2Nlk5U3laOC91V0IxK3Q5cVZZRFJXbEhNcGpRdFZvWGRFRVU4NUtielMwRzVkTEt0UFdpR2dmUWJ4c0gvRVZPalFoemJRdFdQUWFKTG40MERUUFhLZEJKVWZQd05xNUdrYjY0NGZVWlVTVDdtVnZFem1USkpGS3JiWE15L3lCUERwWFVMTEtTZ1V4THBKRm5FZE1CS1h1MExvbDlSQ24rUUpsSUNGc1laNVZNWlJWeVhYdUc5Q1FzbnVDYVFVZytxS2R5UW5SeGFxditxZkxZRkJHYUF6V3lNc0pRMU4wcTZvckxkN1dLaExhd2piQ2ZiWExvbE05Um51S3JUeWxzS05NMTJxOVJkUzdHVVR4Vm5xcFZaRnJWY09sRDBsMmpVcUNZMGZFWWk1aDdQNktnMloxdytTbTFxRkp6UEZUbUZRNGtSTU83VWIxeGJacTFCZmJhTklYZThBWE8yd0tjbU4ycXpXVjVWR3JKVnpNWlJFTGJmSE4xMUZmeVkrUGpDL1l4dTZwS0dYZFhXOWxKVHIwblc5ZDBEekpPcVlKYloxTG5yTEdwWkVyM2hYaHZHMnZOQWk5Wk5GeEExclFVelVjNkhadExScWdOUHdEMXozMTBabk95RkV0R1FVMGdFV21HanlFdU1kVk4wZ0tzc1ROdmhrVmpPTENza0QzSTM5VkVYZmJZNHBOMTNsUUxVdUpUWGdUak40cFIvTy9sMU04YlZPb1J4cnpBOHNDNWQ2blBHREVIRUJCOXlOV0ZHTXRFMVM2RjU2cHhWbUtDNy9EdXFTdjlHbFNZVE5KbFRiMXNJcWZFWXo0UnVISVR3NUY0Q20vT0JQNUhGSGdDcUZiQWNYR1RYZlE3YStxT2FUZGgvUjZHdEsxMENLc3lMMXZiY0huOGpEUWVFeUFhSHYzL3R3RkRmL0ZJNFlsRHlod2pRV3BmVmhqM2RLd09iN0ZFK0pZM0tBOTFWcDdPL1FHTW5KUmJQSkwxRFpzNmkzc09YV25GazRxOEpDcE5lM00yWEZNdERrbTNlOVFucnk2NHBSR0R4VG1Nb3E1dE5RaFBMQVl6RExOOUxUR2JxVHZLQnhNTkFrL0l6U1E1T1lmVUVzREJCUUFCZ0FJQUFBQUlRQlBRSUZucGdJQUFMSUdBQUFjQUFBQWQyOXlaQzlmY21Wc2N5OXpaWFIwYVc1bmN5NTRiV3d1Y21Wc2N5MlUyMjdiTUJCRlh3ZjBId1M5TzdybElzYWdLQkxZeUxwQm02QWZRRWlVSkp1WGdxVHN1UDllbEhTVHR4bk9IbkptWjhobkw3OWw2MzFQYlV3eFY2WlFtbG1wSThaTnJrd3VlWHIrOS9qYktsMyt2YkhpM0hLaFRUSG5hdnNMRXNudGJoemFJUWtCRjlPRlVWWFpORUlZWHl1djQyS3N2ZXBqend4NmI2SHJzS25XcG1wQTdIUlp5S2RLcmFXVW5KcFFwQmEwTU9XVVk3VlZGZjF0SkRlUnpiRTA2SlhrVEJXMVVsTEdQWFZwTlF4RE1mQXU5aHZ3ZDNIRE1CK2o0U0hvNG9Nc0Q5L1FUMEJXTEM1VzdZRFFXcW5FaFFmaldtbTJWZ3BOZTNEQmEyVmNxUmlHVVZDTUg0eXZzTlFtaE9Ed3JmQmtYQ0Y3TUJWa01DVnlCeGRNeHNSNEFuY0FINHlMSmVSUllEeDRZYXlLTXJxRmNSK1YrdUcwcElyVEk3WEw1dlBvR1VmUDlvUFRuNmU5K1BLUHpmNEFVRXNCQWkwQUZBQUdBQWdBQUFBaEFEM3dRUzVPQVFBQXppWUFBQXNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRjl5Wld4ekx5NXlaV3h6VUVzQkFpMEFGQUFHQUFnQUFBQWhBQUdlM3g5SEFRQUF6UVFBQUJ3QUFBQUFBQUFBQUFBQUFBQUFrUVFBQUhkdmNtUXZYM0psYkhNdlpHOWpkVzFsYm5RdWVHMXNMbkpsYkhOUVN3RUNMUUFVQUFZQUNBQUFBQ0VBMW1TelVmUUFBQUF4QXdBQUVRQUFBQUFBQUFBQUFBQUFBQUFDQmdBQVpHOWpVSEp2Y0hNdlkyOXlaUzU0Yld4UVN3RUNMUUFVQUFZQUNBQUFBQ0VBMCtUajRmSUtBQUN4a3dBQUV3QUFBQUFBQUFBQUFBQUFBQUFzQlFBQVcwTnZiblJsYm5SZlZIbHdaWE5kTG5odGJGQkxBUUl0QUJRQUJnQUlBQUFBSVFCbWhiNnR5d01BQURvTkFBQVBBQUFBQUFBQUFBQUFBQUFBQUY4VEFBQjNiM0prTDNOMGVXeGxjeTU0Yld4UVN3RUNMUUFVQUFZQUNBQUFBQ0VBT3FnUWhMa0dBQUF2SGdBQUVRQUFBQUFBQUFBQUFBQUFBQUJURndBQWQyOXlaQzlrYjJOMWJXVnVkQzU0Yld4UVN3RUNMUUFVQUFZQUNBQUFBQ0VBVDBDQlo2WUNBQUMzQmdBQUhBQUFBQUFBQUFBQUFBQUFBQUJTSGdBQWQyOXlaQzlmY21Wc2N5OXpaWFIwYVc1bmN5NTRiV3d1Y21Wc2MxQkxCUVlBQUFBQUJ3QUhBUDBCQUFCV0lnQUFBQUFBJztcbiAgXG4gIC8vIENvbnZlcnQgYmFzZTY0IHRvIEFycmF5QnVmZmVyXG4gIGNvbnN0IGJpbmFyeVN0cmluZyA9IHdpbmRvdy5hdG9iKG1pbmltYWxEb2N4QmFzZTY0KTtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIFxuICByZXR1cm4gYnl0ZXMuYnVmZmVyO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmVwb3J0IGRvY3ggZnJvbSB0aGUgcmVwb3J0IGRhdGFcbiAqIEBwYXJhbSByZXBvcnREYXRhIC0gVGhlIHJlcG9ydCBkYXRhIGZyb20gdGhlIGFwcGxpY2F0aW9uXG4gKiBAcGFyYW0gdGVtcGxhdGVCdWZmZXIgLSBUaGUgYmluYXJ5IHRlbXBsYXRlIGZpbGUgYXMgYW4gQXJyYXlCdWZmZXIgKG9wdGlvbmFsKVxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGdlbmVyYXRlZCBmaWxlIGFzIGEgQmxvYlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVSZXBvcnREb2N4KFxuICByZXBvcnREYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICB0ZW1wbGF0ZUJ1ZmZlcj86IEFycmF5QnVmZmVyXG4pOiBQcm9taXNlPEJsb2I+IHtcbiAgLy8gR2VuZXJhdGUgdGhlIGZpbGVuYW1lIGJhc2VkIG9uIHJlcG9ydCBkYXRhXG4gIGNvbnN0IHN0dWRlbnROYW1lID0gcmVwb3J0RGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbj8uZmlyc3ROYW1lIFxuICAgID8gYCR7cmVwb3J0RGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmZpcnN0TmFtZX1fJHtyZXBvcnREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ubGFzdE5hbWV9YFxuICAgIDogJ3N0dWRlbnQnO1xuICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgY29uc3QgZmlsZW5hbWUgPSBgJHtzdHVkZW50TmFtZS5yZXBsYWNlKC9cXHMrL2csICdfJyl9X3JlcG9ydF8ke3RpbWVzdGFtcH0uZG9jeGA7XG4gIFxuICB0cnkge1xuICAgIC8vIElmIG5vIHRlbXBsYXRlIGJ1ZmZlciBpcyBwcm92aWRlZCwgdXNlIGEgZGVmYXVsdCB0ZW1wbGF0ZVxuICAgIGlmICghdGVtcGxhdGVCdWZmZXIpIHtcbiAgICAgIC8vIFVzZSBmZXRjaCB0byBnZXQgdGhlIHRlbXBsYXRlIGlmIHdlJ3JlIGluIHRoZSBicm93c2VyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnTm8gdGVtcGxhdGUgYnVmZmVyIHByb3ZpZGVkLCBmZXRjaGluZyBkZWZhdWx0IHRlbXBsYXRlJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIHVzZSByZXNwb25zZS5hcnJheUJ1ZmZlcigpIHdoaWNoIGVuc3VyZXMgYmluYXJ5IGRhdGEgaGFuZGxpbmdcbiAgICAgICAgICAvLyBVc2UgbGFzLWFzc2Vzc21lbnQtcmVwb3J0LXRlbXBsYXRlLmRvY3ggaW5zdGVhZCBvZiByZXBvcnQtdGVtcGxhdGUuZG9jeCAod2hpY2ggaXMgYSB0ZXh0IGZpbGUsIG5vdCBhIERPQ1gpXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL3RlbXBsYXRlcy9sYXMtYXNzZXNzbWVudC1yZXBvcnQtdGVtcGxhdGUuZG9jeCcsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBjYWNoZTogJ25vLWNhY2hlJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGRlZmF1bHQgdGVtcGxhdGU6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygnRGVmYXVsdCB0ZW1wbGF0ZSBmZXRjaGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgIHRlbXBsYXRlQnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRGVmYXVsdCB0ZW1wbGF0ZSBidWZmZXIgc2l6ZTogJHt0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgdGVtcGxhdGUgZmlsZSBpcyBlbXB0eScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZXJpZnkgdGhlIHRlbXBsYXRlIGhhcyBhIHByb3BlciBET0NYIHNpZ25hdHVyZVxuICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlci5zbGljZSgwLCA0KSk7XG4gICAgICAgICAgaWYgKCEoZmlyc3RCeXRlc1swXSA9PT0gMHg1MCAmJiBmaXJzdEJ5dGVzWzFdID09PSAweDRCKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBET0NYIGZpbGUgc2lnbmF0dXJlIGluIGRlZmF1bHQgdGVtcGxhdGUuIEZpcnN0IGJ5dGVzOicsIEFycmF5LmZyb20oZmlyc3RCeXRlcykpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IHRlbXBsYXRlIGlzIG5vdCBhIHZhbGlkIERPQ1ggZmlsZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGRlZmF1bHQgdGVtcGxhdGU6JywgZXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZSBhcyBhIGxhc3QgcmVzb3J0XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGxvYWQgYWx0ZXJuYXRpdmUgdGVtcGxhdGU6IGxhcy1hc3Nlc3NtZW50LXJlcG9ydC10ZW1wbGF0ZS1maXhlZC5kb2N4Jyk7XG4gICAgICAgICAgICBjb25zdCBhbHRSZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvdGVtcGxhdGVzL2xhcy1hc3Nlc3NtZW50LXJlcG9ydC10ZW1wbGF0ZS1maXhlZC5kb2N4Jywge1xuICAgICAgICAgICAgICBjYWNoZTogJ25vLWNhY2hlJyxcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICAgICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFhbHRSZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZTogJHthbHRSZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRlbXBsYXRlQnVmZmVyID0gYXdhaXQgYWx0UmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBbHRlcm5hdGl2ZSB0ZW1wbGF0ZSBidWZmZXIgc2l6ZTogJHt0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGFsdGVybmF0aXZlIHRlbXBsYXRlXG4gICAgICAgICAgICBjb25zdCBhbHRGaXJzdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGVtcGxhdGVCdWZmZXIuc2xpY2UoMCwgNCkpO1xuICAgICAgICAgICAgaWYgKCEoYWx0Rmlyc3RCeXRlc1swXSA9PT0gMHg1MCAmJiBhbHRGaXJzdEJ5dGVzWzFdID09PSAweDRCKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIERPQ1ggZmlsZSBzaWduYXR1cmUgaW4gYWx0ZXJuYXRpdmUgdGVtcGxhdGUnKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHRlcm5hdGl2ZSB0ZW1wbGF0ZSBpcyBub3QgYSB2YWxpZCBET0NYIGZpbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH0gY2F0Y2ggKGFsdEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGFsdGVybmF0aXZlIHRlbXBsYXRlOicsIGFsdEVycm9yKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXMgYSBsYXN0IHJlc29ydCwgY3JlYXRlIGEgbWluaW1hbCB2YWxpZCBET0NYIHRlbXBsYXRlXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbWluaW1hbCBlbXB0eSBET0NYIHRlbXBsYXRlJyk7XG4gICAgICAgICAgICB0ZW1wbGF0ZUJ1ZmZlciA9IGNyZWF0ZUVtcHR5VGVtcGxhdGUoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIG1pbmltYWwgdGVtcGxhdGUgd2l0aCBzaXplOiAke3RlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghdGVtcGxhdGVCdWZmZXIgfHwgdGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBBbGwgdGVtcGxhdGUgYXR0ZW1wdHMgZmFpbGVkLCBmYWxsIGJhY2sgdG8gSFRNTFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCB0ZW1wbGF0ZSBhdHRlbXB0cyBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNlcnZlci1zaWRlIGhhbmRsaW5nIHdvdWxkIGJlIGRpZmZlcmVudFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbXBsYXRlIGJ1ZmZlciBpcyByZXF1aXJlZCB3aGVuIHJ1bm5pbmcgb24gc2VydmVyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IGFuZCBwcmVwYXJlIGRhdGEgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgIGNvbnN0IGZvcm1hdHRlZERhdGEgPSBmb3JtYXRSZXBvcnREYXRhRm9yRG9jeChyZXBvcnREYXRhKTtcbiAgICBjb25zb2xlLmxvZygnRGF0YSBmb3JtYXR0ZWQgZm9yIERPQ1ggdGVtcGxhdGUnKTtcblxuICAgIC8vIEZpcnN0IHRyeSB3aXRoIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZVxuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgd2l0aCB0aGUgcHJvdmlkZWQvZmV0Y2hlZCB0ZW1wbGF0ZVxuICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gZ2VuZXJhdGUgRE9DWCB3aXRoIHByaW1hcnkgdGVtcGxhdGUnKTtcbiAgICAgIHJldHVybiBhd2FpdCBnZW5lcmF0ZURvY3hGcm9tVGVtcGxhdGUodGVtcGxhdGVCdWZmZXIsIGZvcm1hdHRlZERhdGEsIGZpbGVuYW1lKTtcbiAgICB9IGNhdGNoICh0ZW1wbGF0ZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1c2luZyB0aGUgcHJvdmlkZWQgdGVtcGxhdGU6JywgdGVtcGxhdGVFcnJvcik7XG4gICAgICBcbiAgICAgIC8vIEZvciBhbnkgZXJyb3Igd2hlbiBwcm9jZXNzaW5nIHRoZSB0ZW1wbGF0ZSwgdHJ5IHdpdGggYSBtaW5pbWFsIHRlbXBsYXRlXG4gICAgICAvLyB0aGF0IGRvZXNuJ3QgcmVseSBvbiBjb21wbGV4IGZvcm1hdHRpbmcgb3IgdGFnc1xuICAgICAgaWYgKHRlbXBsYXRlRXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAvLyBMb2cgdGhlIGZ1bGwgZXJyb3IgdG8gaGVscCBkaWFnbm9zZSB0ZW1wbGF0ZSBpc3N1ZXNcbiAgICAgICAgY29uc29sZS53YXJuKCdUZW1wbGF0ZSBlcnJvciBkZXRhaWxzOicpO1xuICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgbWVzc2FnZTonLCB0ZW1wbGF0ZUVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBcbiAgICAgICAgLy8gTG9nIGRldGFpbGVkIGVycm9yIHByb3BlcnRpZXMgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmICgncHJvcGVydGllcycgaW4gdGVtcGxhdGVFcnJvcikge1xuICAgICAgICAgIGNvbnN0IGVycm9yUHJvcHMgPSAodGVtcGxhdGVFcnJvciBhcyBhbnkpLnByb3BlcnRpZXM7XG4gICAgICAgICAgaWYgKGVycm9yUHJvcHMgJiYgZXJyb3JQcm9wcy5lcnJvcnMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUZW1wbGF0ZSBjb250YWlucyBtdWx0aXBsZSBlcnJvcnM6Jyk7XG4gICAgICAgICAgICBlcnJvclByb3BzLmVycm9ycy5mb3JFYWNoKChlcnI6IGFueSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciAke2krMX06YCwgZXJyKTtcbiAgICAgICAgICAgICAgaWYgKGVyci5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Byb3BlcnRpZXM6JywgZXJyLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUud2FybignQXR0ZW1wdGluZyB0byB1c2UgbWluaW1hbCB0ZW1wbGF0ZSB3aXRob3V0IGNvbXBsZXggZm9ybWF0dGluZy4uLicpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXNlIHRoZSBjcmVhdGVFbXB0eVRlbXBsYXRlIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgbWluaW1hbCB0ZW1wbGF0ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBtaW5pbWFsIGVtcHR5IERPQ1ggdGVtcGxhdGUnKTtcbiAgICAgICAgICBjb25zdCBtaW5pbWFsVGVtcGxhdGVCdWZmZXIgPSBjcmVhdGVFbXB0eVRlbXBsYXRlKCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYE1pbmltYWwgdGVtcGxhdGUgY3JlYXRlZCAoJHttaW5pbWFsVGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aH0gYnl0ZXMpYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IGFnYWluIHdpdGggdGhlIG1pbmltYWwgdGVtcGxhdGVcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZ2VuZXJhdGVEb2N4RnJvbVRlbXBsYXRlKG1pbmltYWxUZW1wbGF0ZUJ1ZmZlciwgZm9ybWF0dGVkRGF0YSwgZmlsZW5hbWUpO1xuICAgICAgICB9IGNhdGNoIChtaW5pbWFsRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3aXRoIG1pbmltYWwgdGVtcGxhdGU6JywgbWluaW1hbEVycm9yKTtcbiAgICAgICAgICAvLyBMZXQgdGhlIG91dGVyIGNhdGNoIGhhbmRsZSB0aGUgZmFsbGJhY2sgdG8gSFRNTFxuICAgICAgICAgIHRocm93IG1pbmltYWxFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0aHJvdyB0byBsZXQgdGhlIG91dGVyIGNhdGNoIGhhbmRsZSBpdFxuICAgICAgICB0aHJvdyB0ZW1wbGF0ZUVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZW5lcmF0ZVJlcG9ydERvY3g6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIElmIGFsbCBET0NYIGdlbmVyYXRpb24gYXR0ZW1wdHMgZmFpbGVkLCBmYWxsIGJhY2sgdG8gSFRNTFxuICAgIGNvbnNvbGUud2FybignQWxsIERPQ1ggZ2VuZXJhdGlvbiBhdHRlbXB0cyBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBIVE1MIGV4cG9ydCcpO1xuICAgIGNvbnN0IGh0bWxCbG9iID0gZ2VuZXJhdGVGYWxsYmFja0h0bWxSZXBvcnQocmVwb3J0RGF0YSk7XG4gICAgY29uc3QgaHRtbEZpbGVuYW1lID0gYCR7c3R1ZGVudE5hbWUucmVwbGFjZSgvXFxzKy9nLCAnXycpfV9yZXBvcnRfJHt0aW1lc3RhbXB9Lmh0bWxgO1xuICAgIFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgc2F2ZUFzKGh0bWxCbG9iLCBodG1sRmlsZW5hbWUpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaHRtbEJsb2I7XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyBhIG5lc3RlZCBvYmplY3Qgc3RydWN0dXJlLCBjb252ZXJ0aW5nIG5lc3RlZCBwcm9wZXJ0aWVzIHRvIHVuZGVyc2NvcmUgbm90YXRpb25cbiAqIFRoaXMgZW5zdXJlcyBjb21wYXRpYmlsaXR5IHdpdGggZG9jeHRlbXBsYXRlciB0ZW1wbGF0ZXMgdGhhdCB1c2UgdW5kZXJzY29yZSBub3RhdGlvblxuICogXG4gKiBAcGFyYW0gb2JqIC0gVGhlIG9iamVjdCB0byBmbGF0dGVuXG4gKiBAcGFyYW0gcHJlZml4IC0gT3B0aW9uYWwgcHJlZml4IGZvciB0aGUgY3VycmVudCBsZXZlbCBvZiBuZXN0aW5nICh1c2VkIGluIHJlY3Vyc2lvbilcbiAqIEBwYXJhbSByZXN1bHQgLSBBY2N1bXVsYXRvciBmb3IgdGhlIGZsYXR0ZW5lZCBvYmplY3QgKHVzZWQgaW4gcmVjdXJzaW9uKVxuICogQHJldHVybnMgQSBmbGF0dGVuZWQgb2JqZWN0IHdpdGggdW5kZXJzY29yZSBub3RhdGlvbiBrZXlzXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5PYmplY3Qob2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBwcmVmaXggPSAnJywgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge30pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgLy8gU2tpcCBudWxsIG9yIHVuZGVmaW5lZCBvYmplY3RzXG4gIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgXG4gIC8vIFByb2Nlc3MgZWFjaCBrZXkgaW4gdGhlIG9iamVjdFxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGNvbnN0IG5ld0tleSA9IHByZWZpeCA/IGAke3ByZWZpeH1fJHtrZXl9YCA6IGtleTtcbiAgICAgIFxuICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBuZXN0ZWQgb2JqZWN0c1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZsYXR0ZW5PYmplY3QodmFsdWUsIG5ld0tleSwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBhcnJheXMsIGtlZXAgdGhlbSBhcyBpcyAoZG9jeHRlbXBsYXRlciBjYW4gaGFuZGxlIGFycmF5cylcbiAgICAgICAgcmVzdWx0W25ld0tleV0gPSB2YWx1ZTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYW4gYXJyYXksIGFkZCBhIF9saXN0IHZlcnNpb24gZm9yIHRlbXBsYXRlIGxvb3AgY29tcGF0aWJpbGl0eVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYga2V5LnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJ3MnKSAmJiAha2V5LmVuZHNXaXRoKCdMaXN0JykgJiYgIWtleS5lbmRzV2l0aCgnbGlzdCcpKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgbGlzdCB2ZXJzaW9uIHdpdGggb2JqZWN0cyBjb250YWluaW5nIGEgdGV4dCBwcm9wZXJ0eVxuICAgICAgICAgIGNvbnN0IHNpbmd1bGFyS2V5ID0ga2V5LnNsaWNlKDAsIC0xKTsgLy8gUmVtb3ZlIHRyYWlsaW5nICdzJ1xuICAgICAgICAgIGNvbnN0IGxpc3RLZXkgPSBgJHtuZXdLZXl9TGlzdGA7XG4gICAgICAgICAgXG4gICAgICAgICAgcmVzdWx0W2xpc3RLZXldID0gdmFsdWUubWFwKChpdGVtOiBhbnkpID0+IHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBpdGVtIGlzIGFscmVhZHkgYW4gb2JqZWN0LCB1c2UgaXQ7IG90aGVyd2lzZSB3cmFwIGl0XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnICYmIGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBpdGVtIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRm9ybWF0IHRoZSByZXBvcnQgZGF0YSBmb3IgZG9jeCB0ZW1wbGF0ZSByZW5kZXJpbmdcbiAqIEBwYXJhbSByZXBvcnREYXRhIC0gVGhlIHJhdyByZXBvcnQgZGF0YSBmcm9tIHRoZSBhcHBsaWNhdGlvblxuICogQHJldHVybnMgRm9ybWF0dGVkIGRhdGEgcmVhZHkgZm9yIGRvY3ggdGVtcGxhdGVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UmVwb3J0RGF0YUZvckRvY3gocmVwb3J0RGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAvLyBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgdGhlIHJlcG9ydCBkYXRhXG4gIGNvbnN0IGZvcm1hdHRlZERhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlcG9ydERhdGEpKTtcblxuICAvLyBGb3JtYXQgYXJyYXlzIHRvIGJlIG1vcmUgZG9jeC10ZW1wbGF0ZSBmcmllbmRseVxuICAvLyBBcnJheXMgaW4gZG9jeHRlbXBsYXRlciBhcmUgdHlwaWNhbGx5IGhhbmRsZWQgd2l0aCBsb29wcywgc28gd2UnbGwgZm9ybWF0IHRoZW1cbiAgLy8gdG8gYmUgcmVhZHkgZm9yIHRoZSB0ZW1wbGF0ZSBzeW50YXhcblxuICAvLyBQcm9jZXNzIHN0cmVuZ3RoIGFuZCBuZWVkcyBsaXN0cyBmb3IgZWFjaCBkb21haW5cbiAgT2JqZWN0LmtleXMoZm9ybWF0dGVkRGF0YS5hc3Nlc3NtZW50UmVzdWx0cz8uZG9tYWlucyB8fCB7fSkuZm9yRWFjaChkb21haW4gPT4ge1xuICAgIGNvbnN0IGRvbWFpbkRhdGEgPSBmb3JtYXR0ZWREYXRhLmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXTtcbiAgICBcbiAgICAvLyBGb3JtYXQgc3RyZW5ndGhzIGFzIGJ1bGxldCBwb2ludHMgZm9yIERPQ1hcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkb21haW5EYXRhLnN0cmVuZ3RocykgJiYgZG9tYWluRGF0YS5zdHJlbmd0aHMubGVuZ3RoID4gMCkge1xuICAgICAgZG9tYWluRGF0YS5zdHJlbmd0aHNMaXN0ID0gZG9tYWluRGF0YS5zdHJlbmd0aHMubWFwKChpdGVtOiBzdHJpbmcpID0+ICh7IHRleHQ6IGl0ZW0gfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgZW1wdHkgYXJyYXkgaGFzIHJpZ2h0IGZvcm1hdCBmb3IgdGVtcGxhdGVzIHRoYXQgZXhwZWN0IGl0XG4gICAgICBkb21haW5EYXRhLnN0cmVuZ3Roc0xpc3QgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgbmVlZHMgYXMgYnVsbGV0IHBvaW50cyBmb3IgRE9DWFxuICAgIGlmIChBcnJheS5pc0FycmF5KGRvbWFpbkRhdGEubmVlZHMpICYmIGRvbWFpbkRhdGEubmVlZHMubGVuZ3RoID4gMCkge1xuICAgICAgZG9tYWluRGF0YS5uZWVkc0xpc3QgPSBkb21haW5EYXRhLm5lZWRzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiAoeyB0ZXh0OiBpdGVtIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRW5zdXJlIGVtcHR5IGFycmF5IGhhcyByaWdodCBmb3JtYXQgZm9yIHRlbXBsYXRlcyB0aGF0IGV4cGVjdCBpdFxuICAgICAgZG9tYWluRGF0YS5uZWVkc0xpc3QgPSBbXTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEZvcm1hdCBhY2NvbW1vZGF0aW9uIGFuZCBmYWNpbGl0YXRpb24gc3RyYXRlZ2llc1xuICBpZiAoQXJyYXkuaXNBcnJheShmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24/LnJlY29tbWVuZGF0aW9ucz8uYWNjb21tb2RhdGlvbnMpKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9uc0xpc3QgPSBcbiAgICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuYWNjb21tb2RhdGlvbnMubWFwKChpdGVtOiBzdHJpbmcpID0+ICh7IHRleHQ6IGl0ZW0gfSkpO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbj8ucmVjb21tZW5kYXRpb25zKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9uc0xpc3QgPSBbXTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbj8ucmVjb21tZW5kYXRpb25zPy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzKSkge1xuICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llc0xpc3QgPSBcbiAgICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llcy5tYXAoKGl0ZW06IHN0cmluZykgPT4gKHsgdGV4dDogaXRlbSB9KSk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uPy5yZWNvbW1lbmRhdGlvbnMpIHtcbiAgICBmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmZhY2lsaXRhdGlvblN0cmF0ZWdpZXNMaXN0ID0gW107XG4gIH1cblxuICAvLyBDb252ZXJ0IHBhcmVudHMgYXJyYXkgdG8gc3RyaW5nIGlmIG5lZWRlZFxuICBpZiAoQXJyYXkuaXNBcnJheShmb3JtYXR0ZWREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5wYXJlbnRzKSkge1xuICAgIGZvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5wYXJlbnRzU3RyaW5nID0gXG4gICAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ucGFyZW50cy5qb2luKCcsICcpO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlZERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24pIHtcbiAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ucGFyZW50c1N0cmluZyA9ICcnO1xuICB9XG5cbiAgLy8gQWRkIGZ1bGwgc3R1ZGVudCBuYW1lIGZvciBjb252ZW5pZW5jZVxuICBpZiAoZm9ybWF0dGVkRGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbj8uZmlyc3ROYW1lKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmZ1bGxOYW1lID0gXG4gICAgICBgJHtmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZmlyc3ROYW1lfSAke2Zvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5sYXN0TmFtZSB8fCAnJ31gO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlZERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24pIHtcbiAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZnVsbE5hbWUgPSAnU3R1ZGVudCc7XG4gIH1cblxuICAvLyBGbGF0dGVuIHRoZSBkYXRhIHN0cnVjdHVyZSB0byBtYXRjaCB1bmRlcnNjb3JlLWZvcm1hdHRlZCB0ZW1wbGF0ZSB0YWdzXG4gIC8vIEZvciBleGFtcGxlOiBoZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmZpcnN0TmFtZSBiZWNvbWVzIGhlYWRlcl9zdHVkZW50SW5mb3JtYXRpb25fZmlyc3ROYW1lXG4gIGNvbnN0IGZsYXR0ZW5lZERhdGEgPSBmbGF0dGVuT2JqZWN0KGZvcm1hdHRlZERhdGEpO1xuICBcbiAgLy8gTG9nIHRoZSBmbGF0dGVuZWQgZGF0YSBzdHJ1Y3R1cmUgZm9yIGRlYnVnZ2luZ1xuICBjb25zb2xlLmxvZygnRmxhdHRlbmVkIGRhdGEgcmVhZHkgZm9yIHRlbXBsYXRlOicpO1xuICBjb25zb2xlLmxvZygnS2V5czonLCBPYmplY3Qua2V5cyhmbGF0dGVuZWREYXRhKS5zbGljZSgwLCAxMCksICcuLi4gYW5kIG1vcmUnKTtcbiAgXG4gIHJldHVybiBmbGF0dGVuZWREYXRhO1xufSJdLCJuYW1lcyI6WyJEb2N4dGVtcGxhdGVyIiwiUGl6WmlwIiwic2F2ZUFzIiwiZ2VuZXJhdGVEb2N4RnJvbVRlbXBsYXRlIiwidGVtcGxhdGVCdWZmZXIiLCJkYXRhIiwib3V0cHV0RmlsZW5hbWUiLCJkZWJ1Z01vZGUiLCJjb25zb2xlIiwibG9nIiwiYnl0ZUxlbmd0aCIsIkpTT04iLCJzdHJpbmdpZnkiLCJmaXJzdEJ5dGVzIiwiVWludDhBcnJheSIsInNsaWNlIiwiQXJyYXkiLCJmcm9tIiwibWFwIiwiYiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwiRXJyb3IiLCJlcnJvciIsInppcCIsImFycmF5QnVmZmVyIiwiZmlsZXMiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiZm9yRWFjaCIsImZpbGUiLCJmaWxlRW50cnkiLCJuYW1lIiwiX2RhdGEiLCJkb2N1bWVudENvbnRlbnQiLCJhc1RleHQiLCJzbmlwcGV0Iiwic3Vic3RyaW5nIiwidGFnTWF0Y2hlcyIsIm1hdGNoIiwid2FybiIsImRvY3VtZW50RXJyb3IiLCJ6aXBFcnJvciIsIm1lc3NhZ2UiLCJkb2MiLCJwYXJhZ3JhcGhMb29wIiwibGluZWJyZWFrcyIsImVycm9yTG9nZ2luZyIsIm51bGxHZXR0ZXIiLCJwYXJ0IiwibW9kdWxlIiwiZGVsaW1pdGVycyIsInN0YXJ0IiwiZW5kIiwiZG9jWG1sIiwiY29udGVudCIsInRhZ1BhdHRlcm4iLCJ0YWdzIiwiZXhlYyIsInB1c2giLCJ1bmRlcnNjb3JlUGF0dGVybiIsImhhc1VuZGVyc2NvcmVUYWdzIiwic29tZSIsInRhZyIsInRlc3QiLCJlIiwiZG9jeEVycm9yIiwicHJvcGVydGllcyIsImVycm9ycyIsImZpcnN0RXJyb3IiLCJpbmRleCIsImV4cGxhbmF0aW9uIiwiaWQiLCJ4dGFnIiwicG9zdHBhcnNlZCIsIk1hdGgiLCJtYXgiLCJvZmZzZXQiLCJyZW5kZXIiLCJyZW5kZXJFcnJvciIsInJhdyIsInByb3BzIiwib3V0cHV0IiwiZ2V0WmlwIiwiZ2VuZXJhdGUiLCJ0eXBlIiwiY29tcHJlc3Npb24iLCJtaW1lVHlwZSIsInNpemUiLCJnZW5FcnJvciIsInNhdmVFcnJvciIsImluY2x1ZGVzIiwiZ2VuZXJhdGVGYWxsYmFja0h0bWxSZXBvcnQiLCJyZXBvcnREYXRhIiwic3R1ZGVudE5hbWUiLCJoZWFkZXIiLCJzdHVkZW50SW5mb3JtYXRpb24iLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImh0bWwiLCJET0IiLCJyZXBvcnREYXRlIiwicmVhc29uRm9yUmVmZXJyYWwiLCJhc3Nlc3NtZW50UmVzdWx0cyIsImRvbWFpbnMiLCJlbnRyaWVzIiwiZG9tYWluTmFtZSIsImRvbWFpbiIsInRvcGljU2VudGVuY2UiLCJzdHJlbmd0aHMiLCJuZWVkcyIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiaXNDb25jZXJuIiwidW5kZWZpbmVkIiwiaXRlbSIsImltcGFjdFN0YXRlbWVudCIsImNvbmNsdXNpb24iLCJyZWNvbW1lbmRhdGlvbnMiLCJhY2NvbW1vZGF0aW9ucyIsImZhY2lsaXRhdGlvblN0cmF0ZWdpZXMiLCJCbG9iIiwiY3JlYXRlRW1wdHlUZW1wbGF0ZSIsIm1pbmltYWxEb2N4QmFzZTY0IiwiYmluYXJ5U3RyaW5nIiwid2luZG93IiwiYXRvYiIsImJ5dGVzIiwiaSIsImNoYXJDb2RlQXQiLCJidWZmZXIiLCJnZW5lcmF0ZVJlcG9ydERvY3giLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImZpbGVuYW1lIiwicmVwbGFjZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJjYWNoZSIsImhlYWRlcnMiLCJvayIsInN0YXR1cyIsImFsdFJlc3BvbnNlIiwiYWx0Rmlyc3RCeXRlcyIsImFsdEVycm9yIiwiZm9ybWF0dGVkRGF0YSIsImZvcm1hdFJlcG9ydERhdGFGb3JEb2N4IiwidGVtcGxhdGVFcnJvciIsImVycm9yUHJvcHMiLCJlcnIiLCJtaW5pbWFsVGVtcGxhdGVCdWZmZXIiLCJtaW5pbWFsRXJyb3IiLCJodG1sQmxvYiIsImh0bWxGaWxlbmFtZSIsImZsYXR0ZW5PYmplY3QiLCJvYmoiLCJwcmVmaXgiLCJyZXN1bHQiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJ2YWx1ZSIsIm5ld0tleSIsImlzQXJyYXkiLCJ0b0xvd2VyQ2FzZSIsImVuZHNXaXRoIiwic2luZ3VsYXJLZXkiLCJsaXN0S2V5IiwidGV4dCIsInBhcnNlIiwiZG9tYWluRGF0YSIsInN0cmVuZ3Roc0xpc3QiLCJuZWVkc0xpc3QiLCJhY2NvbW1vZGF0aW9uc0xpc3QiLCJmYWNpbGl0YXRpb25TdHJhdGVnaWVzTGlzdCIsInBhcmVudHMiLCJwYXJlbnRzU3RyaW5nIiwiZnVsbE5hbWUiLCJmbGF0dGVuZWREYXRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/docx-generator.ts\n"));

/***/ })

});