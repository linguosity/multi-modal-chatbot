"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/reports/text-editor-test/page",{

/***/ "(app-pages-browser)/./src/lib/docx-generator.ts":
/*!***********************************!*\
  !*** ./src/lib/docx-generator.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateDocxFromTemplate: () => (/* binding */ generateDocxFromTemplate),\n/* harmony export */   generateReportDocx: () => (/* binding */ generateReportDocx)\n/* harmony export */ });\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! docxtemplater */ \"(app-pages-browser)/./node_modules/docxtemplater/js/docxtemplater.js\");\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(docxtemplater__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pizzip */ \"(app-pages-browser)/./node_modules/pizzip/js/index.js\");\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pizzip__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! file-saver */ \"(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n/**\n * Generate a docx file from a template and data\n * @param templateBuffer - The binary template file as an ArrayBuffer\n * @param data - The data to inject into the template\n * @param outputFilename - The name of the file to save\n * @param debugMode - Whether to enable extra debugging information\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateDocxFromTemplate(templateBuffer, data) {\n    let outputFilename = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'report.docx', debugMode = arguments.length > 3 && arguments[3] !== void 0 // Enable debug mode by default to help diagnose template issues\n     ? arguments[3] : true;\n    try {\n        console.log(\"Attempting to create PizZip instance with buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n        // Output debug information if debug mode is enabled\n        if (debugMode) {\n            console.log('Data being passed to template:', JSON.stringify(data, null, 2));\n            console.log('Template buffer size:', templateBuffer.byteLength);\n            // Log the first 20 bytes of the template to verify it's a proper DOCX file\n            const firstBytes = new Uint8Array(templateBuffer.slice(0, 20));\n            console.log('First 20 bytes of template (hex):', Array.from(firstBytes).map((b)=>b.toString(16).padStart(2, '0')).join(' '));\n        }\n        // Validate that we have a proper buffer\n        if (!templateBuffer || templateBuffer.byteLength === 0) {\n            throw new Error('Invalid template buffer: Empty or undefined');\n        }\n        // Verify the buffer has a ZIP signature (first bytes of a proper DOCX/ZIP file)\n        const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n        if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n            console.error('Invalid ZIP file signature in template. First bytes:', Array.from(firstBytes));\n            throw new Error('The template does not appear to be a valid ZIP/DOCX file (missing PK signature)');\n        }\n        // Create a new PizZip instance with the template content\n        // Use a try-catch specifically for the PizZip instantiation\n        let zip;\n        try {\n            // Convert ArrayBuffer to Uint8Array to ensure proper binary handling\n            const arrayBuffer = new Uint8Array(templateBuffer);\n            zip = new (pizzip__WEBPACK_IMPORTED_MODULE_1___default())(arrayBuffer);\n            // If in debug mode, examine the structure of the document\n            if (debugMode) {\n                console.log('PizZip opened successfully, inspecting contents:');\n                // List all files in the DOCX (which is a ZIP)\n                const files = Object.keys(zip.files);\n                console.log(\"DOCX contains \".concat(files.length, \" files:\"));\n                // Log the document structure (first 10 files)\n                files.slice(0, 10).forEach((file)=>{\n                    const fileEntry = zip.files[file];\n                    console.log(\" - \".concat(file, \" (\").concat(fileEntry.name, \", size: \").concat(fileEntry._data ? fileEntry._data.length : 'unknown', \" bytes)\"));\n                });\n                // Specifically check for document.xml (main content file)\n                if (zip.files['word/document.xml']) {\n                    try {\n                        const documentContent = zip.files['word/document.xml'].asText();\n                        // Log a snippet of the document.xml for template debugging\n                        const snippet = documentContent.substring(0, 500) + '... [truncated]';\n                        console.log('Document content preview:', snippet);\n                        // Look for template tag patterns\n                        const tagMatches = documentContent.match(/\\{[^{}]+\\}/g);\n                        if (tagMatches && tagMatches.length > 0) {\n                            console.log(\"Found \".concat(tagMatches.length, \" template tags:\"), tagMatches.slice(0, 20));\n                        } else {\n                            console.warn('No template tags found in document.xml - template may not be properly set up!');\n                        }\n                    } catch (documentError) {\n                        console.error('Error examining document.xml:', documentError);\n                    }\n                } else {\n                    console.warn('No word/document.xml found in the template - invalid DOCX structure!');\n                }\n            }\n        } catch (zipError) {\n            console.error('Error creating PizZip instance:', zipError);\n            throw new Error(\"Failed to create ZIP from template: \".concat(zipError instanceof Error ? zipError.message : 'Unknown error'));\n        }\n        console.log('PizZip instance created successfully');\n        // Create a new Docxtemplater instance with improved error handling\n        let doc;\n        try {\n            // Add modules and options for better error handling and debugging\n            doc = new (docxtemplater__WEBPACK_IMPORTED_MODULE_0___default())(zip, {\n                paragraphLoop: true,\n                linebreaks: true,\n                errorLogging: true,\n                // Better handling of missing/null values\n                nullGetter: function(part) {\n                    if (debugMode) {\n                        console.log('Null value encountered for tag:', part);\n                    }\n                    if (!part.module) {\n                        return \"\";\n                    }\n                    if (part.module === \"rawxml\") {\n                        return \"\";\n                    }\n                    return \"\";\n                },\n                // Parse options for more flexibility\n                delimiters: {\n                    start: '{',\n                    end: '}' // Default closing delimiter\n                },\n                // Track detailed tag information for debugging\n                parser: (tag)=>{\n                    if (debugMode) {\n                        console.log('Parsing tag:', tag);\n                    }\n                    return {\n                        get: (scope)=>{\n                            var _scope_tag;\n                            const result = (_scope_tag = scope[tag]) !== null && _scope_tag !== void 0 ? _scope_tag : '';\n                            if (debugMode && (result === undefined || result === null)) {\n                                console.warn(\"Tag '\".concat(tag, \"' resolved to undefined/null value\"));\n                            }\n                            return result;\n                        }\n                    };\n                }\n            });\n            console.log('Docxtemplater instance created successfully');\n        } catch (docxError) {\n            console.error('Error creating Docxtemplater instance:', docxError);\n            // Special handling for Multi error (which contains multiple errors)\n            if (docxError && docxError.properties && docxError.properties.errors) {\n                var _firstError_properties;\n                console.log('Docxtemplater reported multiple errors:');\n                // Log each individual error for debugging\n                docxError.properties.errors.forEach((error, index)=>{\n                    console.log(\"Error \".concat(index + 1, \":\"), error);\n                    // Log detailed information if available\n                    if (error.properties) {\n                        if (error.properties.explanation) {\n                            console.log(\"Explanation: \".concat(error.properties.explanation));\n                        }\n                        if (error.properties.id) {\n                            console.log(\"Error ID: \".concat(error.properties.id));\n                        }\n                        if (error.properties.xtag) {\n                            console.log(\"Tag with error: \".concat(error.properties.xtag));\n                        }\n                        if (error.properties.postparsed) {\n                            console.log('Template structure around error:');\n                            console.log(error.properties.postparsed.slice(Math.max(0, error.properties.offset - 5), error.properties.offset + 5));\n                        }\n                    }\n                });\n                // Throw a more detailed error\n                const firstError = docxError.properties.errors[0] || {};\n                const explanation = ((_firstError_properties = firstError.properties) === null || _firstError_properties === void 0 ? void 0 : _firstError_properties.explanation) || 'Unknown template issues';\n                throw new Error(\"Template errors detected: \".concat(explanation, \" (See console for full details)\"));\n            }\n            throw new Error(\"Failed to create Docxtemplater: \".concat(docxError instanceof Error ? docxError.message : 'Unknown error'));\n        }\n        try {\n            // Render the document with the provided data\n            doc.render(data);\n            console.log('Template rendered with data');\n        } catch (renderError) {\n            console.error('Error rendering template:', renderError);\n            // Special handling for Multi error (which contains multiple errors)\n            if (renderError && renderError.properties && renderError.properties.errors) {\n                var _firstError_properties1;\n                console.log('Docxtemplater reported multiple render errors:');\n                // Log each individual error for debugging\n                renderError.properties.errors.forEach((error, index)=>{\n                    console.log(\"Render Error \".concat(index + 1, \":\"), error);\n                    // Log detailed information if available\n                    if (error.properties) {\n                        if (error.properties.explanation) {\n                            console.log(\"Explanation: \".concat(error.properties.explanation));\n                        }\n                        if (error.properties.id) {\n                            console.log(\"Error ID: \".concat(error.properties.id));\n                        }\n                        if (error.properties.xtag) {\n                            console.log(\"Tag with error: \".concat(error.properties.xtag));\n                        }\n                        // Log the data path that caused the issue if known\n                        if (error.properties.tag) {\n                            console.log(\"Template tag: \".concat(error.properties.tag));\n                            console.log(\"Raw tag: \".concat(error.properties.raw));\n                        }\n                    }\n                });\n                // Throw a more detailed error\n                const firstError = renderError.properties.errors[0] || {};\n                const explanation = ((_firstError_properties1 = firstError.properties) === null || _firstError_properties1 === void 0 ? void 0 : _firstError_properties1.explanation) || 'Unknown template rendering issues';\n                throw new Error(\"Template rendering errors: \".concat(explanation, \" (See console for full details)\"));\n            }\n            // Special handling for individual Docxtemplater errors with properties\n            if (renderError instanceof Error && 'properties' in renderError) {\n                const props = renderError.properties || {};\n                console.log('Detailed render error properties:', props);\n                throw new Error(\"Template render error: \".concat(props.explanation || renderError.message));\n            }\n            throw new Error(\"Failed to render template: \".concat(renderError instanceof Error ? renderError.message : 'Unknown error'));\n        }\n        // Generate the output document\n        let output;\n        try {\n            output = doc.getZip().generate({\n                type: 'blob',\n                compression: 'DEFLATE',\n                mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n            });\n            console.log(\"Output document generated successfully (\".concat(output.size, \" bytes)\"));\n        } catch (genError) {\n            console.error('Error generating output document:', genError);\n            throw new Error(\"Failed to generate output: \".concat(genError instanceof Error ? genError.message : 'Unknown error'));\n        }\n        // If running in browser, save the file\n        if (true) {\n            try {\n                (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(output, outputFilename);\n                console.log(\"File saved as \".concat(outputFilename));\n            } catch (saveError) {\n                console.error('Error saving file:', saveError);\n                throw new Error(\"Failed to save file: \".concat(saveError instanceof Error ? saveError.message : 'Unknown error'));\n            }\n        }\n        return output;\n    } catch (error) {\n        console.error('Error in generateDocxFromTemplate:', error);\n        // If it's a PizZip error (likely invalid template)\n        if (error instanceof Error && error.message.includes('zip')) {\n            console.error('PizZip error - invalid template file structure');\n            throw new Error(\"Template file is not a valid DOCX/ZIP file: \".concat(error.message));\n        }\n        // Rethrow the error\n        throw error;\n    }\n}\n/**\n * Generate a fallback HTML report when DOCX template fails\n * @param reportData - The report data to export\n * @returns A blob with HTML content\n */ function generateFallbackHtmlReport(reportData) {\n    var _reportData_header_studentInformation, _reportData_header, _reportData_header_studentInformation1, _reportData_header1, _reportData_header_studentInformation2, _reportData_header2, _reportData_header3, _reportData_assessmentResults, _reportData_conclusion;\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \" \").concat(reportData.header.studentInformation.lastName) : 'Student';\n    // Create a simple HTML representation of the report\n    let html = '\\n    <!DOCTYPE html>\\n    <html>\\n    <head>\\n      <meta charset=\"utf-8\">\\n      <title>Report for '.concat(studentName, \"</title>\\n      <style>\\n        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }\\n        h1, h2, h3 { color: #444; }\\n        .section { margin-bottom: 30px; }\\n        .domain { margin-bottom: 20px; padding: 15px; border: 1px solid #eee; }\\n        .domain-header { display: flex; justify-content: space-between; align-items: center; }\\n        .concern { color: #f59e0b; font-size: 14px; }\\n        .no-concern { color: #10b981; font-size: 14px; }\\n        ul { margin-top: 5px; }\\n        @media print {\\n          body { margin: 0.5in; }\\n          .domain { break-inside: avoid; }\\n        }\\n      </style>\\n    </head>\\n    <body>\\n      <h1>Report for \").concat(studentName, '</h1>\\n      <div class=\"section\">\\n        <h2>Student Information</h2>\\n        <p><strong>DOB:</strong> ').concat(((_reportData_header1 = reportData.header) === null || _reportData_header1 === void 0 ? void 0 : (_reportData_header_studentInformation1 = _reportData_header1.studentInformation) === null || _reportData_header_studentInformation1 === void 0 ? void 0 : _reportData_header_studentInformation1.DOB) || 'N/A', \"</p>\\n        <p><strong>Report Date:</strong> \").concat(((_reportData_header2 = reportData.header) === null || _reportData_header2 === void 0 ? void 0 : (_reportData_header_studentInformation2 = _reportData_header2.studentInformation) === null || _reportData_header_studentInformation2 === void 0 ? void 0 : _reportData_header_studentInformation2.reportDate) || 'N/A', \"</p>\\n        <p><strong>Reason for Referral:</strong> \").concat(((_reportData_header3 = reportData.header) === null || _reportData_header3 === void 0 ? void 0 : _reportData_header3.reasonForReferral) || 'N/A', \"</p>\\n      </div>\\n  \");\n    // Add domains section\n    if ((_reportData_assessmentResults = reportData.assessmentResults) === null || _reportData_assessmentResults === void 0 ? void 0 : _reportData_assessmentResults.domains) {\n        html += '<div class=\"section\"><h2>Assessment Results</h2>';\n        Object.entries(reportData.assessmentResults.domains).forEach((param)=>{\n            let [domainName, domain] = param;\n            var _domain_strengths, _domain_needs;\n            if (domain.topicSentence || ((_domain_strengths = domain.strengths) === null || _domain_strengths === void 0 ? void 0 : _domain_strengths.length) || ((_domain_needs = domain.needs) === null || _domain_needs === void 0 ? void 0 : _domain_needs.length)) {\n                var _domain_strengths1, _domain_needs1;\n                html += '\\n          <div class=\"domain\">\\n            <div class=\"domain-header\">\\n              <h3>'.concat(domainName.charAt(0).toUpperCase() + domainName.slice(1), \" Language</h3>\\n              \").concat(domain.isConcern !== undefined ? '<span class=\"'.concat(domain.isConcern ? 'concern' : 'no-concern', '\">').concat(domain.isConcern ? 'Area of Concern' : 'No Concern', \"</span>\") : '', \"\\n            </div>\\n            \").concat(domain.topicSentence ? \"<p>\".concat(domain.topicSentence, \"</p>\") : '', \"\\n            \\n            \").concat(((_domain_strengths1 = domain.strengths) === null || _domain_strengths1 === void 0 ? void 0 : _domain_strengths1.length) ? \"\\n              <h4>Strengths:</h4>\\n              <ul>\\n                \".concat(domain.strengths.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(((_domain_needs1 = domain.needs) === null || _domain_needs1 === void 0 ? void 0 : _domain_needs1.length) ? \"\\n              <h4>Needs:</h4>\\n              <ul>\\n                \".concat(domain.needs.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(domain.impactStatement ? \"\\n              <h4>Educational Impact:</h4>\\n              <p>\".concat(domain.impactStatement, \"</p>\\n            \") : '', \"\\n          </div>\\n        \");\n            }\n        });\n        html += \"</div>\";\n    }\n    // Add recommendations\n    if ((_reportData_conclusion = reportData.conclusion) === null || _reportData_conclusion === void 0 ? void 0 : _reportData_conclusion.recommendations) {\n        var _reportData_conclusion_recommendations_accommodations, _reportData_conclusion_recommendations_facilitationStrategies;\n        html += '\\n      <div class=\"section\">\\n        <h2>Recommendations</h2>\\n        '.concat(((_reportData_conclusion_recommendations_accommodations = reportData.conclusion.recommendations.accommodations) === null || _reportData_conclusion_recommendations_accommodations === void 0 ? void 0 : _reportData_conclusion_recommendations_accommodations.length) ? \"\\n          <h3>Accommodations:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.accommodations.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n        \\n        \").concat(((_reportData_conclusion_recommendations_facilitationStrategies = reportData.conclusion.recommendations.facilitationStrategies) === null || _reportData_conclusion_recommendations_facilitationStrategies === void 0 ? void 0 : _reportData_conclusion_recommendations_facilitationStrategies.length) ? \"\\n          <h3>Facilitation Strategies:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.facilitationStrategies.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n      </div>\\n    \");\n    }\n    html += \"\\n      <footer>\\n        <p><em>This is a fallback HTML report generated because the DOCX template could not be processed. \\n        You can print this HTML file to create a PDF.</em></p>\\n      </footer>\\n    </body>\\n    </html>\\n  \";\n    return new Blob([\n        html\n    ], {\n        type: 'text/html'\n    });\n}\n/**\n * Create a simple empty DOCX template programmatically\n * This is a last-resort fallback when all template files fail to load\n */ function createEmptyTemplate() {\n    // Define a minimal valid DOCX file structure as a base64 string\n    // This is a simplified empty DOCX file with minimal content\n    const minimalDocxBase64 = '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';\n    // Convert base64 to ArrayBuffer\n    const binaryString = window.atob(minimalDocxBase64);\n    const bytes = new Uint8Array(binaryString.length);\n    for(let i = 0; i < binaryString.length; i++){\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n/**\n * Generate a report docx from the report data\n * @param reportData - The report data from the application\n * @param templateBuffer - The binary template file as an ArrayBuffer (optional)\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateReportDocx(reportData, templateBuffer) {\n    var _reportData_header_studentInformation, _reportData_header;\n    // Generate the filename based on report data\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \"_\").concat(reportData.header.studentInformation.lastName) : 'student';\n    const timestamp = new Date().toISOString().split('T')[0];\n    const filename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".docx\");\n    try {\n        // If no template buffer is provided, use a default template\n        if (!templateBuffer) {\n            // Use fetch to get the template if we're in the browser\n            if (true) {\n                try {\n                    console.log('No template buffer provided, fetching default template');\n                    // Try to use response.arrayBuffer() which ensures binary data handling\n                    // Use las-assessment-report-template.docx instead of report-template.docx (which is a text file, not a DOCX)\n                    const response = await fetch('/templates/las-assessment-report-template.docx', {\n                        method: 'GET',\n                        cache: 'no-cache',\n                        headers: {\n                            'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                            'Cache-Control': 'no-cache'\n                        }\n                    });\n                    if (!response.ok) {\n                        throw new Error(\"Failed to fetch default template: \".concat(response.status));\n                    }\n                    console.log('Default template fetched successfully');\n                    templateBuffer = await response.arrayBuffer();\n                    console.log(\"Default template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                    if (templateBuffer.byteLength === 0) {\n                        throw new Error('Default template file is empty');\n                    }\n                    // Verify the template has a proper DOCX signature\n                    const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                    if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n                        console.error('Invalid DOCX file signature in default template. First bytes:', Array.from(firstBytes));\n                        throw new Error('Default template is not a valid DOCX file');\n                    }\n                } catch (error) {\n                    console.error('Error loading default template:', error);\n                    // Try alternative template as a last resort\n                    try {\n                        console.log('Attempting to load alternative template: las-assessment-report-template-fixed.docx');\n                        const altResponse = await fetch('/templates/las-assessment-report-template-fixed.docx', {\n                            cache: 'no-cache',\n                            headers: {\n                                'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                                'Cache-Control': 'no-cache'\n                            }\n                        });\n                        if (!altResponse.ok) {\n                            throw new Error(\"Failed to fetch alternative template: \".concat(altResponse.status));\n                        }\n                        templateBuffer = await altResponse.arrayBuffer();\n                        console.log(\"Alternative template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        // Verify the alternative template\n                        const altFirstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                        if (!(altFirstBytes[0] === 0x50 && altFirstBytes[1] === 0x4B)) {\n                            console.error('Invalid DOCX file signature in alternative template');\n                            throw new Error('Alternative template is not a valid DOCX file');\n                        }\n                    } catch (altError) {\n                        console.error('Error loading alternative template:', altError);\n                        // As a last resort, create a minimal valid DOCX template\n                        console.log('Creating minimal empty DOCX template');\n                        templateBuffer = createEmptyTemplate();\n                        console.log(\"Created minimal template with size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        if (!templateBuffer || templateBuffer.byteLength === 0) {\n                            // All template attempts failed, fall back to HTML\n                            throw new Error('All template attempts failed');\n                        }\n                    }\n                }\n            } else {}\n        }\n        // Format and prepare data for the template\n        const formattedData = formatReportDataForDocx(reportData);\n        console.log('Data formatted for DOCX template');\n        // First try with the provided template\n        try {\n            // Try with the provided/fetched template\n            console.log('Attempting to generate DOCX with primary template');\n            return await generateDocxFromTemplate(templateBuffer, formattedData, filename);\n        } catch (templateError) {\n            console.error('Error using the provided template:', templateError);\n            // For any error when processing the template, try with a minimal template\n            // that doesn't rely on complex formatting or tags\n            if (templateError instanceof Error) {\n                // Log the full error to help diagnose template issues\n                console.warn('Template error details:');\n                console.log('Error message:', templateError.message);\n                // Log detailed error properties if available\n                if ('properties' in templateError) {\n                    const errorProps = templateError.properties;\n                    if (errorProps && errorProps.errors) {\n                        console.log('Template contains multiple errors:');\n                        errorProps.errors.forEach((err, i)=>{\n                            console.log(\"Error \".concat(i + 1, \":\"), err);\n                            if (err.properties) {\n                                console.log('Properties:', err.properties);\n                            }\n                        });\n                    }\n                }\n                console.warn('Attempting to use minimal template without complex formatting...');\n                // Use the createEmptyTemplate function to generate a minimal template\n                try {\n                    console.log('Creating minimal empty DOCX template');\n                    const minimalTemplateBuffer = createEmptyTemplate();\n                    console.log(\"Minimal template created (\".concat(minimalTemplateBuffer.byteLength, \" bytes)\"));\n                    // Try again with the minimal template\n                    return await generateDocxFromTemplate(minimalTemplateBuffer, formattedData, filename);\n                } catch (minimalError) {\n                    console.error('Error with minimal template:', minimalError);\n                    // Let the outer catch handle the fallback to HTML\n                    throw minimalError;\n                }\n            } else {\n                // Rethrow to let the outer catch handle it\n                throw templateError;\n            }\n        }\n    } catch (error) {\n        console.error('Error in generateReportDocx:', error);\n        // If all DOCX generation attempts failed, fall back to HTML\n        console.warn('All DOCX generation attempts failed, falling back to HTML export');\n        const htmlBlob = generateFallbackHtmlReport(reportData);\n        const htmlFilename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".html\");\n        if (true) {\n            (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(htmlBlob, htmlFilename);\n        }\n        return htmlBlob;\n    }\n}\n/**\n * Flattens a nested object structure, converting nested properties to underscore notation\n * This ensures compatibility with docxtemplater templates that use underscore notation\n * \n * @param obj - The object to flatten\n * @param prefix - Optional prefix for the current level of nesting (used in recursion)\n * @param result - Accumulator for the flattened object (used in recursion)\n * @returns A flattened object with underscore notation keys\n */ function flattenObject(obj) {\n    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '', result = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    // Skip null or undefined objects\n    if (obj == null) return result;\n    // Process each key in the object\n    for(const key in obj){\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            const value = obj[key];\n            const newKey = prefix ? \"\".concat(prefix, \"_\").concat(key) : key;\n            // Recursively flatten nested objects\n            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n                flattenObject(value, newKey, result);\n            } else {\n                // For arrays, keep them as is (docxtemplater can handle arrays)\n                result[newKey] = value;\n                // If this is an array, add a _list version for template loop compatibility\n                if (Array.isArray(value) && key.toLowerCase().endsWith('s') && !key.endsWith('List') && !key.endsWith('list')) {\n                    // Create a list version with objects containing a text property\n                    const singularKey = key.slice(0, -1); // Remove trailing 's'\n                    const listKey = \"\".concat(newKey, \"List\");\n                    result[listKey] = value.map((item)=>{\n                        // If the item is already an object, use it; otherwise wrap it\n                        if (typeof item === 'object' && item !== null) {\n                            return item;\n                        }\n                        return {\n                            text: item\n                        };\n                    });\n                }\n            }\n        }\n    }\n    return result;\n}\n/**\n * Format the report data for docx template rendering\n * @param reportData - The raw report data from the application\n * @returns Formatted data ready for docx template\n */ function formatReportDataForDocx(reportData) {\n    var _formattedData_assessmentResults, _formattedData_conclusion_recommendations, _formattedData_conclusion, _formattedData_conclusion1, _formattedData_conclusion_recommendations1, _formattedData_conclusion2, _formattedData_conclusion3, _formattedData_header_studentInformation, _formattedData_header, _formattedData_header1, _formattedData_header_studentInformation1, _formattedData_header2, _formattedData_header3;\n    // Create a deep copy of the report data\n    const formattedData = JSON.parse(JSON.stringify(reportData));\n    // Format arrays to be more docx-template friendly\n    // Arrays in docxtemplater are typically handled with loops, so we'll format them\n    // to be ready for the template syntax\n    // Process strength and needs lists for each domain\n    Object.keys(((_formattedData_assessmentResults = formattedData.assessmentResults) === null || _formattedData_assessmentResults === void 0 ? void 0 : _formattedData_assessmentResults.domains) || {}).forEach((domain)=>{\n        const domainData = formattedData.assessmentResults.domains[domain];\n        // Format strengths as bullet points for DOCX\n        if (Array.isArray(domainData.strengths) && domainData.strengths.length > 0) {\n            domainData.strengthsList = domainData.strengths.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.strengthsList = [];\n        }\n        // Format needs as bullet points for DOCX\n        if (Array.isArray(domainData.needs) && domainData.needs.length > 0) {\n            domainData.needsList = domainData.needs.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.needsList = [];\n        }\n    });\n    // Format accommodation and facilitation strategies\n    if (Array.isArray((_formattedData_conclusion = formattedData.conclusion) === null || _formattedData_conclusion === void 0 ? void 0 : (_formattedData_conclusion_recommendations = _formattedData_conclusion.recommendations) === null || _formattedData_conclusion_recommendations === void 0 ? void 0 : _formattedData_conclusion_recommendations.accommodations)) {\n        formattedData.conclusion.recommendations.accommodationsList = formattedData.conclusion.recommendations.accommodations.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion1 = formattedData.conclusion) === null || _formattedData_conclusion1 === void 0 ? void 0 : _formattedData_conclusion1.recommendations) {\n        formattedData.conclusion.recommendations.accommodationsList = [];\n    }\n    if (Array.isArray((_formattedData_conclusion2 = formattedData.conclusion) === null || _formattedData_conclusion2 === void 0 ? void 0 : (_formattedData_conclusion_recommendations1 = _formattedData_conclusion2.recommendations) === null || _formattedData_conclusion_recommendations1 === void 0 ? void 0 : _formattedData_conclusion_recommendations1.facilitationStrategies)) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = formattedData.conclusion.recommendations.facilitationStrategies.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion3 = formattedData.conclusion) === null || _formattedData_conclusion3 === void 0 ? void 0 : _formattedData_conclusion3.recommendations) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = [];\n    }\n    // Convert parents array to string if needed\n    if (Array.isArray((_formattedData_header = formattedData.header) === null || _formattedData_header === void 0 ? void 0 : (_formattedData_header_studentInformation = _formattedData_header.studentInformation) === null || _formattedData_header_studentInformation === void 0 ? void 0 : _formattedData_header_studentInformation.parents)) {\n        formattedData.header.studentInformation.parentsString = formattedData.header.studentInformation.parents.join(', ');\n    } else if ((_formattedData_header1 = formattedData.header) === null || _formattedData_header1 === void 0 ? void 0 : _formattedData_header1.studentInformation) {\n        formattedData.header.studentInformation.parentsString = '';\n    }\n    // Add full student name for convenience\n    if ((_formattedData_header2 = formattedData.header) === null || _formattedData_header2 === void 0 ? void 0 : (_formattedData_header_studentInformation1 = _formattedData_header2.studentInformation) === null || _formattedData_header_studentInformation1 === void 0 ? void 0 : _formattedData_header_studentInformation1.firstName) {\n        formattedData.header.studentInformation.fullName = \"\".concat(formattedData.header.studentInformation.firstName, \" \").concat(formattedData.header.studentInformation.lastName || '');\n    } else if ((_formattedData_header3 = formattedData.header) === null || _formattedData_header3 === void 0 ? void 0 : _formattedData_header3.studentInformation) {\n        formattedData.header.studentInformation.fullName = 'Student';\n    }\n    // Flatten the data structure to match underscore-formatted template tags\n    // For example: header.studentInformation.firstName becomes header_studentInformation_firstName\n    const flattenedData = flattenObject(formattedData);\n    // Log the flattened data structure for debugging\n    console.log('Flattened data ready for template:');\n    console.log('Keys:', Object.keys(flattenedData).slice(0, 10), '... and more');\n    return flattenedData;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZG9jeC1nZW5lcmF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMEM7QUFDZDtBQUNRO0FBRXBDOzs7Ozs7O0NBT0MsR0FDTSxlQUFlRyx5QkFDcEJDLGNBQTJCLEVBQzNCQyxJQUF5QjtRQUN6QkMsaUJBQUFBLGlFQUF5QixlQUN6QkMsWUFBQUEsZ0RBQTBCLGdFQUFnRTtzQkFBckU7SUFFckIsSUFBSTtRQUNGQyxRQUFRQyxHQUFHLENBQUMsMERBQW9GLE9BQTFCTCxlQUFlTSxVQUFVLEVBQUM7UUFFaEcsb0RBQW9EO1FBQ3BELElBQUlILFdBQVc7WUFDYkMsUUFBUUMsR0FBRyxDQUFDLGtDQUFrQ0UsS0FBS0MsU0FBUyxDQUFDUCxNQUFNLE1BQU07WUFDekVHLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJMLGVBQWVNLFVBQVU7WUFDOUQsMkVBQTJFO1lBQzNFLE1BQU1HLGFBQWEsSUFBSUMsV0FBV1YsZUFBZVcsS0FBSyxDQUFDLEdBQUc7WUFDMURQLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUNPLE1BQU1DLElBQUksQ0FBQ0osWUFBWUssR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDO1FBQ3pIO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQ2xCLGtCQUFrQkEsZUFBZU0sVUFBVSxLQUFLLEdBQUc7WUFDdEQsTUFBTSxJQUFJYSxNQUFNO1FBQ2xCO1FBRUEsZ0ZBQWdGO1FBQ2hGLE1BQU1WLGFBQWEsSUFBSUMsV0FBV1YsZUFBZVcsS0FBSyxDQUFDLEdBQUc7UUFDMUQsSUFBSSxDQUFFRixDQUFBQSxVQUFVLENBQUMsRUFBRSxLQUFLLFFBQVFBLFVBQVUsQ0FBQyxFQUFFLEtBQUssSUFBRyxHQUFJO1lBQ3ZETCxRQUFRZ0IsS0FBSyxDQUFDLHdEQUF3RFIsTUFBTUMsSUFBSSxDQUFDSjtZQUNqRixNQUFNLElB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QUEsY0FBY3BELE1BQU0sY0FBcEJvRCw2Q0FBQUEsdUJBQXNCbkQsa0JBQWtCLEVBQUU7UUFDbkRtRCxjQUFjcEQsTUFBTSxDQUFDQyxrQkFBa0IsQ0FBQ2tGLGFBQWEsR0FBRztJQUMxRDtJQUVBLHdDQUF3QztJQUN4QyxLQUFJL0IseUJBQUFBLGNBQWNwRCxNQUFNLGNBQXBCb0QsOENBQUFBLDRDQUFBQSx1QkFBc0JuRCxrQkFBa0IsY0FBeENtRCxnRUFBQUEsMENBQTBDbEQsU0FBUyxFQUFFO1FBQ3ZEa0QsY0FBY3BELE1BQU0sQ0FBQ0Msa0JBQWtCLENBQUNtRixRQUFRLEdBQzlDLEdBQXdEaEMsT0FBckRBLGNBQWNwRCxNQUFNLENBQUNDLGtCQUFrQixDQUFDQyxTQUFTLEVBQUMsS0FBMEQsT0FBdkRrRCxjQUFjcEQsTUFBTSxDQUFDQyxrQkFBa0IsQ0FBQ0UsUUFBUSxJQUFJO0lBQ2hILE9BQU8sS0FBSWlELHlCQUFBQSxjQUFjcEQsTUFBTSxjQUFwQm9ELDZDQUFBQSx1QkFBc0JuRCxrQkFBa0IsRUFBRTtRQUNuRG1ELGNBQWNwRCxNQUFNLENBQUNDLGtCQUFrQixDQUFDbUYsUUFBUSxHQUFHO0lBQ3JEO0lBRUEseUVBQXlFO0lBQ3pFLCtGQUErRjtJQUMvRixNQUFNQyxnQkFBZ0J4QixjQUFjVDtJQUVwQyxpREFBaUQ7SUFDakR2SSxRQUFRQyxHQUFHLENBQUM7SUFDWkQsUUFBUUMsR0FBRyxDQUFDLFNBQVNtQixPQUFPQyxJQUFJLENBQUNtSixlQUFlakssS0FBSyxDQUFDLEdBQUcsS0FBSztJQUU5RCxPQUFPaUs7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9zcmMvbGliL2RvY3gtZ2VuZXJhdG9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBEb2N4dGVtcGxhdGVyIGZyb20gJ2RvY3h0ZW1wbGF0ZXInO1xuaW1wb3J0IFBpelppcCBmcm9tICdwaXp6aXAnO1xuaW1wb3J0IHsgc2F2ZUFzIH0gZnJvbSAnZmlsZS1zYXZlcic7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBkb2N4IGZpbGUgZnJvbSBhIHRlbXBsYXRlIGFuZCBkYXRhXG4gKiBAcGFyYW0gdGVtcGxhdGVCdWZmZXIgLSBUaGUgYmluYXJ5IHRlbXBsYXRlIGZpbGUgYXMgYW4gQXJyYXlCdWZmZXJcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gaW5qZWN0IGludG8gdGhlIHRlbXBsYXRlXG4gKiBAcGFyYW0gb3V0cHV0RmlsZW5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmlsZSB0byBzYXZlXG4gKiBAcGFyYW0gZGVidWdNb2RlIC0gV2hldGhlciB0byBlbmFibGUgZXh0cmEgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgZ2VuZXJhdGVkIGZpbGUgYXMgYSBCbG9iXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZURvY3hGcm9tVGVtcGxhdGUoXG4gIHRlbXBsYXRlQnVmZmVyOiBBcnJheUJ1ZmZlcixcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgYW55PixcbiAgb3V0cHV0RmlsZW5hbWU6IHN0cmluZyA9ICdyZXBvcnQuZG9jeCcsXG4gIGRlYnVnTW9kZTogYm9vbGVhbiA9IHRydWUgLy8gRW5hYmxlIGRlYnVnIG1vZGUgYnkgZGVmYXVsdCB0byBoZWxwIGRpYWdub3NlIHRlbXBsYXRlIGlzc3Vlc1xuKTogUHJvbWlzZTxCbG9iPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgdG8gY3JlYXRlIFBpelppcCBpbnN0YW5jZSB3aXRoIGJ1ZmZlciBzaXplOiAke3RlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGh9IGJ5dGVzYCk7XG4gICAgXG4gICAgLy8gT3V0cHV0IGRlYnVnIGluZm9ybWF0aW9uIGlmIGRlYnVnIG1vZGUgaXMgZW5hYmxlZFxuICAgIGlmIChkZWJ1Z01vZGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdEYXRhIGJlaW5nIHBhc3NlZCB0byB0ZW1wbGF0ZTonLCBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKSk7XG4gICAgICBjb25zb2xlLmxvZygnVGVtcGxhdGUgYnVmZmVyIHNpemU6JywgdGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAvLyBMb2cgdGhlIGZpcnN0IDIwIGJ5dGVzIG9mIHRoZSB0ZW1wbGF0ZSB0byB2ZXJpZnkgaXQncyBhIHByb3BlciBET0NYIGZpbGVcbiAgICAgIGNvbnN0IGZpcnN0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlci5zbGljZSgwLCAyMCkpO1xuICAgICAgY29uc29sZS5sb2coJ0ZpcnN0IDIwIGJ5dGVzIG9mIHRlbXBsYXRlIChoZXgpOicsIEFycmF5LmZyb20oZmlyc3RCeXRlcykubWFwKGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignICcpKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdGhhdCB3ZSBoYXZlIGEgcHJvcGVyIGJ1ZmZlclxuICAgIGlmICghdGVtcGxhdGVCdWZmZXIgfHwgdGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRlbXBsYXRlIGJ1ZmZlcjogRW1wdHkgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFZlcmlmeSB0aGUgYnVmZmVyIGhhcyBhIFpJUCBzaWduYXR1cmUgKGZpcnN0IGJ5dGVzIG9mIGEgcHJvcGVyIERPQ1gvWklQIGZpbGUpXG4gICAgY29uc3QgZmlyc3RCeXRlcyA9IG5ldyBVaW50OEFycmF5KHRlbXBsYXRlQnVmZmVyLnNsaWNlKDAsIDQpKTtcbiAgICBpZiAoIShmaXJzdEJ5dGVzWzBdID09PSAweDUwICYmIGZpcnN0Qnl0ZXNbMV0gPT09IDB4NEIpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIFpJUCBmaWxlIHNpZ25hdHVyZSBpbiB0ZW1wbGF0ZS4gRmlyc3QgYnl0ZXM6JywgQXJyYXkuZnJvbShmaXJzdEJ5dGVzKSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0ZW1wbGF0ZSBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSB2YWxpZCBaSVAvRE9DWCBmaWxlIChtaXNzaW5nIFBLIHNpZ25hdHVyZSknKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgbmV3IFBpelppcCBpbnN0YW5jZSB3aXRoIHRoZSB0ZW1wbGF0ZSBjb250ZW50XG4gICAgLy8gVXNlIGEgdHJ5LWNhdGNoIHNwZWNpZmljYWxseSBmb3IgdGhlIFBpelppcCBpbnN0YW50aWF0aW9uXG4gICAgbGV0IHppcDtcbiAgICB0cnkge1xuICAgICAgLy8gQ29udmVydCBBcnJheUJ1ZmZlciB0byBVaW50OEFycmF5IHRvIGVuc3VyZSBwcm9wZXIgYmluYXJ5IGhhbmRsaW5nXG4gICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRlbXBsYXRlQnVmZmVyKTtcbiAgICAgIHppcCA9IG5ldyBQaXpaaXAoYXJyYXlCdWZmZXIpO1xuICAgICAgXG4gICAgICAvLyBJZiBpbiBkZWJ1ZyBtb2RlLCBleGFtaW5lIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGRvY3VtZW50XG4gICAgICBpZiAoZGVidWdNb2RlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQaXpaaXAgb3BlbmVkIHN1Y2Nlc3NmdWxseSwgaW5zcGVjdGluZyBjb250ZW50czonKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExpc3QgYWxsIGZpbGVzIGluIHRoZSBET0NYICh3aGljaCBpcyBhIFpJUClcbiAgICAgICAgY29uc3QgZmlsZXMgPSBPYmplY3Qua2V5cyh6aXAuZmlsZXMpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRE9DWCBjb250YWlucyAke2ZpbGVzLmxlbmd0aH0gZmlsZXM6YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2cgdGhlIGRvY3VtZW50IHN0cnVjdHVyZSAoZmlyc3QgMTAgZmlsZXMpXG4gICAgICAgIGZpbGVzLnNsaWNlKDAsIDEwKS5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgICAgIGNvbnN0IGZpbGVFbnRyeSA9IHppcC5maWxlc1tmaWxlXTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgIC0gJHtmaWxlfSAoJHtmaWxlRW50cnkubmFtZX0sIHNpemU6ICR7ZmlsZUVudHJ5Ll9kYXRhID8gZmlsZUVudHJ5Ll9kYXRhLmxlbmd0aCA6ICd1bmtub3duJ30gYnl0ZXMpYCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gU3BlY2lmaWNhbGx5IGNoZWNrIGZvciBkb2N1bWVudC54bWwgKG1haW4gY29udGVudCBmaWxlKVxuICAgICAgICBpZiAoemlwLmZpbGVzWyd3b3JkL2RvY3VtZW50LnhtbCddKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50Q29udGVudCA9IHppcC5maWxlc1snd29yZC9kb2N1bWVudC54bWwnXS5hc1RleHQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTG9nIGEgc25pcHBldCBvZiB0aGUgZG9jdW1lbnQueG1sIGZvciB0ZW1wbGF0ZSBkZWJ1Z2dpbmdcbiAgICAgICAgICAgIGNvbnN0IHNuaXBwZXQgPSBkb2N1bWVudENvbnRlbnQuc3Vic3RyaW5nKDAsIDUwMCkgKyAnLi4uIFt0cnVuY2F0ZWRdJztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEb2N1bWVudCBjb250ZW50IHByZXZpZXc6Jywgc25pcHBldCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIExvb2sgZm9yIHRlbXBsYXRlIHRhZyBwYXR0ZXJuc1xuICAgICAgICAgICAgY29uc3QgdGFnTWF0Y2hlcyA9IGRvY3VtZW50Q29udGVudC5tYXRjaCgvXFx7W157fV0rXFx9L2cpO1xuICAgICAgICAgICAgaWYgKHRhZ01hdGNoZXMgJiYgdGFnTWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke3RhZ01hdGNoZXMubGVuZ3RofSB0ZW1wbGF0ZSB0YWdzOmAsIHRhZ01hdGNoZXMuc2xpY2UoMCwgMjApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gdGVtcGxhdGUgdGFncyBmb3VuZCBpbiBkb2N1bWVudC54bWwgLSB0ZW1wbGF0ZSBtYXkgbm90IGJlIHByb3Blcmx5IHNldCB1cCEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChkb2N1bWVudEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBleGFtaW5pbmcgZG9jdW1lbnQueG1sOicsIGRvY3VtZW50RXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIHdvcmQvZG9jdW1lbnQueG1sIGZvdW5kIGluIHRoZSB0ZW1wbGF0ZSAtIGludmFsaWQgRE9DWCBzdHJ1Y3R1cmUhJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoICh6aXBFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgUGl6WmlwIGluc3RhbmNlOicsIHppcEVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBaSVAgZnJvbSB0ZW1wbGF0ZTogJHt6aXBFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gemlwRXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1BpelppcCBpbnN0YW5jZSBjcmVhdGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyBEb2N4dGVtcGxhdGVyIGluc3RhbmNlIHdpdGggaW1wcm92ZWQgZXJyb3IgaGFuZGxpbmdcbiAgICBsZXQgZG9jO1xuICAgIHRyeSB7XG4gICAgICAvLyBBZGQgbW9kdWxlcyBhbmQgb3B0aW9ucyBmb3IgYmV0dGVyIGVycm9yIGhhbmRsaW5nIGFuZCBkZWJ1Z2dpbmdcbiAgICAgIGRvYyA9IG5ldyBEb2N4dGVtcGxhdGVyKHppcCwge1xuICAgICAgICBwYXJhZ3JhcGhMb29wOiB0cnVlLFxuICAgICAgICBsaW5lYnJlYWtzOiB0cnVlLFxuICAgICAgICBlcnJvckxvZ2dpbmc6IHRydWUsXG4gICAgICAgIC8vIEJldHRlciBoYW5kbGluZyBvZiBtaXNzaW5nL251bGwgdmFsdWVzXG4gICAgICAgIG51bGxHZXR0ZXI6IGZ1bmN0aW9uKHBhcnQ6IGFueSkge1xuICAgICAgICAgIGlmIChkZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOdWxsIHZhbHVlIGVuY291bnRlcmVkIGZvciB0YWc6JywgcGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcGFydC5tb2R1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5tb2R1bGUgPT09IFwicmF3eG1sXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUGFyc2Ugb3B0aW9ucyBmb3IgbW9yZSBmbGV4aWJpbGl0eVxuICAgICAgICBkZWxpbWl0ZXJzOiB7XG4gICAgICAgICAgc3RhcnQ6ICd7JywgIC8vIERlZmF1bHQgb3BlbmluZyBkZWxpbWl0ZXJcbiAgICAgICAgICBlbmQ6ICd9JyAgICAgLy8gRGVmYXVsdCBjbG9zaW5nIGRlbGltaXRlclxuICAgICAgICB9LFxuICAgICAgICAvLyBUcmFjayBkZXRhaWxlZCB0YWcgaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2luZ1xuICAgICAgICBwYXJzZXI6ICh0YWc6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGlmIChkZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQYXJzaW5nIHRhZzonLCB0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0OiAoc2NvcGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzY29wZVt0YWddID8/ICcnO1xuICAgICAgICAgICAgICBpZiAoZGVidWdNb2RlICYmIChyZXN1bHQgPT09IHVuZGVmaW5lZCB8fCByZXN1bHQgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUYWcgJyR7dGFnfScgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkL251bGwgdmFsdWVgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coJ0RvY3h0ZW1wbGF0ZXIgaW5zdGFuY2UgY3JlYXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICB9IGNhdGNoIChkb2N4RXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgRG9jeHRlbXBsYXRlciBpbnN0YW5jZTonLCBkb2N4RXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBNdWx0aSBlcnJvciAod2hpY2ggY29udGFpbnMgbXVsdGlwbGUgZXJyb3JzKVxuICAgICAgaWYgKGRvY3hFcnJvciAmJiBkb2N4RXJyb3IucHJvcGVydGllcyAmJiBkb2N4RXJyb3IucHJvcGVydGllcy5lcnJvcnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0RvY3h0ZW1wbGF0ZXIgcmVwb3J0ZWQgbXVsdGlwbGUgZXJyb3JzOicpO1xuICAgICAgICBcbiAgICAgICAgLy8gTG9nIGVhY2ggaW5kaXZpZHVhbCBlcnJvciBmb3IgZGVidWdnaW5nXG4gICAgICAgIGRvY3hFcnJvci5wcm9wZXJ0aWVzLmVycm9ycy5mb3JFYWNoKChlcnJvcjogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEVycm9yICR7aW5kZXggKyAxfTpgLCBlcnJvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTG9nIGRldGFpbGVkIGluZm9ybWF0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcy5leHBsYW5hdGlvbikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXhwbGFuYXRpb246ICR7ZXJyb3IucHJvcGVydGllcy5leHBsYW5hdGlvbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLmlkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciBJRDogJHtlcnJvci5wcm9wZXJ0aWVzLmlkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMueHRhZykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVGFnIHdpdGggZXJyb3I6ICR7ZXJyb3IucHJvcGVydGllcy54dGFnfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMucG9zdHBhcnNlZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVGVtcGxhdGUgc3RydWN0dXJlIGFyb3VuZCBlcnJvcjonKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IucHJvcGVydGllcy5wb3N0cGFyc2VkLnNsaWNlKE1hdGgubWF4KDAsIGVycm9yLnByb3BlcnRpZXMub2Zmc2V0IC0gNSksIGVycm9yLnByb3BlcnRpZXMub2Zmc2V0ICsgNSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBUaHJvdyBhIG1vcmUgZGV0YWlsZWQgZXJyb3JcbiAgICAgICAgY29uc3QgZmlyc3RFcnJvciA9IGRvY3hFcnJvci5wcm9wZXJ0aWVzLmVycm9yc1swXSB8fCB7fTtcbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSBmaXJzdEVycm9yLnByb3BlcnRpZXM/LmV4cGxhbmF0aW9uIHx8ICdVbmtub3duIHRlbXBsYXRlIGlzc3Vlcyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVtcGxhdGUgZXJyb3JzIGRldGVjdGVkOiAke2V4cGxhbmF0aW9ufSAoU2VlIGNvbnNvbGUgZm9yIGZ1bGwgZGV0YWlscylgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIERvY3h0ZW1wbGF0ZXI6ICR7ZG9jeEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBkb2N4RXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlbmRlciB0aGUgZG9jdW1lbnQgd2l0aCB0aGUgcHJvdmlkZWQgZGF0YVxuICAgICAgZG9jLnJlbmRlcihkYXRhKTtcbiAgICAgIGNvbnNvbGUubG9nKCdUZW1wbGF0ZSByZW5kZXJlZCB3aXRoIGRhdGEnKTtcbiAgICB9IGNhdGNoIChyZW5kZXJFcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW5kZXJpbmcgdGVtcGxhdGU6JywgcmVuZGVyRXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBNdWx0aSBlcnJvciAod2hpY2ggY29udGFpbnMgbXVsdGlwbGUgZXJyb3JzKVxuICAgICAgaWYgKHJlbmRlckVycm9yICYmIHJlbmRlckVycm9yLnByb3BlcnRpZXMgJiYgcmVuZGVyRXJyb3IucHJvcGVydGllcy5lcnJvcnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0RvY3h0ZW1wbGF0ZXIgcmVwb3J0ZWQgbXVsdGlwbGUgcmVuZGVyIGVycm9yczonKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExvZyBlYWNoIGluZGl2aWR1YWwgZXJyb3IgZm9yIGRlYnVnZ2luZ1xuICAgICAgICByZW5kZXJFcnJvci5wcm9wZXJ0aWVzLmVycm9ycy5mb3JFYWNoKChlcnJvcjogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFJlbmRlciBFcnJvciAke2luZGV4ICsgMX06YCwgZXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEV4cGxhbmF0aW9uOiAke2Vycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcy5pZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgSUQ6ICR7ZXJyb3IucHJvcGVydGllcy5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLnh0YWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFRhZyB3aXRoIGVycm9yOiAke2Vycm9yLnByb3BlcnRpZXMueHRhZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvZyB0aGUgZGF0YSBwYXRoIHRoYXQgY2F1c2VkIHRoZSBpc3N1ZSBpZiBrbm93blxuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMudGFnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUZW1wbGF0ZSB0YWc6ICR7ZXJyb3IucHJvcGVydGllcy50YWd9YCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSYXcgdGFnOiAke2Vycm9yLnByb3BlcnRpZXMucmF3fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBUaHJvdyBhIG1vcmUgZGV0YWlsZWQgZXJyb3JcbiAgICAgICAgY29uc3QgZmlyc3RFcnJvciA9IHJlbmRlckVycm9yLnByb3BlcnRpZXMuZXJyb3JzWzBdIHx8IHt9O1xuICAgICAgICBjb25zdCBleHBsYW5hdGlvbiA9IGZpcnN0RXJyb3IucHJvcGVydGllcz8uZXhwbGFuYXRpb24gfHwgJ1Vua25vd24gdGVtcGxhdGUgcmVuZGVyaW5nIGlzc3Vlcyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVtcGxhdGUgcmVuZGVyaW5nIGVycm9yczogJHtleHBsYW5hdGlvbn0gKFNlZSBjb25zb2xlIGZvciBmdWxsIGRldGFpbHMpYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGluZGl2aWR1YWwgRG9jeHRlbXBsYXRlciBlcnJvcnMgd2l0aCBwcm9wZXJ0aWVzXG4gICAgICBpZiAocmVuZGVyRXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAncHJvcGVydGllcycgaW4gcmVuZGVyRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSByZW5kZXJFcnJvci5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICBjb25zb2xlLmxvZygnRGV0YWlsZWQgcmVuZGVyIGVycm9yIHByb3BlcnRpZXM6JywgcHJvcHMpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIHJlbmRlciBlcnJvcjogJHtwcm9wcy5leHBsYW5hdGlvbiB8fCByZW5kZXJFcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZW5kZXIgdGVtcGxhdGU6ICR7cmVuZGVyRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHJlbmRlckVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEdlbmVyYXRlIHRoZSBvdXRwdXQgZG9jdW1lbnRcbiAgICBsZXQgb3V0cHV0O1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQgPSBkb2MuZ2V0WmlwKCkuZ2VuZXJhdGUoe1xuICAgICAgICB0eXBlOiAnYmxvYicsXG4gICAgICAgIGNvbXByZXNzaW9uOiAnREVGTEFURScsXG4gICAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZyhgT3V0cHV0IGRvY3VtZW50IGdlbmVyYXRlZCBzdWNjZXNzZnVsbHkgKCR7b3V0cHV0LnNpemV9IGJ5dGVzKWApO1xuICAgIH0gY2F0Y2ggKGdlbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIG91dHB1dCBkb2N1bWVudDonLCBnZW5FcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBvdXRwdXQ6ICR7Z2VuRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGdlbkVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHJ1bm5pbmcgaW4gYnJvd3Nlciwgc2F2ZSB0aGUgZmlsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2F2ZUFzKG91dHB1dCwgb3V0cHV0RmlsZW5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRmlsZSBzYXZlZCBhcyAke291dHB1dEZpbGVuYW1lfWApO1xuICAgICAgfSBjYXRjaCAoc2F2ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBmaWxlOicsIHNhdmVFcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNhdmUgZmlsZTogJHtzYXZlRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHNhdmVFcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdlbmVyYXRlRG9jeEZyb21UZW1wbGF0ZTonLCBlcnJvcik7XG4gICAgXG4gICAgLy8gSWYgaXQncyBhIFBpelppcCBlcnJvciAobGlrZWx5IGludmFsaWQgdGVtcGxhdGUpXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnemlwJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1BpelppcCBlcnJvciAtIGludmFsaWQgdGVtcGxhdGUgZmlsZSBzdHJ1Y3R1cmUnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGVtcGxhdGUgZmlsZSBpcyBub3QgYSB2YWxpZCBET0NYL1pJUCBmaWxlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJldGhyb3cgdGhlIGVycm9yXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGZhbGxiYWNrIEhUTUwgcmVwb3J0IHdoZW4gRE9DWCB0ZW1wbGF0ZSBmYWlsc1xuICogQHBhcmFtIHJlcG9ydERhdGEgLSBUaGUgcmVwb3J0IGRhdGEgdG8gZXhwb3J0XG4gKiBAcmV0dXJucyBBIGJsb2Igd2l0aCBIVE1MIGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVGYWxsYmFja0h0bWxSZXBvcnQocmVwb3J0RGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IEJsb2Ige1xuICBjb25zdCBzdHVkZW50TmFtZSA9IHJlcG9ydERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24/LmZpcnN0TmFtZSBcbiAgICA/IGAke3JlcG9ydERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5maXJzdE5hbWV9ICR7cmVwb3J0RGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmxhc3ROYW1lfWBcbiAgICA6ICdTdHVkZW50JztcbiAgXG4gIC8vIENyZWF0ZSBhIHNpbXBsZSBIVE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXBvcnRcbiAgbGV0IGh0bWwgPSBgXG4gICAgPCFET0NUWVBFIGh0bWw+XG4gICAgPGh0bWw+XG4gICAgPGhlYWQ+XG4gICAgICA8bWV0YSBjaGFyc2V0PVwidXRmLThcIj5cbiAgICAgIDx0aXRsZT5SZXBvcnQgZm9yICR7c3R1ZGVudE5hbWV9PC90aXRsZT5cbiAgICAgIDxzdHlsZT5cbiAgICAgICAgYm9keSB7IGZvbnQtZmFtaWx5OiBBcmlhbCwgc2Fucy1zZXJpZjsgbWFyZ2luOiA0MHB4OyBsaW5lLWhlaWdodDogMS42OyB9XG4gICAgICAgIGgxLCBoMiwgaDMgeyBjb2xvcjogIzQ0NDsgfVxuICAgICAgICAuc2VjdGlvbiB7IG1hcmdpbi1ib3R0b206IDMwcHg7IH1cbiAgICAgICAgLmRvbWFpbiB7IG1hcmdpbi1ib3R0b206IDIwcHg7IHBhZGRpbmc6IDE1cHg7IGJvcmRlcjogMXB4IHNvbGlkICNlZWU7IH1cbiAgICAgICAgLmRvbWFpbi1oZWFkZXIgeyBkaXNwbGF5OiBmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47IGFsaWduLWl0ZW1zOiBjZW50ZXI7IH1cbiAgICAgICAgLmNvbmNlcm4geyBjb2xvcjogI2Y1OWUwYjsgZm9udC1zaXplOiAxNHB4OyB9XG4gICAgICAgIC5uby1jb25jZXJuIHsgY29sb3I6ICMxMGI5ODE7IGZvbnQtc2l6ZTogMTRweDsgfVxuICAgICAgICB1bCB7IG1hcmdpbi10b3A6IDVweDsgfVxuICAgICAgICBAbWVkaWEgcHJpbnQge1xuICAgICAgICAgIGJvZHkgeyBtYXJnaW46IDAuNWluOyB9XG4gICAgICAgICAgLmRvbWFpbiB7IGJyZWFrLWluc2lkZTogYXZvaWQ7IH1cbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cbiAgICA8L2hlYWQ+XG4gICAgPGJvZHk+XG4gICAgICA8aDE+UmVwb3J0IGZvciAke3N0dWRlbnROYW1lfTwvaDE+XG4gICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvblwiPlxuICAgICAgICA8aDI+U3R1ZGVudCBJbmZvcm1hdGlvbjwvaDI+XG4gICAgICAgIDxwPjxzdHJvbmc+RE9COjwvc3Ryb25nPiAke3JlcG9ydERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24/LkRPQiB8fCAnTi9BJ308L3A+XG4gICAgICAgIDxwPjxzdHJvbmc+UmVwb3J0IERhdGU6PC9zdHJvbmc+ICR7cmVwb3J0RGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbj8ucmVwb3J0RGF0ZSB8fCAnTi9BJ308L3A+XG4gICAgICAgIDxwPjxzdHJvbmc+UmVhc29uIGZvciBSZWZlcnJhbDo8L3N0cm9uZz4gJHtyZXBvcnREYXRhLmhlYWRlcj8ucmVhc29uRm9yUmVmZXJyYWwgfHwgJ04vQSd9PC9wPlxuICAgICAgPC9kaXY+XG4gIGA7XG4gIFxuICAvLyBBZGQgZG9tYWlucyBzZWN0aW9uXG4gIGlmIChyZXBvcnREYXRhLmFzc2Vzc21lbnRSZXN1bHRzPy5kb21haW5zKSB7XG4gICAgaHRtbCArPSBgPGRpdiBjbGFzcz1cInNlY3Rpb25cIj48aDI+QXNzZXNzbWVudCBSZXN1bHRzPC9oMj5gO1xuICAgIFxuICAgIE9iamVjdC5lbnRyaWVzKHJlcG9ydERhdGEuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWlucykuZm9yRWFjaCgoW2RvbWFpbk5hbWUsIGRvbWFpbl06IFtzdHJpbmcsIGFueV0pID0+IHtcbiAgICAgIGlmIChkb21haW4udG9waWNTZW50ZW5jZSB8fCBkb21haW4uc3RyZW5ndGhzPy5sZW5ndGggfHwgZG9tYWluLm5lZWRzPy5sZW5ndGgpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImRvbWFpblwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRvbWFpbi1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgPGgzPiR7ZG9tYWluTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGRvbWFpbk5hbWUuc2xpY2UoMSl9IExhbmd1YWdlPC9oMz5cbiAgICAgICAgICAgICAgJHtkb21haW4uaXNDb25jZXJuICE9PSB1bmRlZmluZWQgPyBcbiAgICAgICAgICAgICAgICBgPHNwYW4gY2xhc3M9XCIke2RvbWFpbi5pc0NvbmNlcm4gPyAnY29uY2VybicgOiAnbm8tY29uY2Vybid9XCI+JHtkb21haW4uaXNDb25jZXJuID8gJ0FyZWEgb2YgQ29uY2VybicgOiAnTm8gQ29uY2Vybid9PC9zcGFuPmAgOiBcbiAgICAgICAgICAgICAgICAnJ31cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgJHtkb21haW4udG9waWNTZW50ZW5jZSA/IGA8cD4ke2RvbWFpbi50b3BpY1NlbnRlbmNlfTwvcD5gIDogJyd9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICR7ZG9tYWluLnN0cmVuZ3Rocz8ubGVuZ3RoID8gYFxuICAgICAgICAgICAgICA8aDQ+U3RyZW5ndGhzOjwvaDQ+XG4gICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAke2RvbWFpbi5zdHJlbmd0aHMubWFwKChpdGVtOiBzdHJpbmcpID0+IGA8bGk+JHtpdGVtfTwvbGk+YCkuam9pbignJyl9XG4gICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICBgIDogJyd9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICR7ZG9tYWluLm5lZWRzPy5sZW5ndGggPyBgXG4gICAgICAgICAgICAgIDxoND5OZWVkczo8L2g0PlxuICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgJHtkb21haW4ubmVlZHMubWFwKChpdGVtOiBzdHJpbmcpID0+IGA8bGk+JHtpdGVtfTwvbGk+YCkuam9pbignJyl9XG4gICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICBgIDogJyd9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICR7ZG9tYWluLmltcGFjdFN0YXRlbWVudCA/IGBcbiAgICAgICAgICAgICAgPGg0PkVkdWNhdGlvbmFsIEltcGFjdDo8L2g0PlxuICAgICAgICAgICAgICA8cD4ke2RvbWFpbi5pbXBhY3RTdGF0ZW1lbnR9PC9wPlxuICAgICAgICAgICAgYCA6ICcnfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGh0bWwgKz0gYDwvZGl2PmA7XG4gIH1cbiAgXG4gIC8vIEFkZCByZWNvbW1lbmRhdGlvbnNcbiAgaWYgKHJlcG9ydERhdGEuY29uY2x1c2lvbj8ucmVjb21tZW5kYXRpb25zKSB7XG4gICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvblwiPlxuICAgICAgICA8aDI+UmVjb21tZW5kYXRpb25zPC9oMj5cbiAgICAgICAgJHtyZXBvcnREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmFjY29tbW9kYXRpb25zPy5sZW5ndGggPyBgXG4gICAgICAgICAgPGgzPkFjY29tbW9kYXRpb25zOjwvaDM+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAgJHtyZXBvcnREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmFjY29tbW9kYXRpb25zLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgPGxpPiR7aXRlbX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIGAgOiAnJ31cbiAgICAgICAgXG4gICAgICAgICR7cmVwb3J0RGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzPy5sZW5ndGggPyBgXG4gICAgICAgICAgPGgzPkZhY2lsaXRhdGlvbiBTdHJhdGVnaWVzOjwvaDM+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAgJHtyZXBvcnREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmZhY2lsaXRhdGlvblN0cmF0ZWdpZXMubWFwKChpdGVtOiBzdHJpbmcpID0+IGA8bGk+JHtpdGVtfTwvbGk+YCkuam9pbignJyl9XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgYCA6ICcnfVxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuICBcbiAgaHRtbCArPSBgXG4gICAgICA8Zm9vdGVyPlxuICAgICAgICA8cD48ZW0+VGhpcyBpcyBhIGZhbGxiYWNrIEhUTUwgcmVwb3J0IGdlbmVyYXRlZCBiZWNhdXNlIHRoZSBET0NYIHRlbXBsYXRlIGNvdWxkIG5vdCBiZSBwcm9jZXNzZWQuIFxuICAgICAgICBZb3UgY2FuIHByaW50IHRoaXMgSFRNTCBmaWxlIHRvIGNyZWF0ZSBhIFBERi48L2VtPjwvcD5cbiAgICAgIDwvZm9vdGVyPlxuICAgIDwvYm9keT5cbiAgICA8L2h0bWw+XG4gIGA7XG4gIFxuICByZXR1cm4gbmV3IEJsb2IoW2h0bWxdLCB7IHR5cGU6ICd0ZXh0L2h0bWwnIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNpbXBsZSBlbXB0eSBET0NYIHRlbXBsYXRlIHByb2dyYW1tYXRpY2FsbHlcbiAqIFRoaXMgaXMgYSBsYXN0LXJlc29ydCBmYWxsYmFjayB3aGVuIGFsbCB0ZW1wbGF0ZSBmaWxlcyBmYWlsIHRvIGxvYWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlUZW1wbGF0ZSgpOiBBcnJheUJ1ZmZlciB7XG4gIC8vIERlZmluZSBhIG1pbmltYWwgdmFsaWQgRE9DWCBmaWxlIHN0cnVjdHVyZSBhcyBhIGJhc2U2NCBzdHJpbmdcbiAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgZW1wdHkgRE9DWCBmaWxlIHdpdGggbWluaW1hbCBjb250ZW50XG4gIGNvbnN0IG1pbmltYWxEb2N4QmFzZTY0ID0gJ1VFc0RCQlFBQmdBSUFBQUFJUUE5OEVFdVRnRUFBT0lDQUFBTEFBQUFYM0psYkhNdkxuSmxiSE9ra3NGcXd6QU1RTytEL1lmUnZWRmFHSU5odXpCRzd6YjJBNHhzVEl2YjJaVGFUdnIzT1pDd3JTNVpHTHJhU1h6NkFVbmtldjd6OXVObGtDYXh6RGg2MU1BZ2Vjc0UyOU1VM01GangrbHErU3R5U3FYdXkyVmMySlViTUp4TEZCYWxTWE1RcEpMaHdQU040MVNTZGkweHBzOHZyUjFvUHJTYkx1QWd3bHhBcWprVFltM1A5Ky8vbWZmVlFoQjByZzU1c2FVY3kvTVlxcUJMVi96MWcrU2Y2aThxWGxycGVZTVBzSVhwWDB4R2JtN0FmQ0J4ejlIWGRDS1hFempONVg4T2gzUDZlQmFNWi9ZSnJBc3d2TmF5MVBMRnhvZDVJUVRtYURRU012WlVpZFZyQnY5WEtqVFNlbFRKUnlZem95Y0JLQkhKeEJhZTlKVGNzS01xWE5Zdisxb1d6eGZpc3dRWG9NTFhjUGg3WGZrR1VFc0RCQlFBQmdBSUFBQUFJUUFCbnQ4ZlJ3RUFBT1lFQUFBY0FBQUFkMjl5WkM5ZmNtVnNjeTlrYjJOMWJXVnVkQzU0Yld3dWNtVnNjN1NVMzByRE1CREc3NFBkSWVTKzZjcWkxSFJkaUFwN0piZ0gyS1FuVzJ5VGtLVHEzcHNrWFN0VE84cC9OdzM1UHQ3M0pXUjFjOVBIWWdzNWU0d05MVXRWUUhSSVB2WU5mSDQ4ckc1QVpCYXhKWThSQWw4ZzFtUmVQcit0bnRBUzVXTE9zL1ZCRkVEc1lBUFcydDFTNVlXRm5ySlM3OUFWMEduc0tWT2RtMHpqbDJ6STlsU3ZkTDFXT3hablBJQVpCTlZPR3NoVjdHcVF1ZGg4QUsvYzJhWFFHcnFEdVBJWWozZVFNQnlpTmZmRUQ1U1o4eTY3dXBqazhSbCtjdUs3dWNSRENSa2pwc0w0Sk1WeHh1YzVodVBCRm1FLzdHMGhmT0pMUU9TaUdHcVVJSm5ubEM1cDY0RXl5WWZVcUpuM2tUaHpoVnpZRGtNSkFrTk93LzBzZmdGUVN3TUVGQUFHQUFnQUFBQWhBTlprczFIMEFBQUFNUU1BQUJFQUFBQmtiMk5RY205d2N5OWpiM0psTG5odGJIUE1razFQd3pBTWh1OUkvSWNvbHdsaUkyaWxLdFp0d2dscGlNT1EwRGd0V3B1c1NSMVYvZmZZVkRRSndZbkwrUFh6T25aMnVtdVZ1SU1QeHJrQ3BVbUdFRGhsY2FYckFuMjhiOFlyaElOMnFqVGFPU2pRQXdKYWxmZXpuYzlONjdiMEp0NmNCMElpTGhTb055WTBHY2VRZTFBMkpFNkQ1SmNtS0J2bEdPcmU0MENaUGJNM3BYaVZaUXU4c1VDVkRXT0liVUVMWERJbHYwQnZmOXpXMkdacUJ1V0kySHNpL0p2ZGJ4bkZ4dldHaVYrYVpxUklrajI5bUpWRTNWWFE0MzBKUFlrUkozTE1xYzdZNEtYTHFLZEprb3o1cUIrY1dwa21vYUpZMzNENEZ0VVhCZ0dTTXIya0dZKzJhSHhkTXBYSEZHVlpRZkNuOXYrTVp6UENYVHRVMTI3dkxhMWRWWE1vSjluRXY1dzJxejhwS3ZuSko0bCtkNTZqOGorVW5VdWRYbDNXMi9KMWd5N0hJWXJIeFdRNUNWVWYvRlcrQUViUjRVZFFjdUovVFQ0QlVFc0RCQlFBQmdBSUFBQUFJUURUNU9QaDhnb0FBTEdUQUFBVEFBQUFXME52Ym5SbGJuUmZWSGx3WlhOZExuaHRiTFdhWFcvYk9CYUc3d2ZzZjFEb2VtOWwyYzZIZ3pZejJNYkpkSU5tSmhzN2MwZUp0RVZFSmpXa25IaCsvVklpWlZ1SlFoTjFmTkVDQmkwK1BQd2s4dkNoZlBPdnUyeWFYVVZiMTFXNUNPYkxSWkRGc3FycVNibDdFZnk2ZjdQNUljanFuU2dya2xhWDhTSzRqM1h3citlLy92TG05bW5keGt3c0wrdEYwTy83MjlOaVVaZGR2SzNMWmJXUHBjbmt0V3hGYlg3SzNhSVc5VjNjYlJkYjI4V3lXSncyaTBsWm5nWHY0MWk4dUswcms4SzIyM0pjdm9uVk5OYXpqVmN4TGsxa0s5ZHhYcDBYNStJKzdZcDZJdCsrWG1kWmI1OS92Q2gzWDVQYnU4dXBpTXRuSmgwVHptWlQvR2JqZjF4NHUzdkFtMVQ3YWJJNktxOHYrOER1WExZS2MzWlozOWZwdUc0a3BnVlB4dElrdW96bHFNcm5sNlA3TDdjNVoxY1gwdy8yWDZNenMrT1RNbnVWYkxWMkphcmJuVjUvWEp3dHk4VmwxZVhKanJiYnRyRzJ2OTVrUlN0dWcyeXptWmwvOTJXVnR0T2lLSGVpTjVsV2wycDYvYkxiMnlUdmR1VWlLUE5GOE9LcXJzczQ3ZWVIYjlxTHFwVzlFSzFwSUVhNkRkTlNVY25aWXU5bGJKN1pqWFcxamMvYTdxWVJkU1ViMGQvRVBvdTdKT1Z3Wk5xT29VTlhxMm8vcFNGN0lmWERmdEhFY21mcUYyVnNidmwrczkxT2RxMDNoYzZ5RzNOMU85RkhVN2t3TFVQT1V1dXVGZDFWdiswelB4NWQ3Ky9Yay9rT2dkWkpmcjFQeXZHNkRxZW81WEx4anpsRENZUDZ4SitRREk2Qm96dGZMbk9POFBnb2pnd085UzQzZjl0WGg3L2VZcmcyTGZXcHpKZGpIVEo2SkNlT0t5TnByUyt6bC9QTng1RzRNdmQ0WE1rSnowdHhCVnUvc0hwbkc5SXUvaVdOY3JVY3JiM1JkTzU0YjJZZnJJNkxoL3p3NCs2SEdWL0diVXdmZkRCdUR2bEJYUnl2cmxmRm9lTXQ3ZTQvektOeVh3OFB1OUljVWJYTDF5ekZ3OXdZKzkzalZ2VFZaTndSRnhsbUgrYTBjM09LUlBxb1V3elhqNTFpWDdaWHNSOG5TZlJSNEc5bk56T083WWZrMXc4RGRyMk9aWm5zY3FVcVp2UEZ2V2dUYjVPVHhzOXFHRytOeDJzWjI4L1JqOFoxVzg3U2l1NW4vVkUvZldSUTlQcDJITFNqTCtOazBtd24yem5Hd1FEWHBxWndURHZNeGpQamJ6TXB5aGszL21GditySk0vRG5IbWZiU1JXOWRITGR0ZndqMFE0N3g5RVVmZVBWR3BQaThWWGNwT3B5UHFMWVhWeDlxY1VhaWpjRS9LVkVIc0o1Y2pGUENmbko1Y1RjZHgyT1NEWFBLUXpYMkZiVjVSKythV01WSmRYVEFKZm5pbURhZEJnODBLdFFuZkp6cFpuS1kzSDFPMFNlaWVQWmlTNkV2UjJuTTVtUFhjK1V4TGFkQm5DbFNycHdRUzJBN2d2bDRaNmJScUh6SlhRcE1Ra3JDckpnUTU4cTVmL3Q2ZDVzTERzdlUxeVJPUWtyQ0xKd1E1OHJwdlczdjdYeG1qWmNudlp0d0g5a0drSkl3cXpJaHpwWGJ0dnUreW5aM2FYWFFDUHNxNFpjdjN4dlFCakNUeFBWMVFod0MrTHphei9KbVYvNEhzN0tIRnp4TGFJTWtxVmQvSmJRaGhJZXJVMi96eS90KzI1bDNrWWV1b3FjWG5PM1FCcENTT0xWS2FFTUlEMWVuSGhicTYvN3F2TXFtOTRkVFdGY3ZkTGFHTm9Ba2NlcFZRaHNDK0x4NitJN3BJdW5HN3pjUDRWMjkwTmtaMmdCU0VxZFdDVzBJNGVIcTFEdHJUT3ZiOFgzTk5RTDNySU1US0VuTitpS2hEU0Y4WEoxNmI2M0ozTTBXMUk2ZDNua2QyaUJKelkwQ1Foc0MrTHg2WWdVelJJS3oxUmRXTUdpREpIRnFsVUpJekt1VEFZZVhrYzkrRk83b2hhZVFhQU5JU1p4OHBsQ0RJTytmUXc2alBHM0ZrTjcrUXp4SWtwcjFSUW8xQ1BKKzljUVNwZzhEWnlzc3BNc3c3T1JGckJSSWt0UXNMeEtvUVFRZlY2Y2VGakUyQzV5dHRNaHVSNmtVN3VaRkxHSklrdFFzTHhLb1FRUWZWNmQrOEs2SnZiWHR4TGtKUEd4UTAzY1V6N1pvQTBoSm5IeWxVSU5BSHErZVdNYllkTzdrWm5ZN090K2hEU0FsY2ZLVlFnMENlYng2WWgxajg4RFo2Z3M3R3JRQnBDUk92bEtvUVNDUFYrOGUzdjdhTXEwN3VibmREMzZGUUxKMVdydFNxRUVnajFjZjNVQjNjVGRmOG5DZFlQWml3OXNOa2lSMSs1ZDZpVm5sMWNOdzlhQTMxL01rWFRJSlA5STd6MUhRQnRpWnBHNzlOdVlFZ2FRZVZrNU40LzF0eFgwMlBiYlR6MU1OTEEzdk9VaVdSR3JYdUJQRWt2cXhHeEJIUFVpS3BuN1VRa0ZJWmxLN3hwMGdsdFJQTEVxR2dYQzJ1c1RTV2lDcFdlTU9rRXZxaVdYSk1CRmNydTYraHhSWUd0NkNBS1JtalR0QUxxa25saVhEUkhDNnVzVDZXaUNwV2VNT2tFdnFpV1hKTUJGY3JyNTZXRjdrRXNIMTJ3dHFwWUN5cEU2dDhYZEJBSjlYVDN3NDZhUXUvelorUC83eE5OWUpQcjFBM3dWWWx0U3A3ZXdGQVh4ZVBmRjVhZVpkblAzbTlKdnVwTjZmVHlQdkhyMDdSajlCRFJLN05jK1NCd2ptMWo3eHZXbFdwR2MzMkcxblR0SCtiblh3N3VIZE1Yb3hBaEs3TmMrU0J3am0xajd4em1ub3RVZkZKQ3Z2MDJsSnplZHAzdlRtYUhaUmo5L3NvRURpMUtsNWxqeEFNTFAyNFhQVC9iWWFqdG1GbUE2ZCtURFJNRGg4YTR3Q2liMTYwOG8wMWhIOHZMcExxb2FHL0RZYmVoTDRkTVBKMjBNVVNCdzZ0WjA5SW9BNzcvQjEvM0F4VE9DUHR3MW5ydzlSSUhIbzFMemVJc0o0YzA5L0xmbTh1L2sxR3g3SnAzbkQyZnQzRkVnY09qV3Z0NGd3M3R6OWNKSzFZNFA0ZmtUMVhHbHVFRkFnc1ZmdldwbkdPb0tmVjg4K25KakF3M1QyOUwwaUNpUU9uWnJYVzBRWWIrNTRPSyt2Zmp4ZkYrdnAvbFAyNEJjOGNqaDdINGNDaVVPbjV2VVdFY2FiZStLYjlkWFJqY1hWemZqSEtSNm1jbWZ2NDFBZ2NlalV2TjRpd25oekx4NXVLSHJSWCt5R2g0czZtNWJEci9EazUzbTg3Y2VKUE5TR25yeG5TWUhFb1ZPN0VVV0VjZVlldWR4UDlPWGh3Y2RLN090SmRac05aZUw3VGNHUm45M2c3RVZHQ2lyMmFwM2F4a2VFOGVZZTV6M2gyZFdoMWsvSzdEOFNsZmdmK2RuTjRld2xTZ29xOW1xZDJzWkhoUEhtZm5TdC84amZYMTVmWEcvZDN6NThYWXM2LzN5eUFjMXo4dVB5Tmo1ZllPRlRVQnZNbi84SFVFc0RCQlFBQmdBSUFBQUFJUUJtaGI2dHl3TUFBRG9OQUFBUEFBQUFkMjl5WkM5emRIbHNaWE11ZUcxc3BKYmJidHN3RElidkIrdzlDTjFuU3ByR2FZTFdXWkFtNjJYUXJvdmFkamN3TnRzUnBrT0dwQ1ROMisvSXljbXhDMVR0UmFKSS92dytFcDR2UC9aUzhLMnhsbXMxSS9HUUVjNlUwSFdyZGplTS9IeFlCQlBDcmFOVlM0Vldaa1lPeHBJUHM2OWY1dTFCV3UyTjRSWWpESzFtdExGdWQ1VWtWalJHVWp2VU82UGdTNk9OcEE1RXMwdGFqZGE2QzFLcGt6RWpWOG5YYjFrTjRhdlhHaXo1dmxVTDFkR05Oa0pZSGRyeVZCbUlicmt3SE96WnBESENSeE1KblpnUVh4TWwrYk81bjNIZXdUNWVwTHVmWXJ2ZlRSU05uMEU5SVBqcDJ2eE8vZStycDd0M21MTjB4ODU0Y0hWVjdtdzZOdHBIMTViRldvbVZOcDc0d1lpTDFKRjd3eS9GM3RZNjh5VFhvdk1WYm0rMVVVK0JhR3g3aDY1TmF4OGJaMFUvRjZXZ3pwb3lZaVJJUXJJZ1RraGFKSEhCVjV2bW5DcU9Ga0dTek5Nc0w5SmltWWNKTDE2SzhESkpZSTBzRFlKNHZnN0RWVEtQaTBXeEtOSTBYaVRKWXJYS2lqU09sMm1ScGtYeERwekxsZlpySlE2cWhkZ1hlbk13VDRoODhlVThuUnJJSGlKLzNIRTJkWEFJL0xIVHE2bUR3K2lQL1RaMU1JajlNWjN1allTcDNPNkJ1cHZSR0xxOUlJcXNMS1FQTHRCRnFmMXJaL0hEWFA4ek56eGIweGExSjArU2tac21OaFZOVFkwazErUk13MC9PejYyQytBUXZQZGpIRWcwWlA3MWxTUXFuRHdaOWg3QVplVmd2a2h6TDBhSHpERG02cjhnN0pLbXBjWmVhd1ZwUEs3d0EvS0l6VERWZHY0cEtuVjJ6RnBDVnFWdmIzN08wVzBNbmhHYUUxOXlTRFZLNFJiNVhqN3oyMmNKWHV1TVYxcmptVy9FNGtjMFp0Y05wTDBnVHdmMnowTUZFWTVyM3JMZERscDJad1k2S1RCWVc3SnBqd1hYSG9WREJ0bW1nUXdBNkZnTGNaUGQwQzlPUHZkTVcvbnRjYXlGY0krR1hlNE9qNUFIakd6ZjIrNjdGWHJ1RFhubmdMN1V3OWVhT21uWlFiMDhremp0N1FTWnZvUTl2Sm8vTWRNMnhVR3FKZEVWYTlUUWR2UVVZcEJoaUpnem4wQmRHUDNFTy85Vk8ySDExakN4SEU2a05UTmY3RFprTGpZMjdNWFpUdHp0bDhSUFo5ZUlCalRIVU9IUGRndGtkdzlSWVJSYlAwSmZJWFdkT1E0eFJQZUI5ck9IcW1xSnc5dUM3Z05uMEIwRStCMkdnMHczZGFqZFVNcndDNS9Kd2hnTmxjQXcvR3ZWc083Z3B3alROOG1NdmhLWGNxMGM0UUxCTVIvTTRDVlkvQjlNMEtaWko4WFl3M0ovKy9sWHkyZDRROFFMdjk3QTFZSy9CbGRSS3FUek00anpPOHVKK3Aya09EeEN4NVJzb3BXL0cwQStIKzRNV2VQdENiT0N1S1IrMWdRdmtiRlI2YjZFSlFETERMWkVQVHYwQlVFc0RCQlFBQmdBSUFBQUFJUUE2cUJDRXVRWUFBRFFiQUFBUkFBQUFkMjl5WkM5a2IyTjFiV1Z1ZEM1NGJXeTBXTnR1MnpnUWZTL1FmeUQwM2pweGJraWRpRWxiWkxQWm9saHZQMENXbUZpSUxJS1U0K1R2TzBOS2RwM3VOc2crMUpCRmNjaWRtVE5uT09ycmwvdjd4UElVVmNXazJKaURmdGR5Q1dTb0lpYmlqWG56NDJKblkxbFZEb25vWFVwY0cvTmN5dXJsemRkZi96MklxMWhWSEVXRnJIQ1JHL08rcXRMTlZxdGtmakd3dXJTbDUxWjgrcmsvSG5UdDU4bnQ5cnZEbTBKL3dMVGFkciszL2wrMENZK3V5QzJPM21VQnhZazg1Z2tWaFQ0a0RGbUtZb1lEdlpwRmVjWjFNblBDazlGM3pnSzNEMkZ6YVJVWGYvWTlOOU0vdnRYNXc5Y2pkalE4c1plb0NwblhEMGxINmc4VGxYTDlXWHBaWUkrRDRZYUtVYTl2amJxZTlTNXZFemg4emIvSkpFa2wxR2NYK2gyemZNZnJtQlduVzFZZGFhVERGanQxVjYyTGtYSlZaTEpNV2FEWER2czl5Mk5qZmJWdSthRlhYNjhkekJGMUdhU2RtTVowc090NXA5MVVzanltZ2NRSjU2Ymo5YzVjT2drVUZSRXZWQjNTd2EzWUpSekhiTmN2Q1VleEErM2EvK1BFQ1JHbFRFSXVHZFBMMmNoaE8rL01YZ0tkdmpPYnVlVG44cHUvNWZLdzIrbnU3dTV1RzZ2UHU4N09nMmxucHovbzdYNS9QOXZSb1I1RHhlNFBDREcrcjhXOVVaR2RIeWFYNlJIYnZ6bzV2NXJkbnAzTnJxYmptekZjWFkybjUyZm5sNU9ybzhuc2Z6RllRQ256RzNsOXhTS3hxWG9oaEl6bno4S242NnEyWnpmRVpScjJtV2FaMG4rN09CTEJiTXh1dW5MVXhsM0MxYncrWXZMUHhnazNMSE91TlB1MHdEbGZGU1VKVlp4cHBycWpxeEpwSXVRVEwySlphUEp1b0xZeEI3MUJwNzh4Zy81UWo1T1VaWERrSE41Y25yeE9LUzRTMmJTOFk1RktCTG1QVDMrbzhwRGtoNUw1eGV6TUhjZlIzUi96MmZtVisvdjBlbmUwVTRlQ1BtOHl2VHQ1Y25WeEQ5TjB0VmlwbndwTlNyWXp0elFkUlF4VmN3K0prRldZUE9YS0NkSWk0Vlc0MHZIa1ZrYWhPNnBDcW1MSkMxcld6cDUzcEFVUXJrUVlPMndWYTk0SmJGWGVxL2s0WDlEMFlYWWEzWG1uZ2YzRnc1ZldIWDA3L3ZaK2RIUjVZTzgvaDBUdlJ1OUhsOEg0bnorKys0ZjJEK2QvUHdhblBPWkZ4ZklxZDVKMEpYbnVVTkVYVldWK1lwR3pLajMzZ0R1T3FRaXBkdk04ZTBOcGU0Yk1NM2ZQUmNnL3hiS285aTBvTFBNSmw3bGFQd3FacWdBaGxxamxOeFZWMlZKL0tSbW1CS3RtK3lxbUxBcUt0Ym5SV3k3VGxjZlNIM1JtRGlXZ0lMUUlxVHFNNnluVG41bUxNUmd6Rno5a1JGR0ljMWc5b016QnA4eUIwTG1GaTZKNHA5NHpTL3ZOYytYV3MrUUpKVW1HZDV4VWpqMVFjSkRxWUkyVkJpcFNYQnd2VWhicWxLbUxweUwxc0YwNVdaUVVKMDBWZ0VpcGloaFVKS0FaRFFtaXRObURsT2wweG1JWGJmcFNKcnBkUTB1TG5ZWmExWWswVTZVaXMxV3RzYXJUR2U2MnlyQ21KVnZXT2l1YU1YTTFaOXJBRncrSXF0RHFlTDNWejY2WTlTeVo4L3VXQjErdDlxVllEUldsSE1walF0Vm9YZEVFVTg1S2J6UzBHNWRMS3RQV2lHZ2ZRYnhzSC9FVk9qUWh6YlF0V1BRYUpMbjQwRFRQWEtkQkpVZlB3TnE1R2tiNjQ0ZlVaVVNUN21WdkV6bVRKSkZLcmJYTXkveUJQRHBYVUxMS1NnVXhMcEpGbkVkTUJLWHUwTG9sOVJDbitRSmxJQ0ZzWVo1Vk1aUlZ5WFh1RzlDUXNudUNhUVVnK3FLZHlRblJ4YXF2K3FmTFlGQkdhQXpXeU1zSlExTjBxNm9yTGQ3V0toTGF3amJDZmJYTG9sTTlSbnVLclR5bHNLTk0xMnE5UmRTN0dVVHhWbnFwVlpGclZjT2xEMGwyalVxQ1kwZkVZaTVoN1A2S2cyWjF3K1NtMXFGSnpQRlRtRlE0a1JNTzdVYjF4YlpxMUJmYmFOSVhlOEFYTzJ3S2NtTjJxeldWNVZHckpWek1aUkVMYmZITjExRmZ5WStQakMvWXh1NnBLR1hkWFc5bEpUcjBuVzlkMER6Sk9xWUpiWjFMbnJMR3BaRXIzaFhodkcydk5BaTlaTkZ4QTFyUVV6VWM2SFp0TFJxZ05Qd0QxejMxMFpuT3lGRXRHUVUwZ0VXbUdqeUV1TWRWTjBnS3NzVE52aGtWak9MQ3NrRDNJMzlWRVhmYlk0cE4xM2xRTFV1SlRYZ1RqTjRwUi9PL2wxTThiVk9vUnhyekE4c0M1ZDZuUEdERUhFQkI5eU5XRkdNdEUxUzZGNTZweFZtS0M3L0R1cVN2OUdsU1lUTkpsVGIxc0lxZkVZejRSdUhJVHc1RjRDbS9PQlA1SEZIZ0NxRmJBY1hHVFhmUTdhK3FPYVRkaC9SNkd0SzEwQ0tzeUwxdmJjSG44akRRZUV5QWFIdjMvdHdGRGYvRkk0WWxEeWh3alFXcGZWaGozZEt3T2I3RkUrSlkzS0E5MVZwN08vUUdNbkpSYlBKTDFEWnM2aTNzT1hXbkZrNHE4SkNwTmUzTTJYRk10RGttM2U5UW5yeTY0cFJHRHhUbU1vcTV0TlFoUExBWXpETE45TFRHYnFUdktCeE1OQWsvSXpTUTVPWWZVRXNEQkJRQUJnQUlBQUFBSVFCUFFJRm5wZ0lBQUxJR0FBQWNBQUFBZDI5eVpDOWZjbVZzY3k5elpYUjBhVzVuY3k1NGJXd3VjbVZzY3kyVTIyN2JNQkJGWHdmMEh3UzlPN3JsSXNhZ0tCTFl5THBCbTZBZlFFaVVKSnVYZ3FUc3VQOWVsSFNUdHhuT0huSm1aOGhuTDc5bDYzMVBiVXd4VjZaUW1sbXBJOFpOcmt3dWVYcis5L2piS2wzK3ZiSGkzSEtoVFRIbmF2c0xFc250Ymh6YUlRa0JGOU9GVVZYWk5FSVlYeXV2NDJLc3ZlcGp6d3g2YjZIcnNLbldwbXBBN0hSWnlLZEtyYVdVbkpwUXBCYTBNT1dVWTdWVkZmMXRKRGVSemJFMDZKWGtUQlcxVWxMR1BYVnBOUXhETWZBdTlodndkM0hETUIrajRTSG80b01zRDkvUVQwQldMQzVXN1lEUVdxbkVoUWZqV21tMlZncE5lM0RCYTJWY3FSaUdVVkNNSDR5dnNOUW1oT0R3cmZCa1hDRjdNQlZrTUNWeUJ4ZE14c1I0QW5jQUg0eUxKZVJSWUR4NFlheUtNcnFGY1IrVit1RzBwSXJUSTdYTDV2UG9HVWZQOW9QVG42ZTkrUEtQemY0QVVFc0JBaTBBRkFBR0FBZ0FBQUFoQUQzd1FTNU9BUUFBemlZQUFBc0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFGOXlaV3h6THk1eVpXeHpVRXNCQWkwQUZBQUdBQWdBQUFBaEFBR2UzeDlIQVFBQXpRUUFBQndBQUFBQUFBQUFBQUFBQUFBQWtRUUFBSGR2Y21RdlgzSmxiSE12Wkc5amRXMWxiblF1ZUcxc0xuSmxiSE5RU3dFQ0xRQVVBQVlBQ0FBQUFDRUExbVN6VWZRQUFBQXhBd0FBRVFBQUFBQUFBQUFBQUFBQUFBQUNCZ0FBWkc5alVISnZjSE12WTI5eVpTNTRiV3hRU3dFQ0xRQVVBQVlBQ0FBQUFDRUEwK1RqNGZJS0FBQ3hrd0FBRXdBQUFBQUFBQUFBQUFBQUFBQXNCUUFBVzBOdmJuUmxiblJmVkhsd1pYTmRMbmh0YkZCTEFRSXRBQlFBQmdBSUFBQUFJUUJtaGI2dHl3TUFBRG9OQUFBUEFBQUFBQUFBQUFBQUFBQUFBRjhUQUFCM2IzSmtMM04wZVd4bGN5NTRiV3hRU3dFQ0xRQVVBQVlBQ0FBQUFDRUFPcWdRaExrR0FBQXZIZ0FBRVFBQUFBQUFBQUFBQUFBQUFBQlRGd0FBZDI5eVpDOWtiMk4xYldWdWRDNTRiV3hRU3dFQ0xRQVVBQVlBQ0FBQUFDRUFUMENCWjZZQ0FBQzNCZ0FBSEFBQUFBQUFBQUFBQUFBQUFBQlNIZ0FBZDI5eVpDOWZjbVZzY3k5elpYUjBhVzVuY3k1NGJXd3VjbVZzYzFCTEJRWUFBQUFBQndBSEFQMEJBQUJXSWdBQUFBQUEnO1xuICBcbiAgLy8gQ29udmVydCBiYXNlNjQgdG8gQXJyYXlCdWZmZXJcbiAgY29uc3QgYmluYXJ5U3RyaW5nID0gd2luZG93LmF0b2IobWluaW1hbERvY3hCYXNlNjQpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgXG4gIHJldHVybiBieXRlcy5idWZmZXI7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSByZXBvcnQgZG9jeCBmcm9tIHRoZSByZXBvcnQgZGF0YVxuICogQHBhcmFtIHJlcG9ydERhdGEgLSBUaGUgcmVwb3J0IGRhdGEgZnJvbSB0aGUgYXBwbGljYXRpb25cbiAqIEBwYXJhbSB0ZW1wbGF0ZUJ1ZmZlciAtIFRoZSBiaW5hcnkgdGVtcGxhdGUgZmlsZSBhcyBhbiBBcnJheUJ1ZmZlciAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgZ2VuZXJhdGVkIGZpbGUgYXMgYSBCbG9iXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVJlcG9ydERvY3goXG4gIHJlcG9ydERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIHRlbXBsYXRlQnVmZmVyPzogQXJyYXlCdWZmZXJcbik6IFByb21pc2U8QmxvYj4ge1xuICAvLyBHZW5lcmF0ZSB0aGUgZmlsZW5hbWUgYmFzZWQgb24gcmVwb3J0IGRhdGFcbiAgY29uc3Qgc3R1ZGVudE5hbWUgPSByZXBvcnREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5maXJzdE5hbWUgXG4gICAgPyBgJHtyZXBvcnREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZmlyc3ROYW1lfV8ke3JlcG9ydERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5sYXN0TmFtZX1gXG4gICAgOiAnc3R1ZGVudCc7XG4gIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xuICBjb25zdCBmaWxlbmFtZSA9IGAke3N0dWRlbnROYW1lLnJlcGxhY2UoL1xccysvZywgJ18nKX1fcmVwb3J0XyR7dGltZXN0YW1wfS5kb2N4YDtcbiAgXG4gIHRyeSB7XG4gICAgLy8gSWYgbm8gdGVtcGxhdGUgYnVmZmVyIGlzIHByb3ZpZGVkLCB1c2UgYSBkZWZhdWx0IHRlbXBsYXRlXG4gICAgaWYgKCF0ZW1wbGF0ZUJ1ZmZlcikge1xuICAgICAgLy8gVXNlIGZldGNoIHRvIGdldCB0aGUgdGVtcGxhdGUgaWYgd2UncmUgaW4gdGhlIGJyb3dzZXJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdObyB0ZW1wbGF0ZSBidWZmZXIgcHJvdmlkZWQsIGZldGNoaW5nIGRlZmF1bHQgdGVtcGxhdGUnKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gdXNlIHJlc3BvbnNlLmFycmF5QnVmZmVyKCkgd2hpY2ggZW5zdXJlcyBiaW5hcnkgZGF0YSBoYW5kbGluZ1xuICAgICAgICAgIC8vIFVzZSBsYXMtYXNzZXNzbWVudC1yZXBvcnQtdGVtcGxhdGUuZG9jeCBpbnN0ZWFkIG9mIHJlcG9ydC10ZW1wbGF0ZS5kb2N4ICh3aGljaCBpcyBhIHRleHQgZmlsZSwgbm90IGEgRE9DWClcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvdGVtcGxhdGVzL2xhcy1hc3Nlc3NtZW50LXJlcG9ydC10ZW1wbGF0ZS5kb2N4Jywge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGNhY2hlOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50JyxcbiAgICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggZGVmYXVsdCB0ZW1wbGF0ZTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCdEZWZhdWx0IHRlbXBsYXRlIGZldGNoZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgdGVtcGxhdGVCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBEZWZhdWx0IHRlbXBsYXRlIGJ1ZmZlciBzaXplOiAke3RlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmYXVsdCB0ZW1wbGF0ZSBmaWxlIGlzIGVtcHR5Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFZlcmlmeSB0aGUgdGVtcGxhdGUgaGFzIGEgcHJvcGVyIERPQ1ggc2lnbmF0dXJlXG4gICAgICAgICAgY29uc3QgZmlyc3RCeXRlcyA9IG5ldyBVaW50OEFycmF5KHRlbXBsYXRlQnVmZmVyLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICBpZiAoIShmaXJzdEJ5dGVzWzBdID09PSAweDUwICYmIGZpcnN0Qnl0ZXNbMV0gPT09IDB4NEIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIERPQ1ggZmlsZSBzaWduYXR1cmUgaW4gZGVmYXVsdCB0ZW1wbGF0ZS4gRmlyc3QgYnl0ZXM6JywgQXJyYXkuZnJvbShmaXJzdEJ5dGVzKSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgdGVtcGxhdGUgaXMgbm90IGEgdmFsaWQgRE9DWCBmaWxlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgZGVmYXVsdCB0ZW1wbGF0ZTonLCBlcnJvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IGFsdGVybmF0aXZlIHRlbXBsYXRlIGFzIGEgbGFzdCByZXNvcnRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gbG9hZCBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZTogbGFzLWFzc2Vzc21lbnQtcmVwb3J0LXRlbXBsYXRlLWZpeGVkLmRvY3gnKTtcbiAgICAgICAgICAgIGNvbnN0IGFsdFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy90ZW1wbGF0ZXMvbGFzLWFzc2Vzc21lbnQtcmVwb3J0LXRlbXBsYXRlLWZpeGVkLmRvY3gnLCB7XG4gICAgICAgICAgICAgIGNhY2hlOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gICAgICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWFsdFJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGFsdGVybmF0aXZlIHRlbXBsYXRlOiAke2FsdFJlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGVtcGxhdGVCdWZmZXIgPSBhd2FpdCBhbHRSZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEFsdGVybmF0aXZlIHRlbXBsYXRlIGJ1ZmZlciBzaXplOiAke3RlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgYWx0ZXJuYXRpdmUgdGVtcGxhdGVcbiAgICAgICAgICAgIGNvbnN0IGFsdEZpcnN0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlci5zbGljZSgwLCA0KSk7XG4gICAgICAgICAgICBpZiAoIShhbHRGaXJzdEJ5dGVzWzBdID09PSAweDUwICYmIGFsdEZpcnN0Qnl0ZXNbMV0gPT09IDB4NEIpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgRE9DWCBmaWxlIHNpZ25hdHVyZSBpbiBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZScpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsdGVybmF0aXZlIHRlbXBsYXRlIGlzIG5vdCBhIHZhbGlkIERPQ1ggZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgfSBjYXRjaCAoYWx0RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgYWx0ZXJuYXRpdmUgdGVtcGxhdGU6JywgYWx0RXJyb3IpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBcyBhIGxhc3QgcmVzb3J0LCBjcmVhdGUgYSBtaW5pbWFsIHZhbGlkIERPQ1ggdGVtcGxhdGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBtaW5pbWFsIGVtcHR5IERPQ1ggdGVtcGxhdGUnKTtcbiAgICAgICAgICAgIHRlbXBsYXRlQnVmZmVyID0gY3JlYXRlRW1wdHlUZW1wbGF0ZSgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYENyZWF0ZWQgbWluaW1hbCB0ZW1wbGF0ZSB3aXRoIHNpemU6ICR7dGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZUJ1ZmZlciB8fCB0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIEFsbCB0ZW1wbGF0ZSBhdHRlbXB0cyBmYWlsZWQsIGZhbGwgYmFjayB0byBIVE1MXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIHRlbXBsYXRlIGF0dGVtcHRzIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2VydmVyLXNpZGUgaGFuZGxpbmcgd291bGQgYmUgZGlmZmVyZW50XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGVtcGxhdGUgYnVmZmVyIGlzIHJlcXVpcmVkIHdoZW4gcnVubmluZyBvbiBzZXJ2ZXInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgYW5kIHByZXBhcmUgZGF0YSBmb3IgdGhlIHRlbXBsYXRlXG4gICAgY29uc3QgZm9ybWF0dGVkRGF0YSA9IGZvcm1hdFJlcG9ydERhdGFGb3JEb2N4KHJlcG9ydERhdGEpO1xuICAgIGNvbnNvbGUubG9nKCdEYXRhIGZvcm1hdHRlZCBmb3IgRE9DWCB0ZW1wbGF0ZScpO1xuXG4gICAgLy8gRmlyc3QgdHJ5IHdpdGggdGhlIHByb3ZpZGVkIHRlbXBsYXRlXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyeSB3aXRoIHRoZSBwcm92aWRlZC9mZXRjaGVkIHRlbXBsYXRlXG4gICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBnZW5lcmF0ZSBET0NYIHdpdGggcHJpbWFyeSB0ZW1wbGF0ZScpO1xuICAgICAgcmV0dXJuIGF3YWl0IGdlbmVyYXRlRG9jeEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZUJ1ZmZlciwgZm9ybWF0dGVkRGF0YSwgZmlsZW5hbWUpO1xuICAgIH0gY2F0Y2ggKHRlbXBsYXRlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVzaW5nIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZTonLCB0ZW1wbGF0ZUVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIGFueSBlcnJvciB3aGVuIHByb2Nlc3NpbmcgdGhlIHRlbXBsYXRlLCB0cnkgd2l0aCBhIG1pbmltYWwgdGVtcGxhdGVcbiAgICAgIC8vIHRoYXQgZG9lc24ndCByZWx5IG9uIGNvbXBsZXggZm9ybWF0dGluZyBvciB0YWdzXG4gICAgICBpZiAodGVtcGxhdGVFcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIC8vIExvZyB0aGUgZnVsbCBlcnJvciB0byBoZWxwIGRpYWdub3NlIHRlbXBsYXRlIGlzc3Vlc1xuICAgICAgICBjb25zb2xlLndhcm4oJ1RlbXBsYXRlIGVycm9yIGRldGFpbHM6Jyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBtZXNzYWdlOicsIHRlbXBsYXRlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2cgZGV0YWlsZWQgZXJyb3IgcHJvcGVydGllcyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKCdwcm9wZXJ0aWVzJyBpbiB0ZW1wbGF0ZUVycm9yKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JQcm9wcyA9ICh0ZW1wbGF0ZUVycm9yIGFzIGFueSkucHJvcGVydGllcztcbiAgICAgICAgICBpZiAoZXJyb3JQcm9wcyAmJiBlcnJvclByb3BzLmVycm9ycykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlbXBsYXRlIGNvbnRhaW5zIG11bHRpcGxlIGVycm9yczonKTtcbiAgICAgICAgICAgIGVycm9yUHJvcHMuZXJyb3JzLmZvckVhY2goKGVycjogYW55LCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVycm9yICR7aSsxfTpgLCBlcnIpO1xuICAgICAgICAgICAgICBpZiAoZXJyLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUHJvcGVydGllczonLCBlcnIucHJvcGVydGllcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS53YXJuKCdBdHRlbXB0aW5nIHRvIHVzZSBtaW5pbWFsIHRlbXBsYXRlIHdpdGhvdXQgY29tcGxleCBmb3JtYXR0aW5nLi4uJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBVc2UgdGhlIGNyZWF0ZUVtcHR5VGVtcGxhdGUgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgYSBtaW5pbWFsIHRlbXBsYXRlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIG1pbmltYWwgZW1wdHkgRE9DWCB0ZW1wbGF0ZScpO1xuICAgICAgICAgIGNvbnN0IG1pbmltYWxUZW1wbGF0ZUJ1ZmZlciA9IGNyZWF0ZUVtcHR5VGVtcGxhdGUoKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgTWluaW1hbCB0ZW1wbGF0ZSBjcmVhdGVkICgke21pbmltYWxUZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlcylgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgYWdhaW4gd2l0aCB0aGUgbWluaW1hbCB0ZW1wbGF0ZVxuICAgICAgICAgIHJldHVybiBhd2FpdCBnZW5lcmF0ZURvY3hGcm9tVGVtcGxhdGUobWluaW1hbFRlbXBsYXRlQnVmZmVyLCBmb3JtYXR0ZWREYXRhLCBmaWxlbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKG1pbmltYWxFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHdpdGggbWluaW1hbCB0ZW1wbGF0ZTonLCBtaW5pbWFsRXJyb3IpO1xuICAgICAgICAgIC8vIExldCB0aGUgb3V0ZXIgY2F0Y2ggaGFuZGxlIHRoZSBmYWxsYmFjayB0byBIVE1MXG4gICAgICAgICAgdGhyb3cgbWluaW1hbEVycm9yO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXRocm93IHRvIGxldCB0aGUgb3V0ZXIgY2F0Y2ggaGFuZGxlIGl0XG4gICAgICAgIHRocm93IHRlbXBsYXRlRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdlbmVyYXRlUmVwb3J0RG9jeDonLCBlcnJvcik7XG4gICAgXG4gICAgLy8gSWYgYWxsIERPQ1ggZ2VuZXJhdGlvbiBhdHRlbXB0cyBmYWlsZWQsIGZhbGwgYmFjayB0byBIVE1MXG4gICAgY29uc29sZS53YXJuKCdBbGwgRE9DWCBnZW5lcmF0aW9uIGF0dGVtcHRzIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIEhUTUwgZXhwb3J0Jyk7XG4gICAgY29uc3QgaHRtbEJsb2IgPSBnZW5lcmF0ZUZhbGxiYWNrSHRtbFJlcG9ydChyZXBvcnREYXRhKTtcbiAgICBjb25zdCBodG1sRmlsZW5hbWUgPSBgJHtzdHVkZW50TmFtZS5yZXBsYWNlKC9cXHMrL2csICdfJyl9X3JlcG9ydF8ke3RpbWVzdGFtcH0uaHRtbGA7XG4gICAgXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzYXZlQXMoaHRtbEJsb2IsIGh0bWxGaWxlbmFtZSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBodG1sQmxvYjtcbiAgfVxufVxuXG4vKipcbiAqIEZsYXR0ZW5zIGEgbmVzdGVkIG9iamVjdCBzdHJ1Y3R1cmUsIGNvbnZlcnRpbmcgbmVzdGVkIHByb3BlcnRpZXMgdG8gdW5kZXJzY29yZSBub3RhdGlvblxuICogVGhpcyBlbnN1cmVzIGNvbXBhdGliaWxpdHkgd2l0aCBkb2N4dGVtcGxhdGVyIHRlbXBsYXRlcyB0aGF0IHVzZSB1bmRlcnNjb3JlIG5vdGF0aW9uXG4gKiBcbiAqIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IHRvIGZsYXR0ZW5cbiAqIEBwYXJhbSBwcmVmaXggLSBPcHRpb25hbCBwcmVmaXggZm9yIHRoZSBjdXJyZW50IGxldmVsIG9mIG5lc3RpbmcgKHVzZWQgaW4gcmVjdXJzaW9uKVxuICogQHBhcmFtIHJlc3VsdCAtIEFjY3VtdWxhdG9yIGZvciB0aGUgZmxhdHRlbmVkIG9iamVjdCAodXNlZCBpbiByZWN1cnNpb24pXG4gKiBAcmV0dXJucyBBIGZsYXR0ZW5lZCBvYmplY3Qgd2l0aCB1bmRlcnNjb3JlIG5vdGF0aW9uIGtleXNcbiAqL1xuZnVuY3Rpb24gZmxhdHRlbk9iamVjdChvYmo6IFJlY29yZDxzdHJpbmcsIGFueT4sIHByZWZpeCA9ICcnLCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fSk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAvLyBTa2lwIG51bGwgb3IgdW5kZWZpbmVkIG9iamVjdHNcbiAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICBcbiAgLy8gUHJvY2VzcyBlYWNoIGtleSBpbiB0aGUgb2JqZWN0XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgY29uc3QgbmV3S2V5ID0gcHJlZml4ID8gYCR7cHJlZml4fV8ke2tleX1gIDoga2V5O1xuICAgICAgXG4gICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIG5lc3RlZCBvYmplY3RzXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZmxhdHRlbk9iamVjdCh2YWx1ZSwgbmV3S2V5LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIGFycmF5cywga2VlcCB0aGVtIGFzIGlzIChkb2N4dGVtcGxhdGVyIGNhbiBoYW5kbGUgYXJyYXlzKVxuICAgICAgICByZXN1bHRbbmV3S2V5XSA9IHZhbHVlO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhbiBhcnJheSwgYWRkIGEgX2xpc3QgdmVyc2lvbiBmb3IgdGVtcGxhdGUgbG9vcCBjb21wYXRpYmlsaXR5XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBrZXkudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgncycpICYmICFrZXkuZW5kc1dpdGgoJ0xpc3QnKSAmJiAha2V5LmVuZHNXaXRoKCdsaXN0JykpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IHZlcnNpb24gd2l0aCBvYmplY3RzIGNvbnRhaW5pbmcgYSB0ZXh0IHByb3BlcnR5XG4gICAgICAgICAgY29uc3Qgc2luZ3VsYXJLZXkgPSBrZXkuc2xpY2UoMCwgLTEpOyAvLyBSZW1vdmUgdHJhaWxpbmcgJ3MnXG4gICAgICAgICAgY29uc3QgbGlzdEtleSA9IGAke25ld0tleX1MaXN0YDtcbiAgICAgICAgICBcbiAgICAgICAgICByZXN1bHRbbGlzdEtleV0gPSB2YWx1ZS5tYXAoKGl0ZW06IGFueSkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGl0ZW0gaXMgYWxyZWFkeSBhbiBvYmplY3QsIHVzZSBpdDsgb3RoZXJ3aXNlIHdyYXAgaXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGl0ZW0gfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBGb3JtYXQgdGhlIHJlcG9ydCBkYXRhIGZvciBkb2N4IHRlbXBsYXRlIHJlbmRlcmluZ1xuICogQHBhcmFtIHJlcG9ydERhdGEgLSBUaGUgcmF3IHJlcG9ydCBkYXRhIGZyb20gdGhlIGFwcGxpY2F0aW9uXG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgZGF0YSByZWFkeSBmb3IgZG9jeCB0ZW1wbGF0ZVxuICovXG5mdW5jdGlvbiBmb3JtYXRSZXBvcnREYXRhRm9yRG9jeChyZXBvcnREYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIC8vIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGUgcmVwb3J0IGRhdGFcbiAgY29uc3QgZm9ybWF0dGVkRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVwb3J0RGF0YSkpO1xuXG4gIC8vIEZvcm1hdCBhcnJheXMgdG8gYmUgbW9yZSBkb2N4LXRlbXBsYXRlIGZyaWVuZGx5XG4gIC8vIEFycmF5cyBpbiBkb2N4dGVtcGxhdGVyIGFyZSB0eXBpY2FsbHkgaGFuZGxlZCB3aXRoIGxvb3BzLCBzbyB3ZSdsbCBmb3JtYXQgdGhlbVxuICAvLyB0byBiZSByZWFkeSBmb3IgdGhlIHRlbXBsYXRlIHN5bnRheFxuXG4gIC8vIFByb2Nlc3Mgc3RyZW5ndGggYW5kIG5lZWRzIGxpc3RzIGZvciBlYWNoIGRvbWFpblxuICBPYmplY3Qua2V5cyhmb3JtYXR0ZWREYXRhLmFzc2Vzc21lbnRSZXN1bHRzPy5kb21haW5zIHx8IHt9KS5mb3JFYWNoKGRvbWFpbiA9PiB7XG4gICAgY29uc3QgZG9tYWluRGF0YSA9IGZvcm1hdHRlZERhdGEuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWluc1tkb21haW5dO1xuICAgIFxuICAgIC8vIEZvcm1hdCBzdHJlbmd0aHMgYXMgYnVsbGV0IHBvaW50cyBmb3IgRE9DWFxuICAgIGlmIChBcnJheS5pc0FycmF5KGRvbWFpbkRhdGEuc3RyZW5ndGhzKSAmJiBkb21haW5EYXRhLnN0cmVuZ3Rocy5sZW5ndGggPiAwKSB7XG4gICAgICBkb21haW5EYXRhLnN0cmVuZ3Roc0xpc3QgPSBkb21haW5EYXRhLnN0cmVuZ3Rocy5tYXAoKGl0ZW06IHN0cmluZykgPT4gKHsgdGV4dDogaXRlbSB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVuc3VyZSBlbXB0eSBhcnJheSBoYXMgcmlnaHQgZm9ybWF0IGZvciB0ZW1wbGF0ZXMgdGhhdCBleHBlY3QgaXRcbiAgICAgIGRvbWFpbkRhdGEuc3RyZW5ndGhzTGlzdCA9IFtdO1xuICAgIH1cblxuICAgIC8vIEZvcm1hdCBuZWVkcyBhcyBidWxsZXQgcG9pbnRzIGZvciBET0NYXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZG9tYWluRGF0YS5uZWVkcykgJiYgZG9tYWluRGF0YS5uZWVkcy5sZW5ndGggPiAwKSB7XG4gICAgICBkb21haW5EYXRhLm5lZWRzTGlzdCA9IGRvbWFpbkRhdGEubmVlZHMubWFwKChpdGVtOiBzdHJpbmcpID0+ICh7IHRleHQ6IGl0ZW0gfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgZW1wdHkgYXJyYXkgaGFzIHJpZ2h0IGZvcm1hdCBmb3IgdGVtcGxhdGVzIHRoYXQgZXhwZWN0IGl0XG4gICAgICBkb21haW5EYXRhLm5lZWRzTGlzdCA9IFtdO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRm9ybWF0IGFjY29tbW9kYXRpb24gYW5kIGZhY2lsaXRhdGlvbiBzdHJhdGVnaWVzXG4gIGlmIChBcnJheS5pc0FycmF5KGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbj8ucmVjb21tZW5kYXRpb25zPy5hY2NvbW1vZGF0aW9ucykpIHtcbiAgICBmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmFjY29tbW9kYXRpb25zTGlzdCA9IFxuICAgICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9ucy5tYXAoKGl0ZW06IHN0cmluZykgPT4gKHsgdGV4dDogaXRlbSB9KSk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uPy5yZWNvbW1lbmRhdGlvbnMpIHtcbiAgICBmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmFjY29tbW9kYXRpb25zTGlzdCA9IFtdO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uPy5yZWNvbW1lbmRhdGlvbnM/LmZhY2lsaXRhdGlvblN0cmF0ZWdpZXMpKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzTGlzdCA9IFxuICAgICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiAoeyB0ZXh0OiBpdGVtIH0pKTtcbiAgfSBlbHNlIGlmIChmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24/LnJlY29tbWVuZGF0aW9ucykge1xuICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llc0xpc3QgPSBbXTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgcGFyZW50cyBhcnJheSB0byBzdHJpbmcgaWYgbmVlZGVkXG4gIGlmIChBcnJheS5pc0FycmF5KGZvcm1hdHRlZERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24/LnBhcmVudHMpKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLnBhcmVudHNTdHJpbmcgPSBcbiAgICAgIGZvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5wYXJlbnRzLmpvaW4oJywgJyk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVkRGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbikge1xuICAgIGZvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5wYXJlbnRzU3RyaW5nID0gJyc7XG4gIH1cblxuICAvLyBBZGQgZnVsbCBzdHVkZW50IG5hbWUgZm9yIGNvbnZlbmllbmNlXG4gIGlmIChmb3JtYXR0ZWREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5maXJzdE5hbWUpIHtcbiAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZnVsbE5hbWUgPSBcbiAgICAgIGAke2Zvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5maXJzdE5hbWV9ICR7Zm9ybWF0dGVkRGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmxhc3ROYW1lIHx8ICcnfWA7XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVkRGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbikge1xuICAgIGZvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5mdWxsTmFtZSA9ICdTdHVkZW50JztcbiAgfVxuXG4gIC8vIEZsYXR0ZW4gdGhlIGRhdGEgc3RydWN0dXJlIHRvIG1hdGNoIHVuZGVyc2NvcmUtZm9ybWF0dGVkIHRlbXBsYXRlIHRhZ3NcbiAgLy8gRm9yIGV4YW1wbGU6IGhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZmlyc3ROYW1lIGJlY29tZXMgaGVhZGVyX3N0dWRlbnRJbmZvcm1hdGlvbl9maXJzdE5hbWVcbiAgY29uc3QgZmxhdHRlbmVkRGF0YSA9IGZsYXR0ZW5PYmplY3QoZm9ybWF0dGVkRGF0YSk7XG4gIFxuICAvLyBMb2cgdGhlIGZsYXR0ZW5lZCBkYXRhIHN0cnVjdHVyZSBmb3IgZGVidWdnaW5nXG4gIGNvbnNvbGUubG9nKCdGbGF0dGVuZWQgZGF0YSByZWFkeSBmb3IgdGVtcGxhdGU6Jyk7XG4gIGNvbnNvbGUubG9nKCdLZXlzOicsIE9iamVjdC5rZXlzKGZsYXR0ZW5lZERhdGEpLnNsaWNlKDAsIDEwKSwgJy4uLiBhbmQgbW9yZScpO1xuICBcbiAgcmV0dXJuIGZsYXR0ZW5lZERhdGE7XG59Il0sIm5hbWVzIjpbIkRvY3h0ZW1wbGF0ZXIiLCJQaXpaaXAiLCJzYXZlQXMiLCJnZW5lcmF0ZURvY3hGcm9tVGVtcGxhdGUiLCJ0ZW1wbGF0ZUJ1ZmZlciIsImRhdGEiLCJvdXRwdXRGaWxlbmFtZSIsImRlYnVnTW9kZSIsImNvbnNvbGUiLCJsb2ciLCJieXRlTGVuZ3RoIiwiSlNPTiIsInN0cmluZ2lmeSIsImZpcnN0Qnl0ZXMiLCJVaW50OEFycmF5Iiwic2xpY2UiLCJBcnJheSIsImZyb20iLCJtYXAiLCJiIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImpvaW4iLCJFcnJvciIsImVycm9yIiwiemlwIiwiYXJyYXlCdWZmZXIiLCJmaWxlcyIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiZmlsZSIsImZpbGVFbnRyeSIsIm5hbWUiLCJfZGF0YSIsImRvY3VtZW50Q29udGVudCIsImFzVGV4dCIsInNuaXBwZXQiLCJzdWJzdHJpbmciLCJ0YWdNYXRjaGVzIiwibWF0Y2giLCJ3YXJuIiwiZG9jdW1lbnRFcnJvciIsInppcEVycm9yIiwibWVzc2FnZSIsImRvYyIsInBhcmFncmFwaExvb3AiLCJsaW5lYnJlYWtzIiwiZXJyb3JMb2dnaW5nIiwibnVsbEdldHRlciIsInBhcnQiLCJtb2R1bGUiLCJkZWxpbWl0ZXJzIiwic3RhcnQiLCJlbmQiLCJwYXJzZXIiLCJ0YWciLCJnZXQiLCJzY29wZSIsInJlc3VsdCIsInVuZGVmaW5lZCIsImRvY3hFcnJvciIsInByb3BlcnRpZXMiLCJlcnJvcnMiLCJmaXJzdEVycm9yIiwiaW5kZXgiLCJleHBsYW5hdGlvbiIsImlkIiwieHRhZyIsInBvc3RwYXJzZWQiLCJNYXRoIiwibWF4Iiwib2Zmc2V0IiwicmVuZGVyIiwicmVuZGVyRXJyb3IiLCJyYXciLCJwcm9wcyIsIm91dHB1dCIsImdldFppcCIsImdlbmVyYXRlIiwidHlwZSIsImNvbXByZXNzaW9uIiwibWltZVR5cGUiLCJzaXplIiwiZ2VuRXJyb3IiLCJzYXZlRXJyb3IiLCJpbmNsdWRlcyIsImdlbmVyYXRlRmFsbGJhY2tIdG1sUmVwb3J0IiwicmVwb3J0RGF0YSIsInN0dWRlbnROYW1lIiwiaGVhZGVyIiwic3R1ZGVudEluZm9ybWF0aW9uIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJodG1sIiwiRE9CIiwicmVwb3J0RGF0ZSIsInJlYXNvbkZvclJlZmVycmFsIiwiYXNzZXNzbWVudFJlc3VsdHMiLCJkb21haW5zIiwiZW50cmllcyIsImRvbWFpbk5hbWUiLCJkb21haW4iLCJ0b3BpY1NlbnRlbmNlIiwic3RyZW5ndGhzIiwibmVlZHMiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsImlzQ29uY2VybiIsIml0ZW0iLCJpbXBhY3RTdGF0ZW1lbnQiLCJjb25jbHVzaW9uIiwicmVjb21tZW5kYXRpb25zIiwiYWNjb21tb2RhdGlvbnMiLCJmYWNpbGl0YXRpb25TdHJhdGVnaWVzIiwiQmxvYiIsImNyZWF0ZUVtcHR5VGVtcGxhdGUiLCJtaW5pbWFsRG9jeEJhc2U2NCIsImJpbmFyeVN0cmluZyIsIndpbmRvdyIsImF0b2IiLCJieXRlcyIsImkiLCJjaGFyQ29kZUF0IiwiYnVmZmVyIiwiZ2VuZXJhdGVSZXBvcnREb2N4IiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJmaWxlbmFtZSIsInJlcGxhY2UiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiY2FjaGUiLCJoZWFkZXJzIiwib2siLCJzdGF0dXMiLCJhbHRSZXNwb25zZSIsImFsdEZpcnN0Qnl0ZXMiLCJhbHRFcnJvciIsImZvcm1hdHRlZERhdGEiLCJmb3JtYXRSZXBvcnREYXRhRm9yRG9jeCIsInRlbXBsYXRlRXJyb3IiLCJlcnJvclByb3BzIiwiZXJyIiwibWluaW1hbFRlbXBsYXRlQnVmZmVyIiwibWluaW1hbEVycm9yIiwiaHRtbEJsb2IiLCJodG1sRmlsZW5hbWUiLCJmbGF0dGVuT2JqZWN0Iiwib2JqIiwicHJlZml4Iiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWUiLCJuZXdLZXkiLCJpc0FycmF5IiwidG9Mb3dlckNhc2UiLCJlbmRzV2l0aCIsInNpbmd1bGFyS2V5IiwibGlzdEtleSIsInRleHQiLCJwYXJzZSIsImRvbWFpbkRhdGEiLCJzdHJlbmd0aHNMaXN0IiwibmVlZHNMaXN0IiwiYWNjb21tb2RhdGlvbnNMaXN0IiwiZmFjaWxpdGF0aW9uU3RyYXRlZ2llc0xpc3QiLCJwYXJlbnRzIiwicGFyZW50c1N0cmluZyIsImZ1bGxOYW1lIiwiZmxhdHRlbmVkRGF0YSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/docx-generator.ts\n"));

/***/ })

});