"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/reports/text-editor-test/page",{

/***/ "(app-pages-browser)/./src/lib/docx-generator.ts":
/*!***********************************!*\
  !*** ./src/lib/docx-generator.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateDocxFromTemplate: () => (/* binding */ generateDocxFromTemplate),\n/* harmony export */   generateReportDocx: () => (/* binding */ generateReportDocx)\n/* harmony export */ });\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! docxtemplater */ \"(app-pages-browser)/./node_modules/docxtemplater/js/docxtemplater.js\");\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(docxtemplater__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pizzip */ \"(app-pages-browser)/./node_modules/pizzip/js/index.js\");\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pizzip__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! file-saver */ \"(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n/**\n * Generate a docx file from a template and data\n * @param templateBuffer - The binary template file as an ArrayBuffer\n * @param data - The data to inject into the template\n * @param outputFilename - The name of the file to save\n * @param debugMode - Whether to enable extra debugging information\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateDocxFromTemplate(templateBuffer, data) {\n    let outputFilename = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'report.docx', debugMode = arguments.length > 3 && arguments[3] !== void 0 // Enable debug mode by default to help diagnose template issues\n     ? arguments[3] : true;\n    try {\n        console.log(\"Attempting to create PizZip instance with buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n        // Output debug information if debug mode is enabled\n        if (debugMode) {\n            console.log('Data being passed to template:', JSON.stringify(data, null, 2));\n            console.log('Template buffer size:', templateBuffer.byteLength);\n            // Log the first 20 bytes of the template to verify it's a proper DOCX file\n            const firstBytes = new Uint8Array(templateBuffer.slice(0, 20));\n            console.log('First 20 bytes of template (hex):', Array.from(firstBytes).map((b)=>b.toString(16).padStart(2, '0')).join(' '));\n        }\n        // Validate that we have a proper buffer\n        if (!templateBuffer || templateBuffer.byteLength === 0) {\n            throw new Error('Invalid template buffer: Empty or undefined');\n        }\n        // Verify the buffer has a ZIP signature (first bytes of a proper DOCX/ZIP file)\n        const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n        if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n            console.error('Invalid ZIP file signature in template. First bytes:', Array.from(firstBytes));\n            throw new Error('The template does not appear to be a valid ZIP/DOCX file (missing PK signature)');\n        }\n        // Create a new PizZip instance with the template content\n        // Use a try-catch specifically for the PizZip instantiation\n        let zip;\n        try {\n            // Convert ArrayBuffer to Uint8Array to ensure proper binary handling\n            const arrayBuffer = new Uint8Array(templateBuffer);\n            zip = new (pizzip__WEBPACK_IMPORTED_MODULE_1___default())(arrayBuffer);\n        } catch (zipError) {\n            console.error('Error creating PizZip instance:', zipError);\n            throw new Error(\"Failed to create ZIP from template: \".concat(zipError instanceof Error ? zipError.message : 'Unknown error'));\n        }\n        console.log('PizZip instance created successfully');\n        // Create a new Docxtemplater instance with improved error handling\n        let doc;\n        try {\n            doc = new (docxtemplater__WEBPACK_IMPORTED_MODULE_0___default())(zip, {\n                paragraphLoop: true,\n                linebreaks: true,\n                errorLogging: true,\n                nullGetter: function(part) {\n                    if (!part.module) {\n                        return \"\";\n                    }\n                    if (part.module === \"rawxml\") {\n                        return \"\";\n                    }\n                    return \"\";\n                }\n            });\n            console.log('Docxtemplater instance created successfully');\n        } catch (docxError) {\n            console.error('Error creating Docxtemplater instance:', docxError);\n            // Special handling for Multi error (which contains multiple errors)\n            if (docxError && docxError.properties && docxError.properties.errors) {\n                var _firstError_properties;\n                console.log('Docxtemplater reported multiple errors:');\n                // Log each individual error for debugging\n                docxError.properties.errors.forEach((error, index)=>{\n                    console.log(\"Error \".concat(index + 1, \":\"), error);\n                    // Log detailed information if available\n                    if (error.properties) {\n                        if (error.properties.explanation) {\n                            console.log(\"Explanation: \".concat(error.properties.explanation));\n                        }\n                        if (error.properties.id) {\n                            console.log(\"Error ID: \".concat(error.properties.id));\n                        }\n                        if (error.properties.xtag) {\n                            console.log(\"Tag with error: \".concat(error.properties.xtag));\n                        }\n                        if (error.properties.postparsed) {\n                            console.log('Template structure around error:');\n                            console.log(error.properties.postparsed.slice(Math.max(0, error.properties.offset - 5), error.properties.offset + 5));\n                        }\n                    }\n                });\n                // Throw a more detailed error\n                const firstError = docxError.properties.errors[0] || {};\n                const explanation = ((_firstError_properties = firstError.properties) === null || _firstError_properties === void 0 ? void 0 : _firstError_properties.explanation) || 'Unknown template issues';\n                throw new Error(\"Template errors detected: \".concat(explanation, \" (See console for full details)\"));\n            }\n            throw new Error(\"Failed to create Docxtemplater: \".concat(docxError instanceof Error ? docxError.message : 'Unknown error'));\n        }\n        try {\n            // Render the document with the provided data\n            doc.render(data);\n            console.log('Template rendered with data');\n        } catch (renderError) {\n            console.error('Error rendering template:', renderError);\n            // Special handling for Multi error (which contains multiple errors)\n            if (renderError && renderError.properties && renderError.properties.errors) {\n                var _firstError_properties1;\n                console.log('Docxtemplater reported multiple render errors:');\n                // Log each individual error for debugging\n                renderError.properties.errors.forEach((error, index)=>{\n                    console.log(\"Render Error \".concat(index + 1, \":\"), error);\n                    // Log detailed information if available\n                    if (error.properties) {\n                        if (error.properties.explanation) {\n                            console.log(\"Explanation: \".concat(error.properties.explanation));\n                        }\n                        if (error.properties.id) {\n                            console.log(\"Error ID: \".concat(error.properties.id));\n                        }\n                        if (error.properties.xtag) {\n                            console.log(\"Tag with error: \".concat(error.properties.xtag));\n                        }\n                        // Log the data path that caused the issue if known\n                        if (error.properties.tag) {\n                            console.log(\"Template tag: \".concat(error.properties.tag));\n                            console.log(\"Raw tag: \".concat(error.properties.raw));\n                        }\n                    }\n                });\n                // Throw a more detailed error\n                const firstError = renderError.properties.errors[0] || {};\n                const explanation = ((_firstError_properties1 = firstError.properties) === null || _firstError_properties1 === void 0 ? void 0 : _firstError_properties1.explanation) || 'Unknown template rendering issues';\n                throw new Error(\"Template rendering errors: \".concat(explanation, \" (See console for full details)\"));\n            }\n            // Special handling for individual Docxtemplater errors with properties\n            if (renderError instanceof Error && 'properties' in renderError) {\n                const props = renderError.properties || {};\n                console.log('Detailed render error properties:', props);\n                throw new Error(\"Template render error: \".concat(props.explanation || renderError.message));\n            }\n            throw new Error(\"Failed to render template: \".concat(renderError instanceof Error ? renderError.message : 'Unknown error'));\n        }\n        // Generate the output document\n        let output;\n        try {\n            output = doc.getZip().generate({\n                type: 'blob',\n                compression: 'DEFLATE',\n                mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n            });\n            console.log(\"Output document generated successfully (\".concat(output.size, \" bytes)\"));\n        } catch (genError) {\n            console.error('Error generating output document:', genError);\n            throw new Error(\"Failed to generate output: \".concat(genError instanceof Error ? genError.message : 'Unknown error'));\n        }\n        // If running in browser, save the file\n        if (true) {\n            try {\n                (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(output, outputFilename);\n                console.log(\"File saved as \".concat(outputFilename));\n            } catch (saveError) {\n                console.error('Error saving file:', saveError);\n                throw new Error(\"Failed to save file: \".concat(saveError instanceof Error ? saveError.message : 'Unknown error'));\n            }\n        }\n        return output;\n    } catch (error) {\n        console.error('Error in generateDocxFromTemplate:', error);\n        // If it's a PizZip error (likely invalid template)\n        if (error instanceof Error && error.message.includes('zip')) {\n            console.error('PizZip error - invalid template file structure');\n            throw new Error(\"Template file is not a valid DOCX/ZIP file: \".concat(error.message));\n        }\n        // Rethrow the error\n        throw error;\n    }\n}\n/**\n * Generate a fallback HTML report when DOCX template fails\n * @param reportData - The report data to export\n * @returns A blob with HTML content\n */ function generateFallbackHtmlReport(reportData) {\n    var _reportData_header_studentInformation, _reportData_header, _reportData_header_studentInformation1, _reportData_header1, _reportData_header_studentInformation2, _reportData_header2, _reportData_header3, _reportData_assessmentResults, _reportData_conclusion;\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \" \").concat(reportData.header.studentInformation.lastName) : 'Student';\n    // Create a simple HTML representation of the report\n    let html = '\\n    <!DOCTYPE html>\\n    <html>\\n    <head>\\n      <meta charset=\"utf-8\">\\n      <title>Report for '.concat(studentName, \"</title>\\n      <style>\\n        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }\\n        h1, h2, h3 { color: #444; }\\n        .section { margin-bottom: 30px; }\\n        .domain { margin-bottom: 20px; padding: 15px; border: 1px solid #eee; }\\n        .domain-header { display: flex; justify-content: space-between; align-items: center; }\\n        .concern { color: #f59e0b; font-size: 14px; }\\n        .no-concern { color: #10b981; font-size: 14px; }\\n        ul { margin-top: 5px; }\\n        @media print {\\n          body { margin: 0.5in; }\\n          .domain { break-inside: avoid; }\\n        }\\n      </style>\\n    </head>\\n    <body>\\n      <h1>Report for \").concat(studentName, '</h1>\\n      <div class=\"section\">\\n        <h2>Student Information</h2>\\n        <p><strong>DOB:</strong> ').concat(((_reportData_header1 = reportData.header) === null || _reportData_header1 === void 0 ? void 0 : (_reportData_header_studentInformation1 = _reportData_header1.studentInformation) === null || _reportData_header_studentInformation1 === void 0 ? void 0 : _reportData_header_studentInformation1.DOB) || 'N/A', \"</p>\\n        <p><strong>Report Date:</strong> \").concat(((_reportData_header2 = reportData.header) === null || _reportData_header2 === void 0 ? void 0 : (_reportData_header_studentInformation2 = _reportData_header2.studentInformation) === null || _reportData_header_studentInformation2 === void 0 ? void 0 : _reportData_header_studentInformation2.reportDate) || 'N/A', \"</p>\\n        <p><strong>Reason for Referral:</strong> \").concat(((_reportData_header3 = reportData.header) === null || _reportData_header3 === void 0 ? void 0 : _reportData_header3.reasonForReferral) || 'N/A', \"</p>\\n      </div>\\n  \");\n    // Add domains section\n    if ((_reportData_assessmentResults = reportData.assessmentResults) === null || _reportData_assessmentResults === void 0 ? void 0 : _reportData_assessmentResults.domains) {\n        html += '<div class=\"section\"><h2>Assessment Results</h2>';\n        Object.entries(reportData.assessmentResults.domains).forEach((param)=>{\n            let [domainName, domain] = param;\n            var _domain_strengths, _domain_needs;\n            if (domain.topicSentence || ((_domain_strengths = domain.strengths) === null || _domain_strengths === void 0 ? void 0 : _domain_strengths.length) || ((_domain_needs = domain.needs) === null || _domain_needs === void 0 ? void 0 : _domain_needs.length)) {\n                var _domain_strengths1, _domain_needs1;\n                html += '\\n          <div class=\"domain\">\\n            <div class=\"domain-header\">\\n              <h3>'.concat(domainName.charAt(0).toUpperCase() + domainName.slice(1), \" Language</h3>\\n              \").concat(domain.isConcern !== undefined ? '<span class=\"'.concat(domain.isConcern ? 'concern' : 'no-concern', '\">').concat(domain.isConcern ? 'Area of Concern' : 'No Concern', \"</span>\") : '', \"\\n            </div>\\n            \").concat(domain.topicSentence ? \"<p>\".concat(domain.topicSentence, \"</p>\") : '', \"\\n            \\n            \").concat(((_domain_strengths1 = domain.strengths) === null || _domain_strengths1 === void 0 ? void 0 : _domain_strengths1.length) ? \"\\n              <h4>Strengths:</h4>\\n              <ul>\\n                \".concat(domain.strengths.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(((_domain_needs1 = domain.needs) === null || _domain_needs1 === void 0 ? void 0 : _domain_needs1.length) ? \"\\n              <h4>Needs:</h4>\\n              <ul>\\n                \".concat(domain.needs.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(domain.impactStatement ? \"\\n              <h4>Educational Impact:</h4>\\n              <p>\".concat(domain.impactStatement, \"</p>\\n            \") : '', \"\\n          </div>\\n        \");\n            }\n        });\n        html += \"</div>\";\n    }\n    // Add recommendations\n    if ((_reportData_conclusion = reportData.conclusion) === null || _reportData_conclusion === void 0 ? void 0 : _reportData_conclusion.recommendations) {\n        var _reportData_conclusion_recommendations_accommodations, _reportData_conclusion_recommendations_facilitationStrategies;\n        html += '\\n      <div class=\"section\">\\n        <h2>Recommendations</h2>\\n        '.concat(((_reportData_conclusion_recommendations_accommodations = reportData.conclusion.recommendations.accommodations) === null || _reportData_conclusion_recommendations_accommodations === void 0 ? void 0 : _reportData_conclusion_recommendations_accommodations.length) ? \"\\n          <h3>Accommodations:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.accommodations.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n        \\n        \").concat(((_reportData_conclusion_recommendations_facilitationStrategies = reportData.conclusion.recommendations.facilitationStrategies) === null || _reportData_conclusion_recommendations_facilitationStrategies === void 0 ? void 0 : _reportData_conclusion_recommendations_facilitationStrategies.length) ? \"\\n          <h3>Facilitation Strategies:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.facilitationStrategies.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n      </div>\\n    \");\n    }\n    html += \"\\n      <footer>\\n        <p><em>This is a fallback HTML report generated because the DOCX template could not be processed. \\n        You can print this HTML file to create a PDF.</em></p>\\n      </footer>\\n    </body>\\n    </html>\\n  \";\n    return new Blob([\n        html\n    ], {\n        type: 'text/html'\n    });\n}\n/**\n * Create a simple empty DOCX template programmatically\n * This is a last-resort fallback when all template files fail to load\n */ function createEmptyTemplate() {\n    // Define a minimal valid DOCX file structure as a base64 string\n    // This is a simplified empty DOCX file with minimal content\n    const minimalDocxBase64 = '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';\n    // Convert base64 to ArrayBuffer\n    const binaryString = window.atob(minimalDocxBase64);\n    const bytes = new Uint8Array(binaryString.length);\n    for(let i = 0; i < binaryString.length; i++){\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n/**\n * Generate a report docx from the report data\n * @param reportData - The report data from the application\n * @param templateBuffer - The binary template file as an ArrayBuffer (optional)\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateReportDocx(reportData, templateBuffer) {\n    var _reportData_header_studentInformation, _reportData_header;\n    // Generate the filename based on report data\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \"_\").concat(reportData.header.studentInformation.lastName) : 'student';\n    const timestamp = new Date().toISOString().split('T')[0];\n    const filename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".docx\");\n    try {\n        // If no template buffer is provided, use a default template\n        if (!templateBuffer) {\n            // Use fetch to get the template if we're in the browser\n            if (true) {\n                try {\n                    console.log('No template buffer provided, fetching default template');\n                    // Try to use response.arrayBuffer() which ensures binary data handling\n                    // Use las-assessment-report-template.docx instead of report-template.docx (which is a text file, not a DOCX)\n                    const response = await fetch('/templates/las-assessment-report-template.docx', {\n                        method: 'GET',\n                        cache: 'no-cache',\n                        headers: {\n                            'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                            'Cache-Control': 'no-cache'\n                        }\n                    });\n                    if (!response.ok) {\n                        throw new Error(\"Failed to fetch default template: \".concat(response.status));\n                    }\n                    console.log('Default template fetched successfully');\n                    templateBuffer = await response.arrayBuffer();\n                    console.log(\"Default template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                    if (templateBuffer.byteLength === 0) {\n                        throw new Error('Default template file is empty');\n                    }\n                    // Verify the template has a proper DOCX signature\n                    const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                    if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n                        console.error('Invalid DOCX file signature in default template. First bytes:', Array.from(firstBytes));\n                        throw new Error('Default template is not a valid DOCX file');\n                    }\n                } catch (error) {\n                    console.error('Error loading default template:', error);\n                    // Try alternative template as a last resort\n                    try {\n                        console.log('Attempting to load alternative template: las-assessment-report-template-fixed.docx');\n                        const altResponse = await fetch('/templates/las-assessment-report-template-fixed.docx', {\n                            cache: 'no-cache',\n                            headers: {\n                                'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                                'Cache-Control': 'no-cache'\n                            }\n                        });\n                        if (!altResponse.ok) {\n                            throw new Error(\"Failed to fetch alternative template: \".concat(altResponse.status));\n                        }\n                        templateBuffer = await altResponse.arrayBuffer();\n                        console.log(\"Alternative template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        // Verify the alternative template\n                        const altFirstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                        if (!(altFirstBytes[0] === 0x50 && altFirstBytes[1] === 0x4B)) {\n                            console.error('Invalid DOCX file signature in alternative template');\n                            throw new Error('Alternative template is not a valid DOCX file');\n                        }\n                    } catch (altError) {\n                        console.error('Error loading alternative template:', altError);\n                        // As a last resort, create a minimal valid DOCX template\n                        console.log('Creating minimal empty DOCX template');\n                        templateBuffer = createEmptyTemplate();\n                        console.log(\"Created minimal template with size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        if (!templateBuffer || templateBuffer.byteLength === 0) {\n                            // All template attempts failed, fall back to HTML\n                            throw new Error('All template attempts failed');\n                        }\n                    }\n                }\n            } else {}\n        }\n        // Format and prepare data for the template\n        const formattedData = formatReportDataForDocx(reportData);\n        console.log('Data formatted for DOCX template');\n        // Generate the document\n        return await generateDocxFromTemplate(templateBuffer, formattedData, filename);\n    } catch (error) {\n        console.error('Error in generateReportDocx:', error);\n        // If there was an error with the template or docxtemplater,\n        // try to generate a fallback HTML report\n        if (error instanceof Error && (error.message.includes('zip') || error.message.includes('template') || error.message.includes('docxtemplater'))) {\n            console.warn('DOCX generation failed, falling back to HTML export');\n            const htmlBlob = generateFallbackHtmlReport(reportData);\n            const htmlFilename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".html\");\n            if (true) {\n                (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(htmlBlob, htmlFilename);\n            }\n            return htmlBlob;\n        }\n        throw error;\n    }\n}\n/**\n * Format the report data for docx template rendering\n * @param reportData - The raw report data from the application\n * @returns Formatted data ready for docx template\n */ function formatReportDataForDocx(reportData) {\n    var _formattedData_assessmentResults, _formattedData_conclusion_recommendations, _formattedData_conclusion, _formattedData_conclusion1, _formattedData_conclusion_recommendations1, _formattedData_conclusion2, _formattedData_conclusion3, _formattedData_header_studentInformation, _formattedData_header, _formattedData_header1, _formattedData_header_studentInformation1, _formattedData_header2, _formattedData_header3;\n    // Create a deep copy of the report data\n    const formattedData = JSON.parse(JSON.stringify(reportData));\n    // Format arrays to be more docx-template friendly\n    // Arrays in docxtemplater are typically handled with loops, so we'll format them\n    // to be ready for the template syntax\n    // Process strength and needs lists for each domain\n    Object.keys(((_formattedData_assessmentResults = formattedData.assessmentResults) === null || _formattedData_assessmentResults === void 0 ? void 0 : _formattedData_assessmentResults.domains) || {}).forEach((domain)=>{\n        const domainData = formattedData.assessmentResults.domains[domain];\n        // Format strengths as bullet points for DOCX\n        if (Array.isArray(domainData.strengths) && domainData.strengths.length > 0) {\n            domainData.strengthsList = domainData.strengths.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.strengthsList = [];\n        }\n        // Format needs as bullet points for DOCX\n        if (Array.isArray(domainData.needs) && domainData.needs.length > 0) {\n            domainData.needsList = domainData.needs.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.needsList = [];\n        }\n    });\n    // Format accommodation and facilitation strategies\n    if (Array.isArray((_formattedData_conclusion = formattedData.conclusion) === null || _formattedData_conclusion === void 0 ? void 0 : (_formattedData_conclusion_recommendations = _formattedData_conclusion.recommendations) === null || _formattedData_conclusion_recommendations === void 0 ? void 0 : _formattedData_conclusion_recommendations.accommodations)) {\n        formattedData.conclusion.recommendations.accommodationsList = formattedData.conclusion.recommendations.accommodations.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion1 = formattedData.conclusion) === null || _formattedData_conclusion1 === void 0 ? void 0 : _formattedData_conclusion1.recommendations) {\n        formattedData.conclusion.recommendations.accommodationsList = [];\n    }\n    if (Array.isArray((_formattedData_conclusion2 = formattedData.conclusion) === null || _formattedData_conclusion2 === void 0 ? void 0 : (_formattedData_conclusion_recommendations1 = _formattedData_conclusion2.recommendations) === null || _formattedData_conclusion_recommendations1 === void 0 ? void 0 : _formattedData_conclusion_recommendations1.facilitationStrategies)) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = formattedData.conclusion.recommendations.facilitationStrategies.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion3 = formattedData.conclusion) === null || _formattedData_conclusion3 === void 0 ? void 0 : _formattedData_conclusion3.recommendations) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = [];\n    }\n    // Convert parents array to string if needed\n    if (Array.isArray((_formattedData_header = formattedData.header) === null || _formattedData_header === void 0 ? void 0 : (_formattedData_header_studentInformation = _formattedData_header.studentInformation) === null || _formattedData_header_studentInformation === void 0 ? void 0 : _formattedData_header_studentInformation.parents)) {\n        formattedData.header.studentInformation.parentsString = formattedData.header.studentInformation.parents.join(', ');\n    } else if ((_formattedData_header1 = formattedData.header) === null || _formattedData_header1 === void 0 ? void 0 : _formattedData_header1.studentInformation) {\n        formattedData.header.studentInformation.parentsString = '';\n    }\n    // Add full student name for convenience\n    if ((_formattedData_header2 = formattedData.header) === null || _formattedData_header2 === void 0 ? void 0 : (_formattedData_header_studentInformation1 = _formattedData_header2.studentInformation) === null || _formattedData_header_studentInformation1 === void 0 ? void 0 : _formattedData_header_studentInformation1.firstName) {\n        formattedData.header.studentInformation.fullName = \"\".concat(formattedData.header.studentInformation.firstName, \" \").concat(formattedData.header.studentInformation.lastName || '');\n    } else if ((_formattedData_header3 = formattedData.header) === null || _formattedData_header3 === void 0 ? void 0 : _formattedData_header3.studentInformation) {\n        formattedData.header.studentInformation.fullName = 'Student';\n    }\n    return formattedData;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZG9jeC1nZW5lcmF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMEM7QUFDZDtBQUNRO0FBRXBDOzs7Ozs7O0NBT0MsR0FDTSxlQUFlRyx5QkFDcEJDLGNBQTJCLEVBQzNCQyxJQUF5QjtRQUN6QkMsaUJBQUFBLGlFQUF5QixlQUN6QkMsWUFBQUEsZ0RBQTBCLGdFQUFnRTtzQkFBckU7SUFFckIsSUFBSTtRQUNGQyxRQUFRQyxHQUFHLENBQUMsMERBQW9GLE9BQTFCTCxlQUFlTSxVQUFVLEVBQUM7UUFFaEcsb0RBQW9EO1FBQ3BELElBQUlILFdBQVc7WUFDYkMsUUFBUUMsR0FBRyxDQUFDLGtDQUFrQ0UsS0FBS0MsU0FBUyxDQUFDUCxNQUFNLE1BQU07WUFDekVHLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJMLGVBQWVNLFVBQVU7WUFDOUQsMkVBQTJFO1lBQzNFLE1BQU1HLGFBQWEsSUFBSUMsV0FBV1YsZUFBZVcsS0FBSyxDQUFDLEdBQUc7WUFDMURQLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUNPLE1BQU1DLElBQUksQ0FBQ0osWUFBWUssR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDO1FBQ3pIO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQ2xCLGtCQUFrQkEsZUFBZU0sVUFBVSxLQUFLLEdBQUc7WUFDdEQsTUFBTSxJQUFJYSxNQUFNO1FBQ2xCO1FBRUEsZ0ZBQWdGO1FBQ2hGLE1BQU1WLGFBQWEsSUFBSUMsV0FBV1YsZUFBZVcsS0FBSyxDQUFDLEdBQUc7UUFDMUQsSUFBSSxDQUFFRixDQUFBQSxVQUFVLENBQUMsRUFBRSxLQUFLLFFBQVFBLFVBQVUsQ0FBQyxFQUFFLEtBQUssSUFBRyxHQUFJO1lBQ3ZETCxRQUFRZ0IsS0FBSyxDQUFDLHdEQUF3RFIsTUFBTUMsSUFBSSxDQUFDSjtZQUNqRixNQUFNLElB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QUFrQixDQUFDc0UsUUFBUSxHQUFHO0lBQ3JEO0lBRUEsT0FBT2hCO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvc3JjL2xpYi9kb2N4LWdlbmVyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRG9jeHRlbXBsYXRlciBmcm9tICdkb2N4dGVtcGxhdGVyJztcbmltcG9ydCBQaXpaaXAgZnJvbSAncGl6emlwJztcbmltcG9ydCB7IHNhdmVBcyB9IGZyb20gJ2ZpbGUtc2F2ZXInO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZG9jeCBmaWxlIGZyb20gYSB0ZW1wbGF0ZSBhbmQgZGF0YVxuICogQHBhcmFtIHRlbXBsYXRlQnVmZmVyIC0gVGhlIGJpbmFyeSB0ZW1wbGF0ZSBmaWxlIGFzIGFuIEFycmF5QnVmZmVyXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIGluamVjdCBpbnRvIHRoZSB0ZW1wbGF0ZVxuICogQHBhcmFtIG91dHB1dEZpbGVuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gc2F2ZVxuICogQHBhcmFtIGRlYnVnTW9kZSAtIFdoZXRoZXIgdG8gZW5hYmxlIGV4dHJhIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGdlbmVyYXRlZCBmaWxlIGFzIGEgQmxvYlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVEb2N4RnJvbVRlbXBsYXRlKFxuICB0ZW1wbGF0ZUJ1ZmZlcjogQXJyYXlCdWZmZXIsXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIG91dHB1dEZpbGVuYW1lOiBzdHJpbmcgPSAncmVwb3J0LmRvY3gnLFxuICBkZWJ1Z01vZGU6IGJvb2xlYW4gPSB0cnVlIC8vIEVuYWJsZSBkZWJ1ZyBtb2RlIGJ5IGRlZmF1bHQgdG8gaGVscCBkaWFnbm9zZSB0ZW1wbGF0ZSBpc3N1ZXNcbik6IFByb21pc2U8QmxvYj4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIGNyZWF0ZSBQaXpaaXAgaW5zdGFuY2Ugd2l0aCBidWZmZXIgc2l6ZTogJHt0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlc2ApO1xuICAgIFxuICAgIC8vIE91dHB1dCBkZWJ1ZyBpbmZvcm1hdGlvbiBpZiBkZWJ1ZyBtb2RlIGlzIGVuYWJsZWRcbiAgICBpZiAoZGVidWdNb2RlKSB7XG4gICAgICBjb25zb2xlLmxvZygnRGF0YSBiZWluZyBwYXNzZWQgdG8gdGVtcGxhdGU6JywgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xuICAgICAgY29uc29sZS5sb2coJ1RlbXBsYXRlIGJ1ZmZlciBzaXplOicsIHRlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgLy8gTG9nIHRoZSBmaXJzdCAyMCBieXRlcyBvZiB0aGUgdGVtcGxhdGUgdG8gdmVyaWZ5IGl0J3MgYSBwcm9wZXIgRE9DWCBmaWxlXG4gICAgICBjb25zdCBmaXJzdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGVtcGxhdGVCdWZmZXIuc2xpY2UoMCwgMjApKTtcbiAgICAgIGNvbnNvbGUubG9nKCdGaXJzdCAyMCBieXRlcyBvZiB0ZW1wbGF0ZSAoaGV4KTonLCBBcnJheS5mcm9tKGZpcnN0Qnl0ZXMpLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJyAnKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIHRoYXQgd2UgaGF2ZSBhIHByb3BlciBidWZmZXJcbiAgICBpZiAoIXRlbXBsYXRlQnVmZmVyIHx8IHRlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0ZW1wbGF0ZSBidWZmZXI6IEVtcHR5IG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIGJ1ZmZlciBoYXMgYSBaSVAgc2lnbmF0dXJlIChmaXJzdCBieXRlcyBvZiBhIHByb3BlciBET0NYL1pJUCBmaWxlKVxuICAgIGNvbnN0IGZpcnN0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlci5zbGljZSgwLCA0KSk7XG4gICAgaWYgKCEoZmlyc3RCeXRlc1swXSA9PT0gMHg1MCAmJiBmaXJzdEJ5dGVzWzFdID09PSAweDRCKSkge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBaSVAgZmlsZSBzaWduYXR1cmUgaW4gdGVtcGxhdGUuIEZpcnN0IGJ5dGVzOicsIEFycmF5LmZyb20oZmlyc3RCeXRlcykpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdGVtcGxhdGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgdmFsaWQgWklQL0RPQ1ggZmlsZSAobWlzc2luZyBQSyBzaWduYXR1cmUpJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyBQaXpaaXAgaW5zdGFuY2Ugd2l0aCB0aGUgdGVtcGxhdGUgY29udGVudFxuICAgIC8vIFVzZSBhIHRyeS1jYXRjaCBzcGVjaWZpY2FsbHkgZm9yIHRoZSBQaXpaaXAgaW5zdGFudGlhdGlvblxuICAgIGxldCB6aXA7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnQgQXJyYXlCdWZmZXIgdG8gVWludDhBcnJheSB0byBlbnN1cmUgcHJvcGVyIGJpbmFyeSBoYW5kbGluZ1xuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlcik7XG4gICAgICB6aXAgPSBuZXcgUGl6WmlwKGFycmF5QnVmZmVyKTtcbiAgICB9IGNhdGNoICh6aXBFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgUGl6WmlwIGluc3RhbmNlOicsIHppcEVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBaSVAgZnJvbSB0ZW1wbGF0ZTogJHt6aXBFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gemlwRXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1BpelppcCBpbnN0YW5jZSBjcmVhdGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyBEb2N4dGVtcGxhdGVyIGluc3RhbmNlIHdpdGggaW1wcm92ZWQgZXJyb3IgaGFuZGxpbmdcbiAgICBsZXQgZG9jO1xuICAgIHRyeSB7XG4gICAgICBkb2MgPSBuZXcgRG9jeHRlbXBsYXRlcih6aXAsIHtcbiAgICAgICAgcGFyYWdyYXBoTG9vcDogdHJ1ZSxcbiAgICAgICAgbGluZWJyZWFrczogdHJ1ZSxcbiAgICAgICAgZXJyb3JMb2dnaW5nOiB0cnVlLFxuICAgICAgICBudWxsR2V0dGVyOiBmdW5jdGlvbihwYXJ0OiBhbnkpIHtcbiAgICAgICAgICBpZiAoIXBhcnQubW9kdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnQubW9kdWxlID09PSBcInJhd3htbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKCdEb2N4dGVtcGxhdGVyIGluc3RhbmNlIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgfSBjYXRjaCAoZG9jeEVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIERvY3h0ZW1wbGF0ZXIgaW5zdGFuY2U6JywgZG9jeEVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgTXVsdGkgZXJyb3IgKHdoaWNoIGNvbnRhaW5zIG11bHRpcGxlIGVycm9ycylcbiAgICAgIGlmIChkb2N4RXJyb3IgJiYgZG9jeEVycm9yLnByb3BlcnRpZXMgJiYgZG9jeEVycm9yLnByb3BlcnRpZXMuZXJyb3JzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdEb2N4dGVtcGxhdGVyIHJlcG9ydGVkIG11bHRpcGxlIGVycm9yczonKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExvZyBlYWNoIGluZGl2aWR1YWwgZXJyb3IgZm9yIGRlYnVnZ2luZ1xuICAgICAgICBkb2N4RXJyb3IucHJvcGVydGllcy5lcnJvcnMuZm9yRWFjaCgoZXJyb3I6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciAke2luZGV4ICsgMX06YCwgZXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEV4cGxhbmF0aW9uOiAke2Vycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcy5pZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgSUQ6ICR7ZXJyb3IucHJvcGVydGllcy5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLnh0YWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFRhZyB3aXRoIGVycm9yOiAke2Vycm9yLnByb3BlcnRpZXMueHRhZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLnBvc3RwYXJzZWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RlbXBsYXRlIHN0cnVjdHVyZSBhcm91bmQgZXJyb3I6Jyk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yLnByb3BlcnRpZXMucG9zdHBhcnNlZC5zbGljZShNYXRoLm1heCgwLCBlcnJvci5wcm9wZXJ0aWVzLm9mZnNldCAtIDUpLCBlcnJvci5wcm9wZXJ0aWVzLm9mZnNldCArIDUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhyb3cgYSBtb3JlIGRldGFpbGVkIGVycm9yXG4gICAgICAgIGNvbnN0IGZpcnN0RXJyb3IgPSBkb2N4RXJyb3IucHJvcGVydGllcy5lcnJvcnNbMF0gfHwge307XG4gICAgICAgIGNvbnN0IGV4cGxhbmF0aW9uID0gZmlyc3RFcnJvci5wcm9wZXJ0aWVzPy5leHBsYW5hdGlvbiB8fCAnVW5rbm93biB0ZW1wbGF0ZSBpc3N1ZXMnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIGVycm9ycyBkZXRlY3RlZDogJHtleHBsYW5hdGlvbn0gKFNlZSBjb25zb2xlIGZvciBmdWxsIGRldGFpbHMpYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBEb2N4dGVtcGxhdGVyOiAke2RvY3hFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZG9jeEVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBSZW5kZXIgdGhlIGRvY3VtZW50IHdpdGggdGhlIHByb3ZpZGVkIGRhdGFcbiAgICAgIGRvYy5yZW5kZXIoZGF0YSk7XG4gICAgICBjb25zb2xlLmxvZygnVGVtcGxhdGUgcmVuZGVyZWQgd2l0aCBkYXRhJyk7XG4gICAgfSBjYXRjaCAocmVuZGVyRXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVuZGVyaW5nIHRlbXBsYXRlOicsIHJlbmRlckVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgTXVsdGkgZXJyb3IgKHdoaWNoIGNvbnRhaW5zIG11bHRpcGxlIGVycm9ycylcbiAgICAgIGlmIChyZW5kZXJFcnJvciAmJiByZW5kZXJFcnJvci5wcm9wZXJ0aWVzICYmIHJlbmRlckVycm9yLnByb3BlcnRpZXMuZXJyb3JzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdEb2N4dGVtcGxhdGVyIHJlcG9ydGVkIG11bHRpcGxlIHJlbmRlciBlcnJvcnM6Jyk7XG4gICAgICAgIFxuICAgICAgICAvLyBMb2cgZWFjaCBpbmRpdmlkdWFsIGVycm9yIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgcmVuZGVyRXJyb3IucHJvcGVydGllcy5lcnJvcnMuZm9yRWFjaCgoZXJyb3I6IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBSZW5kZXIgRXJyb3IgJHtpbmRleCArIDF9OmAsIGVycm9yKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBMb2cgZGV0YWlsZWQgaW5mb3JtYXRpb24gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLmV4cGxhbmF0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFeHBsYW5hdGlvbjogJHtlcnJvci5wcm9wZXJ0aWVzLmV4cGxhbmF0aW9ufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMuaWQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEVycm9yIElEOiAke2Vycm9yLnByb3BlcnRpZXMuaWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcy54dGFnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUYWcgd2l0aCBlcnJvcjogJHtlcnJvci5wcm9wZXJ0aWVzLnh0YWd9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb2cgdGhlIGRhdGEgcGF0aCB0aGF0IGNhdXNlZCB0aGUgaXNzdWUgaWYga25vd25cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLnRhZykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVGVtcGxhdGUgdGFnOiAke2Vycm9yLnByb3BlcnRpZXMudGFnfWApO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmF3IHRhZzogJHtlcnJvci5wcm9wZXJ0aWVzLnJhd31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVGhyb3cgYSBtb3JlIGRldGFpbGVkIGVycm9yXG4gICAgICAgIGNvbnN0IGZpcnN0RXJyb3IgPSByZW5kZXJFcnJvci5wcm9wZXJ0aWVzLmVycm9yc1swXSB8fCB7fTtcbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSBmaXJzdEVycm9yLnByb3BlcnRpZXM/LmV4cGxhbmF0aW9uIHx8ICdVbmtub3duIHRlbXBsYXRlIHJlbmRlcmluZyBpc3N1ZXMnO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIHJlbmRlcmluZyBlcnJvcnM6ICR7ZXhwbGFuYXRpb259IChTZWUgY29uc29sZSBmb3IgZnVsbCBkZXRhaWxzKWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBpbmRpdmlkdWFsIERvY3h0ZW1wbGF0ZXIgZXJyb3JzIHdpdGggcHJvcGVydGllc1xuICAgICAgaWYgKHJlbmRlckVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3Byb3BlcnRpZXMnIGluIHJlbmRlckVycm9yKSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gcmVuZGVyRXJyb3IucHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgY29uc29sZS5sb2coJ0RldGFpbGVkIHJlbmRlciBlcnJvciBwcm9wZXJ0aWVzOicsIHByb3BzKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW1wbGF0ZSByZW5kZXIgZXJyb3I6ICR7cHJvcHMuZXhwbGFuYXRpb24gfHwgcmVuZGVyRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVuZGVyIHRlbXBsYXRlOiAke3JlbmRlckVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyByZW5kZXJFcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZW5lcmF0ZSB0aGUgb3V0cHV0IGRvY3VtZW50XG4gICAgbGV0IG91dHB1dDtcbiAgICB0cnkge1xuICAgICAgb3V0cHV0ID0gZG9jLmdldFppcCgpLmdlbmVyYXRlKHtcbiAgICAgICAgdHlwZTogJ2Jsb2InLFxuICAgICAgICBjb21wcmVzc2lvbjogJ0RFRkxBVEUnLFxuICAgICAgICBtaW1lVHlwZTogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50JyxcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coYE91dHB1dCBkb2N1bWVudCBnZW5lcmF0ZWQgc3VjY2Vzc2Z1bGx5ICgke291dHB1dC5zaXplfSBieXRlcylgKTtcbiAgICB9IGNhdGNoIChnZW5FcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBvdXRwdXQgZG9jdW1lbnQ6JywgZ2VuRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgb3V0cHV0OiAke2dlbkVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBnZW5FcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiBydW5uaW5nIGluIGJyb3dzZXIsIHNhdmUgdGhlIGZpbGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNhdmVBcyhvdXRwdXQsIG91dHB1dEZpbGVuYW1lKTtcbiAgICAgICAgY29uc29sZS5sb2coYEZpbGUgc2F2ZWQgYXMgJHtvdXRwdXRGaWxlbmFtZX1gKTtcbiAgICAgIH0gY2F0Y2ggKHNhdmVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgZmlsZTonLCBzYXZlRXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzYXZlIGZpbGU6ICR7c2F2ZUVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBzYXZlRXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZW5lcmF0ZURvY3hGcm9tVGVtcGxhdGU6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIElmIGl0J3MgYSBQaXpaaXAgZXJyb3IgKGxpa2VseSBpbnZhbGlkIHRlbXBsYXRlKVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3ppcCcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdQaXpaaXAgZXJyb3IgLSBpbnZhbGlkIHRlbXBsYXRlIGZpbGUgc3RydWN0dXJlJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIGZpbGUgaXMgbm90IGEgdmFsaWQgRE9DWC9aSVAgZmlsZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXRocm93IHRoZSBlcnJvclxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBmYWxsYmFjayBIVE1MIHJlcG9ydCB3aGVuIERPQ1ggdGVtcGxhdGUgZmFpbHNcbiAqIEBwYXJhbSByZXBvcnREYXRhIC0gVGhlIHJlcG9ydCBkYXRhIHRvIGV4cG9ydFxuICogQHJldHVybnMgQSBibG9iIHdpdGggSFRNTCBjb250ZW50XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRmFsbGJhY2tIdG1sUmVwb3J0KHJlcG9ydERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBCbG9iIHtcbiAgY29uc3Qgc3R1ZGVudE5hbWUgPSByZXBvcnREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5maXJzdE5hbWUgXG4gICAgPyBgJHtyZXBvcnREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZmlyc3ROYW1lfSAke3JlcG9ydERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5sYXN0TmFtZX1gXG4gICAgOiAnU3R1ZGVudCc7XG4gIFxuICAvLyBDcmVhdGUgYSBzaW1wbGUgSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVwb3J0XG4gIGxldCBodG1sID0gYFxuICAgIDwhRE9DVFlQRSBodG1sPlxuICAgIDxodG1sPlxuICAgIDxoZWFkPlxuICAgICAgPG1ldGEgY2hhcnNldD1cInV0Zi04XCI+XG4gICAgICA8dGl0bGU+UmVwb3J0IGZvciAke3N0dWRlbnROYW1lfTwvdGl0bGU+XG4gICAgICA8c3R5bGU+XG4gICAgICAgIGJvZHkgeyBmb250LWZhbWlseTogQXJpYWwsIHNhbnMtc2VyaWY7IG1hcmdpbjogNDBweDsgbGluZS1oZWlnaHQ6IDEuNjsgfVxuICAgICAgICBoMSwgaDIsIGgzIHsgY29sb3I6ICM0NDQ7IH1cbiAgICAgICAgLnNlY3Rpb24geyBtYXJnaW4tYm90dG9tOiAzMHB4OyB9XG4gICAgICAgIC5kb21haW4geyBtYXJnaW4tYm90dG9tOiAyMHB4OyBwYWRkaW5nOiAxNXB4OyBib3JkZXI6IDFweCBzb2xpZCAjZWVlOyB9XG4gICAgICAgIC5kb21haW4taGVhZGVyIHsgZGlzcGxheTogZmxleDsganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuOyBhbGlnbi1pdGVtczogY2VudGVyOyB9XG4gICAgICAgIC5jb25jZXJuIHsgY29sb3I6ICNmNTllMGI7IGZvbnQtc2l6ZTogMTRweDsgfVxuICAgICAgICAubm8tY29uY2VybiB7IGNvbG9yOiAjMTBiOTgxOyBmb250LXNpemU6IDE0cHg7IH1cbiAgICAgICAgdWwgeyBtYXJnaW4tdG9wOiA1cHg7IH1cbiAgICAgICAgQG1lZGlhIHByaW50IHtcbiAgICAgICAgICBib2R5IHsgbWFyZ2luOiAwLjVpbjsgfVxuICAgICAgICAgIC5kb21haW4geyBicmVhay1pbnNpZGU6IGF2b2lkOyB9XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG4gICAgPC9oZWFkPlxuICAgIDxib2R5PlxuICAgICAgPGgxPlJlcG9ydCBmb3IgJHtzdHVkZW50TmFtZX08L2gxPlxuICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb25cIj5cbiAgICAgICAgPGgyPlN0dWRlbnQgSW5mb3JtYXRpb248L2gyPlxuICAgICAgICA8cD48c3Ryb25nPkRPQjo8L3N0cm9uZz4gJHtyZXBvcnREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5ET0IgfHwgJ04vQSd9PC9wPlxuICAgICAgICA8cD48c3Ryb25nPlJlcG9ydCBEYXRlOjwvc3Ryb25nPiAke3JlcG9ydERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24/LnJlcG9ydERhdGUgfHwgJ04vQSd9PC9wPlxuICAgICAgICA8cD48c3Ryb25nPlJlYXNvbiBmb3IgUmVmZXJyYWw6PC9zdHJvbmc+ICR7cmVwb3J0RGF0YS5oZWFkZXI/LnJlYXNvbkZvclJlZmVycmFsIHx8ICdOL0EnfTwvcD5cbiAgICAgIDwvZGl2PlxuICBgO1xuICBcbiAgLy8gQWRkIGRvbWFpbnMgc2VjdGlvblxuICBpZiAocmVwb3J0RGF0YS5hc3Nlc3NtZW50UmVzdWx0cz8uZG9tYWlucykge1xuICAgIGh0bWwgKz0gYDxkaXYgY2xhc3M9XCJzZWN0aW9uXCI+PGgyPkFzc2Vzc21lbnQgUmVzdWx0czwvaDI+YDtcbiAgICBcbiAgICBPYmplY3QuZW50cmllcyhyZXBvcnREYXRhLmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnMpLmZvckVhY2goKFtkb21haW5OYW1lLCBkb21haW5dOiBbc3RyaW5nLCBhbnldKSA9PiB7XG4gICAgICBpZiAoZG9tYWluLnRvcGljU2VudGVuY2UgfHwgZG9tYWluLnN0cmVuZ3Rocz8ubGVuZ3RoIHx8IGRvbWFpbi5uZWVkcz8ubGVuZ3RoKSB7XG4gICAgICAgIGh0bWwgKz0gYFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJkb21haW5cIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJkb21haW4taGVhZGVyXCI+XG4gICAgICAgICAgICAgIDxoMz4ke2RvbWFpbk5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBkb21haW5OYW1lLnNsaWNlKDEpfSBMYW5ndWFnZTwvaDM+XG4gICAgICAgICAgICAgICR7ZG9tYWluLmlzQ29uY2VybiAhPT0gdW5kZWZpbmVkID8gXG4gICAgICAgICAgICAgICAgYDxzcGFuIGNsYXNzPVwiJHtkb21haW4uaXNDb25jZXJuID8gJ2NvbmNlcm4nIDogJ25vLWNvbmNlcm4nfVwiPiR7ZG9tYWluLmlzQ29uY2VybiA/ICdBcmVhIG9mIENvbmNlcm4nIDogJ05vIENvbmNlcm4nfTwvc3Bhbj5gIDogXG4gICAgICAgICAgICAgICAgJyd9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICR7ZG9tYWluLnRvcGljU2VudGVuY2UgPyBgPHA+JHtkb21haW4udG9waWNTZW50ZW5jZX08L3A+YCA6ICcnfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAke2RvbWFpbi5zdHJlbmd0aHM/Lmxlbmd0aCA/IGBcbiAgICAgICAgICAgICAgPGg0PlN0cmVuZ3Roczo8L2g0PlxuICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgJHtkb21haW4uc3RyZW5ndGhzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgPGxpPiR7aXRlbX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgYCA6ICcnfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAke2RvbWFpbi5uZWVkcz8ubGVuZ3RoID8gYFxuICAgICAgICAgICAgICA8aDQ+TmVlZHM6PC9oND5cbiAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICR7ZG9tYWluLm5lZWRzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgPGxpPiR7aXRlbX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgYCA6ICcnfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAke2RvbWFpbi5pbXBhY3RTdGF0ZW1lbnQgPyBgXG4gICAgICAgICAgICAgIDxoND5FZHVjYXRpb25hbCBJbXBhY3Q6PC9oND5cbiAgICAgICAgICAgICAgPHA+JHtkb21haW4uaW1wYWN0U3RhdGVtZW50fTwvcD5cbiAgICAgICAgICAgIGAgOiAnJ31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBodG1sICs9IGA8L2Rpdj5gO1xuICB9XG4gIFxuICAvLyBBZGQgcmVjb21tZW5kYXRpb25zXG4gIGlmIChyZXBvcnREYXRhLmNvbmNsdXNpb24/LnJlY29tbWVuZGF0aW9ucykge1xuICAgIGh0bWwgKz0gYFxuICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb25cIj5cbiAgICAgICAgPGgyPlJlY29tbWVuZGF0aW9uczwvaDI+XG4gICAgICAgICR7cmVwb3J0RGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9ucz8ubGVuZ3RoID8gYFxuICAgICAgICAgIDxoMz5BY2NvbW1vZGF0aW9uczo8L2gzPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICR7cmVwb3J0RGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9ucy5tYXAoKGl0ZW06IHN0cmluZykgPT4gYDxsaT4ke2l0ZW19PC9saT5gKS5qb2luKCcnKX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgICBgIDogJyd9XG4gICAgICAgIFxuICAgICAgICAke3JlcG9ydERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llcz8ubGVuZ3RoID8gYFxuICAgICAgICAgIDxoMz5GYWNpbGl0YXRpb24gU3RyYXRlZ2llczo8L2gzPlxuICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICR7cmVwb3J0RGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgPGxpPiR7aXRlbX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIGAgOiAnJ31cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cbiAgXG4gIGh0bWwgKz0gYFxuICAgICAgPGZvb3Rlcj5cbiAgICAgICAgPHA+PGVtPlRoaXMgaXMgYSBmYWxsYmFjayBIVE1MIHJlcG9ydCBnZW5lcmF0ZWQgYmVjYXVzZSB0aGUgRE9DWCB0ZW1wbGF0ZSBjb3VsZCBub3QgYmUgcHJvY2Vzc2VkLiBcbiAgICAgICAgWW91IGNhbiBwcmludCB0aGlzIEhUTUwgZmlsZSB0byBjcmVhdGUgYSBQREYuPC9lbT48L3A+XG4gICAgICA8L2Zvb3Rlcj5cbiAgICA8L2JvZHk+XG4gICAgPC9odG1sPlxuICBgO1xuICBcbiAgcmV0dXJuIG5ldyBCbG9iKFtodG1sXSwgeyB0eXBlOiAndGV4dC9odG1sJyB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzaW1wbGUgZW1wdHkgRE9DWCB0ZW1wbGF0ZSBwcm9ncmFtbWF0aWNhbGx5XG4gKiBUaGlzIGlzIGEgbGFzdC1yZXNvcnQgZmFsbGJhY2sgd2hlbiBhbGwgdGVtcGxhdGUgZmlsZXMgZmFpbCB0byBsb2FkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5VGVtcGxhdGUoKTogQXJyYXlCdWZmZXIge1xuICAvLyBEZWZpbmUgYSBtaW5pbWFsIHZhbGlkIERPQ1ggZmlsZSBzdHJ1Y3R1cmUgYXMgYSBiYXNlNjQgc3RyaW5nXG4gIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGVtcHR5IERPQ1ggZmlsZSB3aXRoIG1pbmltYWwgY29udGVudFxuICBjb25zdCBtaW5pbWFsRG9jeEJhc2U2NCA9ICdVRXNEQkJRQUJnQUlBQUFBSVFBOThFRXVUZ0VBQU9JQ0FBQUxBQUFBWDNKbGJITXZMbkpsYkhPa2tzRnF3ekFNUU8rRC9ZZlJ2VkZhR0lOaHV6Qkc3emIyQTR4c1RJdmIyWlRhVHZyM09aQ3dyUzVaR0xyYVNYejZBVW5rZXY3ejl1TmxrQ2F4ekRoNjFNQWdlY3NFMjlNVTNNRmp4K2xxK1N0eVNxWHV5MlZjMkpVYk1KeExGQmFsU1hNUXBKTGh3UFNONDFTU2RpMHhwczh2clIxb1ByU2JMdUFnd2x4QXFqa1RZbTNQOSsvL21mZlZRaEIwcmc1NXNhVWN5L01ZcXFCTFYvejFnK1NmNmk4cVhscnBlWU1Qc0lYcFgweEdibTdBZkNCeHo5SFhkQ0tYRXpqTjVYOE9oM1A2ZUJhTVovWUpyQXN3dk5heTFQTEZ4b2Q1SVFUbWFEUVNNdlpVaWRWckJ2OVhLalRTZWxUSlJ5WXpveWNCS0JISnhCYWU5SlRjc0tNcVhOWXYrMW9XenhmaXN3UVhvTUxYY1BoN1hma0dVRXNEQkJRQUJnQUlBQUFBSVFBQm50OGZSd0VBQU9ZRUFBQWNBQUFBZDI5eVpDOWZjbVZzY3k5a2IyTjFiV1Z1ZEM1NGJXd3VjbVZzYzdTVTMwckRNQkRHNzRQZEllUys2Y3FpMUhSZGlBcDdKYmdIMktRblcyeVRrS1RxM3Bza1hTdFRPOHAvTnczNVB0NzNKV1IxYzlQSFlnczVlNHdOTFV0VlFIUklQdllOZkg0OHJHNUFaQmF4Slk4UkFsOGcxbVJlUHIrdG50QVM1V0xPcy9WQkZFRHNZQVBXMnQxUzVZV0ZuckpTNzlBVjBHbnNLVk9kbTB6amwyekk5bFN2ZEwxV094Wm5QSUFaQk5WT0dzaFY3R3FRdWRoOEFLL2MyYVhRR3JxRHVQSVlqM2VRTUJ5aU5mZkVENVNaOHk2N3Vwams4UmwrY3VLN3VjUkRDUmtqcHNMNEpNVnh4dWM1aHVQQkZtRS83RzBoZk9KTFFPU2lHR3FVSUpubmxDNXA2NEV5eVlmVXFKbjNrVGh6aFZ6WURrTUpBa05Pdy8wc2ZnRlFTd01FRkFBR0FBZ0FBQUFoQU5aa3MxSDBBQUFBTVFNQUFCRUFBQUJrYjJOUWNtOXdjeTlqYjNKbExuaHRiSFBNa2sxUHd6QU1odTlJL0ljb2x3bGlJMmlsS3RadHdnbHBpTU9RMERndFdwdXNTUjFWL2ZmWVZEUUp3WW5MK1BYek9uWjJ1bXVWdUlNUHhya0NwVW1HRURobGNhWHJBbjI4YjhZcmhJTjJxalRhT1NqUUF3SmFsZmV6bmM5TjY3YjBKdDZjQjBJaUxoU29OeVkwR2NlUWUxQTJKRTZENUpjbUtCdmxHT3JlNDBDWlBiTTNwWGlWWlF1OHNVQ1ZEV09JYlVFTFhESWx2MEJ2Zjl6VzJHWnFCdVdJMkhzaS9KdmRieG5GeHZXR2lWK2FacVJJa2oyOW1KVkUzVlhRNDMwSlBZa1JKM0xNcWM3WTRLWExxS2RKa296NXFCK2NXcGttb2FKWTMzRDRGdFVYQmdHU01yMmtHWSsyYUh4ZE1wWEhGR1ZaUWZDbjl2K01aelBDWFR0VTEyN3ZMYTFkVlhNb0o5bkV2NXcycXo4cEt2bkpKNGwrZDU2ajhqK1VuVXVkWGwzVzIvSjFneTdISVlySHhXUTVDVlVmL0ZXK0FFYlI0VWRRY3VKL1RUNEJVRXNEQkJRQUJnQUlBQUFBSVFEVDVPUGg4Z29BQUxHVEFBQVRBQUFBVzBOdmJuUmxiblJmVkhsd1pYTmRMbmh0YkxXYVhXL2JPQmFHN3dmc2YxRG9lbTlsMmM2SGd6WXoyTWJKZElObUpoczdjMGVKdEVWRUpqV2tuSGgrL1ZJaVpWdUpRaE4xZk5FQ0JpMCtQUHdrOHZDaGZQT3Z1MnlhWFVWYjExVzVDT2JMUlpERnNxcnFTYmw3RWZ5NmY3UDVJY2pxblNncmtsYVg4U0s0ajNYd3IrZS8vdkxtOW1uZHhrd3NMK3RGME8vNzI5TmlVWmRkdkszTFpiV1BwY25rdFd4RmJYN0szYUlXOVYzY2JSZGIyOFd5V0p3MmkwbFpuZ1h2NDFpOHVLMHJrOEsyMjNKY3ZvblZOTmF6alZjeExrMWtLOWR4WHAwWDUrSSs3WXA2SXQrK1htZFpiNTkvdkNoM1g1UGJ1OHVwaU10bkpoMFR6bVpUL0diamYxeDR1M3ZBbTFUN2FiSTZLcTh2KzhEdVhMWUtjM1paMzlmcHVHNGtwZ1ZQeHRJa3VvemxxTXJubDZQN0w3YzVaMWNYMHcvMlg2TXpzK09UTW51VmJMVjJKYXJiblY1L1hKd3R5OFZsMWVYSmpyYmJ0ckcydjk1a1JTdHVnMnl6bVpsLzkyV1Z0dE9pS0hlaU41bFdsMnA2L2JMYjJ5VHZkdVVpS1BORjhPS3Fyc3M0N2VlSGI5cUxxcFc5RUsxcElFYTZEZE5TVWNuWll1OWxiSjdaalhXMWpjL2E3cVlSZFNVYjBkL0VQb3U3Sk9Wd1pOcU9vVU5YcTJvL3BTRjdJZlhEZnRIRWNtZnFGMlZzYnZsK3M5MU9kcTAzaGM2eUczTjFPOUZIVTdrd0xVUE9VdXV1RmQxVnYrMHpQeDVkNysvWGsva09nZFpKZnIxUHl2RzZEcWVvNVhMeGp6bERDWVA2eEorUURJNkJvenRmTG5PTzhQZ29qZ3dPOVM0M2Y5dFhoNy9lWXJnMkxmV3B6SmRqSFRKNkpDZU9LeU5wclMremwvUE54NUc0TXZkNFhNa0p6MHR4QlZ1L3NIcG5HOUl1L2lXTmNyVWNyYjNSZE81NGIyWWZySTZMaC96dzQrNkhHVi9HYlV3ZmZEQnVEdmxCWFJ5dnJsZkZvZU10N2U0L3pLTnlYdzhQdTlJY1ViWEwxeXpGdzl3WSs5M2pWdlRWWk53UkZ4bG1IK2EwYzNPS1JQcW9Vd3pYajUxaVg3WlhzUjhuU2ZSUjRHOW5Oek9PN1lmazF3OERkcjJPWlpuc2NxVXFadlBGdldnVGI1T1R4czlxR0crTngyc1oyOC9SajhaMVc4N1NpdTVuL1ZFL2ZXUlE5UHAySExTakwrTmswbXduMnpuR3dRRFhwcVp3VER2TXhqUGpiek1weWhrMy9tRnYrckpNL0RuSG1mYlNSVzlkSExkdGZ3ajBRNDd4OUVVZmVQVkdwUGk4VlhjcE9weVBxTFlYVng5cWNVYWlqY0UvS1ZFSHNKNWNqRlBDZm5KNWNUY2R4Mk9TRFhQS1F6WDJGYlY1UisrYVdNVkpkWFRBSmZuaW1EYWRCZzgwS3RRbmZKenBabktZM0gxTzBTZWllUFppUzZFdlIybk01bVBYYytVeExhZEJuQ2xTcnB3UVMyQTdndmw0WjZiUnFIekpYUXBNUWtyQ3JKZ1E1OHE1Zi90NmQ1c0xEc3ZVMXlST1FrckNMSndRNThycHZXM3Y3WHhtalpjbnZadHdIOWtHa0pJd3F6SWh6cFhidHZ1K3luWjNhWFhRQ1BzcTRaY3YzeHZRQmpDVHhQVjFRaHdDK0x6YXovSm1WLzRIczdLSEZ6eExhSU1rcVZkL0piUWhoSWVyVTIvenkvdCsyNWwza1lldW9xY1huTzNRQnBDU09MVkthRU1JRDFlbkhoYnE2Lzdxdk1xbTk0ZFRXRmN2ZExhR05vQWtjZXBWUWhzQytMeDYrSTdwSXVuRzd6Y1A0VjI5ME5rWjJnQlNFcWRXQ1cwSTRlSHExRHRyVE92YjhYM05OUUwzcklNVEtFbk4raUtoRFNGOFhKMTZiNjNKM00wVzFJNmQzbmtkMmlCSnpZMENRaHNDK0x4NllnVXpSSUt6MVJkV01HaURKSEZxbFVKSXpLdVRBWWVYa2M5K0ZPN29oYWVRYUFOSVNaeDhwbENESU8rZlF3NmpQRzNGa043K1F6eElrcHIxUlFvMUNQSis5Y1FTcGc4RFp5c3NwTXN3N09SRnJCUklrdFFzTHhLb1FRUWZWNmNlRmpFMkM1eXR0TWh1UjZrVTd1WkZMR0pJa3RRc0x4S29RUVFmVjZkKzhLNkp2Ylh0eExrSlBHeFEwM2NVejdab0EwaEpuSHlsVUlOQUhxK2VXTWJZZE83a1puWTdPdCtoRFNBbGNmS1ZRZzBDZWJ4NlloMWo4OERaNmdzN0dyUUJwQ1JPdmxLb1FTQ1BWKzhlM3Y3YU1xMDd1Ym5kRDM2RlFMSjFXcnRTcUVFZ2oxY2YzVUIzY1RkZjhuQ2RZUFppdzlzTmtpUjErNWQ2aVZubDFjTnc5YUEzMS9Na1hUSUpQOUk3ejFIUUJ0aVpwRzc5TnVZRWdhUWVWazVONC8xdHhYMDJQYmJUejFNTkxBM3ZPVWlXUkdyWHVCUEVrdnF4R3hCSFBVaUtwbjdVUWtGSVpsSzd4cDBnbHRSUExFcUdnWEMydXNUU1dpQ3BXZU1Pa0V2cWlXWEpNQkZjcnU2K2h4UllHdDZDQUtSbWpUdEFMcWtubGlYRFJIQzZ1c1Q2V2lDcFdlTU9rRXZxaVdYSk1CRmNycjU2V0Y3a0VzSDEyd3RxcFlDeXBFNnQ4WGRCQUo5WFQzdzQ2YVF1L3paK1AvN3hOTllKUHIxQTN3VllsdFNwN2V3RkFYeGVQZkY1YWVaZG5QM205SnZ1cE42ZlR5UHZIcjA3Umo5QkRSSzdOYytTQndqbTFqN3h2V2xXcEdjMzJHMW5UdEgrYm5Ydzd1SGRNWG94QWhLN05jK1NCd2ptMWo3eHptbm90VWZGSkN2djAybEp6ZWRwM3ZUbWFIWlJqOS9zb0VEaTFLbDVsanhBTUxQMjRYUFQvYllhanRtRm1BNmQrVERSTURoOGE0d0NpYjE2MDhvMDFoSDh2THBMcW9hRy9EWWJlaEw0ZE1QSjIwTVVTQnc2dFowOUlvQTc3L0IxLzNBeFRPQ1B0dzFucnc5UklISG8xTHplSXNKNGMwOS9MZm04dS9rMUd4N0pwM25EMmZ0M0ZFZ2NPald2dDRndzN0ejljSksxWTRQNGZrVDFYR2x1RUZBZ3NWZnZXcG5HT29LZlY4OCtuSmpBdzNUMjlMMGlDaVFPblpyWFcwUVliKzU0T0srdmZqeGZGK3ZwL2xQMjRCYzhjamg3SDRjQ2lVT241dlVXRWNhYmUrS2I5ZFhSamNYVnpmakhLUjZtY21mdjQxQWdjZWpVdk40aXduaHpMeDV1S0hyUlgreUdoNHM2bTViRHIvRGs1M204N2NlSlBOU0ducnhuU1lIRW9WTzdFVVdFY2VZZXVkeFA5T1hod2NkSzdPdEpkWnNOWmVMN1RjR1JuOTNnN0VWR0NpcjJhcDNheGtlRThlWWU1ejNoMmRXaDFrL0s3RDhTbGZnZitkbk40ZXdsU2dvcTltcWQyc1pIaFBIbWZuU3QvOGpmWDE1ZlhHL2QzejU4WFlzNi8zeXlBYzF6OHVQeU5qNWZZT0ZUVUJ2TW4vOEhVRXNEQkJRQUJnQUlBQUFBSVFCbWhiNnR5d01BQURvTkFBQVBBQUFBZDI5eVpDOXpkSGxzWlhNdWVHMXNwSmJiYnRzd0RJYnZCK3c5Q04xblNwckdhWUxXV1pBbTYyWFFyb3ZhZGpjd050c1Jwa09HcENUTjIrL0l5Y214QzFUdFJhSkkvdncrRXA0dlAvWlM4SzJ4bG1zMUkvR1FFYzZVMEhXcmRqZU0vSHhZQkJQQ3JhTlZTNFZXWmtZT3hwSVBzNjlmNXUxQld1Mk40UllqREsxbXRMRnVkNVVrVmpSR1VqdlVPNlBnUzZPTnBBNUVzMHRhamRhNkMxS3BrekVqVjhuWGIxa040YXZYR2l6NXZsVUwxZEdOTmtKWUhkcnlWQm1JYnJrd0hPelpwREhDUnhNSm5aZ1FYeE1sK2JPNW4zSGV3VDVlcEx1ZllydmZUUlNObjBFOUlQanAydnhPL2UrcnA3dDNtTE4weDg1NGNIVlY3bXc2TnRwSDE1YkZXb21WTnA3NHdZaUwxSkY3d3kvRjN0WTY4eVRYb3ZNVmJtKzFVVStCYUd4N2g2NU5heDhiWjBVL0Y2V2d6cG95WWlSSVFySWdUa2hhSkhIQlY1dm1uQ3FPRmtHU3pOTXNMOUppbVljSkwxNks4REpKWUkwc0RZSjR2ZzdEVlRLUGkwV3hLTkkwWGlUSllyWEtpalNPbDJtUnBrWHhEcHpMbGZackpRNnFoZGdYZW5Nd1Q0aDg4ZVU4blJySUhpSi8zSEUyZFhBSS9MSFRxNm1EdytpUC9UWjFNSWo5TVozdWpZU3AzTzZCdXB2UkdMcTlJSXFzTEtRUEx0QkZxZjFyWi9IRFhQOHpOenhiMHhhMUowK1NrWnNtTmhWTlRZMGsxK1JNdzAvT3o2MkMrQVF2UGRqSEVnMFpQNzFsU1FxbkR3WjloN0FaZVZndmtoekwwYUh6RERtNnI4ZzdKS21wY1plYXdWcFBLN3dBL0tJelREVmR2NHBLblYyekZwQ1ZxVnZiMzdPMFcwTW5oR2FFMTl5U0RWSzRSYjVYajd6MjJjSlh1dU1WMXJqbVcvRTRrYzBadGNOcEwwZ1R3ZjJ6ME1GRVk1cjNyTGREbHAyWndZNktUQllXN0pwandYWEhvVkRCdG1tZ1F3QTZGZ0xjWlBkMEM5T1B2ZE1XL250Y2F5RmNJK0dYZTRPajVBSGpHemYyKzY3RlhydURYbm5nTDdVdzllYU9tblpRYjA4a3pqdDdRU1p2b1E5dkpvL01kTTJ4VUdxSmRFVmE5VFFkdlFVWXBCaGlKZ3puMEJkR1AzRU8vOVZPMkgxMWpDeEhFNmtOVE5mN0Raa0xqWTI3TVhaVHR6dGw4UlBaOWVJQmpUSFVPSFBkZ3RrZHc5UllSUmJQMEpmSVhXZE9RNHhSUGVCOXJPSHFtcUp3OXVDN2dObjBCMEUrQjJHZzB3M2RhamRVTXJ3QzUvSndoZ05sY0F3L0d2VnNPN2dwd2pUTjhtTXZoS1hjcTBjNFFMQk1SL000Q1ZZL0I5TTBLWlpKOFhZdzNKLysvbFh5MmQ0UThRTHY5N0ExWUsvQmxkUktxVHpNNGp6Tzh1SitwMmtPRHhDeDVSc29wVy9HMEErSCs0TVdlUHRDYk9DdUtSKzFnUXZrYkZSNmI2RUpRRExETFpFUFR2MEJVRXNEQkJRQUJnQUlBQUFBSVFBNnFCQ0V1UVlBQURRYkFBQVJBQUFBZDI5eVpDOWtiMk4xYldWdWRDNTRiV3kwV050dTJ6Z1FmUy9RZnlEMDNqcHhia2lkaUVsYlpMUFpvbGh2UDBDV21GaUlMSUtVNCtUdk8wTktkcDN1TnNnKzFKQkZjY2lkbVRObk9PcnJsL3Y3eFBJVVZjV2sySmlEZnRkeUNXU29JaWJpalhuejQySm5ZMWxWRG9ub1hVcGNHL05jeXVybHpkZGYvejJJcTFoVkhFV0ZySENSRy9PK3F0TE5WcXRrZmpHd3VyU2w1MVo4K3JrL0huVHQ1OG50OXJ2RG0wSi93TFRhZHIrMy9sKzBDWSt1eUMyTzNtVUJ4WWs4NWdrVmhUNGtERm1LWW9ZRHZacEZlY1oxTW5QQ2s5RjN6Z0szRDJGemFSVVhmL1k5TjlNL3Z0WDV3OWNqZGpROHNaZW9DcG5YRDBsSDZnOFRsWEw5V1hwWllJK0Q0WWFLVWE5dmpicWU5UzV2RXpoOHpiL0pKRWtsMUdjWCtoMnpmTWZybUJXblcxWWRhYVRERmp0MVY2MkxrWEpWWkxKTVdhRFhEdnM5eTJOamZiVnUrYUZYWDY4ZHpCRjFHYVNkbU1aMHNPdDVwOTFVc2p5bWdjUUo1NmJqOWM1Y09na1VGUkV2VkIzU3dhM1lKUnpIYk5jdkNVZXhBKzNhLytQRUNSR2xURUl1R2RQTDJjaGhPKy9NWGdLZHZqT2J1ZVRuOHB1LzVmS3cyK251N3U1dUc2dlB1ODdPZzJsbnB6L283WDUvUDl2Um9SNUR4ZTRQQ0RHK3I4VzlVWkdkSHlhWDZSSGJ2em81djVyZG5wM05ycWJqbXpGY1hZMm41MmZubDVPcm84bnNmekZZUUNuekczbDl4U0t4cVhvaGhJem56OEtuNjZxMlp6ZkVaUnIybVdhWjBuKzdPQkxCYk14dXVuTFV4bDNDMWJ3K1l2TFB4Z2szTEhPdU5QdTB3RGxmRlNVSlZaeHBwcnFqcXhKcEl1UVRMMkpaYVBKdW9MWXhCNzFCcDc4eGcvNVFqNU9VWlhEa0hONWNucnhPS1M0UzJiUzhZNUZLQkxtUFQzK284cERraDVMNXhlek1IY2ZSM1IvejJmbVYrL3YwZW5lMFU0ZUNQbTh5dlR0NWNuVnhEOU4wdFZpcG53cE5Tcll6dHpRZFJReFZjdytKa0ZXWVBPWEtDZElpNFZXNDB2SGtWa2FoTzZwQ3FtTEpDMXJXenA1M3BBVVFya1FZTzJ3VmE5NEpiRlhlcS9rNFg5RDBZWFlhM1htbmdmM0Z3NWZXSFgwNy92WitkSFI1WU84L2gwVHZSdTlIbDhING56KysrNGYyRCtkL1B3YW5QT1pGeGZJcWQ1SjBKWG51VU5FWFZXVitZcEd6S2ozM2dEdU9xUWlwZHZNOGUwTnBlNGJNTTNmUFJjZy94YktvOWkwb0xQTUpsN2xhUHdxWnFnQWhscWpsTnhWVjJWSi9LUm1tQkt0bSt5cW1MQXFLdGJuUld5N1RsY2ZTSDNSbURpV2dJTFFJcVRxTTZ5blRuNW1MTVJnekZ6OWtSRkdJYzFnOW9NekJwOHlCMExtRmk2SjRwOTR6Uy92TmMrWFdzK1FKSlVtR2Q1eFVqajFRY0pEcVlJMlZCaXBTWEJ3dlVoYnFsS21McHlMMXNGMDVXWlFVSjAwVmdFaXBpaGhVSktBWkRRbWl0Tm1EbE9sMHhtSVhiZnBTSnJwZFEwdUxuWVphMVlrMFU2VWlzMVd0c2FyVEdlNjJ5ckNtSlZ2V09pdWFNWE0xWjlyQUZ3K0lxdERxZUwzVno2Nlk5U3laOC91V0IxK3Q5cVZZRFJXbEhNcGpRdFZvWGRFRVU4NUtielMwRzVkTEt0UFdpR2dmUWJ4c0gvRVZPalFoemJRdFdQUWFKTG40MERUUFhLZEJKVWZQd05xNUdrYjY0NGZVWlVTVDdtVnZFem1USkpGS3JiWE15L3lCUERwWFVMTEtTZ1V4THBKRm5FZE1CS1h1MExvbDlSQ24rUUpsSUNGc1laNVZNWlJWeVhYdUc5Q1FzbnVDYVFVZytxS2R5UW5SeGFxditxZkxZRkJHYUF6V3lNc0pRMU4wcTZvckxkN1dLaExhd2piQ2ZiWExvbE05Um51S3JUeWxzS05NMTJxOVJkUzdHVVR4Vm5xcFZaRnJWY09sRDBsMmpVcUNZMGZFWWk1aDdQNktnMloxdytTbTFxRkp6UEZUbUZRNGtSTU83VWIxeGJacTFCZmJhTklYZThBWE8yd0tjbU4ycXpXVjVWR3JKVnpNWlJFTGJmSE4xMUZmeVkrUGpDL1l4dTZwS0dYZFhXOWxKVHIwblc5ZDBEekpPcVlKYloxTG5yTEdwWkVyM2hYaHZHMnZOQWk5Wk5GeEExclFVelVjNkhadExScWdOUHdEMXozMTBabk95RkV0R1FVMGdFV21HanlFdU1kVk4wZ0tzc1ROdmhrVmpPTENza0QzSTM5VkVYZmJZNHBOMTNsUUxVdUpUWGdUak40cFIvTy9sMU04YlZPb1J4cnpBOHNDNWQ2blBHREVIRUJCOXlOV0ZHTXRFMVM2RjU2cHhWbUtDNy9EdXFTdjlHbFNZVE5KbFRiMXNJcWZFWXo0UnVISVR3NUY0Q20vT0JQNUhGSGdDcUZiQWNYR1RYZlE3YStxT2FUZGgvUjZHdEsxMENLc3lMMXZiY0huOGpEUWVFeUFhSHYzL3R3RkRmL0ZJNFlsRHlod2pRV3BmVmhqM2RLd09iN0ZFK0pZM0tBOTFWcDdPL1FHTW5KUmJQSkwxRFpzNmkzc09YV25GazRxOEpDcE5lM00yWEZNdERrbTNlOVFucnk2NHBSR0R4VG1Nb3E1dE5RaFBMQVl6RExOOUxUR2JxVHZLQnhNTkFrL0l6U1E1T1lmVUVzREJCUUFCZ0FJQUFBQUlRQlBRSUZucGdJQUFMSUdBQUFjQUFBQWQyOXlaQzlmY21Wc2N5OXpaWFIwYVc1bmN5NTRiV3d1Y21Wc2N5MlUyMjdiTUJCRlh3ZjBId1M5TzdybElzYWdLQkxZeUxwQm02QWZRRWlVSkp1WGdxVHN1UDllbEhTVHR4bk9IbkptWjhobkw3OWw2MzFQYlV3eFY2WlFtbG1wSThaTnJrd3VlWHIrOS9qYktsMyt2YkhpM0hLaFRUSG5hdnNMRXNudGJoemFJUWtCRjlPRlVWWFpORUlZWHl1djQyS3N2ZXBqend4NmI2SHJzS25XcG1wQTdIUlp5S2RLcmFXVW5KcFFwQmEwTU9XVVk3VlZGZjF0SkRlUnpiRTA2SlhrVEJXMVVsTEdQWFZwTlF4RE1mQXU5aHZ3ZDNIRE1CK2o0U0hvNG9Nc0Q5L1FUMEJXTEM1VzdZRFFXcW5FaFFmaldtbTJWZ3BOZTNEQmEyVmNxUmlHVVZDTUg0eXZzTlFtaE9Ed3JmQmtYQ0Y3TUJWa01DVnlCeGRNeHNSNEFuY0FINHlMSmVSUllEeDRZYXlLTXJxRmNSK1YrdUcwcElyVEk3WEw1dlBvR1VmUDlvUFRuNmU5K1BLUHpmNEFVRXNCQWkwQUZBQUdBQWdBQUFBaEFEM3dRUzVPQVFBQXppWUFBQXNBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRjl5Wld4ekx5NXlaV3h6VUVzQkFpMEFGQUFHQUFnQUFBQWhBQUdlM3g5SEFRQUF6UVFBQUJ3QUFBQUFBQUFBQUFBQUFBQUFrUVFBQUhkdmNtUXZYM0psYkhNdlpHOWpkVzFsYm5RdWVHMXNMbkpsYkhOUVN3RUNMUUFVQUFZQUNBQUFBQ0VBMW1TelVmUUFBQUF4QXdBQUVRQUFBQUFBQUFBQUFBQUFBQUFDQmdBQVpHOWpVSEp2Y0hNdlkyOXlaUzU0Yld4UVN3RUNMUUFVQUFZQUNBQUFBQ0VBMCtUajRmSUtBQUN4a3dBQUV3QUFBQUFBQUFBQUFBQUFBQUFzQlFBQVcwTnZiblJsYm5SZlZIbHdaWE5kTG5odGJGQkxBUUl0QUJRQUJnQUlBQUFBSVFCbWhiNnR5d01BQURvTkFBQVBBQUFBQUFBQUFBQUFBQUFBQUY4VEFBQjNiM0prTDNOMGVXeGxjeTU0Yld4UVN3RUNMUUFVQUFZQUNBQUFBQ0VBT3FnUWhMa0dBQUF2SGdBQUVRQUFBQUFBQUFBQUFBQUFBQUJURndBQWQyOXlaQzlrYjJOMWJXVnVkQzU0Yld4UVN3RUNMUUFVQUFZQUNBQUFBQ0VBVDBDQlo2WUNBQUMzQmdBQUhBQUFBQUFBQUFBQUFBQUFBQUJTSGdBQWQyOXlaQzlmY21Wc2N5OXpaWFIwYVc1bmN5NTRiV3d1Y21Wc2MxQkxCUVlBQUFBQUJ3QUhBUDBCQUFCV0lnQUFBQUFBJztcbiAgXG4gIC8vIENvbnZlcnQgYmFzZTY0IHRvIEFycmF5QnVmZmVyXG4gIGNvbnN0IGJpbmFyeVN0cmluZyA9IHdpbmRvdy5hdG9iKG1pbmltYWxEb2N4QmFzZTY0KTtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIFxuICByZXR1cm4gYnl0ZXMuYnVmZmVyO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmVwb3J0IGRvY3ggZnJvbSB0aGUgcmVwb3J0IGRhdGFcbiAqIEBwYXJhbSByZXBvcnREYXRhIC0gVGhlIHJlcG9ydCBkYXRhIGZyb20gdGhlIGFwcGxpY2F0aW9uXG4gKiBAcGFyYW0gdGVtcGxhdGVCdWZmZXIgLSBUaGUgYmluYXJ5IHRlbXBsYXRlIGZpbGUgYXMgYW4gQXJyYXlCdWZmZXIgKG9wdGlvbmFsKVxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGdlbmVyYXRlZCBmaWxlIGFzIGEgQmxvYlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVSZXBvcnREb2N4KFxuICByZXBvcnREYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICB0ZW1wbGF0ZUJ1ZmZlcj86IEFycmF5QnVmZmVyXG4pOiBQcm9taXNlPEJsb2I+IHtcbiAgLy8gR2VuZXJhdGUgdGhlIGZpbGVuYW1lIGJhc2VkIG9uIHJlcG9ydCBkYXRhXG4gIGNvbnN0IHN0dWRlbnROYW1lID0gcmVwb3J0RGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbj8uZmlyc3ROYW1lIFxuICAgID8gYCR7cmVwb3J0RGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmZpcnN0TmFtZX1fJHtyZXBvcnREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ubGFzdE5hbWV9YFxuICAgIDogJ3N0dWRlbnQnO1xuICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcbiAgY29uc3QgZmlsZW5hbWUgPSBgJHtzdHVkZW50TmFtZS5yZXBsYWNlKC9cXHMrL2csICdfJyl9X3JlcG9ydF8ke3RpbWVzdGFtcH0uZG9jeGA7XG4gIFxuICB0cnkge1xuICAgIC8vIElmIG5vIHRlbXBsYXRlIGJ1ZmZlciBpcyBwcm92aWRlZCwgdXNlIGEgZGVmYXVsdCB0ZW1wbGF0ZVxuICAgIGlmICghdGVtcGxhdGVCdWZmZXIpIHtcbiAgICAgIC8vIFVzZSBmZXRjaCB0byBnZXQgdGhlIHRlbXBsYXRlIGlmIHdlJ3JlIGluIHRoZSBicm93c2VyXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnTm8gdGVtcGxhdGUgYnVmZmVyIHByb3ZpZGVkLCBmZXRjaGluZyBkZWZhdWx0IHRlbXBsYXRlJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIHVzZSByZXNwb25zZS5hcnJheUJ1ZmZlcigpIHdoaWNoIGVuc3VyZXMgYmluYXJ5IGRhdGEgaGFuZGxpbmdcbiAgICAgICAgICAvLyBVc2UgbGFzLWFzc2Vzc21lbnQtcmVwb3J0LXRlbXBsYXRlLmRvY3ggaW5zdGVhZCBvZiByZXBvcnQtdGVtcGxhdGUuZG9jeCAod2hpY2ggaXMgYSB0ZXh0IGZpbGUsIG5vdCBhIERPQ1gpXG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL3RlbXBsYXRlcy9sYXMtYXNzZXNzbWVudC1yZXBvcnQtdGVtcGxhdGUuZG9jeCcsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBjYWNoZTogJ25vLWNhY2hlJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGRlZmF1bHQgdGVtcGxhdGU6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZygnRGVmYXVsdCB0ZW1wbGF0ZSBmZXRjaGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICAgIHRlbXBsYXRlQnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRGVmYXVsdCB0ZW1wbGF0ZSBidWZmZXIgc2l6ZTogJHt0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgIGlmICh0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgdGVtcGxhdGUgZmlsZSBpcyBlbXB0eScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBWZXJpZnkgdGhlIHRlbXBsYXRlIGhhcyBhIHByb3BlciBET0NYIHNpZ25hdHVyZVxuICAgICAgICAgIGNvbnN0IGZpcnN0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlci5zbGljZSgwLCA0KSk7XG4gICAgICAgICAgaWYgKCEoZmlyc3RCeXRlc1swXSA9PT0gMHg1MCAmJiBmaXJzdEJ5dGVzWzFdID09PSAweDRCKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBET0NYIGZpbGUgc2lnbmF0dXJlIGluIGRlZmF1bHQgdGVtcGxhdGUuIEZpcnN0IGJ5dGVzOicsIEFycmF5LmZyb20oZmlyc3RCeXRlcykpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IHRlbXBsYXRlIGlzIG5vdCBhIHZhbGlkIERPQ1ggZmlsZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGRlZmF1bHQgdGVtcGxhdGU6JywgZXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZSBhcyBhIGxhc3QgcmVzb3J0XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGxvYWQgYWx0ZXJuYXRpdmUgdGVtcGxhdGU6IGxhcy1hc3Nlc3NtZW50LXJlcG9ydC10ZW1wbGF0ZS1maXhlZC5kb2N4Jyk7XG4gICAgICAgICAgICBjb25zdCBhbHRSZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvdGVtcGxhdGVzL2xhcy1hc3Nlc3NtZW50LXJlcG9ydC10ZW1wbGF0ZS1maXhlZC5kb2N4Jywge1xuICAgICAgICAgICAgICBjYWNoZTogJ25vLWNhY2hlJyxcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICAgICAgICAgICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLWNhY2hlJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFhbHRSZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZTogJHthbHRSZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRlbXBsYXRlQnVmZmVyID0gYXdhaXQgYWx0UmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBBbHRlcm5hdGl2ZSB0ZW1wbGF0ZSBidWZmZXIgc2l6ZTogJHt0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIGFsdGVybmF0aXZlIHRlbXBsYXRlXG4gICAgICAgICAgICBjb25zdCBhbHRGaXJzdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGVtcGxhdGVCdWZmZXIuc2xpY2UoMCwgNCkpO1xuICAgICAgICAgICAgaWYgKCEoYWx0Rmlyc3RCeXRlc1swXSA9PT0gMHg1MCAmJiBhbHRGaXJzdEJ5dGVzWzFdID09PSAweDRCKSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIERPQ1ggZmlsZSBzaWduYXR1cmUgaW4gYWx0ZXJuYXRpdmUgdGVtcGxhdGUnKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHRlcm5hdGl2ZSB0ZW1wbGF0ZSBpcyBub3QgYSB2YWxpZCBET0NYIGZpbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH0gY2F0Y2ggKGFsdEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGFsdGVybmF0aXZlIHRlbXBsYXRlOicsIGFsdEVycm9yKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXMgYSBsYXN0IHJlc29ydCwgY3JlYXRlIGEgbWluaW1hbCB2YWxpZCBET0NYIHRlbXBsYXRlXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbWluaW1hbCBlbXB0eSBET0NYIHRlbXBsYXRlJyk7XG4gICAgICAgICAgICB0ZW1wbGF0ZUJ1ZmZlciA9IGNyZWF0ZUVtcHR5VGVtcGxhdGUoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIG1pbmltYWwgdGVtcGxhdGUgd2l0aCBzaXplOiAke3RlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghdGVtcGxhdGVCdWZmZXIgfHwgdGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBBbGwgdGVtcGxhdGUgYXR0ZW1wdHMgZmFpbGVkLCBmYWxsIGJhY2sgdG8gSFRNTFxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsbCB0ZW1wbGF0ZSBhdHRlbXB0cyBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNlcnZlci1zaWRlIGhhbmRsaW5nIHdvdWxkIGJlIGRpZmZlcmVudFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RlbXBsYXRlIGJ1ZmZlciBpcyByZXF1aXJlZCB3aGVuIHJ1bm5pbmcgb24gc2VydmVyJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IGFuZCBwcmVwYXJlIGRhdGEgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgIGNvbnN0IGZvcm1hdHRlZERhdGEgPSBmb3JtYXRSZXBvcnREYXRhRm9yRG9jeChyZXBvcnREYXRhKTtcbiAgICBjb25zb2xlLmxvZygnRGF0YSBmb3JtYXR0ZWQgZm9yIERPQ1ggdGVtcGxhdGUnKTtcblxuICAgIC8vIEdlbmVyYXRlIHRoZSBkb2N1bWVudFxuICAgIHJldHVybiBhd2FpdCBnZW5lcmF0ZURvY3hGcm9tVGVtcGxhdGUodGVtcGxhdGVCdWZmZXIsIGZvcm1hdHRlZERhdGEsIGZpbGVuYW1lKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZW5lcmF0ZVJlcG9ydERvY3g6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciB3aXRoIHRoZSB0ZW1wbGF0ZSBvciBkb2N4dGVtcGxhdGVyLFxuICAgIC8vIHRyeSB0byBnZW5lcmF0ZSBhIGZhbGxiYWNrIEhUTUwgcmVwb3J0XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgXG4gICAgICAgIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd6aXAnKSB8fCBcbiAgICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3RlbXBsYXRlJykgfHwgXG4gICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdkb2N4dGVtcGxhdGVyJykpKSB7XG4gICAgICBcbiAgICAgIGNvbnNvbGUud2FybignRE9DWCBnZW5lcmF0aW9uIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIEhUTUwgZXhwb3J0Jyk7XG4gICAgICBjb25zdCBodG1sQmxvYiA9IGdlbmVyYXRlRmFsbGJhY2tIdG1sUmVwb3J0KHJlcG9ydERhdGEpO1xuICAgICAgY29uc3QgaHRtbEZpbGVuYW1lID0gYCR7c3R1ZGVudE5hbWUucmVwbGFjZSgvXFxzKy9nLCAnXycpfV9yZXBvcnRfJHt0aW1lc3RhbXB9Lmh0bWxgO1xuICAgICAgXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2F2ZUFzKGh0bWxCbG9iLCBodG1sRmlsZW5hbWUpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gaHRtbEJsb2I7XG4gICAgfVxuICAgIFxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IHRoZSByZXBvcnQgZGF0YSBmb3IgZG9jeCB0ZW1wbGF0ZSByZW5kZXJpbmdcbiAqIEBwYXJhbSByZXBvcnREYXRhIC0gVGhlIHJhdyByZXBvcnQgZGF0YSBmcm9tIHRoZSBhcHBsaWNhdGlvblxuICogQHJldHVybnMgRm9ybWF0dGVkIGRhdGEgcmVhZHkgZm9yIGRvY3ggdGVtcGxhdGVcbiAqL1xuZnVuY3Rpb24gZm9ybWF0UmVwb3J0RGF0YUZvckRvY3gocmVwb3J0RGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAvLyBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgdGhlIHJlcG9ydCBkYXRhXG4gIGNvbnN0IGZvcm1hdHRlZERhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlcG9ydERhdGEpKTtcblxuICAvLyBGb3JtYXQgYXJyYXlzIHRvIGJlIG1vcmUgZG9jeC10ZW1wbGF0ZSBmcmllbmRseVxuICAvLyBBcnJheXMgaW4gZG9jeHRlbXBsYXRlciBhcmUgdHlwaWNhbGx5IGhhbmRsZWQgd2l0aCBsb29wcywgc28gd2UnbGwgZm9ybWF0IHRoZW1cbiAgLy8gdG8gYmUgcmVhZHkgZm9yIHRoZSB0ZW1wbGF0ZSBzeW50YXhcblxuICAvLyBQcm9jZXNzIHN0cmVuZ3RoIGFuZCBuZWVkcyBsaXN0cyBmb3IgZWFjaCBkb21haW5cbiAgT2JqZWN0LmtleXMoZm9ybWF0dGVkRGF0YS5hc3Nlc3NtZW50UmVzdWx0cz8uZG9tYWlucyB8fCB7fSkuZm9yRWFjaChkb21haW4gPT4ge1xuICAgIGNvbnN0IGRvbWFpbkRhdGEgPSBmb3JtYXR0ZWREYXRhLmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXTtcbiAgICBcbiAgICAvLyBGb3JtYXQgc3RyZW5ndGhzIGFzIGJ1bGxldCBwb2ludHMgZm9yIERPQ1hcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkb21haW5EYXRhLnN0cmVuZ3RocykgJiYgZG9tYWluRGF0YS5zdHJlbmd0aHMubGVuZ3RoID4gMCkge1xuICAgICAgZG9tYWluRGF0YS5zdHJlbmd0aHNMaXN0ID0gZG9tYWluRGF0YS5zdHJlbmd0aHMubWFwKChpdGVtOiBzdHJpbmcpID0+ICh7IHRleHQ6IGl0ZW0gfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgZW1wdHkgYXJyYXkgaGFzIHJpZ2h0IGZvcm1hdCBmb3IgdGVtcGxhdGVzIHRoYXQgZXhwZWN0IGl0XG4gICAgICBkb21haW5EYXRhLnN0cmVuZ3Roc0xpc3QgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgbmVlZHMgYXMgYnVsbGV0IHBvaW50cyBmb3IgRE9DWFxuICAgIGlmIChBcnJheS5pc0FycmF5KGRvbWFpbkRhdGEubmVlZHMpICYmIGRvbWFpbkRhdGEubmVlZHMubGVuZ3RoID4gMCkge1xuICAgICAgZG9tYWluRGF0YS5uZWVkc0xpc3QgPSBkb21haW5EYXRhLm5lZWRzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiAoeyB0ZXh0OiBpdGVtIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRW5zdXJlIGVtcHR5IGFycmF5IGhhcyByaWdodCBmb3JtYXQgZm9yIHRlbXBsYXRlcyB0aGF0IGV4cGVjdCBpdFxuICAgICAgZG9tYWluRGF0YS5uZWVkc0xpc3QgPSBbXTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEZvcm1hdCBhY2NvbW1vZGF0aW9uIGFuZCBmYWNpbGl0YXRpb24gc3RyYXRlZ2llc1xuICBpZiAoQXJyYXkuaXNBcnJheShmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24/LnJlY29tbWVuZGF0aW9ucz8uYWNjb21tb2RhdGlvbnMpKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9uc0xpc3QgPSBcbiAgICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuYWNjb21tb2RhdGlvbnMubWFwKChpdGVtOiBzdHJpbmcpID0+ICh7IHRleHQ6IGl0ZW0gfSkpO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbj8ucmVjb21tZW5kYXRpb25zKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9uc0xpc3QgPSBbXTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbj8ucmVjb21tZW5kYXRpb25zPy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzKSkge1xuICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llc0xpc3QgPSBcbiAgICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llcy5tYXAoKGl0ZW06IHN0cmluZykgPT4gKHsgdGV4dDogaXRlbSB9KSk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uPy5yZWNvbW1lbmRhdGlvbnMpIHtcbiAgICBmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmZhY2lsaXRhdGlvblN0cmF0ZWdpZXNMaXN0ID0gW107XG4gIH1cblxuICAvLyBDb252ZXJ0IHBhcmVudHMgYXJyYXkgdG8gc3RyaW5nIGlmIG5lZWRlZFxuICBpZiAoQXJyYXkuaXNBcnJheShmb3JtYXR0ZWREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5wYXJlbnRzKSkge1xuICAgIGZvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5wYXJlbnRzU3RyaW5nID0gXG4gICAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ucGFyZW50cy5qb2luKCcsICcpO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlZERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24pIHtcbiAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ucGFyZW50c1N0cmluZyA9ICcnO1xuICB9XG5cbiAgLy8gQWRkIGZ1bGwgc3R1ZGVudCBuYW1lIGZvciBjb252ZW5pZW5jZVxuICBpZiAoZm9ybWF0dGVkRGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbj8uZmlyc3ROYW1lKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmZ1bGxOYW1lID0gXG4gICAgICBgJHtmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZmlyc3ROYW1lfSAke2Zvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5sYXN0TmFtZSB8fCAnJ31gO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlZERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24pIHtcbiAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZnVsbE5hbWUgPSAnU3R1ZGVudCc7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0dGVkRGF0YTtcbn0iXSwibmFtZXMiOlsiRG9jeHRlbXBsYXRlciIsIlBpelppcCIsInNhdmVBcyIsImdlbmVyYXRlRG9jeEZyb21UZW1wbGF0ZSIsInRlbXBsYXRlQnVmZmVyIiwiZGF0YSIsIm91dHB1dEZpbGVuYW1lIiwiZGVidWdNb2RlIiwiY29uc29sZSIsImxvZyIsImJ5dGVMZW5ndGgiLCJKU09OIiwic3RyaW5naWZ5IiwiZmlyc3RCeXRlcyIsIlVpbnQ4QXJyYXkiLCJzbGljZSIsIkFycmF5IiwiZnJvbSIsIm1hcCIsImIiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwiam9pbiIsIkVycm9yIiwiZXJyb3IiLCJ6aXAiLCJhcnJheUJ1ZmZlciIsInppcEVycm9yIiwibWVzc2FnZSIsImRvYyIsInBhcmFncmFwaExvb3AiLCJsaW5lYnJlYWtzIiwiZXJyb3JMb2dnaW5nIiwibnVsbEdldHRlciIsInBhcnQiLCJtb2R1bGUiLCJkb2N4RXJyb3IiLCJwcm9wZXJ0aWVzIiwiZXJyb3JzIiwiZmlyc3RFcnJvciIsImZvckVhY2giLCJpbmRleCIsImV4cGxhbmF0aW9uIiwiaWQiLCJ4dGFnIiwicG9zdHBhcnNlZCIsIk1hdGgiLCJtYXgiLCJvZmZzZXQiLCJyZW5kZXIiLCJyZW5kZXJFcnJvciIsInRhZyIsInJhdyIsInByb3BzIiwib3V0cHV0IiwiZ2V0WmlwIiwiZ2VuZXJhdGUiLCJ0eXBlIiwiY29tcHJlc3Npb24iLCJtaW1lVHlwZSIsInNpemUiLCJnZW5FcnJvciIsInNhdmVFcnJvciIsImluY2x1ZGVzIiwiZ2VuZXJhdGVGYWxsYmFja0h0bWxSZXBvcnQiLCJyZXBvcnREYXRhIiwic3R1ZGVudE5hbWUiLCJoZWFkZXIiLCJzdHVkZW50SW5mb3JtYXRpb24iLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImh0bWwiLCJET0IiLCJyZXBvcnREYXRlIiwicmVhc29uRm9yUmVmZXJyYWwiLCJhc3Nlc3NtZW50UmVzdWx0cyIsImRvbWFpbnMiLCJPYmplY3QiLCJlbnRyaWVzIiwiZG9tYWluTmFtZSIsImRvbWFpbiIsInRvcGljU2VudGVuY2UiLCJzdHJlbmd0aHMiLCJsZW5ndGgiLCJuZWVkcyIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiaXNDb25jZXJuIiwidW5kZWZpbmVkIiwiaXRlbSIsImltcGFjdFN0YXRlbWVudCIsImNvbmNsdXNpb24iLCJyZWNvbW1lbmRhdGlvbnMiLCJhY2NvbW1vZGF0aW9ucyIsImZhY2lsaXRhdGlvblN0cmF0ZWdpZXMiLCJCbG9iIiwiY3JlYXRlRW1wdHlUZW1wbGF0ZSIsIm1pbmltYWxEb2N4QmFzZTY0IiwiYmluYXJ5U3RyaW5nIiwid2luZG93IiwiYXRvYiIsImJ5dGVzIiwiaSIsImNoYXJDb2RlQXQiLCJidWZmZXIiLCJnZW5lcmF0ZVJlcG9ydERvY3giLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzcGxpdCIsImZpbGVuYW1lIiwicmVwbGFjZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJjYWNoZSIsImhlYWRlcnMiLCJvayIsInN0YXR1cyIsImFsdFJlc3BvbnNlIiwiYWx0Rmlyc3RCeXRlcyIsImFsdEVycm9yIiwiZm9ybWF0dGVkRGF0YSIsImZvcm1hdFJlcG9ydERhdGFGb3JEb2N4Iiwid2FybiIsImh0bWxCbG9iIiwiaHRtbEZpbGVuYW1lIiwicGFyc2UiLCJrZXlzIiwiZG9tYWluRGF0YSIsImlzQXJyYXkiLCJzdHJlbmd0aHNMaXN0IiwidGV4dCIsIm5lZWRzTGlzdCIsImFjY29tbW9kYXRpb25zTGlzdCIsImZhY2lsaXRhdGlvblN0cmF0ZWdpZXNMaXN0IiwicGFyZW50cyIsInBhcmVudHNTdHJpbmciLCJmdWxsTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/docx-generator.ts\n"));

/***/ })

});