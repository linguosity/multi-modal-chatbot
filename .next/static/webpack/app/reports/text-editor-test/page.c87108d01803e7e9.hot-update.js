"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/reports/text-editor-test/page",{

/***/ "(app-pages-browser)/./src/lib/docx-generator.ts":
/*!***********************************!*\
  !*** ./src/lib/docx-generator.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateDocxFromTemplate: () => (/* binding */ generateDocxFromTemplate),\n/* harmony export */   generateReportDocx: () => (/* binding */ generateReportDocx)\n/* harmony export */ });\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! docxtemplater */ \"(app-pages-browser)/./node_modules/docxtemplater/js/docxtemplater.js\");\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(docxtemplater__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pizzip */ \"(app-pages-browser)/./node_modules/pizzip/js/index.js\");\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pizzip__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! file-saver */ \"(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n/**\n * Generate a docx file from a template and data\n * @param templateBuffer - The binary template file as an ArrayBuffer\n * @param data - The data to inject into the template\n * @param outputFilename - The name of the file to save\n * @param debugMode - Whether to enable extra debugging information\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateDocxFromTemplate(templateBuffer, data) {\n    let outputFilename = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'report.docx', debugMode = arguments.length > 3 && arguments[3] !== void 0 // Enable debug mode by default to help diagnose template issues\n     ? arguments[3] : true;\n    try {\n        console.log(\"Attempting to create PizZip instance with buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n        // Output debug information if debug mode is enabled\n        if (debugMode) {\n            console.log('Data being passed to template:', JSON.stringify(data, null, 2));\n            console.log('Template buffer size:', templateBuffer.byteLength);\n            // Log the first 20 bytes of the template to verify it's a proper DOCX file\n            const firstBytes = new Uint8Array(templateBuffer.slice(0, 20));\n            console.log('First 20 bytes of template (hex):', Array.from(firstBytes).map((b)=>b.toString(16).padStart(2, '0')).join(' '));\n        }\n        // Validate that we have a proper buffer\n        if (!templateBuffer || templateBuffer.byteLength === 0) {\n            throw new Error('Invalid template buffer: Empty or undefined');\n        }\n        // Verify the buffer has a ZIP signature (first bytes of a proper DOCX/ZIP file)\n        const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n        if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n            console.error('Invalid ZIP file signature in template. First bytes:', Array.from(firstBytes));\n            throw new Error('The template does not appear to be a valid ZIP/DOCX file (missing PK signature)');\n        }\n        // Create a new PizZip instance with the template content\n        // Use a try-catch specifically for the PizZip instantiation\n        let zip;\n        try {\n            // Convert ArrayBuffer to Uint8Array to ensure proper binary handling\n            const arrayBuffer = new Uint8Array(templateBuffer);\n            zip = new (pizzip__WEBPACK_IMPORTED_MODULE_1___default())(arrayBuffer);\n        } catch (zipError) {\n            console.error('Error creating PizZip instance:', zipError);\n            throw new Error(\"Failed to create ZIP from template: \".concat(zipError instanceof Error ? zipError.message : 'Unknown error'));\n        }\n        console.log('PizZip instance created successfully');\n        // Create a new Docxtemplater instance with improved error handling\n        let doc;\n        try {\n            // Add modules and options for better error handling and debugging\n            doc = new (docxtemplater__WEBPACK_IMPORTED_MODULE_0___default())(zip, {\n                paragraphLoop: true,\n                linebreaks: true,\n                errorLogging: true,\n                // Better handling of missing/null values\n                nullGetter: function(part) {\n                    if (debugMode) {\n                        console.log('Null value encountered for tag:', part);\n                    }\n                    if (!part.module) {\n                        return \"\";\n                    }\n                    if (part.module === \"rawxml\") {\n                        return \"\";\n                    }\n                    return \"\";\n                },\n                // Parse options for more flexibility\n                delimiters: {\n                    start: '{',\n                    end: '}' // Default closing delimiter\n                },\n                // Track detailed tag information for debugging\n                parser: (tag)=>{\n                    if (debugMode) {\n                        console.log('Parsing tag:', tag);\n                    }\n                    return {\n                        get: (scope)=>{\n                            var _scope_tag;\n                            const result = (_scope_tag = scope[tag]) !== null && _scope_tag !== void 0 ? _scope_tag : '';\n                            if (debugMode && (result === undefined || result === null)) {\n                                console.warn(\"Tag '\".concat(tag, \"' resolved to undefined/null value\"));\n                            }\n                            return result;\n                        }\n                    };\n                }\n            });\n            console.log('Docxtemplater instance created successfully');\n        } catch (docxError) {\n            console.error('Error creating Docxtemplater instance:', docxError);\n            // Special handling for Multi error (which contains multiple errors)\n            if (docxError && docxError.properties && docxError.properties.errors) {\n                var _firstError_properties;\n                console.log('Docxtemplater reported multiple errors:');\n                // Log each individual error for debugging\n                docxError.properties.errors.forEach((error, index)=>{\n                    console.log(\"Error \".concat(index + 1, \":\"), error);\n                    // Log detailed information if available\n                    if (error.properties) {\n                        if (error.properties.explanation) {\n                            console.log(\"Explanation: \".concat(error.properties.explanation));\n                        }\n                        if (error.properties.id) {\n                            console.log(\"Error ID: \".concat(error.properties.id));\n                        }\n                        if (error.properties.xtag) {\n                            console.log(\"Tag with error: \".concat(error.properties.xtag));\n                        }\n                        if (error.properties.postparsed) {\n                            console.log('Template structure around error:');\n                            console.log(error.properties.postparsed.slice(Math.max(0, error.properties.offset - 5), error.properties.offset + 5));\n                        }\n                    }\n                });\n                // Throw a more detailed error\n                const firstError = docxError.properties.errors[0] || {};\n                const explanation = ((_firstError_properties = firstError.properties) === null || _firstError_properties === void 0 ? void 0 : _firstError_properties.explanation) || 'Unknown template issues';\n                throw new Error(\"Template errors detected: \".concat(explanation, \" (See console for full details)\"));\n            }\n            throw new Error(\"Failed to create Docxtemplater: \".concat(docxError instanceof Error ? docxError.message : 'Unknown error'));\n        }\n        try {\n            // Render the document with the provided data\n            doc.render(data);\n            console.log('Template rendered with data');\n        } catch (renderError) {\n            console.error('Error rendering template:', renderError);\n            // Special handling for Multi error (which contains multiple errors)\n            if (renderError && renderError.properties && renderError.properties.errors) {\n                var _firstError_properties1;\n                console.log('Docxtemplater reported multiple render errors:');\n                // Log each individual error for debugging\n                renderError.properties.errors.forEach((error, index)=>{\n                    console.log(\"Render Error \".concat(index + 1, \":\"), error);\n                    // Log detailed information if available\n                    if (error.properties) {\n                        if (error.properties.explanation) {\n                            console.log(\"Explanation: \".concat(error.properties.explanation));\n                        }\n                        if (error.properties.id) {\n                            console.log(\"Error ID: \".concat(error.properties.id));\n                        }\n                        if (error.properties.xtag) {\n                            console.log(\"Tag with error: \".concat(error.properties.xtag));\n                        }\n                        // Log the data path that caused the issue if known\n                        if (error.properties.tag) {\n                            console.log(\"Template tag: \".concat(error.properties.tag));\n                            console.log(\"Raw tag: \".concat(error.properties.raw));\n                        }\n                    }\n                });\n                // Throw a more detailed error\n                const firstError = renderError.properties.errors[0] || {};\n                const explanation = ((_firstError_properties1 = firstError.properties) === null || _firstError_properties1 === void 0 ? void 0 : _firstError_properties1.explanation) || 'Unknown template rendering issues';\n                throw new Error(\"Template rendering errors: \".concat(explanation, \" (See console for full details)\"));\n            }\n            // Special handling for individual Docxtemplater errors with properties\n            if (renderError instanceof Error && 'properties' in renderError) {\n                const props = renderError.properties || {};\n                console.log('Detailed render error properties:', props);\n                throw new Error(\"Template render error: \".concat(props.explanation || renderError.message));\n            }\n            throw new Error(\"Failed to render template: \".concat(renderError instanceof Error ? renderError.message : 'Unknown error'));\n        }\n        // Generate the output document\n        let output;\n        try {\n            output = doc.getZip().generate({\n                type: 'blob',\n                compression: 'DEFLATE',\n                mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n            });\n            console.log(\"Output document generated successfully (\".concat(output.size, \" bytes)\"));\n        } catch (genError) {\n            console.error('Error generating output document:', genError);\n            throw new Error(\"Failed to generate output: \".concat(genError instanceof Error ? genError.message : 'Unknown error'));\n        }\n        // If running in browser, save the file\n        if (true) {\n            try {\n                (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(output, outputFilename);\n                console.log(\"File saved as \".concat(outputFilename));\n            } catch (saveError) {\n                console.error('Error saving file:', saveError);\n                throw new Error(\"Failed to save file: \".concat(saveError instanceof Error ? saveError.message : 'Unknown error'));\n            }\n        }\n        return output;\n    } catch (error) {\n        console.error('Error in generateDocxFromTemplate:', error);\n        // If it's a PizZip error (likely invalid template)\n        if (error instanceof Error && error.message.includes('zip')) {\n            console.error('PizZip error - invalid template file structure');\n            throw new Error(\"Template file is not a valid DOCX/ZIP file: \".concat(error.message));\n        }\n        // Rethrow the error\n        throw error;\n    }\n}\n/**\n * Generate a fallback HTML report when DOCX template fails\n * @param reportData - The report data to export\n * @returns A blob with HTML content\n */ function generateFallbackHtmlReport(reportData) {\n    var _reportData_header_studentInformation, _reportData_header, _reportData_header_studentInformation1, _reportData_header1, _reportData_header_studentInformation2, _reportData_header2, _reportData_header3, _reportData_assessmentResults, _reportData_conclusion;\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \" \").concat(reportData.header.studentInformation.lastName) : 'Student';\n    // Create a simple HTML representation of the report\n    let html = '\\n    <!DOCTYPE html>\\n    <html>\\n    <head>\\n      <meta charset=\"utf-8\">\\n      <title>Report for '.concat(studentName, \"</title>\\n      <style>\\n        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }\\n        h1, h2, h3 { color: #444; }\\n        .section { margin-bottom: 30px; }\\n        .domain { margin-bottom: 20px; padding: 15px; border: 1px solid #eee; }\\n        .domain-header { display: flex; justify-content: space-between; align-items: center; }\\n        .concern { color: #f59e0b; font-size: 14px; }\\n        .no-concern { color: #10b981; font-size: 14px; }\\n        ul { margin-top: 5px; }\\n        @media print {\\n          body { margin: 0.5in; }\\n          .domain { break-inside: avoid; }\\n        }\\n      </style>\\n    </head>\\n    <body>\\n      <h1>Report for \").concat(studentName, '</h1>\\n      <div class=\"section\">\\n        <h2>Student Information</h2>\\n        <p><strong>DOB:</strong> ').concat(((_reportData_header1 = reportData.header) === null || _reportData_header1 === void 0 ? void 0 : (_reportData_header_studentInformation1 = _reportData_header1.studentInformation) === null || _reportData_header_studentInformation1 === void 0 ? void 0 : _reportData_header_studentInformation1.DOB) || 'N/A', \"</p>\\n        <p><strong>Report Date:</strong> \").concat(((_reportData_header2 = reportData.header) === null || _reportData_header2 === void 0 ? void 0 : (_reportData_header_studentInformation2 = _reportData_header2.studentInformation) === null || _reportData_header_studentInformation2 === void 0 ? void 0 : _reportData_header_studentInformation2.reportDate) || 'N/A', \"</p>\\n        <p><strong>Reason for Referral:</strong> \").concat(((_reportData_header3 = reportData.header) === null || _reportData_header3 === void 0 ? void 0 : _reportData_header3.reasonForReferral) || 'N/A', \"</p>\\n      </div>\\n  \");\n    // Add domains section\n    if ((_reportData_assessmentResults = reportData.assessmentResults) === null || _reportData_assessmentResults === void 0 ? void 0 : _reportData_assessmentResults.domains) {\n        html += '<div class=\"section\"><h2>Assessment Results</h2>';\n        Object.entries(reportData.assessmentResults.domains).forEach((param)=>{\n            let [domainName, domain] = param;\n            var _domain_strengths, _domain_needs;\n            if (domain.topicSentence || ((_domain_strengths = domain.strengths) === null || _domain_strengths === void 0 ? void 0 : _domain_strengths.length) || ((_domain_needs = domain.needs) === null || _domain_needs === void 0 ? void 0 : _domain_needs.length)) {\n                var _domain_strengths1, _domain_needs1;\n                html += '\\n          <div class=\"domain\">\\n            <div class=\"domain-header\">\\n              <h3>'.concat(domainName.charAt(0).toUpperCase() + domainName.slice(1), \" Language</h3>\\n              \").concat(domain.isConcern !== undefined ? '<span class=\"'.concat(domain.isConcern ? 'concern' : 'no-concern', '\">').concat(domain.isConcern ? 'Area of Concern' : 'No Concern', \"</span>\") : '', \"\\n            </div>\\n            \").concat(domain.topicSentence ? \"<p>\".concat(domain.topicSentence, \"</p>\") : '', \"\\n            \\n            \").concat(((_domain_strengths1 = domain.strengths) === null || _domain_strengths1 === void 0 ? void 0 : _domain_strengths1.length) ? \"\\n              <h4>Strengths:</h4>\\n              <ul>\\n                \".concat(domain.strengths.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(((_domain_needs1 = domain.needs) === null || _domain_needs1 === void 0 ? void 0 : _domain_needs1.length) ? \"\\n              <h4>Needs:</h4>\\n              <ul>\\n                \".concat(domain.needs.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(domain.impactStatement ? \"\\n              <h4>Educational Impact:</h4>\\n              <p>\".concat(domain.impactStatement, \"</p>\\n            \") : '', \"\\n          </div>\\n        \");\n            }\n        });\n        html += \"</div>\";\n    }\n    // Add recommendations\n    if ((_reportData_conclusion = reportData.conclusion) === null || _reportData_conclusion === void 0 ? void 0 : _reportData_conclusion.recommendations) {\n        var _reportData_conclusion_recommendations_accommodations, _reportData_conclusion_recommendations_facilitationStrategies;\n        html += '\\n      <div class=\"section\">\\n        <h2>Recommendations</h2>\\n        '.concat(((_reportData_conclusion_recommendations_accommodations = reportData.conclusion.recommendations.accommodations) === null || _reportData_conclusion_recommendations_accommodations === void 0 ? void 0 : _reportData_conclusion_recommendations_accommodations.length) ? \"\\n          <h3>Accommodations:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.accommodations.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n        \\n        \").concat(((_reportData_conclusion_recommendations_facilitationStrategies = reportData.conclusion.recommendations.facilitationStrategies) === null || _reportData_conclusion_recommendations_facilitationStrategies === void 0 ? void 0 : _reportData_conclusion_recommendations_facilitationStrategies.length) ? \"\\n          <h3>Facilitation Strategies:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.facilitationStrategies.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n      </div>\\n    \");\n    }\n    html += \"\\n      <footer>\\n        <p><em>This is a fallback HTML report generated because the DOCX template could not be processed. \\n        You can print this HTML file to create a PDF.</em></p>\\n      </footer>\\n    </body>\\n    </html>\\n  \";\n    return new Blob([\n        html\n    ], {\n        type: 'text/html'\n    });\n}\n/**\n * Create a simple empty DOCX template programmatically\n * This is a last-resort fallback when all template files fail to load\n */ function createEmptyTemplate() {\n    // Define a minimal valid DOCX file structure as a base64 string\n    // This is a simplified empty DOCX file with minimal content\n    const minimalDocxBase64 = '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';\n    // Convert base64 to ArrayBuffer\n    const binaryString = window.atob(minimalDocxBase64);\n    const bytes = new Uint8Array(binaryString.length);\n    for(let i = 0; i < binaryString.length; i++){\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n/**\n * Generate a report docx from the report data\n * @param reportData - The report data from the application\n * @param templateBuffer - The binary template file as an ArrayBuffer (optional)\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateReportDocx(reportData, templateBuffer) {\n    var _reportData_header_studentInformation, _reportData_header;\n    // Generate the filename based on report data\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \"_\").concat(reportData.header.studentInformation.lastName) : 'student';\n    const timestamp = new Date().toISOString().split('T')[0];\n    const filename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".docx\");\n    try {\n        // If no template buffer is provided, use a default template\n        if (!templateBuffer) {\n            // Use fetch to get the template if we're in the browser\n            if (true) {\n                try {\n                    console.log('No template buffer provided, fetching default template');\n                    // Try to use response.arrayBuffer() which ensures binary data handling\n                    // Use las-assessment-report-template.docx instead of report-template.docx (which is a text file, not a DOCX)\n                    const response = await fetch('/templates/las-assessment-report-template.docx', {\n                        method: 'GET',\n                        cache: 'no-cache',\n                        headers: {\n                            'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                            'Cache-Control': 'no-cache'\n                        }\n                    });\n                    if (!response.ok) {\n                        throw new Error(\"Failed to fetch default template: \".concat(response.status));\n                    }\n                    console.log('Default template fetched successfully');\n                    templateBuffer = await response.arrayBuffer();\n                    console.log(\"Default template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                    if (templateBuffer.byteLength === 0) {\n                        throw new Error('Default template file is empty');\n                    }\n                    // Verify the template has a proper DOCX signature\n                    const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                    if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n                        console.error('Invalid DOCX file signature in default template. First bytes:', Array.from(firstBytes));\n                        throw new Error('Default template is not a valid DOCX file');\n                    }\n                } catch (error) {\n                    console.error('Error loading default template:', error);\n                    // Try alternative template as a last resort\n                    try {\n                        console.log('Attempting to load alternative template: las-assessment-report-template-fixed.docx');\n                        const altResponse = await fetch('/templates/las-assessment-report-template-fixed.docx', {\n                            cache: 'no-cache',\n                            headers: {\n                                'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                                'Cache-Control': 'no-cache'\n                            }\n                        });\n                        if (!altResponse.ok) {\n                            throw new Error(\"Failed to fetch alternative template: \".concat(altResponse.status));\n                        }\n                        templateBuffer = await altResponse.arrayBuffer();\n                        console.log(\"Alternative template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        // Verify the alternative template\n                        const altFirstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                        if (!(altFirstBytes[0] === 0x50 && altFirstBytes[1] === 0x4B)) {\n                            console.error('Invalid DOCX file signature in alternative template');\n                            throw new Error('Alternative template is not a valid DOCX file');\n                        }\n                    } catch (altError) {\n                        console.error('Error loading alternative template:', altError);\n                        // As a last resort, create a minimal valid DOCX template\n                        console.log('Creating minimal empty DOCX template');\n                        templateBuffer = createEmptyTemplate();\n                        console.log(\"Created minimal template with size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        if (!templateBuffer || templateBuffer.byteLength === 0) {\n                            // All template attempts failed, fall back to HTML\n                            throw new Error('All template attempts failed');\n                        }\n                    }\n                }\n            } else {}\n        }\n        // Format and prepare data for the template\n        const formattedData = formatReportDataForDocx(reportData);\n        console.log('Data formatted for DOCX template');\n        // Generate the document\n        return await generateDocxFromTemplate(templateBuffer, formattedData, filename);\n    } catch (error) {\n        console.error('Error in generateReportDocx:', error);\n        // If there was an error with the template or docxtemplater,\n        // try to generate a fallback HTML report\n        if (error instanceof Error && (error.message.includes('zip') || error.message.includes('template') || error.message.includes('docxtemplater'))) {\n            console.warn('DOCX generation failed, falling back to HTML export');\n            const htmlBlob = generateFallbackHtmlReport(reportData);\n            const htmlFilename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".html\");\n            if (true) {\n                (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(htmlBlob, htmlFilename);\n            }\n            return htmlBlob;\n        }\n        throw error;\n    }\n}\n/**\n * Format the report data for docx template rendering\n * @param reportData - The raw report data from the application\n * @returns Formatted data ready for docx template\n */ function formatReportDataForDocx(reportData) {\n    var _formattedData_assessmentResults, _formattedData_conclusion_recommendations, _formattedData_conclusion, _formattedData_conclusion1, _formattedData_conclusion_recommendations1, _formattedData_conclusion2, _formattedData_conclusion3, _formattedData_header_studentInformation, _formattedData_header, _formattedData_header1, _formattedData_header_studentInformation1, _formattedData_header2, _formattedData_header3;\n    // Create a deep copy of the report data\n    const formattedData = JSON.parse(JSON.stringify(reportData));\n    // Format arrays to be more docx-template friendly\n    // Arrays in docxtemplater are typically handled with loops, so we'll format them\n    // to be ready for the template syntax\n    // Process strength and needs lists for each domain\n    Object.keys(((_formattedData_assessmentResults = formattedData.assessmentResults) === null || _formattedData_assessmentResults === void 0 ? void 0 : _formattedData_assessmentResults.domains) || {}).forEach((domain)=>{\n        const domainData = formattedData.assessmentResults.domains[domain];\n        // Format strengths as bullet points for DOCX\n        if (Array.isArray(domainData.strengths) && domainData.strengths.length > 0) {\n            domainData.strengthsList = domainData.strengths.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.strengthsList = [];\n        }\n        // Format needs as bullet points for DOCX\n        if (Array.isArray(domainData.needs) && domainData.needs.length > 0) {\n            domainData.needsList = domainData.needs.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.needsList = [];\n        }\n    });\n    // Format accommodation and facilitation strategies\n    if (Array.isArray((_formattedData_conclusion = formattedData.conclusion) === null || _formattedData_conclusion === void 0 ? void 0 : (_formattedData_conclusion_recommendations = _formattedData_conclusion.recommendations) === null || _formattedData_conclusion_recommendations === void 0 ? void 0 : _formattedData_conclusion_recommendations.accommodations)) {\n        formattedData.conclusion.recommendations.accommodationsList = formattedData.conclusion.recommendations.accommodations.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion1 = formattedData.conclusion) === null || _formattedData_conclusion1 === void 0 ? void 0 : _formattedData_conclusion1.recommendations) {\n        formattedData.conclusion.recommendations.accommodationsList = [];\n    }\n    if (Array.isArray((_formattedData_conclusion2 = formattedData.conclusion) === null || _formattedData_conclusion2 === void 0 ? void 0 : (_formattedData_conclusion_recommendations1 = _formattedData_conclusion2.recommendations) === null || _formattedData_conclusion_recommendations1 === void 0 ? void 0 : _formattedData_conclusion_recommendations1.facilitationStrategies)) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = formattedData.conclusion.recommendations.facilitationStrategies.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion3 = formattedData.conclusion) === null || _formattedData_conclusion3 === void 0 ? void 0 : _formattedData_conclusion3.recommendations) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = [];\n    }\n    // Convert parents array to string if needed\n    if (Array.isArray((_formattedData_header = formattedData.header) === null || _formattedData_header === void 0 ? void 0 : (_formattedData_header_studentInformation = _formattedData_header.studentInformation) === null || _formattedData_header_studentInformation === void 0 ? void 0 : _formattedData_header_studentInformation.parents)) {\n        formattedData.header.studentInformation.parentsString = formattedData.header.studentInformation.parents.join(', ');\n    } else if ((_formattedData_header1 = formattedData.header) === null || _formattedData_header1 === void 0 ? void 0 : _formattedData_header1.studentInformation) {\n        formattedData.header.studentInformation.parentsString = '';\n    }\n    // Add full student name for convenience\n    if ((_formattedData_header2 = formattedData.header) === null || _formattedData_header2 === void 0 ? void 0 : (_formattedData_header_studentInformation1 = _formattedData_header2.studentInformation) === null || _formattedData_header_studentInformation1 === void 0 ? void 0 : _formattedData_header_studentInformation1.firstName) {\n        formattedData.header.studentInformation.fullName = \"\".concat(formattedData.header.studentInformation.firstName, \" \").concat(formattedData.header.studentInformation.lastName || '');\n    } else if ((_formattedData_header3 = formattedData.header) === null || _formattedData_header3 === void 0 ? void 0 : _formattedData_header3.studentInformation) {\n        formattedData.header.studentInformation.fullName = 'Student';\n    }\n    return formattedData;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZG9jeC1nZW5lcmF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMEM7QUFDZDtBQUNRO0FBRXBDOzs7Ozs7O0NBT0MsR0FDTSxlQUFlRyx5QkFDcEJDLGNBQTJCLEVBQzNCQyxJQUF5QjtRQUN6QkMsaUJBQUFBLGlFQUF5QixlQUN6QkMsWUFBQUEsZ0RBQTBCLGdFQUFnRTtzQkFBckU7SUFFckIsSUFBSTtRQUNGQyxRQUFRQyxHQUFHLENBQUMsMERBQW9GLE9BQTFCTCxlQUFlTSxVQUFVLEVBQUM7UUFFaEcsb0RBQW9EO1FBQ3BELElBQUlILFdBQVc7WUFDYkMsUUFBUUMsR0FBRyxDQUFDLGtDQUFrQ0UsS0FBS0MsU0FBUyxDQUFDUCxNQUFNLE1BQU07WUFDekVHLFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJMLGVBQWVNLFVBQVU7WUFDOUQsMkVBQTJFO1lBQzNFLE1BQU1HLGFBQWEsSUFBSUMsV0FBV1YsZUFBZVcsS0FBSyxDQUFDLEdBQUc7WUFDMURQLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUNPLE1BQU1DLElBQUksQ0FBQ0osWUFBWUssR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUcsTUFBTUMsSUFBSSxDQUFDO1FBQ3pIO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUksQ0FBQ2xCLGtCQUFrQkEsZUFBZU0sVUFBVSxLQUFLLEdBQUc7WUFDdEQsTUFBTSxJQUFJYSxNQUFNO1FBQ2xCO1FBRUEsZ0ZBQWdGO1FBQ2hGLE1BQU1WLGFBQWEsSUFBSUMsV0FBV1YsZUFBZVcsS0FBSyxDQUFDLEdBQUc7UUFDMUQsSUFBSSxDQUFFRixDQUFBQSxVQUFVLENBQUMsRUFBRSxLQUFLLFFBQVFBLFVBQVUsQ0FBQyxFQUFFLEtBQUssSUFBRyxHQUFJO1lBQ3ZETCxRQUFRZ0IsS0FBSyxDQUFDLHdEQUF3RFIsTUFBTUMsSUFBSSxDQUFDSjtZQUNqRixNQUFNLElB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QUN6RCxPQUFPLEtBQUk0Ryx5QkFBQUEsY0FBY3RELE1BQU0sY0FBcEJzRCw2Q0FBQUEsdUJBQXNCckQsa0JBQWtCLEVBQUU7UUFDbkRxRCxjQUFjdEQsTUFBTSxDQUFDQyxrQkFBa0IsQ0FBQ21FLGFBQWEsR0FBRztJQUMxRDtJQUVBLHdDQUF3QztJQUN4QyxLQUFJZCx5QkFBQUEsY0FBY3RELE1BQU0sY0FBcEJzRCw4Q0FBQUEsNENBQUFBLHVCQUFzQnJELGtCQUFrQixjQUF4Q3FELGdFQUFBQSwwQ0FBMENwRCxTQUFTLEVBQUU7UUFDdkRvRCxjQUFjdEQsTUFBTSxDQUFDQyxrQkFBa0IsQ0FBQ29FLFFBQVEsR0FDOUMsR0FBd0RmLE9BQXJEQSxjQUFjdEQsTUFBTSxDQUFDQyxrQkFBa0IsQ0FBQ0MsU0FBUyxFQUFDLEtBQTBELE9BQXZEb0QsY0FBY3RELE1BQU0sQ0FBQ0Msa0JBQWtCLENBQUNFLFFBQVEsSUFBSTtJQUNoSCxPQUFPLEtBQUltRCx5QkFBQUEsY0FBY3RELE1BQU0sY0FBcEJzRCw2Q0FBQUEsdUJBQXNCckQsa0JBQWtCLEVBQUU7UUFDbkRxRCxjQUFjdEQsTUFBTSxDQUFDQyxrQkFBa0IsQ0FBQ29FLFFBQVEsR0FBRztJQUNyRDtJQUVBLE9BQU9mO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvc3JjL2xpYi9kb2N4LWdlbmVyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRG9jeHRlbXBsYXRlciBmcm9tICdkb2N4dGVtcGxhdGVyJztcbmltcG9ydCBQaXpaaXAgZnJvbSAncGl6emlwJztcbmltcG9ydCB7IHNhdmVBcyB9IGZyb20gJ2ZpbGUtc2F2ZXInO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZG9jeCBmaWxlIGZyb20gYSB0ZW1wbGF0ZSBhbmQgZGF0YVxuICogQHBhcmFtIHRlbXBsYXRlQnVmZmVyIC0gVGhlIGJpbmFyeSB0ZW1wbGF0ZSBmaWxlIGFzIGFuIEFycmF5QnVmZmVyXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIGluamVjdCBpbnRvIHRoZSB0ZW1wbGF0ZVxuICogQHBhcmFtIG91dHB1dEZpbGVuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gc2F2ZVxuICogQHBhcmFtIGRlYnVnTW9kZSAtIFdoZXRoZXIgdG8gZW5hYmxlIGV4dHJhIGRlYnVnZ2luZyBpbmZvcm1hdGlvblxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGdlbmVyYXRlZCBmaWxlIGFzIGEgQmxvYlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVEb2N4RnJvbVRlbXBsYXRlKFxuICB0ZW1wbGF0ZUJ1ZmZlcjogQXJyYXlCdWZmZXIsXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIG91dHB1dEZpbGVuYW1lOiBzdHJpbmcgPSAncmVwb3J0LmRvY3gnLFxuICBkZWJ1Z01vZGU6IGJvb2xlYW4gPSB0cnVlIC8vIEVuYWJsZSBkZWJ1ZyBtb2RlIGJ5IGRlZmF1bHQgdG8gaGVscCBkaWFnbm9zZSB0ZW1wbGF0ZSBpc3N1ZXNcbik6IFByb21pc2U8QmxvYj4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIGNyZWF0ZSBQaXpaaXAgaW5zdGFuY2Ugd2l0aCBidWZmZXIgc2l6ZTogJHt0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlc2ApO1xuICAgIFxuICAgIC8vIE91dHB1dCBkZWJ1ZyBpbmZvcm1hdGlvbiBpZiBkZWJ1ZyBtb2RlIGlzIGVuYWJsZWRcbiAgICBpZiAoZGVidWdNb2RlKSB7XG4gICAgICBjb25zb2xlLmxvZygnRGF0YSBiZWluZyBwYXNzZWQgdG8gdGVtcGxhdGU6JywgSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMikpO1xuICAgICAgY29uc29sZS5sb2coJ1RlbXBsYXRlIGJ1ZmZlciBzaXplOicsIHRlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgICAgLy8gTG9nIHRoZSBmaXJzdCAyMCBieXRlcyBvZiB0aGUgdGVtcGxhdGUgdG8gdmVyaWZ5IGl0J3MgYSBwcm9wZXIgRE9DWCBmaWxlXG4gICAgICBjb25zdCBmaXJzdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGVtcGxhdGVCdWZmZXIuc2xpY2UoMCwgMjApKTtcbiAgICAgIGNvbnNvbGUubG9nKCdGaXJzdCAyMCBieXRlcyBvZiB0ZW1wbGF0ZSAoaGV4KTonLCBBcnJheS5mcm9tKGZpcnN0Qnl0ZXMpLm1hcChiID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJyAnKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFZhbGlkYXRlIHRoYXQgd2UgaGF2ZSBhIHByb3BlciBidWZmZXJcbiAgICBpZiAoIXRlbXBsYXRlQnVmZmVyIHx8IHRlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0ZW1wbGF0ZSBidWZmZXI6IEVtcHR5IG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIGJ1ZmZlciBoYXMgYSBaSVAgc2lnbmF0dXJlIChmaXJzdCBieXRlcyBvZiBhIHByb3BlciBET0NYL1pJUCBmaWxlKVxuICAgIGNvbnN0IGZpcnN0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlci5zbGljZSgwLCA0KSk7XG4gICAgaWYgKCEoZmlyc3RCeXRlc1swXSA9PT0gMHg1MCAmJiBmaXJzdEJ5dGVzWzFdID09PSAweDRCKSkge1xuICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBaSVAgZmlsZSBzaWduYXR1cmUgaW4gdGVtcGxhdGUuIEZpcnN0IGJ5dGVzOicsIEFycmF5LmZyb20oZmlyc3RCeXRlcykpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdGVtcGxhdGUgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgdmFsaWQgWklQL0RPQ1ggZmlsZSAobWlzc2luZyBQSyBzaWduYXR1cmUpJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyBQaXpaaXAgaW5zdGFuY2Ugd2l0aCB0aGUgdGVtcGxhdGUgY29udGVudFxuICAgIC8vIFVzZSBhIHRyeS1jYXRjaCBzcGVjaWZpY2FsbHkgZm9yIHRoZSBQaXpaaXAgaW5zdGFudGlhdGlvblxuICAgIGxldCB6aXA7XG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnQgQXJyYXlCdWZmZXIgdG8gVWludDhBcnJheSB0byBlbnN1cmUgcHJvcGVyIGJpbmFyeSBoYW5kbGluZ1xuICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlcik7XG4gICAgICB6aXAgPSBuZXcgUGl6WmlwKGFycmF5QnVmZmVyKTtcbiAgICB9IGNhdGNoICh6aXBFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgUGl6WmlwIGluc3RhbmNlOicsIHppcEVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBaSVAgZnJvbSB0ZW1wbGF0ZTogJHt6aXBFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gemlwRXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1BpelppcCBpbnN0YW5jZSBjcmVhdGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyBEb2N4dGVtcGxhdGVyIGluc3RhbmNlIHdpdGggaW1wcm92ZWQgZXJyb3IgaGFuZGxpbmdcbiAgICBsZXQgZG9jO1xuICAgIHRyeSB7XG4gICAgICAvLyBBZGQgbW9kdWxlcyBhbmQgb3B0aW9ucyBmb3IgYmV0dGVyIGVycm9yIGhhbmRsaW5nIGFuZCBkZWJ1Z2dpbmdcbiAgICAgIGRvYyA9IG5ldyBEb2N4dGVtcGxhdGVyKHppcCwge1xuICAgICAgICBwYXJhZ3JhcGhMb29wOiB0cnVlLFxuICAgICAgICBsaW5lYnJlYWtzOiB0cnVlLFxuICAgICAgICBlcnJvckxvZ2dpbmc6IHRydWUsXG4gICAgICAgIC8vIEJldHRlciBoYW5kbGluZyBvZiBtaXNzaW5nL251bGwgdmFsdWVzXG4gICAgICAgIG51bGxHZXR0ZXI6IGZ1bmN0aW9uKHBhcnQ6IGFueSkge1xuICAgICAgICAgIGlmIChkZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOdWxsIHZhbHVlIGVuY291bnRlcmVkIGZvciB0YWc6JywgcGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcGFydC5tb2R1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5tb2R1bGUgPT09IFwicmF3eG1sXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUGFyc2Ugb3B0aW9ucyBmb3IgbW9yZSBmbGV4aWJpbGl0eVxuICAgICAgICBkZWxpbWl0ZXJzOiB7XG4gICAgICAgICAgc3RhcnQ6ICd7JywgIC8vIERlZmF1bHQgb3BlbmluZyBkZWxpbWl0ZXJcbiAgICAgICAgICBlbmQ6ICd9JyAgICAgLy8gRGVmYXVsdCBjbG9zaW5nIGRlbGltaXRlclxuICAgICAgICB9LFxuICAgICAgICAvLyBUcmFjayBkZXRhaWxlZCB0YWcgaW5mb3JtYXRpb24gZm9yIGRlYnVnZ2luZ1xuICAgICAgICBwYXJzZXI6ICh0YWc6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGlmIChkZWJ1Z01vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQYXJzaW5nIHRhZzonLCB0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0OiAoc2NvcGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBzY29wZVt0YWddID8/ICcnO1xuICAgICAgICAgICAgICBpZiAoZGVidWdNb2RlICYmIChyZXN1bHQgPT09IHVuZGVmaW5lZCB8fCByZXN1bHQgPT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUYWcgJyR7dGFnfScgcmVzb2x2ZWQgdG8gdW5kZWZpbmVkL251bGwgdmFsdWVgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coJ0RvY3h0ZW1wbGF0ZXIgaW5zdGFuY2UgY3JlYXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICB9IGNhdGNoIChkb2N4RXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgRG9jeHRlbXBsYXRlciBpbnN0YW5jZTonLCBkb2N4RXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBNdWx0aSBlcnJvciAod2hpY2ggY29udGFpbnMgbXVsdGlwbGUgZXJyb3JzKVxuICAgICAgaWYgKGRvY3hFcnJvciAmJiBkb2N4RXJyb3IucHJvcGVydGllcyAmJiBkb2N4RXJyb3IucHJvcGVydGllcy5lcnJvcnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0RvY3h0ZW1wbGF0ZXIgcmVwb3J0ZWQgbXVsdGlwbGUgZXJyb3JzOicpO1xuICAgICAgICBcbiAgICAgICAgLy8gTG9nIGVhY2ggaW5kaXZpZHVhbCBlcnJvciBmb3IgZGVidWdnaW5nXG4gICAgICAgIGRvY3hFcnJvci5wcm9wZXJ0aWVzLmVycm9ycy5mb3JFYWNoKChlcnJvcjogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEVycm9yICR7aW5kZXggKyAxfTpgLCBlcnJvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTG9nIGRldGFpbGVkIGluZm9ybWF0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcy5leHBsYW5hdGlvbikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXhwbGFuYXRpb246ICR7ZXJyb3IucHJvcGVydGllcy5leHBsYW5hdGlvbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLmlkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBFcnJvciBJRDogJHtlcnJvci5wcm9wZXJ0aWVzLmlkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMueHRhZykge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVGFnIHdpdGggZXJyb3I6ICR7ZXJyb3IucHJvcGVydGllcy54dGFnfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMucG9zdHBhcnNlZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVGVtcGxhdGUgc3RydWN0dXJlIGFyb3VuZCBlcnJvcjonKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IucHJvcGVydGllcy5wb3N0cGFyc2VkLnNsaWNlKE1hdGgubWF4KDAsIGVycm9yLnByb3BlcnRpZXMub2Zmc2V0IC0gNSksIGVycm9yLnByb3BlcnRpZXMub2Zmc2V0ICsgNSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBUaHJvdyBhIG1vcmUgZGV0YWlsZWQgZXJyb3JcbiAgICAgICAgY29uc3QgZmlyc3RFcnJvciA9IGRvY3hFcnJvci5wcm9wZXJ0aWVzLmVycm9yc1swXSB8fCB7fTtcbiAgICAgICAgY29uc3QgZXhwbGFuYXRpb24gPSBmaXJzdEVycm9yLnByb3BlcnRpZXM/LmV4cGxhbmF0aW9uIHx8ICdVbmtub3duIHRlbXBsYXRlIGlzc3Vlcyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVtcGxhdGUgZXJyb3JzIGRldGVjdGVkOiAke2V4cGxhbmF0aW9ufSAoU2VlIGNvbnNvbGUgZm9yIGZ1bGwgZGV0YWlscylgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIERvY3h0ZW1wbGF0ZXI6ICR7ZG9jeEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBkb2N4RXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlbmRlciB0aGUgZG9jdW1lbnQgd2l0aCB0aGUgcHJvdmlkZWQgZGF0YVxuICAgICAgZG9jLnJlbmRlcihkYXRhKTtcbiAgICAgIGNvbnNvbGUubG9nKCdUZW1wbGF0ZSByZW5kZXJlZCB3aXRoIGRhdGEnKTtcbiAgICB9IGNhdGNoIChyZW5kZXJFcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW5kZXJpbmcgdGVtcGxhdGU6JywgcmVuZGVyRXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciBNdWx0aSBlcnJvciAod2hpY2ggY29udGFpbnMgbXVsdGlwbGUgZXJyb3JzKVxuICAgICAgaWYgKHJlbmRlckVycm9yICYmIHJlbmRlckVycm9yLnByb3BlcnRpZXMgJiYgcmVuZGVyRXJyb3IucHJvcGVydGllcy5lcnJvcnMpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0RvY3h0ZW1wbGF0ZXIgcmVwb3J0ZWQgbXVsdGlwbGUgcmVuZGVyIGVycm9yczonKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExvZyBlYWNoIGluZGl2aWR1YWwgZXJyb3IgZm9yIGRlYnVnZ2luZ1xuICAgICAgICByZW5kZXJFcnJvci5wcm9wZXJ0aWVzLmVycm9ycy5mb3JFYWNoKChlcnJvcjogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFJlbmRlciBFcnJvciAke2luZGV4ICsgMX06YCwgZXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEV4cGxhbmF0aW9uOiAke2Vycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb259YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IucHJvcGVydGllcy5pZCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgSUQ6ICR7ZXJyb3IucHJvcGVydGllcy5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvci5wcm9wZXJ0aWVzLnh0YWcpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFRhZyB3aXRoIGVycm9yOiAke2Vycm9yLnByb3BlcnRpZXMueHRhZ31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvZyB0aGUgZGF0YSBwYXRoIHRoYXQgY2F1c2VkIHRoZSBpc3N1ZSBpZiBrbm93blxuICAgICAgICAgICAgaWYgKGVycm9yLnByb3BlcnRpZXMudGFnKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUZW1wbGF0ZSB0YWc6ICR7ZXJyb3IucHJvcGVydGllcy50YWd9YCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSYXcgdGFnOiAke2Vycm9yLnByb3BlcnRpZXMucmF3fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBUaHJvdyBhIG1vcmUgZGV0YWlsZWQgZXJyb3JcbiAgICAgICAgY29uc3QgZmlyc3RFcnJvciA9IHJlbmRlckVycm9yLnByb3BlcnRpZXMuZXJyb3JzWzBdIHx8IHt9O1xuICAgICAgICBjb25zdCBleHBsYW5hdGlvbiA9IGZpcnN0RXJyb3IucHJvcGVydGllcz8uZXhwbGFuYXRpb24gfHwgJ1Vua25vd24gdGVtcGxhdGUgcmVuZGVyaW5nIGlzc3Vlcyc7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVtcGxhdGUgcmVuZGVyaW5nIGVycm9yczogJHtleHBsYW5hdGlvbn0gKFNlZSBjb25zb2xlIGZvciBmdWxsIGRldGFpbHMpYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGluZGl2aWR1YWwgRG9jeHRlbXBsYXRlciBlcnJvcnMgd2l0aCBwcm9wZXJ0aWVzXG4gICAgICBpZiAocmVuZGVyRXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAncHJvcGVydGllcycgaW4gcmVuZGVyRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSByZW5kZXJFcnJvci5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICBjb25zb2xlLmxvZygnRGV0YWlsZWQgcmVuZGVyIGVycm9yIHByb3BlcnRpZXM6JywgcHJvcHMpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIHJlbmRlciBlcnJvcjogJHtwcm9wcy5leHBsYW5hdGlvbiB8fCByZW5kZXJFcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byByZW5kZXIgdGVtcGxhdGU6ICR7cmVuZGVyRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHJlbmRlckVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEdlbmVyYXRlIHRoZSBvdXRwdXQgZG9jdW1lbnRcbiAgICBsZXQgb3V0cHV0O1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQgPSBkb2MuZ2V0WmlwKCkuZ2VuZXJhdGUoe1xuICAgICAgICB0eXBlOiAnYmxvYicsXG4gICAgICAgIGNvbXByZXNzaW9uOiAnREVGTEFURScsXG4gICAgICAgIG1pbWVUeXBlOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZyhgT3V0cHV0IGRvY3VtZW50IGdlbmVyYXRlZCBzdWNjZXNzZnVsbHkgKCR7b3V0cHV0LnNpemV9IGJ5dGVzKWApO1xuICAgIH0gY2F0Y2ggKGdlbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZW5lcmF0aW5nIG91dHB1dCBkb2N1bWVudDonLCBnZW5FcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBvdXRwdXQ6ICR7Z2VuRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGdlbkVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHJ1bm5pbmcgaW4gYnJvd3Nlciwgc2F2ZSB0aGUgZmlsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2F2ZUFzKG91dHB1dCwgb3V0cHV0RmlsZW5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhgRmlsZSBzYXZlZCBhcyAke291dHB1dEZpbGVuYW1lfWApO1xuICAgICAgfSBjYXRjaCAoc2F2ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBmaWxlOicsIHNhdmVFcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNhdmUgZmlsZTogJHtzYXZlRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHNhdmVFcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdlbmVyYXRlRG9jeEZyb21UZW1wbGF0ZTonLCBlcnJvcik7XG4gICAgXG4gICAgLy8gSWYgaXQncyBhIFBpelppcCBlcnJvciAobGlrZWx5IGludmFsaWQgdGVtcGxhdGUpXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnemlwJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1BpelppcCBlcnJvciAtIGludmFsaWQgdGVtcGxhdGUgZmlsZSBzdHJ1Y3R1cmUnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGVtcGxhdGUgZmlsZSBpcyBub3QgYSB2YWxpZCBET0NYL1pJUCBmaWxlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJldGhyb3cgdGhlIGVycm9yXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGZhbGxiYWNrIEhUTUwgcmVwb3J0IHdoZW4gRE9DWCB0ZW1wbGF0ZSBmYWlsc1xuICogQHBhcmFtIHJlcG9ydERhdGEgLSBUaGUgcmVwb3J0IGRhdGEgdG8gZXhwb3J0XG4gKiBAcmV0dXJucyBBIGJsb2Igd2l0aCBIVE1MIGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVGYWxsYmFja0h0bWxSZXBvcnQocmVwb3J0RGF0YTogUmVjb3JkPHN0cmluZywgYW55Pik6IEJsb2Ige1xuICBjb25zdCBzdHVkZW50TmFtZSA9IHJlcG9ydERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24/LmZpcnN0TmFtZSBcbiAgICA/IGAke3JlcG9ydERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5maXJzdE5hbWV9ICR7cmVwb3J0RGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmxhc3ROYW1lfWBcbiAgICA6ICdTdHVkZW50JztcbiAgXG4gIC8vIENyZWF0ZSBhIHNpbXBsZSBIVE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXBvcnRcbiAgbGV0IGh0bWwgPSBgXG4gICAgPCFET0NUWVBFIGh0bWw+XG4gICAgPGh0bWw+XG4gICAgPGhlYWQ+XG4gICAgICA8bWV0YSBjaGFyc2V0PVwidXRmLThcIj5cbiAgICAgIDx0aXRsZT5SZXBvcnQgZm9yICR7c3R1ZGVudE5hbWV9PC90aXRsZT5cbiAgICAgIDxzdHlsZT5cbiAgICAgICAgYm9keSB7IGZvbnQtZmFtaWx5OiBBcmlhbCwgc2Fucy1zZXJpZjsgbWFyZ2luOiA0MHB4OyBsaW5lLWhlaWdodDogMS42OyB9XG4gICAgICAgIGgxLCBoMiwgaDMgeyBjb2xvcjogIzQ0NDsgfVxuICAgICAgICAuc2VjdGlvbiB7IG1hcmdpbi1ib3R0b206IDMwcHg7IH1cbiAgICAgICAgLmRvbWFpbiB7IG1hcmdpbi1ib3R0b206IDIwcHg7IHBhZGRpbmc6IDE1cHg7IGJvcmRlcjogMXB4IHNvbGlkICNlZWU7IH1cbiAgICAgICAgLmRvbWFpbi1oZWFkZXIgeyBkaXNwbGF5OiBmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47IGFsaWduLWl0ZW1zOiBjZW50ZXI7IH1cbiAgICAgICAgLmNvbmNlcm4geyBjb2xvcjogI2Y1OWUwYjsgZm9udC1zaXplOiAxNHB4OyB9XG4gICAgICAgIC5uby1jb25jZXJuIHsgY29sb3I6ICMxMGI5ODE7IGZvbnQtc2l6ZTogMTRweDsgfVxuICAgICAgICB1bCB7IG1hcmdpbi10b3A6IDVweDsgfVxuICAgICAgICBAbWVkaWEgcHJpbnQge1xuICAgICAgICAgIGJvZHkgeyBtYXJnaW46IDAuNWluOyB9XG4gICAgICAgICAgLmRvbWFpbiB7IGJyZWFrLWluc2lkZTogYXZvaWQ7IH1cbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cbiAgICA8L2hlYWQ+XG4gICAgPGJvZHk+XG4gICAgICA8aDE+UmVwb3J0IGZvciAke3N0dWRlbnROYW1lfTwvaDE+XG4gICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvblwiPlxuICAgICAgICA8aDI+U3R1ZGVudCBJbmZvcm1hdGlvbjwvaDI+XG4gICAgICAgIDxwPjxzdHJvbmc+RE9COjwvc3Ryb25nPiAke3JlcG9ydERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24/LkRPQiB8fCAnTi9BJ308L3A+XG4gICAgICAgIDxwPjxzdHJvbmc+UmVwb3J0IERhdGU6PC9zdHJvbmc+ICR7cmVwb3J0RGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbj8ucmVwb3J0RGF0ZSB8fCAnTi9BJ308L3A+XG4gICAgICAgIDxwPjxzdHJvbmc+UmVhc29uIGZvciBSZWZlcnJhbDo8L3N0cm9uZz4gJHtyZXBvcnREYXRhLmhlYWRlcj8ucmVhc29uRm9yUmVmZXJyYWwgfHwgJ04vQSd9PC9wPlxuICAgICAgPC9kaXY+XG4gIGA7XG4gIFxuICAvLyBBZGQgZG9tYWlucyBzZWN0aW9uXG4gIGlmIChyZXBvcnREYXRhLmFzc2Vzc21lbnRSZXN1bHRzPy5kb21haW5zKSB7XG4gICAgaHRtbCArPSBgPGRpdiBjbGFzcz1cInNlY3Rpb25cIj48aDI+QXNzZXNzbWVudCBSZXN1bHRzPC9oMj5gO1xuICAgIFxuICAgIE9iamVjdC5lbnRyaWVzKHJlcG9ydERhdGEuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWlucykuZm9yRWFjaCgoW2RvbWFpbk5hbWUsIGRvbWFpbl06IFtzdHJpbmcsIGFueV0pID0+IHtcbiAgICAgIGlmIChkb21haW4udG9waWNTZW50ZW5jZSB8fCBkb21haW4uc3RyZW5ndGhzPy5sZW5ndGggfHwgZG9tYWluLm5lZWRzPy5sZW5ndGgpIHtcbiAgICAgICAgaHRtbCArPSBgXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImRvbWFpblwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImRvbWFpbi1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgPGgzPiR7ZG9tYWluTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGRvbWFpbk5hbWUuc2xpY2UoMSl9IExhbmd1YWdlPC9oMz5cbiAgICAgICAgICAgICAgJHtkb21haW4uaXNDb25jZXJuICE9PSB1bmRlZmluZWQgPyBcbiAgICAgICAgICAgICAgICBgPHNwYW4gY2xhc3M9XCIke2RvbWFpbi5pc0NvbmNlcm4gPyAnY29uY2VybicgOiAnbm8tY29uY2Vybid9XCI+JHtkb21haW4uaXNDb25jZXJuID8gJ0FyZWEgb2YgQ29uY2VybicgOiAnTm8gQ29uY2Vybid9PC9zcGFuPmAgOiBcbiAgICAgICAgICAgICAgICAnJ31cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgJHtkb21haW4udG9waWNTZW50ZW5jZSA/IGA8cD4ke2RvbWFpbi50b3BpY1NlbnRlbmNlfTwvcD5gIDogJyd9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICR7ZG9tYWluLnN0cmVuZ3Rocz8ubGVuZ3RoID8gYFxuICAgICAgICAgICAgICA8aDQ+U3RyZW5ndGhzOjwvaDQ+XG4gICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAke2RvbWFpbi5zdHJlbmd0aHMubWFwKChpdGVtOiBzdHJpbmcpID0+IGA8bGk+JHtpdGVtfTwvbGk+YCkuam9pbignJyl9XG4gICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICBgIDogJyd9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICR7ZG9tYWluLm5lZWRzPy5sZW5ndGggPyBgXG4gICAgICAgICAgICAgIDxoND5OZWVkczo8L2g0PlxuICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgJHtkb21haW4ubmVlZHMubWFwKChpdGVtOiBzdHJpbmcpID0+IGA8bGk+JHtpdGVtfTwvbGk+YCkuam9pbignJyl9XG4gICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICBgIDogJyd9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICR7ZG9tYWluLmltcGFjdFN0YXRlbWVudCA/IGBcbiAgICAgICAgICAgICAgPGg0PkVkdWNhdGlvbmFsIEltcGFjdDo8L2g0PlxuICAgICAgICAgICAgICA8cD4ke2RvbWFpbi5pbXBhY3RTdGF0ZW1lbnR9PC9wPlxuICAgICAgICAgICAgYCA6ICcnfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGh0bWwgKz0gYDwvZGl2PmA7XG4gIH1cbiAgXG4gIC8vIEFkZCByZWNvbW1lbmRhdGlvbnNcbiAgaWYgKHJlcG9ydERhdGEuY29uY2x1c2lvbj8ucmVjb21tZW5kYXRpb25zKSB7XG4gICAgaHRtbCArPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvblwiPlxuICAgICAgICA8aDI+UmVjb21tZW5kYXRpb25zPC9oMj5cbiAgICAgICAgJHtyZXBvcnREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmFjY29tbW9kYXRpb25zPy5sZW5ndGggPyBgXG4gICAgICAgICAgPGgzPkFjY29tbW9kYXRpb25zOjwvaDM+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAgJHtyZXBvcnREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmFjY29tbW9kYXRpb25zLm1hcCgoaXRlbTogc3RyaW5nKSA9PiBgPGxpPiR7aXRlbX08L2xpPmApLmpvaW4oJycpfVxuICAgICAgICAgIDwvdWw+XG4gICAgICAgIGAgOiAnJ31cbiAgICAgICAgXG4gICAgICAgICR7cmVwb3J0RGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzPy5sZW5ndGggPyBgXG4gICAgICAgICAgPGgzPkZhY2lsaXRhdGlvbiBTdHJhdGVnaWVzOjwvaDM+XG4gICAgICAgICAgPHVsPlxuICAgICAgICAgICAgJHtyZXBvcnREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmZhY2lsaXRhdGlvblN0cmF0ZWdpZXMubWFwKChpdGVtOiBzdHJpbmcpID0+IGA8bGk+JHtpdGVtfTwvbGk+YCkuam9pbignJyl9XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgYCA6ICcnfVxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuICBcbiAgaHRtbCArPSBgXG4gICAgICA8Zm9vdGVyPlxuICAgICAgICA8cD48ZW0+VGhpcyBpcyBhIGZhbGxiYWNrIEhUTUwgcmVwb3J0IGdlbmVyYXRlZCBiZWNhdXNlIHRoZSBET0NYIHRlbXBsYXRlIGNvdWxkIG5vdCBiZSBwcm9jZXNzZWQuIFxuICAgICAgICBZb3UgY2FuIHByaW50IHRoaXMgSFRNTCBmaWxlIHRvIGNyZWF0ZSBhIFBERi48L2VtPjwvcD5cbiAgICAgIDwvZm9vdGVyPlxuICAgIDwvYm9keT5cbiAgICA8L2h0bWw+XG4gIGA7XG4gIFxuICByZXR1cm4gbmV3IEJsb2IoW2h0bWxdLCB7IHR5cGU6ICd0ZXh0L2h0bWwnIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHNpbXBsZSBlbXB0eSBET0NYIHRlbXBsYXRlIHByb2dyYW1tYXRpY2FsbHlcbiAqIFRoaXMgaXMgYSBsYXN0LXJlc29ydCBmYWxsYmFjayB3aGVuIGFsbCB0ZW1wbGF0ZSBmaWxlcyBmYWlsIHRvIGxvYWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlUZW1wbGF0ZSgpOiBBcnJheUJ1ZmZlciB7XG4gIC8vIERlZmluZSBhIG1pbmltYWwgdmFsaWQgRE9DWCBmaWxlIHN0cnVjdHVyZSBhcyBhIGJhc2U2NCBzdHJpbmdcbiAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgZW1wdHkgRE9DWCBmaWxlIHdpdGggbWluaW1hbCBjb250ZW50XG4gIGNvbnN0IG1pbmltYWxEb2N4QmFzZTY0ID0gJ1VFc0RCQlFBQmdBSUFBQUFJUUE5OEVFdVRnRUFBT0lDQUFBTEFBQUFYM0psYkhNdkxuSmxiSE9ra3NGcXd6QU1RTytEL1lmUnZWRmFHSU5odXpCRzd6YjJBNHhzVEl2YjJaVGFUdnIzT1pDd3JTNVpHTHJhU1h6NkFVbmtldjd6OXVObGtDYXh6RGg2MU1BZ2Vjc0UyOU1VM01GangrbHErU3R5U3FYdXkyVmMySlViTUp4TEZCYWxTWE1RcEpMaHdQU040MVNTZGkweHBzOHZyUjFvUHJTYkx1QWd3bHhBcWprVFltM1A5Ky8vbWZmVlFoQjByZzU1c2FVY3kvTVlxcUJMVi96MWcrU2Y2aThxWGxycGVZTVBzSVhwWDB4R2JtN0FmQ0J4ejlIWGRDS1hFempONVg4T2gzUDZlQmFNWi9ZSnJBc3d2TmF5MVBMRnhvZDVJUVRtYURRU012WlVpZFZyQnY5WEtqVFNlbFRKUnlZem95Y0JLQkhKeEJhZTlKVGNzS01xWE5Zdisxb1d6eGZpc3dRWG9NTFhjUGg3WGZrR1VFc0RCQlFBQmdBSUFBQUFJUUFCbnQ4ZlJ3RUFBT1lFQUFBY0FBQUFkMjl5WkM5ZmNtVnNjeTlrYjJOMWJXVnVkQzU0Yld3dWNtVnNjN1NVMzByRE1CREc3NFBkSWVTKzZjcWkxSFJkaUFwN0piZ0gyS1FuVzJ5VGtLVHEzcHNrWFN0VE84cC9OdzM1UHQ3M0pXUjFjOVBIWWdzNWU0d05MVXRWUUhSSVB2WU5mSDQ4ckc1QVpCYXhKWThSQWw4ZzFtUmVQcit0bnRBUzVXTE9zL1ZCRkVEc1lBUFcydDFTNVlXRm5ySlM3OUFWMEduc0tWT2RtMHpqbDJ6STlsU3ZkTDFXT3hablBJQVpCTlZPR3NoVjdHcVF1ZGg4QUsvYzJhWFFHcnFEdVBJWWozZVFNQnlpTmZmRUQ1U1o4eTY3dXBqazhSbCtjdUs3dWNSRENSa2pwc0w0Sk1WeHh1YzVodVBCRm1FLzdHMGhmT0pMUU9TaUdHcVVJSm5ubEM1cDY0RXl5WWZVcUpuM2tUaHpoVnpZRGtNSkFrTk93LzBzZmdGUVN3TUVGQUFHQUFnQUFBQWhBTlprczFIMEFBQUFNUU1BQUJFQUFBQmtiMk5RY205d2N5OWpiM0psTG5odGJIUE1razFQd3pBTWh1OUkvSWNvbHdsaUkyaWxLdFp0d2dscGlNT1EwRGd0V3B1c1NSMVYvZmZZVkRRSndZbkwrUFh6T25aMnVtdVZ1SU1QeHJrQ3BVbUdFRGhsY2FYckFuMjhiOFlyaElOMnFqVGFPU2pRQXdKYWxmZXpuYzlONjdiMEp0NmNCMElpTGhTb055WTBHY2VRZTFBMkpFNkQ1SmNtS0J2bEdPcmU0MENaUGJNM3BYaVZaUXU4c1VDVkRXT0liVUVMWERJbHYwQnZmOXpXMkdacUJ1V0kySHNpL0p2ZGJ4bkZ4dldHaVYrYVpxUklrajI5bUpWRTNWWFE0MzBKUFlrUkozTE1xYzdZNEtYTHFLZEprb3o1cUIrY1dwa21vYUpZMzNENEZ0VVhCZ0dTTXIya0dZKzJhSHhkTXBYSEZHVlpRZkNuOXYrTVp6UENYVHRVMTI3dkxhMWRWWE1vSjluRXY1dzJxejhwS3ZuSko0bCtkNTZqOGorVW5VdWRYbDNXMi9KMWd5N0hJWXJIeFdRNUNWVWYvRlcrQUViUjRVZFFjdUovVFQ0QlVFc0RCQlFBQmdBSUFBQUFJUURUNU9QaDhnb0FBTEdUQUFBVEFBQUFXME52Ym5SbGJuUmZWSGx3WlhOZExuaHRiTFdhWFcvYk9CYUc3d2ZzZjFEb2VtOWwyYzZIZ3pZejJNYkpkSU5tSmhzN2MwZUp0RVZFSmpXa25IaCsvVklpWlZ1SlFoTjFmTkVDQmkwK1BQd2s4dkNoZlBPdnUyeWFYVVZiMTFXNUNPYkxSWkRGc3FycVNibDdFZnk2ZjdQNUljanFuU2dya2xhWDhTSzRqM1h3citlLy92TG05bW5keGt3c0wrdEYwTy83MjlOaVVaZGR2SzNMWmJXUHBjbmt0V3hGYlg3SzNhSVc5VjNjYlJkYjI4V3lXSncyaTBsWm5nWHY0MWk4dUswcms4SzIyM0pjdm9uVk5OYXpqVmN4TGsxa0s5ZHhYcDBYNStJKzdZcDZJdCsrWG1kWmI1OS92Q2gzWDVQYnU4dXBpTXRuSmgwVHptWlQvR2JqZjF4NHUzdkFtMVQ3YWJJNktxOHYrOER1WExZS2MzWlozOWZwdUc0a3BnVlB4dElrdW96bHFNcm5sNlA3TDdjNVoxY1gwdy8yWDZNenMrT1RNbnVWYkxWMkphcmJuVjUvWEp3dHk4VmwxZVhKanJiYnRyRzJ2OTVrUlN0dWcyeXptWmwvOTJXVnR0T2lLSGVpTjVsV2wycDYvYkxiMnlUdmR1VWlLUE5GOE9LcXJzczQ3ZWVIYjlxTHFwVzlFSzFwSUVhNkRkTlNVY25aWXU5bGJKN1pqWFcxamMvYTdxWVJkU1ViMGQvRVBvdTdKT1Z3Wk5xT29VTlhxMm8vcFNGN0lmWERmdEhFY21mcUYyVnNidmwrczkxT2RxMDNoYzZ5RzNOMU85RkhVN2t3TFVQT1V1dXVGZDFWdiswelB4NWQ3Ky9Yay9rT2dkWkpmcjFQeXZHNkRxZW81WEx4anpsRENZUDZ4SitRREk2Qm96dGZMbk9POFBnb2pnd085UzQzZjl0WGg3L2VZcmcyTGZXcHpKZGpIVEo2SkNlT0t5TnByUyt6bC9QTng1RzRNdmQ0WE1rSnowdHhCVnUvc0hwbkc5SXUvaVdOY3JVY3JiM1JkTzU0YjJZZnJJNkxoL3p3NCs2SEdWL0diVXdmZkRCdUR2bEJYUnl2cmxmRm9lTXQ3ZTQvektOeVh3OFB1OUljVWJYTDF5ekZ3OXdZKzkzalZ2VFZaTndSRnhsbUgrYTBjM09LUlBxb1V3elhqNTFpWDdaWHNSOG5TZlJSNEc5bk56T083WWZrMXc4RGRyMk9aWm5zY3FVcVp2UEZ2V2dUYjVPVHhzOXFHRytOeDJzWjI4L1JqOFoxVzg3U2l1NW4vVkUvZldSUTlQcDJITFNqTCtOazBtd24yem5Hd1FEWHBxWndURHZNeGpQamJ6TXB5aGszL21GditySk0vRG5IbWZiU1JXOWRITGR0ZndqMFE0N3g5RVVmZVBWR3BQaThWWGNwT3B5UHFMWVhWeDlxY1VhaWpjRS9LVkVIc0o1Y2pGUENmbko1Y1RjZHgyT1NEWFBLUXpYMkZiVjVSKythV01WSmRYVEFKZm5pbURhZEJnODBLdFFuZkp6cFpuS1kzSDFPMFNlaWVQWmlTNkV2UjJuTTVtUFhjK1V4TGFkQm5DbFNycHdRUzJBN2d2bDRaNmJScUh6SlhRcE1Ra3JDckpnUTU4cTVmL3Q2ZDVzTERzdlUxeVJPUWtyQ0xKd1E1OHJwdlczdjdYeG1qWmNudlp0d0g5a0drSkl3cXpJaHpwWGJ0dnUreW5aM2FYWFFDUHNxNFpjdjN4dlFCakNUeFBWMVFod0MrTHphei9KbVYvNEhzN0tIRnp4TGFJTWtxVmQvSmJRaGhJZXJVMi96eS90KzI1bDNrWWV1b3FjWG5PM1FCcENTT0xWS2FFTUlEMWVuSGhicTYvN3F2TXFtOTRkVFdGY3ZkTGFHTm9Ba2NlcFZRaHNDK0x4NitJN3BJdW5HN3pjUDRWMjkwTmtaMmdCU0VxZFdDVzBJNGVIcTFEdHJUT3ZiOFgzTk5RTDNySU1US0VuTitpS2hEU0Y4WEoxNmI2M0ozTTBXMUk2ZDNua2QyaUJKelkwQ1Foc0MrTHg2WWdVelJJS3oxUmRXTUdpREpIRnFsVUpJekt1VEFZZVhrYzkrRk83b2hhZVFhQU5JU1p4OHBsQ0RJTytmUXc2alBHM0ZrTjcrUXp4SWtwcjFSUW8xQ1BKKzljUVNwZzhEWnlzc3BNc3c3T1JGckJSSWt0UXNMeEtvUVFRZlY2Y2VGakUyQzV5dHRNaHVSNmtVN3VaRkxHSklrdFFzTHhLb1FRUWZWNmQrOEs2SnZiWHR4TGtKUEd4UTAzY1V6N1pvQTBoSm5IeWxVSU5BSHErZVdNYllkTzdrWm5ZN090K2hEU0FsY2ZLVlFnMENlYng2WWgxajg4RFo2Z3M3R3JRQnBDUk92bEtvUVNDUFYrOGUzdjdhTXEwN3VibmREMzZGUUxKMVdydFNxRUVnajFjZjNVQjNjVGRmOG5DZFlQWml3OXNOa2lSMSs1ZDZpVm5sMWNOdzlhQTMxL01rWFRJSlA5STd6MUhRQnRpWnBHNzlOdVlFZ2FRZVZrNU40LzF0eFgwMlBiYlR6MU1OTEEzdk9VaVdSR3JYdUJQRWt2cXhHeEJIUFVpS3BuN1VRa0ZJWmxLN3hwMGdsdFJQTEVxR2dYQzJ1c1RTV2lDcFdlTU9rRXZxaVdYSk1CRmNydTYraHhSWUd0NkNBS1JtalR0QUxxa25saVhEUkhDNnVzVDZXaUNwV2VNT2tFdnFpV1hKTUJGY3JyNTZXRjdrRXNIMTJ3dHFwWUN5cEU2dDhYZEJBSjlYVDN3NDZhUXUvelorUC83eE5OWUpQcjFBM3dWWWx0U3A3ZXdGQVh4ZVBmRjVhZVpkblAzbTlKdnVwTjZmVHlQdkhyMDdSajlCRFJLN05jK1NCd2ptMWo3eHZXbFdwR2MzMkcxblR0SCtiblh3N3VIZE1Yb3hBaEs3TmMrU0J3am0xajd4em1ub3RVZkZKQ3Z2MDJsSnplZHAzdlRtYUhaUmo5L3NvRURpMUtsNWxqeEFNTFAyNFhQVC9iWWFqdG1GbUE2ZCtURFJNRGg4YTR3Q2liMTYwOG8wMWhIOHZMcExxb2FHL0RZYmVoTDRkTVBKMjBNVVNCdzZ0WjA5SW9BNzcvQjEvM0F4VE9DUHR3MW5ydzlSSUhIbzFMemVJc0o0YzA5L0xmbTh1L2sxR3g3SnAzbkQyZnQzRkVnY09qV3Z0NGd3M3R6OWNKSzFZNFA0ZmtUMVhHbHVFRkFnc1ZmdldwbkdPb0tmVjg4K25KakF3M1QyOUwwaUNpUU9uWnJYVzBRWWIrNTRPSyt2Zmp4ZkYrdnAvbFAyNEJjOGNqaDdINGNDaVVPbjV2VVdFY2FiZStLYjlkWFJqY1hWemZqSEtSNm1jbWZ2NDFBZ2NlalV2TjRpd25oekx4NXVLSHJSWCt5R2g0czZtNWJEci9EazUzbTg3Y2VKUE5TR25yeG5TWUhFb1ZPN0VVV0VjZVlldWR4UDlPWGh3Y2RLN090SmRac05aZUw3VGNHUm45M2c3RVZHQ2lyMmFwM2F4a2VFOGVZZTV6M2gyZFdoMWsvSzdEOFNsZmdmK2RuTjRld2xTZ29xOW1xZDJzWkhoUEhtZm5TdC84amZYMTVmWEcvZDN6NThYWXM2LzN5eUFjMXo4dVB5Tmo1ZllPRlRVQnZNbi84SFVFc0RCQlFBQmdBSUFBQUFJUUJtaGI2dHl3TUFBRG9OQUFBUEFBQUFkMjl5WkM5emRIbHNaWE11ZUcxc3BKYmJidHN3RElidkIrdzlDTjFuU3ByR2FZTFdXWkFtNjJYUXJvdmFkamN3TnRzUnBrT0dwQ1ROMisvSXljbXhDMVR0UmFKSS92dytFcDR2UC9aUzhLMnhsbXMxSS9HUUVjNlUwSFdyZGplTS9IeFlCQlBDcmFOVlM0Vldaa1lPeHBJUHM2OWY1dTFCV3UyTjRSWWpESzFtdExGdWQ1VWtWalJHVWp2VU82UGdTNk9OcEE1RXMwdGFqZGE2QzFLcGt6RWpWOG5YYjFrTjRhdlhHaXo1dmxVTDFkR05Oa0pZSGRyeVZCbUlicmt3SE96WnBESENSeE1KblpnUVh4TWwrYk81bjNIZXdUNWVwTHVmWXJ2ZlRSU05uMEU5SVBqcDJ2eE8vZStycDd0M21MTjB4ODU0Y0hWVjdtdzZOdHBIMTViRldvbVZOcDc0d1lpTDFKRjd3eS9GM3RZNjh5VFhvdk1WYm0rMVVVK0JhR3g3aDY1TmF4OGJaMFUvRjZXZ3pwb3lZaVJJUXJJZ1RraGFKSEhCVjV2bW5DcU9Ga0dTek5Nc0w5SmltWWNKTDE2SzhESkpZSTBzRFlKNHZnN0RWVEtQaTBXeEtOSTBYaVRKWXJYS2lqU09sMm1ScGtYeERwekxsZlpySlE2cWhkZ1hlbk13VDRoODhlVThuUnJJSGlKLzNIRTJkWEFJL0xIVHE2bUR3K2lQL1RaMU1JajlNWjN1allTcDNPNkJ1cHZSR0xxOUlJcXNMS1FQTHRCRnFmMXJaL0hEWFA4ek56eGIweGExSjArU2tac21OaFZOVFkwazErUk13MC9PejYyQytBUXZQZGpIRWcwWlA3MWxTUXFuRHdaOWg3QVplVmd2a2h6TDBhSHpERG02cjhnN0pLbXBjWmVhd1ZwUEs3d0EvS0l6VERWZHY0cEtuVjJ6RnBDVnFWdmIzN08wVzBNbmhHYUUxOXlTRFZLNFJiNVhqN3oyMmNKWHV1TVYxcmptVy9FNGtjMFp0Y05wTDBnVHdmMnowTUZFWTVyM3JMZERscDJad1k2S1RCWVc3SnBqd1hYSG9WREJ0bW1nUXdBNkZnTGNaUGQwQzlPUHZkTVcvbnRjYXlGY0krR1hlNE9qNUFIakd6ZjIrNjdGWHJ1RFhubmdMN1V3OWVhT21uWlFiMDhremp0N1FTWnZvUTl2Sm8vTWRNMnhVR3FKZEVWYTlUUWR2UVVZcEJoaUpnem4wQmRHUDNFTy85Vk8ySDExakN4SEU2a05UTmY3RFprTGpZMjdNWFpUdHp0bDhSUFo5ZUlCalRIVU9IUGRndGtkdzlSWVJSYlAwSmZJWFdkT1E0eFJQZUI5ck9IcW1xSnc5dUM3Z05uMEIwRStCMkdnMHczZGFqZFVNcndDNS9Kd2hnTmxjQXcvR3ZWc083Z3B3alROOG1NdmhLWGNxMGM0UUxCTVIvTTRDVlkvQjlNMEtaWko4WFl3M0ovKy9sWHkyZDRROFFMdjk3QTFZSy9CbGRSS3FUek00anpPOHVKK3Aya09EeEN4NVJzb3BXL0cwQStIKzRNV2VQdENiT0N1S1IrMWdRdmtiRlI2YjZFSlFETERMWkVQVHYwQlVFc0RCQlFBQmdBSUFBQUFJUUE2cUJDRXVRWUFBRFFiQUFBUkFBQUFkMjl5WkM5a2IyTjFiV1Z1ZEM1NGJXeTBXTnR1MnpnUWZTL1FmeUQwM2pweGJraWRpRWxiWkxQWm9saHZQMENXbUZpSUxJS1U0K1R2TzBOS2RwM3VOc2crMUpCRmNjaWRtVE5uT09ycmwvdjd4UElVVmNXazJKaURmdGR5Q1dTb0lpYmlqWG56NDJKblkxbFZEb25vWFVwY0cvTmN5dXJsemRkZi96MklxMWhWSEVXRnJIQ1JHL08rcXRMTlZxdGtmakd3dXJTbDUxWjgrcmsvSG5UdDU4bnQ5cnZEbTBKL3dMVGFkciszL2wrMENZK3V5QzJPM21VQnhZazg1Z2tWaFQ0a0RGbUtZb1lEdlpwRmVjWjFNblBDazlGM3pnSzNEMkZ6YVJVWGYvWTlOOU0vdnRYNXc5Y2pkalE4c1plb0NwblhEMGxINmc4VGxYTDlXWHBaWUkrRDRZYUtVYTl2amJxZTlTNXZFemg4emIvSkpFa2wxR2NYK2gyemZNZnJtQlduVzFZZGFhVERGanQxVjYyTGtYSlZaTEpNV2FEWER2czl5Mk5qZmJWdSthRlhYNjhkekJGMUdhU2RtTVowc090NXA5MVVzanltZ2NRSjU2Ymo5YzVjT2drVUZSRXZWQjNTd2EzWUpSekhiTmN2Q1VleEErM2EvK1BFQ1JHbFRFSXVHZFBMMmNoaE8rL01YZ0tkdmpPYnVlVG44cHUvNWZLdzIrbnU3dTV1RzZ2UHU4N09nMmxucHovbzdYNS9QOXZSb1I1RHhlNFBDREcrcjhXOVVaR2RIeWFYNlJIYnZ6bzV2NXJkbnAzTnJxYmptekZjWFkybjUyZm5sNU9ybzhuc2Z6RllRQ256RzNsOXhTS3hxWG9oaEl6bno4S242NnEyWnpmRVpScjJtV2FaMG4rN09CTEJiTXh1dW5MVXhsM0MxYncrWXZMUHhnazNMSE91TlB1MHdEbGZGU1VKVlp4cHBycWpxeEpwSXVRVEwySlphUEp1b0xZeEI3MUJwNzh4Zy81UWo1T1VaWERrSE41Y25yeE9LUzRTMmJTOFk1RktCTG1QVDMrbzhwRGtoNUw1eGV6TUhjZlIzUi96MmZtVisvdjBlbmUwVTRlQ1BtOHl2VHQ1Y25WeEQ5TjB0VmlwbndwTlNyWXp0elFkUlF4VmN3K0prRldZUE9YS0NkSWk0Vlc0MHZIa1ZrYWhPNnBDcW1MSkMxcld6cDUzcEFVUXJrUVlPMndWYTk0SmJGWGVxL2s0WDlEMFlYWWEzWG1uZ2YzRnc1ZldIWDA3L3ZaK2RIUjVZTzgvaDBUdlJ1OUhsOEg0bnorKys0ZjJEK2QvUHdhblBPWkZ4ZklxZDVKMEpYbnVVTkVYVldWK1lwR3pLajMzZ0R1T3FRaXBkdk04ZTBOcGU0Yk1NM2ZQUmNnL3hiS285aTBvTFBNSmw3bGFQd3FacWdBaGxxamxOeFZWMlZKL0tSbW1CS3RtK3lxbUxBcUt0Ym5SV3k3VGxjZlNIM1JtRGlXZ0lMUUlxVHFNNnluVG41bUxNUmd6Rno5a1JGR0ljMWc5b016QnA4eUIwTG1GaTZKNHA5NHpTL3ZOYytYV3MrUUpKVW1HZDV4VWpqMVFjSkRxWUkyVkJpcFNYQnd2VWhicWxLbUxweUwxc0YwNVdaUVVKMDBWZ0VpcGloaFVKS0FaRFFtaXRObURsT2wweG1JWGJmcFNKcnBkUTB1TG5ZWmExWWswVTZVaXMxV3RzYXJUR2U2MnlyQ21KVnZXT2l1YU1YTTFaOXJBRncrSXF0RHFlTDNWejY2WTlTeVo4L3VXQjErdDlxVllEUldsSE1walF0Vm9YZEVFVTg1S2J6UzBHNWRMS3RQV2lHZ2ZRYnhzSC9FVk9qUWh6YlF0V1BRYUpMbjQwRFRQWEtkQkpVZlB3TnE1R2tiNjQ0ZlVaVVNUN21WdkV6bVRKSkZLcmJYTXkveUJQRHBYVUxMS1NnVXhMcEpGbkVkTUJLWHUwTG9sOVJDbitRSmxJQ0ZzWVo1Vk1aUlZ5WFh1RzlDUXNudUNhUVVnK3FLZHlRblJ4YXF2K3FmTFlGQkdhQXpXeU1zSlExTjBxNm9yTGQ3V0toTGF3amJDZmJYTG9sTTlSbnVLclR5bHNLTk0xMnE5UmRTN0dVVHhWbnFwVlpGclZjT2xEMGwyalVxQ1kwZkVZaTVoN1A2S2cyWjF3K1NtMXFGSnpQRlRtRlE0a1JNTzdVYjF4YlpxMUJmYmFOSVhlOEFYTzJ3S2NtTjJxeldWNVZHckpWek1aUkVMYmZITjExRmZ5WStQakMvWXh1NnBLR1hkWFc5bEpUcjBuVzlkMER6Sk9xWUpiWjFMbnJMR3BaRXIzaFhodkcydk5BaTlaTkZ4QTFyUVV6VWM2SFp0TFJxZ05Qd0QxejMxMFpuT3lGRXRHUVUwZ0VXbUdqeUV1TWRWTjBnS3NzVE52aGtWak9MQ3NrRDNJMzlWRVhmYlk0cE4xM2xRTFV1SlRYZ1RqTjRwUi9PL2wxTThiVk9vUnhyekE4c0M1ZDZuUEdERUhFQkI5eU5XRkdNdEUxUzZGNTZweFZtS0M3L0R1cVN2OUdsU1lUTkpsVGIxc0lxZkVZejRSdUhJVHc1RjRDbS9PQlA1SEZIZ0NxRmJBY1hHVFhmUTdhK3FPYVRkaC9SNkd0SzEwQ0tzeUwxdmJjSG44akRRZUV5QWFIdjMvdHdGRGYvRkk0WWxEeWh3alFXcGZWaGozZEt3T2I3RkUrSlkzS0E5MVZwN08vUUdNbkpSYlBKTDFEWnM2aTNzT1hXbkZrNHE4SkNwTmUzTTJYRk10RGttM2U5UW5yeTY0cFJHRHhUbU1vcTV0TlFoUExBWXpETE45TFRHYnFUdktCeE1OQWsvSXpTUTVPWWZVRXNEQkJRQUJnQUlBQUFBSVFCUFFJRm5wZ0lBQUxJR0FBQWNBQUFBZDI5eVpDOWZjbVZzY3k5elpYUjBhVzVuY3k1NGJXd3VjbVZzY3kyVTIyN2JNQkJGWHdmMEh3UzlPN3JsSXNhZ0tCTFl5THBCbTZBZlFFaVVKSnVYZ3FUc3VQOWVsSFNUdHhuT0huSm1aOGhuTDc5bDYzMVBiVXd4VjZaUW1sbXBJOFpOcmt3dWVYcis5L2piS2wzK3ZiSGkzSEtoVFRIbmF2c0xFc250Ymh6YUlRa0JGOU9GVVZYWk5FSVlYeXV2NDJLc3ZlcGp6d3g2YjZIcnNLbldwbXBBN0hSWnlLZEtyYVdVbkpwUXBCYTBNT1dVWTdWVkZmMXRKRGVSemJFMDZKWGtUQlcxVWxMR1BYVnBOUXhETWZBdTlodndkM0hETUIrajRTSG80b01zRDkvUVQwQldMQzVXN1lEUVdxbkVoUWZqV21tMlZncE5lM0RCYTJWY3FSaUdVVkNNSDR5dnNOUW1oT0R3cmZCa1hDRjdNQlZrTUNWeUJ4ZE14c1I0QW5jQUg0eUxKZVJSWUR4NFlheUtNcnFGY1IrVit1RzBwSXJUSTdYTDV2UG9HVWZQOW9QVG42ZTkrUEtQemY0QVVFc0JBaTBBRkFBR0FBZ0FBQUFoQUQzd1FTNU9BUUFBemlZQUFBc0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFGOXlaV3h6THk1eVpXeHpVRXNCQWkwQUZBQUdBQWdBQUFBaEFBR2UzeDlIQVFBQXpRUUFBQndBQUFBQUFBQUFBQUFBQUFBQWtRUUFBSGR2Y21RdlgzSmxiSE12Wkc5amRXMWxiblF1ZUcxc0xuSmxiSE5RU3dFQ0xRQVVBQVlBQ0FBQUFDRUExbVN6VWZRQUFBQXhBd0FBRVFBQUFBQUFBQUFBQUFBQUFBQUNCZ0FBWkc5alVISnZjSE12WTI5eVpTNTRiV3hRU3dFQ0xRQVVBQVlBQ0FBQUFDRUEwK1RqNGZJS0FBQ3hrd0FBRXdBQUFBQUFBQUFBQUFBQUFBQXNCUUFBVzBOdmJuUmxiblJmVkhsd1pYTmRMbmh0YkZCTEFRSXRBQlFBQmdBSUFBQUFJUUJtaGI2dHl3TUFBRG9OQUFBUEFBQUFBQUFBQUFBQUFBQUFBRjhUQUFCM2IzSmtMM04wZVd4bGN5NTRiV3hRU3dFQ0xRQVVBQVlBQ0FBQUFDRUFPcWdRaExrR0FBQXZIZ0FBRVFBQUFBQUFBQUFBQUFBQUFBQlRGd0FBZDI5eVpDOWtiMk4xYldWdWRDNTRiV3hRU3dFQ0xRQVVBQVlBQ0FBQUFDRUFUMENCWjZZQ0FBQzNCZ0FBSEFBQUFBQUFBQUFBQUFBQUFBQlNIZ0FBZDI5eVpDOWZjbVZzY3k5elpYUjBhVzVuY3k1NGJXd3VjbVZzYzFCTEJRWUFBQUFBQndBSEFQMEJBQUJXSWdBQUFBQUEnO1xuICBcbiAgLy8gQ29udmVydCBiYXNlNjQgdG8gQXJyYXlCdWZmZXJcbiAgY29uc3QgYmluYXJ5U3RyaW5nID0gd2luZG93LmF0b2IobWluaW1hbERvY3hCYXNlNjQpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgXG4gIHJldHVybiBieXRlcy5idWZmZXI7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSByZXBvcnQgZG9jeCBmcm9tIHRoZSByZXBvcnQgZGF0YVxuICogQHBhcmFtIHJlcG9ydERhdGEgLSBUaGUgcmVwb3J0IGRhdGEgZnJvbSB0aGUgYXBwbGljYXRpb25cbiAqIEBwYXJhbSB0ZW1wbGF0ZUJ1ZmZlciAtIFRoZSBiaW5hcnkgdGVtcGxhdGUgZmlsZSBhcyBhbiBBcnJheUJ1ZmZlciAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgZ2VuZXJhdGVkIGZpbGUgYXMgYSBCbG9iXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVJlcG9ydERvY3goXG4gIHJlcG9ydERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIHRlbXBsYXRlQnVmZmVyPzogQXJyYXlCdWZmZXJcbik6IFByb21pc2U8QmxvYj4ge1xuICAvLyBHZW5lcmF0ZSB0aGUgZmlsZW5hbWUgYmFzZWQgb24gcmVwb3J0IGRhdGFcbiAgY29uc3Qgc3R1ZGVudE5hbWUgPSByZXBvcnREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5maXJzdE5hbWUgXG4gICAgPyBgJHtyZXBvcnREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZmlyc3ROYW1lfV8ke3JlcG9ydERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5sYXN0TmFtZX1gXG4gICAgOiAnc3R1ZGVudCc7XG4gIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdO1xuICBjb25zdCBmaWxlbmFtZSA9IGAke3N0dWRlbnROYW1lLnJlcGxhY2UoL1xccysvZywgJ18nKX1fcmVwb3J0XyR7dGltZXN0YW1wfS5kb2N4YDtcbiAgXG4gIHRyeSB7XG4gICAgLy8gSWYgbm8gdGVtcGxhdGUgYnVmZmVyIGlzIHByb3ZpZGVkLCB1c2UgYSBkZWZhdWx0IHRlbXBsYXRlXG4gICAgaWYgKCF0ZW1wbGF0ZUJ1ZmZlcikge1xuICAgICAgLy8gVXNlIGZldGNoIHRvIGdldCB0aGUgdGVtcGxhdGUgaWYgd2UncmUgaW4gdGhlIGJyb3dzZXJcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdObyB0ZW1wbGF0ZSBidWZmZXIgcHJvdmlkZWQsIGZldGNoaW5nIGRlZmF1bHQgdGVtcGxhdGUnKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gdXNlIHJlc3BvbnNlLmFycmF5QnVmZmVyKCkgd2hpY2ggZW5zdXJlcyBiaW5hcnkgZGF0YSBoYW5kbGluZ1xuICAgICAgICAgIC8vIFVzZSBsYXMtYXNzZXNzbWVudC1yZXBvcnQtdGVtcGxhdGUuZG9jeCBpbnN0ZWFkIG9mIHJlcG9ydC10ZW1wbGF0ZS5kb2N4ICh3aGljaCBpcyBhIHRleHQgZmlsZSwgbm90IGEgRE9DWClcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvdGVtcGxhdGVzL2xhcy1hc3Nlc3NtZW50LXJlcG9ydC10ZW1wbGF0ZS5kb2N4Jywge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIGNhY2hlOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50JyxcbiAgICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggZGVmYXVsdCB0ZW1wbGF0ZTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCdEZWZhdWx0IHRlbXBsYXRlIGZldGNoZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgdGVtcGxhdGVCdWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBEZWZhdWx0IHRlbXBsYXRlIGJ1ZmZlciBzaXplOiAke3RlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmYXVsdCB0ZW1wbGF0ZSBmaWxlIGlzIGVtcHR5Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFZlcmlmeSB0aGUgdGVtcGxhdGUgaGFzIGEgcHJvcGVyIERPQ1ggc2lnbmF0dXJlXG4gICAgICAgICAgY29uc3QgZmlyc3RCeXRlcyA9IG5ldyBVaW50OEFycmF5KHRlbXBsYXRlQnVmZmVyLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICBpZiAoIShmaXJzdEJ5dGVzWzBdID09PSAweDUwICYmIGZpcnN0Qnl0ZXNbMV0gPT09IDB4NEIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIERPQ1ggZmlsZSBzaWduYXR1cmUgaW4gZGVmYXVsdCB0ZW1wbGF0ZS4gRmlyc3QgYnl0ZXM6JywgQXJyYXkuZnJvbShmaXJzdEJ5dGVzKSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlZmF1bHQgdGVtcGxhdGUgaXMgbm90IGEgdmFsaWQgRE9DWCBmaWxlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgZGVmYXVsdCB0ZW1wbGF0ZTonLCBlcnJvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IGFsdGVybmF0aXZlIHRlbXBsYXRlIGFzIGEgbGFzdCByZXNvcnRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gbG9hZCBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZTogbGFzLWFzc2Vzc21lbnQtcmVwb3J0LXRlbXBsYXRlLWZpeGVkLmRvY3gnKTtcbiAgICAgICAgICAgIGNvbnN0IGFsdFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy90ZW1wbGF0ZXMvbGFzLWFzc2Vzc21lbnQtcmVwb3J0LXRlbXBsYXRlLWZpeGVkLmRvY3gnLCB7XG4gICAgICAgICAgICAgIGNhY2hlOiAnbm8tY2FjaGUnLFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gICAgICAgICAgICAgICAgJ0NhY2hlLUNvbnRyb2wnOiAnbm8tY2FjaGUnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWFsdFJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGFsdGVybmF0aXZlIHRlbXBsYXRlOiAke2FsdFJlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGVtcGxhdGVCdWZmZXIgPSBhd2FpdCBhbHRSZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEFsdGVybmF0aXZlIHRlbXBsYXRlIGJ1ZmZlciBzaXplOiAke3RlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgYWx0ZXJuYXRpdmUgdGVtcGxhdGVcbiAgICAgICAgICAgIGNvbnN0IGFsdEZpcnN0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0ZW1wbGF0ZUJ1ZmZlci5zbGljZSgwLCA0KSk7XG4gICAgICAgICAgICBpZiAoIShhbHRGaXJzdEJ5dGVzWzBdID09PSAweDUwICYmIGFsdEZpcnN0Qnl0ZXNbMV0gPT09IDB4NEIpKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgRE9DWCBmaWxlIHNpZ25hdHVyZSBpbiBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZScpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsdGVybmF0aXZlIHRlbXBsYXRlIGlzIG5vdCBhIHZhbGlkIERPQ1ggZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgfSBjYXRjaCAoYWx0RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgYWx0ZXJuYXRpdmUgdGVtcGxhdGU6JywgYWx0RXJyb3IpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBcyBhIGxhc3QgcmVzb3J0LCBjcmVhdGUgYSBtaW5pbWFsIHZhbGlkIERPQ1ggdGVtcGxhdGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBtaW5pbWFsIGVtcHR5IERPQ1ggdGVtcGxhdGUnKTtcbiAgICAgICAgICAgIHRlbXBsYXRlQnVmZmVyID0gY3JlYXRlRW1wdHlUZW1wbGF0ZSgpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYENyZWF0ZWQgbWluaW1hbCB0ZW1wbGF0ZSB3aXRoIHNpemU6ICR7dGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZUJ1ZmZlciB8fCB0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIEFsbCB0ZW1wbGF0ZSBhdHRlbXB0cyBmYWlsZWQsIGZhbGwgYmFjayB0byBIVE1MXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIHRlbXBsYXRlIGF0dGVtcHRzIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2VydmVyLXNpZGUgaGFuZGxpbmcgd291bGQgYmUgZGlmZmVyZW50XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGVtcGxhdGUgYnVmZmVyIGlzIHJlcXVpcmVkIHdoZW4gcnVubmluZyBvbiBzZXJ2ZXInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3JtYXQgYW5kIHByZXBhcmUgZGF0YSBmb3IgdGhlIHRlbXBsYXRlXG4gICAgY29uc3QgZm9ybWF0dGVkRGF0YSA9IGZvcm1hdFJlcG9ydERhdGFGb3JEb2N4KHJlcG9ydERhdGEpO1xuICAgIGNvbnNvbGUubG9nKCdEYXRhIGZvcm1hdHRlZCBmb3IgRE9DWCB0ZW1wbGF0ZScpO1xuXG4gICAgLy8gR2VuZXJhdGUgdGhlIGRvY3VtZW50XG4gICAgcmV0dXJuIGF3YWl0IGdlbmVyYXRlRG9jeEZyb21UZW1wbGF0ZSh0ZW1wbGF0ZUJ1ZmZlciwgZm9ybWF0dGVkRGF0YSwgZmlsZW5hbWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdlbmVyYXRlUmVwb3J0RG9jeDonLCBlcnJvcik7XG4gICAgXG4gICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yIHdpdGggdGhlIHRlbXBsYXRlIG9yIGRvY3h0ZW1wbGF0ZXIsXG4gICAgLy8gdHJ5IHRvIGdlbmVyYXRlIGEgZmFsbGJhY2sgSFRNTCByZXBvcnRcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBcbiAgICAgICAgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3ppcCcpIHx8IFxuICAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygndGVtcGxhdGUnKSB8fCBcbiAgICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ2RvY3h0ZW1wbGF0ZXInKSkpIHtcbiAgICAgIFxuICAgICAgY29uc29sZS53YXJuKCdET0NYIGdlbmVyYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gSFRNTCBleHBvcnQnKTtcbiAgICAgIGNvbnN0IGh0bWxCbG9iID0gZ2VuZXJhdGVGYWxsYmFja0h0bWxSZXBvcnQocmVwb3J0RGF0YSk7XG4gICAgICBjb25zdCBodG1sRmlsZW5hbWUgPSBgJHtzdHVkZW50TmFtZS5yZXBsYWNlKC9cXHMrL2csICdfJyl9X3JlcG9ydF8ke3RpbWVzdGFtcH0uaHRtbGA7XG4gICAgICBcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzYXZlQXMoaHRtbEJsb2IsIGh0bWxGaWxlbmFtZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBodG1sQmxvYjtcbiAgICB9XG4gICAgXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JtYXQgdGhlIHJlcG9ydCBkYXRhIGZvciBkb2N4IHRlbXBsYXRlIHJlbmRlcmluZ1xuICogQHBhcmFtIHJlcG9ydERhdGEgLSBUaGUgcmF3IHJlcG9ydCBkYXRhIGZyb20gdGhlIGFwcGxpY2F0aW9uXG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgZGF0YSByZWFkeSBmb3IgZG9jeCB0ZW1wbGF0ZVxuICovXG5mdW5jdGlvbiBmb3JtYXRSZXBvcnREYXRhRm9yRG9jeChyZXBvcnREYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIC8vIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGUgcmVwb3J0IGRhdGFcbiAgY29uc3QgZm9ybWF0dGVkRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVwb3J0RGF0YSkpO1xuXG4gIC8vIEZvcm1hdCBhcnJheXMgdG8gYmUgbW9yZSBkb2N4LXRlbXBsYXRlIGZyaWVuZGx5XG4gIC8vIEFycmF5cyBpbiBkb2N4dGVtcGxhdGVyIGFyZSB0eXBpY2FsbHkgaGFuZGxlZCB3aXRoIGxvb3BzLCBzbyB3ZSdsbCBmb3JtYXQgdGhlbVxuICAvLyB0byBiZSByZWFkeSBmb3IgdGhlIHRlbXBsYXRlIHN5bnRheFxuXG4gIC8vIFByb2Nlc3Mgc3RyZW5ndGggYW5kIG5lZWRzIGxpc3RzIGZvciBlYWNoIGRvbWFpblxuICBPYmplY3Qua2V5cyhmb3JtYXR0ZWREYXRhLmFzc2Vzc21lbnRSZXN1bHRzPy5kb21haW5zIHx8IHt9KS5mb3JFYWNoKGRvbWFpbiA9PiB7XG4gICAgY29uc3QgZG9tYWluRGF0YSA9IGZvcm1hdHRlZERhdGEuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWluc1tkb21haW5dO1xuICAgIFxuICAgIC8vIEZvcm1hdCBzdHJlbmd0aHMgYXMgYnVsbGV0IHBvaW50cyBmb3IgRE9DWFxuICAgIGlmIChBcnJheS5pc0FycmF5KGRvbWFpbkRhdGEuc3RyZW5ndGhzKSAmJiBkb21haW5EYXRhLnN0cmVuZ3Rocy5sZW5ndGggPiAwKSB7XG4gICAgICBkb21haW5EYXRhLnN0cmVuZ3Roc0xpc3QgPSBkb21haW5EYXRhLnN0cmVuZ3Rocy5tYXAoKGl0ZW06IHN0cmluZykgPT4gKHsgdGV4dDogaXRlbSB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVuc3VyZSBlbXB0eSBhcnJheSBoYXMgcmlnaHQgZm9ybWF0IGZvciB0ZW1wbGF0ZXMgdGhhdCBleHBlY3QgaXRcbiAgICAgIGRvbWFpbkRhdGEuc3RyZW5ndGhzTGlzdCA9IFtdO1xuICAgIH1cblxuICAgIC8vIEZvcm1hdCBuZWVkcyBhcyBidWxsZXQgcG9pbnRzIGZvciBET0NYXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZG9tYWluRGF0YS5uZWVkcykgJiYgZG9tYWluRGF0YS5uZWVkcy5sZW5ndGggPiAwKSB7XG4gICAgICBkb21haW5EYXRhLm5lZWRzTGlzdCA9IGRvbWFpbkRhdGEubmVlZHMubWFwKChpdGVtOiBzdHJpbmcpID0+ICh7IHRleHQ6IGl0ZW0gfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbnN1cmUgZW1wdHkgYXJyYXkgaGFzIHJpZ2h0IGZvcm1hdCBmb3IgdGVtcGxhdGVzIHRoYXQgZXhwZWN0IGl0XG4gICAgICBkb21haW5EYXRhLm5lZWRzTGlzdCA9IFtdO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRm9ybWF0IGFjY29tbW9kYXRpb24gYW5kIGZhY2lsaXRhdGlvbiBzdHJhdGVnaWVzXG4gIGlmIChBcnJheS5pc0FycmF5KGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbj8ucmVjb21tZW5kYXRpb25zPy5hY2NvbW1vZGF0aW9ucykpIHtcbiAgICBmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmFjY29tbW9kYXRpb25zTGlzdCA9IFxuICAgICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5hY2NvbW1vZGF0aW9ucy5tYXAoKGl0ZW06IHN0cmluZykgPT4gKHsgdGV4dDogaXRlbSB9KSk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uPy5yZWNvbW1lbmRhdGlvbnMpIHtcbiAgICBmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmFjY29tbW9kYXRpb25zTGlzdCA9IFtdO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uPy5yZWNvbW1lbmRhdGlvbnM/LmZhY2lsaXRhdGlvblN0cmF0ZWdpZXMpKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzTGlzdCA9IFxuICAgICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiAoeyB0ZXh0OiBpdGVtIH0pKTtcbiAgfSBlbHNlIGlmIChmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24/LnJlY29tbWVuZGF0aW9ucykge1xuICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llc0xpc3QgPSBbXTtcbiAgfVxuXG4gIC8vIENvbnZlcnQgcGFyZW50cyBhcnJheSB0byBzdHJpbmcgaWYgbmVlZGVkXG4gIGlmIChBcnJheS5pc0FycmF5KGZvcm1hdHRlZERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24/LnBhcmVudHMpKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLnBhcmVudHNTdHJpbmcgPSBcbiAgICAgIGZvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5wYXJlbnRzLmpvaW4oJywgJyk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVkRGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbikge1xuICAgIGZvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5wYXJlbnRzU3RyaW5nID0gJyc7XG4gIH1cblxuICAvLyBBZGQgZnVsbCBzdHVkZW50IG5hbWUgZm9yIGNvbnZlbmllbmNlXG4gIGlmIChmb3JtYXR0ZWREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5maXJzdE5hbWUpIHtcbiAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24uZnVsbE5hbWUgPSBcbiAgICAgIGAke2Zvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5maXJzdE5hbWV9ICR7Zm9ybWF0dGVkRGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmxhc3ROYW1lIHx8ICcnfWA7XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVkRGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbikge1xuICAgIGZvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5mdWxsTmFtZSA9ICdTdHVkZW50JztcbiAgfVxuXG4gIHJldHVybiBmb3JtYXR0ZWREYXRhO1xufSJdLCJuYW1lcyI6WyJEb2N4dGVtcGxhdGVyIiwiUGl6WmlwIiwic2F2ZUFzIiwiZ2VuZXJhdGVEb2N4RnJvbVRlbXBsYXRlIiwidGVtcGxhdGVCdWZmZXIiLCJkYXRhIiwib3V0cHV0RmlsZW5hbWUiLCJkZWJ1Z01vZGUiLCJjb25zb2xlIiwibG9nIiwiYnl0ZUxlbmd0aCIsIkpTT04iLCJzdHJpbmdpZnkiLCJmaXJzdEJ5dGVzIiwiVWludDhBcnJheSIsInNsaWNlIiwiQXJyYXkiLCJmcm9tIiwibWFwIiwiYiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJqb2luIiwiRXJyb3IiLCJlcnJvciIsInppcCIsImFycmF5QnVmZmVyIiwiemlwRXJyb3IiLCJtZXNzYWdlIiwiZG9jIiwicGFyYWdyYXBoTG9vcCIsImxpbmVicmVha3MiLCJlcnJvckxvZ2dpbmciLCJudWxsR2V0dGVyIiwicGFydCIsIm1vZHVsZSIsImRlbGltaXRlcnMiLCJzdGFydCIsImVuZCIsInBhcnNlciIsInRhZyIsImdldCIsInNjb3BlIiwicmVzdWx0IiwidW5kZWZpbmVkIiwid2FybiIsImRvY3hFcnJvciIsInByb3BlcnRpZXMiLCJlcnJvcnMiLCJmaXJzdEVycm9yIiwiZm9yRWFjaCIsImluZGV4IiwiZXhwbGFuYXRpb24iLCJpZCIsInh0YWciLCJwb3N0cGFyc2VkIiwiTWF0aCIsIm1heCIsIm9mZnNldCIsInJlbmRlciIsInJlbmRlckVycm9yIiwicmF3IiwicHJvcHMiLCJvdXRwdXQiLCJnZXRaaXAiLCJnZW5lcmF0ZSIsInR5cGUiLCJjb21wcmVzc2lvbiIsIm1pbWVUeXBlIiwic2l6ZSIsImdlbkVycm9yIiwic2F2ZUVycm9yIiwiaW5jbHVkZXMiLCJnZW5lcmF0ZUZhbGxiYWNrSHRtbFJlcG9ydCIsInJlcG9ydERhdGEiLCJzdHVkZW50TmFtZSIsImhlYWRlciIsInN0dWRlbnRJbmZvcm1hdGlvbiIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwiaHRtbCIsIkRPQiIsInJlcG9ydERhdGUiLCJyZWFzb25Gb3JSZWZlcnJhbCIsImFzc2Vzc21lbnRSZXN1bHRzIiwiZG9tYWlucyIsIk9iamVjdCIsImVudHJpZXMiLCJkb21haW5OYW1lIiwiZG9tYWluIiwidG9waWNTZW50ZW5jZSIsInN0cmVuZ3RocyIsImxlbmd0aCIsIm5lZWRzIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJpc0NvbmNlcm4iLCJpdGVtIiwiaW1wYWN0U3RhdGVtZW50IiwiY29uY2x1c2lvbiIsInJlY29tbWVuZGF0aW9ucyIsImFjY29tbW9kYXRpb25zIiwiZmFjaWxpdGF0aW9uU3RyYXRlZ2llcyIsIkJsb2IiLCJjcmVhdGVFbXB0eVRlbXBsYXRlIiwibWluaW1hbERvY3hCYXNlNjQiLCJiaW5hcnlTdHJpbmciLCJ3aW5kb3ciLCJhdG9iIiwiYnl0ZXMiLCJpIiwiY2hhckNvZGVBdCIsImJ1ZmZlciIsImdlbmVyYXRlUmVwb3J0RG9jeCIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwiZmlsZW5hbWUiLCJyZXBsYWNlIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImNhY2hlIiwiaGVhZGVycyIsIm9rIiwic3RhdHVzIiwiYWx0UmVzcG9uc2UiLCJhbHRGaXJzdEJ5dGVzIiwiYWx0RXJyb3IiLCJmb3JtYXR0ZWREYXRhIiwiZm9ybWF0UmVwb3J0RGF0YUZvckRvY3giLCJodG1sQmxvYiIsImh0bWxGaWxlbmFtZSIsInBhcnNlIiwia2V5cyIsImRvbWFpbkRhdGEiLCJpc0FycmF5Iiwic3RyZW5ndGhzTGlzdCIsInRleHQiLCJuZWVkc0xpc3QiLCJhY2NvbW1vZGF0aW9uc0xpc3QiLCJmYWNpbGl0YXRpb25TdHJhdGVnaWVzTGlzdCIsInBhcmVudHMiLCJwYXJlbnRzU3RyaW5nIiwiZnVsbE5hbWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/docx-generator.ts\n"));

/***/ })

});