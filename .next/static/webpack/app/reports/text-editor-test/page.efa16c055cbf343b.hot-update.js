"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/reports/text-editor-test/page",{

/***/ "(app-pages-browser)/./src/lib/docx-generator.ts":
/*!***********************************!*\
  !*** ./src/lib/docx-generator.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateDocxFromTemplate: () => (/* binding */ generateDocxFromTemplate),\n/* harmony export */   generateReportDocx: () => (/* binding */ generateReportDocx)\n/* harmony export */ });\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! docxtemplater */ \"(app-pages-browser)/./node_modules/docxtemplater/js/docxtemplater.js\");\n/* harmony import */ var docxtemplater__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(docxtemplater__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pizzip */ \"(app-pages-browser)/./node_modules/pizzip/js/index.js\");\n/* harmony import */ var pizzip__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pizzip__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! file-saver */ \"(app-pages-browser)/./node_modules/file-saver/dist/FileSaver.min.js\");\n/* harmony import */ var file_saver__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(file_saver__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n/**\n * Generate a docx file from a template and data\n * @param templateBuffer - The binary template file as an ArrayBuffer\n * @param data - The data to inject into the template\n * @param outputFilename - The name of the file to save\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateDocxFromTemplate(templateBuffer, data) {\n    let outputFilename = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'report.docx';\n    try {\n        console.log(\"Attempting to create PizZip instance with buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n        // Validate that we have a proper buffer\n        if (!templateBuffer || templateBuffer.byteLength === 0) {\n            throw new Error('Invalid template buffer: Empty or undefined');\n        }\n        // Verify the buffer has a ZIP signature (first bytes of a proper DOCX/ZIP file)\n        const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n        if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n            console.error('Invalid ZIP file signature in template. First bytes:', Array.from(firstBytes));\n            throw new Error('The template does not appear to be a valid ZIP/DOCX file (missing PK signature)');\n        }\n        // Create a new PizZip instance with the template content\n        // Use a try-catch specifically for the PizZip instantiation\n        let zip;\n        try {\n            // Convert ArrayBuffer to Uint8Array to ensure proper binary handling\n            const arrayBuffer = new Uint8Array(templateBuffer);\n            zip = new (pizzip__WEBPACK_IMPORTED_MODULE_1___default())(arrayBuffer);\n        } catch (zipError) {\n            console.error('Error creating PizZip instance:', zipError);\n            throw new Error(\"Failed to create ZIP from template: \".concat(zipError instanceof Error ? zipError.message : 'Unknown error'));\n        }\n        console.log('PizZip instance created successfully');\n        // Create a new Docxtemplater instance with improved error handling\n        let doc;\n        try {\n            doc = new (docxtemplater__WEBPACK_IMPORTED_MODULE_0___default())(zip, {\n                paragraphLoop: true,\n                linebreaks: true,\n                errorLogging: true,\n                nullGetter: function(part) {\n                    if (!part.module) {\n                        return \"\";\n                    }\n                    if (part.module === \"rawxml\") {\n                        return \"\";\n                    }\n                    return \"\";\n                }\n            });\n            console.log('Docxtemplater instance created successfully');\n        } catch (docxError) {\n            console.error('Error creating Docxtemplater instance:', docxError);\n            throw new Error(\"Failed to create Docxtemplater: \".concat(docxError instanceof Error ? docxError.message : 'Unknown error'));\n        }\n        try {\n            // Render the document with the provided data\n            doc.render(data);\n            console.log('Template rendered with data');\n        } catch (renderError) {\n            console.error('Error rendering template:', renderError);\n            // Special handling for Docxtemplater errors which might have detailed error info\n            if (renderError instanceof Error && 'properties' in renderError) {\n                const props = renderError.properties || {};\n                throw new Error(\"Template render error: \".concat(props.explanation || renderError.message));\n            }\n            throw new Error(\"Failed to render template: \".concat(renderError instanceof Error ? renderError.message : 'Unknown error'));\n        }\n        // Generate the output document\n        let output;\n        try {\n            output = doc.getZip().generate({\n                type: 'blob',\n                compression: 'DEFLATE',\n                mimeType: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n            });\n            console.log(\"Output document generated successfully (\".concat(output.size, \" bytes)\"));\n        } catch (genError) {\n            console.error('Error generating output document:', genError);\n            throw new Error(\"Failed to generate output: \".concat(genError instanceof Error ? genError.message : 'Unknown error'));\n        }\n        // If running in browser, save the file\n        if (true) {\n            try {\n                (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(output, outputFilename);\n                console.log(\"File saved as \".concat(outputFilename));\n            } catch (saveError) {\n                console.error('Error saving file:', saveError);\n                throw new Error(\"Failed to save file: \".concat(saveError instanceof Error ? saveError.message : 'Unknown error'));\n            }\n        }\n        return output;\n    } catch (error) {\n        console.error('Error in generateDocxFromTemplate:', error);\n        // If it's a PizZip error (likely invalid template)\n        if (error instanceof Error && error.message.includes('zip')) {\n            console.error('PizZip error - invalid template file structure');\n            throw new Error(\"Template file is not a valid DOCX/ZIP file: \".concat(error.message));\n        }\n        // Rethrow the error\n        throw error;\n    }\n}\n/**\n * Generate a fallback HTML report when DOCX template fails\n * @param reportData - The report data to export\n * @returns A blob with HTML content\n */ function generateFallbackHtmlReport(reportData) {\n    var _reportData_header_studentInformation, _reportData_header, _reportData_header_studentInformation1, _reportData_header1, _reportData_header_studentInformation2, _reportData_header2, _reportData_header3, _reportData_assessmentResults, _reportData_conclusion;\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \" \").concat(reportData.header.studentInformation.lastName) : 'Student';\n    // Create a simple HTML representation of the report\n    let html = '\\n    <!DOCTYPE html>\\n    <html>\\n    <head>\\n      <meta charset=\"utf-8\">\\n      <title>Report for '.concat(studentName, \"</title>\\n      <style>\\n        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }\\n        h1, h2, h3 { color: #444; }\\n        .section { margin-bottom: 30px; }\\n        .domain { margin-bottom: 20px; padding: 15px; border: 1px solid #eee; }\\n        .domain-header { display: flex; justify-content: space-between; align-items: center; }\\n        .concern { color: #f59e0b; font-size: 14px; }\\n        .no-concern { color: #10b981; font-size: 14px; }\\n        ul { margin-top: 5px; }\\n        @media print {\\n          body { margin: 0.5in; }\\n          .domain { break-inside: avoid; }\\n        }\\n      </style>\\n    </head>\\n    <body>\\n      <h1>Report for \").concat(studentName, '</h1>\\n      <div class=\"section\">\\n        <h2>Student Information</h2>\\n        <p><strong>DOB:</strong> ').concat(((_reportData_header1 = reportData.header) === null || _reportData_header1 === void 0 ? void 0 : (_reportData_header_studentInformation1 = _reportData_header1.studentInformation) === null || _reportData_header_studentInformation1 === void 0 ? void 0 : _reportData_header_studentInformation1.DOB) || 'N/A', \"</p>\\n        <p><strong>Report Date:</strong> \").concat(((_reportData_header2 = reportData.header) === null || _reportData_header2 === void 0 ? void 0 : (_reportData_header_studentInformation2 = _reportData_header2.studentInformation) === null || _reportData_header_studentInformation2 === void 0 ? void 0 : _reportData_header_studentInformation2.reportDate) || 'N/A', \"</p>\\n        <p><strong>Reason for Referral:</strong> \").concat(((_reportData_header3 = reportData.header) === null || _reportData_header3 === void 0 ? void 0 : _reportData_header3.reasonForReferral) || 'N/A', \"</p>\\n      </div>\\n  \");\n    // Add domains section\n    if ((_reportData_assessmentResults = reportData.assessmentResults) === null || _reportData_assessmentResults === void 0 ? void 0 : _reportData_assessmentResults.domains) {\n        html += '<div class=\"section\"><h2>Assessment Results</h2>';\n        Object.entries(reportData.assessmentResults.domains).forEach((param)=>{\n            let [domainName, domain] = param;\n            var _domain_strengths, _domain_needs;\n            if (domain.topicSentence || ((_domain_strengths = domain.strengths) === null || _domain_strengths === void 0 ? void 0 : _domain_strengths.length) || ((_domain_needs = domain.needs) === null || _domain_needs === void 0 ? void 0 : _domain_needs.length)) {\n                var _domain_strengths1, _domain_needs1;\n                html += '\\n          <div class=\"domain\">\\n            <div class=\"domain-header\">\\n              <h3>'.concat(domainName.charAt(0).toUpperCase() + domainName.slice(1), \" Language</h3>\\n              \").concat(domain.isConcern !== undefined ? '<span class=\"'.concat(domain.isConcern ? 'concern' : 'no-concern', '\">').concat(domain.isConcern ? 'Area of Concern' : 'No Concern', \"</span>\") : '', \"\\n            </div>\\n            \").concat(domain.topicSentence ? \"<p>\".concat(domain.topicSentence, \"</p>\") : '', \"\\n            \\n            \").concat(((_domain_strengths1 = domain.strengths) === null || _domain_strengths1 === void 0 ? void 0 : _domain_strengths1.length) ? \"\\n              <h4>Strengths:</h4>\\n              <ul>\\n                \".concat(domain.strengths.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(((_domain_needs1 = domain.needs) === null || _domain_needs1 === void 0 ? void 0 : _domain_needs1.length) ? \"\\n              <h4>Needs:</h4>\\n              <ul>\\n                \".concat(domain.needs.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n              </ul>\\n            \") : '', \"\\n            \\n            \").concat(domain.impactStatement ? \"\\n              <h4>Educational Impact:</h4>\\n              <p>\".concat(domain.impactStatement, \"</p>\\n            \") : '', \"\\n          </div>\\n        \");\n            }\n        });\n        html += \"</div>\";\n    }\n    // Add recommendations\n    if ((_reportData_conclusion = reportData.conclusion) === null || _reportData_conclusion === void 0 ? void 0 : _reportData_conclusion.recommendations) {\n        var _reportData_conclusion_recommendations_accommodations, _reportData_conclusion_recommendations_facilitationStrategies;\n        html += '\\n      <div class=\"section\">\\n        <h2>Recommendations</h2>\\n        '.concat(((_reportData_conclusion_recommendations_accommodations = reportData.conclusion.recommendations.accommodations) === null || _reportData_conclusion_recommendations_accommodations === void 0 ? void 0 : _reportData_conclusion_recommendations_accommodations.length) ? \"\\n          <h3>Accommodations:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.accommodations.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n        \\n        \").concat(((_reportData_conclusion_recommendations_facilitationStrategies = reportData.conclusion.recommendations.facilitationStrategies) === null || _reportData_conclusion_recommendations_facilitationStrategies === void 0 ? void 0 : _reportData_conclusion_recommendations_facilitationStrategies.length) ? \"\\n          <h3>Facilitation Strategies:</h3>\\n          <ul>\\n            \".concat(reportData.conclusion.recommendations.facilitationStrategies.map((item)=>\"<li>\".concat(item, \"</li>\")).join(''), \"\\n          </ul>\\n        \") : '', \"\\n      </div>\\n    \");\n    }\n    html += \"\\n      <footer>\\n        <p><em>This is a fallback HTML report generated because the DOCX template could not be processed. \\n        You can print this HTML file to create a PDF.</em></p>\\n      </footer>\\n    </body>\\n    </html>\\n  \";\n    return new Blob([\n        html\n    ], {\n        type: 'text/html'\n    });\n}\n/**\n * Create a simple empty DOCX template programmatically\n * This is a last-resort fallback when all template files fail to load\n */ function createEmptyTemplate() {\n    // Define a minimal valid DOCX file structure as a base64 string\n    // This is a simplified empty DOCX file with minimal content\n    const minimalDocxBase64 = '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';\n    // Convert base64 to ArrayBuffer\n    const binaryString = window.atob(minimalDocxBase64);\n    const bytes = new Uint8Array(binaryString.length);\n    for(let i = 0; i < binaryString.length; i++){\n        bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n}\n/**\n * Generate a report docx from the report data\n * @param reportData - The report data from the application\n * @param templateBuffer - The binary template file as an ArrayBuffer (optional)\n * @returns Promise resolving to the generated file as a Blob\n */ async function generateReportDocx(reportData, templateBuffer) {\n    var _reportData_header_studentInformation, _reportData_header;\n    // Generate the filename based on report data\n    const studentName = ((_reportData_header = reportData.header) === null || _reportData_header === void 0 ? void 0 : (_reportData_header_studentInformation = _reportData_header.studentInformation) === null || _reportData_header_studentInformation === void 0 ? void 0 : _reportData_header_studentInformation.firstName) ? \"\".concat(reportData.header.studentInformation.firstName, \"_\").concat(reportData.header.studentInformation.lastName) : 'student';\n    const timestamp = new Date().toISOString().split('T')[0];\n    const filename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".docx\");\n    try {\n        // If no template buffer is provided, use a default template\n        if (!templateBuffer) {\n            // Use fetch to get the template if we're in the browser\n            if (true) {\n                try {\n                    console.log('No template buffer provided, fetching default template');\n                    // Try to use response.arrayBuffer() which ensures binary data handling\n                    // Use las-assessment-report-template.docx instead of report-template.docx (which is a text file, not a DOCX)\n                    const response = await fetch('/templates/las-assessment-report-template.docx', {\n                        method: 'GET',\n                        cache: 'no-cache',\n                        headers: {\n                            'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                            'Cache-Control': 'no-cache'\n                        }\n                    });\n                    if (!response.ok) {\n                        throw new Error(\"Failed to fetch default template: \".concat(response.status));\n                    }\n                    console.log('Default template fetched successfully');\n                    templateBuffer = await response.arrayBuffer();\n                    console.log(\"Default template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                    if (templateBuffer.byteLength === 0) {\n                        throw new Error('Default template file is empty');\n                    }\n                    // Verify the template has a proper DOCX signature\n                    const firstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                    if (!(firstBytes[0] === 0x50 && firstBytes[1] === 0x4B)) {\n                        console.error('Invalid DOCX file signature in default template. First bytes:', Array.from(firstBytes));\n                        throw new Error('Default template is not a valid DOCX file');\n                    }\n                } catch (error) {\n                    console.error('Error loading default template:', error);\n                    // Try alternative template as a last resort\n                    try {\n                        console.log('Attempting to load alternative template: las-assessment-report-template.docx');\n                        const altResponse = await fetch('/templates/las-assessment-report-template.docx', {\n                            cache: 'no-cache',\n                            headers: {\n                                'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n                                'Cache-Control': 'no-cache'\n                            }\n                        });\n                        if (!altResponse.ok) {\n                            throw new Error(\"Failed to fetch alternative template: \".concat(altResponse.status));\n                        }\n                        templateBuffer = await altResponse.arrayBuffer();\n                        console.log(\"Alternative template buffer size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        // Verify the alternative template\n                        const altFirstBytes = new Uint8Array(templateBuffer.slice(0, 4));\n                        if (!(altFirstBytes[0] === 0x50 && altFirstBytes[1] === 0x4B)) {\n                            console.error('Invalid DOCX file signature in alternative template');\n                            throw new Error('Alternative template is not a valid DOCX file');\n                        }\n                    } catch (altError) {\n                        console.error('Error loading alternative template:', altError);\n                        // As a last resort, create a minimal valid DOCX template\n                        console.log('Creating minimal empty DOCX template');\n                        templateBuffer = createEmptyTemplate();\n                        console.log(\"Created minimal template with size: \".concat(templateBuffer.byteLength, \" bytes\"));\n                        if (!templateBuffer || templateBuffer.byteLength === 0) {\n                            // All template attempts failed, fall back to HTML\n                            throw new Error('All template attempts failed');\n                        }\n                    }\n                }\n            } else {}\n        }\n        // Format and prepare data for the template\n        const formattedData = formatReportDataForDocx(reportData);\n        console.log('Data formatted for DOCX template');\n        // Generate the document\n        return await generateDocxFromTemplate(templateBuffer, formattedData, filename);\n    } catch (error) {\n        console.error('Error in generateReportDocx:', error);\n        // If there was an error with the template or docxtemplater,\n        // try to generate a fallback HTML report\n        if (error instanceof Error && (error.message.includes('zip') || error.message.includes('template') || error.message.includes('docxtemplater'))) {\n            console.warn('DOCX generation failed, falling back to HTML export');\n            const htmlBlob = generateFallbackHtmlReport(reportData);\n            const htmlFilename = \"\".concat(studentName.replace(/\\s+/g, '_'), \"_report_\").concat(timestamp, \".html\");\n            if (true) {\n                (0,file_saver__WEBPACK_IMPORTED_MODULE_2__.saveAs)(htmlBlob, htmlFilename);\n            }\n            return htmlBlob;\n        }\n        throw error;\n    }\n}\n/**\n * Format the report data for docx template rendering\n * @param reportData - The raw report data from the application\n * @returns Formatted data ready for docx template\n */ function formatReportDataForDocx(reportData) {\n    var _formattedData_assessmentResults, _formattedData_conclusion_recommendations, _formattedData_conclusion, _formattedData_conclusion1, _formattedData_conclusion_recommendations1, _formattedData_conclusion2, _formattedData_conclusion3, _formattedData_header_studentInformation, _formattedData_header, _formattedData_header1, _formattedData_header_studentInformation1, _formattedData_header2, _formattedData_header3;\n    // Create a deep copy of the report data\n    const formattedData = JSON.parse(JSON.stringify(reportData));\n    // Format arrays to be more docx-template friendly\n    // Arrays in docxtemplater are typically handled with loops, so we'll format them\n    // to be ready for the template syntax\n    // Process strength and needs lists for each domain\n    Object.keys(((_formattedData_assessmentResults = formattedData.assessmentResults) === null || _formattedData_assessmentResults === void 0 ? void 0 : _formattedData_assessmentResults.domains) || {}).forEach((domain)=>{\n        const domainData = formattedData.assessmentResults.domains[domain];\n        // Format strengths as bullet points for DOCX\n        if (Array.isArray(domainData.strengths) && domainData.strengths.length > 0) {\n            domainData.strengthsList = domainData.strengths.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.strengthsList = [];\n        }\n        // Format needs as bullet points for DOCX\n        if (Array.isArray(domainData.needs) && domainData.needs.length > 0) {\n            domainData.needsList = domainData.needs.map((item)=>({\n                    text: item\n                }));\n        } else {\n            // Ensure empty array has right format for templates that expect it\n            domainData.needsList = [];\n        }\n    });\n    // Format accommodation and facilitation strategies\n    if (Array.isArray((_formattedData_conclusion = formattedData.conclusion) === null || _formattedData_conclusion === void 0 ? void 0 : (_formattedData_conclusion_recommendations = _formattedData_conclusion.recommendations) === null || _formattedData_conclusion_recommendations === void 0 ? void 0 : _formattedData_conclusion_recommendations.accommodations)) {\n        formattedData.conclusion.recommendations.accommodationsList = formattedData.conclusion.recommendations.accommodations.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion1 = formattedData.conclusion) === null || _formattedData_conclusion1 === void 0 ? void 0 : _formattedData_conclusion1.recommendations) {\n        formattedData.conclusion.recommendations.accommodationsList = [];\n    }\n    if (Array.isArray((_formattedData_conclusion2 = formattedData.conclusion) === null || _formattedData_conclusion2 === void 0 ? void 0 : (_formattedData_conclusion_recommendations1 = _formattedData_conclusion2.recommendations) === null || _formattedData_conclusion_recommendations1 === void 0 ? void 0 : _formattedData_conclusion_recommendations1.facilitationStrategies)) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = formattedData.conclusion.recommendations.facilitationStrategies.map((item)=>({\n                text: item\n            }));\n    } else if ((_formattedData_conclusion3 = formattedData.conclusion) === null || _formattedData_conclusion3 === void 0 ? void 0 : _formattedData_conclusion3.recommendations) {\n        formattedData.conclusion.recommendations.facilitationStrategiesList = [];\n    }\n    // Convert parents array to string if needed\n    if (Array.isArray((_formattedData_header = formattedData.header) === null || _formattedData_header === void 0 ? void 0 : (_formattedData_header_studentInformation = _formattedData_header.studentInformation) === null || _formattedData_header_studentInformation === void 0 ? void 0 : _formattedData_header_studentInformation.parents)) {\n        formattedData.header.studentInformation.parentsString = formattedData.header.studentInformation.parents.join(', ');\n    } else if ((_formattedData_header1 = formattedData.header) === null || _formattedData_header1 === void 0 ? void 0 : _formattedData_header1.studentInformation) {\n        formattedData.header.studentInformation.parentsString = '';\n    }\n    // Add full student name for convenience\n    if ((_formattedData_header2 = formattedData.header) === null || _formattedData_header2 === void 0 ? void 0 : (_formattedData_header_studentInformation1 = _formattedData_header2.studentInformation) === null || _formattedData_header_studentInformation1 === void 0 ? void 0 : _formattedData_header_studentInformation1.firstName) {\n        formattedData.header.studentInformation.fullName = \"\".concat(formattedData.header.studentInformation.firstName, \" \").concat(formattedData.header.studentInformation.lastName || '');\n    } else if ((_formattedData_header3 = formattedData.header) === null || _formattedData_header3 === void 0 ? void 0 : _formattedData_header3.studentInformation) {\n        formattedData.header.studentInformation.fullName = 'Student';\n    }\n    return formattedData;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZG9jeC1nZW5lcmF0b3IudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMEM7QUFDZDtBQUNRO0FBRXBDOzs7Ozs7Q0FNQyxHQUNNLGVBQWVHLHlCQUNwQkMsY0FBMkIsRUFDM0JDLElBQXlCO1FBQ3pCQyxpQkFBQUEsaUVBQXlCO0lBRXpCLElBQUk7UUFDRkMsUUFBUUMsR0FBRyxDQUFDLDBEQUFvRixPQUExQkosZUFBZUssVUFBVSxFQUFDO1FBRWhHLHdDQUF3QztRQUN4QyxJQUFJLENBQUNMLGtCQUFrQkEsZUFBZUssVUFBVSxLQUFLLEdBQUc7WUFDdEQsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBRUEsZ0ZBQWdGO1FBQ2hGLE1BQU1DLGFBQWEsSUFBSUMsV0FBV1IsZUFBZVMsS0FBSyxDQUFDLEdBQUc7UUFDMUQsSUFBSSxDQUFFRixDQUFBQSxVQUFVLENBQUMsRUFBRSxLQUFLLFFBQVFBLFVBQVUsQ0FBQyxFQUFFLEtBQUssSUFBRyxHQUFJO1lBQ3ZESixRQUFRTyxLQUFLLENBQUMsd0RBQXdEQyxNQUFNQyxJQUFJLENBQUNMO1lBQ2pGLE1BQU0sSUFBSUQsTUFBTTtRQUNsQjtRQUVBLHlEQUF5RDtRQUN6RCw0REFBNEQ7UUFDNUQsSUFBSU87UUFDSixJQUFJO1lBQ0YscUVBQXFFO1lBQ3JFLE1BQU1DLGNBQWMsSUFBSU4sV0FBV1I7WUFDbkNhLE1BQU0sSUFBSWhCLCtDQUFNQSxDQUFDaUI7UUFDbkIsRUFBRSxPQUFPQyxVQUFVO1lBQ2pCWixRQUFRTyxLQUFLLENBQUMsbUNBQW1DSztZQUNqRCxNQUFNLElBQUlULE1BQU0sdUNBQXNHLE9BQS9EUyxvQkFBb0JULFFBQVFTLFNBQVNDLE9BQU8sR0FBRztRQUN4RztRQUVBYixRQUFRQyxHQUFHLENBQUM7UUFFWixtRUFBbUU7UUFDbkUsSUFBSWE7UUFDSixJQUFJO1lBQ0ZBLE1BQU0sSUFBSXJCLHNEQUFhQSxDQUFDaUIsS0FBSztnQkFDM0JLLGVB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LEdBQzlDLEdBQXdEbEIsT0FBckRBLGNBQWMxRCxNQUFNLENBQUNDLGtCQUFrQixDQUFDQyxTQUFTLEVBQUMsS0FBMEQsT0FBdkR3RCxjQUFjMUQsTUFBTSxDQUFDQyxrQkFBa0IsQ0FBQ0UsUUFBUSxJQUFJO0lBQ2hILE9BQU8sS0FBSXVELHlCQUFBQSxjQUFjMUQsTUFBTSxjQUFwQjBELDZDQUFBQSx1QkFBc0J6RCxrQkFBa0IsRUFBRTtRQUNuRHlELGNBQWMxRCxNQUFNLENBQUNDLGtCQUFrQixDQUFDMkUsUUFBUSxHQUFHO0lBQ3JEO0lBRUEsT0FBT2xCO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvc3JjL2xpYi9kb2N4LWdlbmVyYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRG9jeHRlbXBsYXRlciBmcm9tICdkb2N4dGVtcGxhdGVyJztcbmltcG9ydCBQaXpaaXAgZnJvbSAncGl6emlwJztcbmltcG9ydCB7IHNhdmVBcyB9IGZyb20gJ2ZpbGUtc2F2ZXInO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZG9jeCBmaWxlIGZyb20gYSB0ZW1wbGF0ZSBhbmQgZGF0YVxuICogQHBhcmFtIHRlbXBsYXRlQnVmZmVyIC0gVGhlIGJpbmFyeSB0ZW1wbGF0ZSBmaWxlIGFzIGFuIEFycmF5QnVmZmVyXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIGluamVjdCBpbnRvIHRoZSB0ZW1wbGF0ZVxuICogQHBhcmFtIG91dHB1dEZpbGVuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gc2F2ZVxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGdlbmVyYXRlZCBmaWxlIGFzIGEgQmxvYlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVEb2N4RnJvbVRlbXBsYXRlKFxuICB0ZW1wbGF0ZUJ1ZmZlcjogQXJyYXlCdWZmZXIsXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIG91dHB1dEZpbGVuYW1lOiBzdHJpbmcgPSAncmVwb3J0LmRvY3gnXG4pOiBQcm9taXNlPEJsb2I+IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyB0byBjcmVhdGUgUGl6WmlwIGluc3RhbmNlIHdpdGggYnVmZmVyIHNpemU6ICR7dGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aH0gYnl0ZXNgKTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGF0IHdlIGhhdmUgYSBwcm9wZXIgYnVmZmVyXG4gICAgaWYgKCF0ZW1wbGF0ZUJ1ZmZlciB8fCB0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGVtcGxhdGUgYnVmZmVyOiBFbXB0eSBvciB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSBidWZmZXIgaGFzIGEgWklQIHNpZ25hdHVyZSAoZmlyc3QgYnl0ZXMgb2YgYSBwcm9wZXIgRE9DWC9aSVAgZmlsZSlcbiAgICBjb25zdCBmaXJzdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGVtcGxhdGVCdWZmZXIuc2xpY2UoMCwgNCkpO1xuICAgIGlmICghKGZpcnN0Qnl0ZXNbMF0gPT09IDB4NTAgJiYgZmlyc3RCeXRlc1sxXSA9PT0gMHg0QikpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgWklQIGZpbGUgc2lnbmF0dXJlIGluIHRlbXBsYXRlLiBGaXJzdCBieXRlczonLCBBcnJheS5mcm9tKGZpcnN0Qnl0ZXMpKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRlbXBsYXRlIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIHZhbGlkIFpJUC9ET0NYIGZpbGUgKG1pc3NpbmcgUEsgc2lnbmF0dXJlKScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgYSBuZXcgUGl6WmlwIGluc3RhbmNlIHdpdGggdGhlIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAvLyBVc2UgYSB0cnktY2F0Y2ggc3BlY2lmaWNhbGx5IGZvciB0aGUgUGl6WmlwIGluc3RhbnRpYXRpb25cbiAgICBsZXQgemlwO1xuICAgIHRyeSB7XG4gICAgICAvLyBDb252ZXJ0IEFycmF5QnVmZmVyIHRvIFVpbnQ4QXJyYXkgdG8gZW5zdXJlIHByb3BlciBiaW5hcnkgaGFuZGxpbmdcbiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGVtcGxhdGVCdWZmZXIpO1xuICAgICAgemlwID0gbmV3IFBpelppcChhcnJheUJ1ZmZlcik7XG4gICAgfSBjYXRjaCAoemlwRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIFBpelppcCBpbnN0YW5jZTonLCB6aXBFcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgWklQIGZyb20gdGVtcGxhdGU6ICR7emlwRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IHppcEVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdQaXpaaXAgaW5zdGFuY2UgY3JlYXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBuZXcgRG9jeHRlbXBsYXRlciBpbnN0YW5jZSB3aXRoIGltcHJvdmVkIGVycm9yIGhhbmRsaW5nXG4gICAgbGV0IGRvYztcbiAgICB0cnkge1xuICAgICAgZG9jID0gbmV3IERvY3h0ZW1wbGF0ZXIoemlwLCB7XG4gICAgICAgIHBhcmFncmFwaExvb3A6IHRydWUsXG4gICAgICAgIGxpbmVicmVha3M6IHRydWUsXG4gICAgICAgIGVycm9yTG9nZ2luZzogdHJ1ZSxcbiAgICAgICAgbnVsbEdldHRlcjogZnVuY3Rpb24ocGFydDogYW55KSB7XG4gICAgICAgICAgaWYgKCFwYXJ0Lm1vZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0Lm1vZHVsZSA9PT0gXCJyYXd4bWxcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygnRG9jeHRlbXBsYXRlciBpbnN0YW5jZSBjcmVhdGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgIH0gY2F0Y2ggKGRvY3hFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgRG9jeHRlbXBsYXRlciBpbnN0YW5jZTonLCBkb2N4RXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIERvY3h0ZW1wbGF0ZXI6ICR7ZG9jeEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBkb2N4RXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlbmRlciB0aGUgZG9jdW1lbnQgd2l0aCB0aGUgcHJvdmlkZWQgZGF0YVxuICAgICAgZG9jLnJlbmRlcihkYXRhKTtcbiAgICAgIGNvbnNvbGUubG9nKCdUZW1wbGF0ZSByZW5kZXJlZCB3aXRoIGRhdGEnKTtcbiAgICB9IGNhdGNoIChyZW5kZXJFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVuZGVyaW5nIHRlbXBsYXRlOicsIHJlbmRlckVycm9yKTtcbiAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIERvY3h0ZW1wbGF0ZXIgZXJyb3JzIHdoaWNoIG1pZ2h0IGhhdmUgZGV0YWlsZWQgZXJyb3IgaW5mb1xuICAgICAgaWYgKHJlbmRlckVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgJ3Byb3BlcnRpZXMnIGluIHJlbmRlckVycm9yKSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gKHJlbmRlckVycm9yIGFzIGFueSkucHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW1wbGF0ZSByZW5kZXIgZXJyb3I6ICR7cHJvcHMuZXhwbGFuYXRpb24gfHwgcmVuZGVyRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlbmRlciB0ZW1wbGF0ZTogJHtyZW5kZXJFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gcmVuZGVyRXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2VuZXJhdGUgdGhlIG91dHB1dCBkb2N1bWVudFxuICAgIGxldCBvdXRwdXQ7XG4gICAgdHJ5IHtcbiAgICAgIG91dHB1dCA9IGRvYy5nZXRaaXAoKS5nZW5lcmF0ZSh7XG4gICAgICAgIHR5cGU6ICdibG9iJyxcbiAgICAgICAgY29tcHJlc3Npb246ICdERUZMQVRFJyxcbiAgICAgICAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKGBPdXRwdXQgZG9jdW1lbnQgZ2VuZXJhdGVkIHN1Y2Nlc3NmdWxseSAoJHtvdXRwdXQuc2l6ZX0gYnl0ZXMpYCk7XG4gICAgfSBjYXRjaCAoZ2VuRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgb3V0cHV0IGRvY3VtZW50OicsIGdlbkVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdlbmVyYXRlIG91dHB1dDogJHtnZW5FcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZ2VuRXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgcnVubmluZyBpbiBicm93c2VyLCBzYXZlIHRoZSBmaWxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzYXZlQXMob3V0cHV0LCBvdXRwdXRGaWxlbmFtZSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGaWxlIHNhdmVkIGFzICR7b3V0cHV0RmlsZW5hbWV9YCk7XG4gICAgICB9IGNhdGNoIChzYXZlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIGZpbGU6Jywgc2F2ZUVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2F2ZSBmaWxlOiAke3NhdmVFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gc2F2ZUVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2VuZXJhdGVEb2N4RnJvbVRlbXBsYXRlOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBJZiBpdCdzIGEgUGl6WmlwIGVycm9yIChsaWtlbHkgaW52YWxpZCB0ZW1wbGF0ZSlcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd6aXAnKSkge1xuICAgICAgY29uc29sZS5lcnJvcignUGl6WmlwIGVycm9yIC0gaW52YWxpZCB0ZW1wbGF0ZSBmaWxlIHN0cnVjdHVyZScpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZW1wbGF0ZSBmaWxlIGlzIG5vdCBhIHZhbGlkIERPQ1gvWklQIGZpbGU6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmV0aHJvdyB0aGUgZXJyb3JcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgZmFsbGJhY2sgSFRNTCByZXBvcnQgd2hlbiBET0NYIHRlbXBsYXRlIGZhaWxzXG4gKiBAcGFyYW0gcmVwb3J0RGF0YSAtIFRoZSByZXBvcnQgZGF0YSB0byBleHBvcnRcbiAqIEByZXR1cm5zIEEgYmxvYiB3aXRoIEhUTUwgY29udGVudFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUZhbGxiYWNrSHRtbFJlcG9ydChyZXBvcnREYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogQmxvYiB7XG4gIGNvbnN0IHN0dWRlbnROYW1lID0gcmVwb3J0RGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbj8uZmlyc3ROYW1lIFxuICAgID8gYCR7cmVwb3J0RGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmZpcnN0TmFtZX0gJHtyZXBvcnREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ubGFzdE5hbWV9YFxuICAgIDogJ1N0dWRlbnQnO1xuICBcbiAgLy8gQ3JlYXRlIGEgc2ltcGxlIEhUTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJlcG9ydFxuICBsZXQgaHRtbCA9IGBcbiAgICA8IURPQ1RZUEUgaHRtbD5cbiAgICA8aHRtbD5cbiAgICA8aGVhZD5cbiAgICAgIDxtZXRhIGNoYXJzZXQ9XCJ1dGYtOFwiPlxuICAgICAgPHRpdGxlPlJlcG9ydCBmb3IgJHtzdHVkZW50TmFtZX08L3RpdGxlPlxuICAgICAgPHN0eWxlPlxuICAgICAgICBib2R5IHsgZm9udC1mYW1pbHk6IEFyaWFsLCBzYW5zLXNlcmlmOyBtYXJnaW46IDQwcHg7IGxpbmUtaGVpZ2h0OiAxLjY7IH1cbiAgICAgICAgaDEsIGgyLCBoMyB7IGNvbG9yOiAjNDQ0OyB9XG4gICAgICAgIC5zZWN0aW9uIHsgbWFyZ2luLWJvdHRvbTogMzBweDsgfVxuICAgICAgICAuZG9tYWluIHsgbWFyZ2luLWJvdHRvbTogMjBweDsgcGFkZGluZzogMTVweDsgYm9yZGVyOiAxcHggc29saWQgI2VlZTsgfVxuICAgICAgICAuZG9tYWluLWhlYWRlciB7IGRpc3BsYXk6IGZsZXg7IGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjsgYWxpZ24taXRlbXM6IGNlbnRlcjsgfVxuICAgICAgICAuY29uY2VybiB7IGNvbG9yOiAjZjU5ZTBiOyBmb250LXNpemU6IDE0cHg7IH1cbiAgICAgICAgLm5vLWNvbmNlcm4geyBjb2xvcjogIzEwYjk4MTsgZm9udC1zaXplOiAxNHB4OyB9XG4gICAgICAgIHVsIHsgbWFyZ2luLXRvcDogNXB4OyB9XG4gICAgICAgIEBtZWRpYSBwcmludCB7XG4gICAgICAgICAgYm9keSB7IG1hcmdpbjogMC41aW47IH1cbiAgICAgICAgICAuZG9tYWluIHsgYnJlYWstaW5zaWRlOiBhdm9pZDsgfVxuICAgICAgICB9XG4gICAgICA8L3N0eWxlPlxuICAgIDwvaGVhZD5cbiAgICA8Ym9keT5cbiAgICAgIDxoMT5SZXBvcnQgZm9yICR7c3R1ZGVudE5hbWV9PC9oMT5cbiAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uXCI+XG4gICAgICAgIDxoMj5TdHVkZW50IEluZm9ybWF0aW9uPC9oMj5cbiAgICAgICAgPHA+PHN0cm9uZz5ET0I6PC9zdHJvbmc+ICR7cmVwb3J0RGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbj8uRE9CIHx8ICdOL0EnfTwvcD5cbiAgICAgICAgPHA+PHN0cm9uZz5SZXBvcnQgRGF0ZTo8L3N0cm9uZz4gJHtyZXBvcnREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uPy5yZXBvcnREYXRlIHx8ICdOL0EnfTwvcD5cbiAgICAgICAgPHA+PHN0cm9uZz5SZWFzb24gZm9yIFJlZmVycmFsOjwvc3Ryb25nPiAke3JlcG9ydERhdGEuaGVhZGVyPy5yZWFzb25Gb3JSZWZlcnJhbCB8fCAnTi9BJ308L3A+XG4gICAgICA8L2Rpdj5cbiAgYDtcbiAgXG4gIC8vIEFkZCBkb21haW5zIHNlY3Rpb25cbiAgaWYgKHJlcG9ydERhdGEuYXNzZXNzbWVudFJlc3VsdHM/LmRvbWFpbnMpIHtcbiAgICBodG1sICs9IGA8ZGl2IGNsYXNzPVwic2VjdGlvblwiPjxoMj5Bc3Nlc3NtZW50IFJlc3VsdHM8L2gyPmA7XG4gICAgXG4gICAgT2JqZWN0LmVudHJpZXMocmVwb3J0RGF0YS5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zKS5mb3JFYWNoKChbZG9tYWluTmFtZSwgZG9tYWluXTogW3N0cmluZywgYW55XSkgPT4ge1xuICAgICAgaWYgKGRvbWFpbi50b3BpY1NlbnRlbmNlIHx8IGRvbWFpbi5zdHJlbmd0aHM/Lmxlbmd0aCB8fCBkb21haW4ubmVlZHM/Lmxlbmd0aCkge1xuICAgICAgICBodG1sICs9IGBcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiZG9tYWluXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZG9tYWluLWhlYWRlclwiPlxuICAgICAgICAgICAgICA8aDM+JHtkb21haW5OYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZG9tYWluTmFtZS5zbGljZSgxKX0gTGFuZ3VhZ2U8L2gzPlxuICAgICAgICAgICAgICAke2RvbWFpbi5pc0NvbmNlcm4gIT09IHVuZGVmaW5lZCA/IFxuICAgICAgICAgICAgICAgIGA8c3BhbiBjbGFzcz1cIiR7ZG9tYWluLmlzQ29uY2VybiA/ICdjb25jZXJuJyA6ICduby1jb25jZXJuJ31cIj4ke2RvbWFpbi5pc0NvbmNlcm4gPyAnQXJlYSBvZiBDb25jZXJuJyA6ICdObyBDb25jZXJuJ308L3NwYW4+YCA6IFxuICAgICAgICAgICAgICAgICcnfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAke2RvbWFpbi50b3BpY1NlbnRlbmNlID8gYDxwPiR7ZG9tYWluLnRvcGljU2VudGVuY2V9PC9wPmAgOiAnJ31cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgJHtkb21haW4uc3RyZW5ndGhzPy5sZW5ndGggPyBgXG4gICAgICAgICAgICAgIDxoND5TdHJlbmd0aHM6PC9oND5cbiAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICR7ZG9tYWluLnN0cmVuZ3Rocy5tYXAoKGl0ZW06IHN0cmluZykgPT4gYDxsaT4ke2l0ZW19PC9saT5gKS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIGAgOiAnJ31cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgJHtkb21haW4ubmVlZHM/Lmxlbmd0aCA/IGBcbiAgICAgICAgICAgICAgPGg0Pk5lZWRzOjwvaDQ+XG4gICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAke2RvbWFpbi5uZWVkcy5tYXAoKGl0ZW06IHN0cmluZykgPT4gYDxsaT4ke2l0ZW19PC9saT5gKS5qb2luKCcnKX1cbiAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIGAgOiAnJ31cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgJHtkb21haW4uaW1wYWN0U3RhdGVtZW50ID8gYFxuICAgICAgICAgICAgICA8aDQ+RWR1Y2F0aW9uYWwgSW1wYWN0OjwvaDQ+XG4gICAgICAgICAgICAgIDxwPiR7ZG9tYWluLmltcGFjdFN0YXRlbWVudH08L3A+XG4gICAgICAgICAgICBgIDogJyd9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIGA7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaHRtbCArPSBgPC9kaXY+YDtcbiAgfVxuICBcbiAgLy8gQWRkIHJlY29tbWVuZGF0aW9uc1xuICBpZiAocmVwb3J0RGF0YS5jb25jbHVzaW9uPy5yZWNvbW1lbmRhdGlvbnMpIHtcbiAgICBodG1sICs9IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uXCI+XG4gICAgICAgIDxoMj5SZWNvbW1lbmRhdGlvbnM8L2gyPlxuICAgICAgICAke3JlcG9ydERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuYWNjb21tb2RhdGlvbnM/Lmxlbmd0aCA/IGBcbiAgICAgICAgICA8aDM+QWNjb21tb2RhdGlvbnM6PC9oMz5cbiAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAke3JlcG9ydERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuYWNjb21tb2RhdGlvbnMubWFwKChpdGVtOiBzdHJpbmcpID0+IGA8bGk+JHtpdGVtfTwvbGk+YCkuam9pbignJyl9XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgYCA6ICcnfVxuICAgICAgICBcbiAgICAgICAgJHtyZXBvcnREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmZhY2lsaXRhdGlvblN0cmF0ZWdpZXM/Lmxlbmd0aCA/IGBcbiAgICAgICAgICA8aDM+RmFjaWxpdGF0aW9uIFN0cmF0ZWdpZXM6PC9oMz5cbiAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAke3JlcG9ydERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuZmFjaWxpdGF0aW9uU3RyYXRlZ2llcy5tYXAoKGl0ZW06IHN0cmluZykgPT4gYDxsaT4ke2l0ZW19PC9saT5gKS5qb2luKCcnKX1cbiAgICAgICAgICA8L3VsPlxuICAgICAgICBgIDogJyd9XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG4gIFxuICBodG1sICs9IGBcbiAgICAgIDxmb290ZXI+XG4gICAgICAgIDxwPjxlbT5UaGlzIGlzIGEgZmFsbGJhY2sgSFRNTCByZXBvcnQgZ2VuZXJhdGVkIGJlY2F1c2UgdGhlIERPQ1ggdGVtcGxhdGUgY291bGQgbm90IGJlIHByb2Nlc3NlZC4gXG4gICAgICAgIFlvdSBjYW4gcHJpbnQgdGhpcyBIVE1MIGZpbGUgdG8gY3JlYXRlIGEgUERGLjwvZW0+PC9wPlxuICAgICAgPC9mb290ZXI+XG4gICAgPC9ib2R5PlxuICAgIDwvaHRtbD5cbiAgYDtcbiAgXG4gIHJldHVybiBuZXcgQmxvYihbaHRtbF0sIHsgdHlwZTogJ3RleHQvaHRtbCcgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc2ltcGxlIGVtcHR5IERPQ1ggdGVtcGxhdGUgcHJvZ3JhbW1hdGljYWxseVxuICogVGhpcyBpcyBhIGxhc3QtcmVzb3J0IGZhbGxiYWNrIHdoZW4gYWxsIHRlbXBsYXRlIGZpbGVzIGZhaWwgdG8gbG9hZFxuICovXG5mdW5jdGlvbiBjcmVhdGVFbXB0eVRlbXBsYXRlKCk6IEFycmF5QnVmZmVyIHtcbiAgLy8gRGVmaW5lIGEgbWluaW1hbCB2YWxpZCBET0NYIGZpbGUgc3RydWN0dXJlIGFzIGEgYmFzZTY0IHN0cmluZ1xuICAvLyBUaGlzIGlzIGEgc2ltcGxpZmllZCBlbXB0eSBET0NYIGZpbGUgd2l0aCBtaW5pbWFsIGNvbnRlbnRcbiAgY29uc3QgbWluaW1hbERvY3hCYXNlNjQgPSAnVUVzREJCUUFCZ0FJQUFBQUlRQTk4RUV1VGdFQUFPSUNBQUFMQUFBQVgzSmxiSE12TG5KbGJIT2trc0Zxd3pBTVFPK0QvWWZSdlZGYUdJTmh1ekJHN3piMkE0eHNUSXZiMlpUYVR2cjNPWkN3clM1WkdMcmFTWHo2QVVua2V2N3o5dU5sa0NheHpEaDYxTUFnZWNzRTI5TVUzTUZqeCtscStTdHlTcVh1eTJWYzJKVWJNSnhMRkJhbFNYTVFwSkxod1BTTjQxU1NkaTB4cHM4dnJSMW9QclNiTHVBZ3dseEFxamtUWW0zUDkrLy9tZmZWUWhCMHJnNTVzYVVjeS9NWXFxQkxWL3oxZytTZjZpOHFYbHJwZVlNUHNJWHBYMHhHYm03QWZDQnh6OUhYZENLWEV6ak41WDhPaDNQNmVCYU1aL1lKckFzd3ZOYXkxUExGeG9kNUlRVG1hRFFTTXZaVWlkVnJCdjlYS2pUU2VsVEpSeVl6b3ljQktCSEp4QmFlOUpUY3NLTXFYTll2KzFvV3p4Zmlzd1FYb01MWGNQaDdYZmtHVUVzREJCUUFCZ0FJQUFBQUlRQUJudDhmUndFQUFPWUVBQUFjQUFBQWQyOXlaQzlmY21Wc2N5OWtiMk4xYldWdWRDNTRiV3d1Y21Wc2M3U1UzMHJETUJERzc0UGRJZVMrNmNxaTFIUmRpQXA3SmJnSDJLUW5XMnlUa0tUcTNwc2tYU3RUTzhwL053MzVQdDczSldSMWM5UEhZZ3M1ZTR3TkxVdFZRSFJJUHZZTmZINDhyRzVBWkJheEpZOFJBbDhnMW1SZVByK3RudEFTNVdMT3MvVkJGRURzWUFQVzJ0MVM1WVdGbnJKUzc5QVYwR25zS1ZPZG0wempsMnpJOWxTdmRMMVdPeFpuUElBWkJOVk9Hc2hWN0dxUXVkaDhBSy9jMmFYUUdycUR1UElZajNlUU1CeWlOZmZFRDVTWjh5Njd1cGprOFJsK2N1Szd1Y1JEQ1JranBzTDRKTVZ4eHVjNWh1UEJGbUUvN0cwaGZPSkxRT1NpR0dxVUlKbm5sQzVwNjRFeXlZZlVxSm4za1RoemhWellEa01KQWtOT3cvMHNmZ0ZRU3dNRUZBQUdBQWdBQUFBaEFOWmtzMUgwQUFBQU1RTUFBQkVBQUFCa2IyTlFjbTl3Y3k5amIzSmxMbmh0YkhQTWtrMVB3ekFNaHU5SS9JY29sd2xpSTJpbEt0WnR3Z2xwaU1PUTBEZ3RXcHVzU1IxVi9mZllWRFFKd1luTCtQWHpPbloydW11VnVJTVB4cmtDcFVtR0VEaGxjYVhyQW4yOGI4WXJoSU4ycWpUYU9TalFBd0phbGZlem5jOU42N2IwSnQ2Y0IwSWlMaFNvTnlZMEdjZVFlMUEySkU2RDVKY21LQnZsR09yZTQwQ1pQYk0zcFhpVlpRdThzVUNWRFdPSWJVRUxYRElsdjBCdmY5elcyR1pxQnVXSTJIc2kvSnZkYnhuRnh2V0dpVithWnFSSWtqMjltSlZFM1ZYUTQzMEpQWWtSSjNMTXFjN1k0S1hMcUtkSmtvejVxQitjV3BrbW9hSlkzM0Q0RnRVWEJnR1NNcjJrR1krMmFIeGRNcFhIRkdWWlFmQ245ditNWnpQQ1hUdFUxMjd2TGExZFZYTW9KOW5FdjV3MnF6OHBLdm5KSjRsK2Q1Nmo4aitVblV1ZFhsM1cyL0oxZ3k3SElZckh4V1E1Q1ZVZi9GVytBRWJSNFVkUWN1Si9UVDRCVUVzREJCUUFCZ0FJQUFBQUlRRFQ1T1BoOGdvQUFMR1RBQUFUQUFBQVcwTnZiblJsYm5SZlZIbHdaWE5kTG5odGJMV2FYVy9iT0JhRzd3ZnNmMURvZW05bDJjNkhnell6Mk1iSmRJTm1KaHM3YzBlSnRFVkVKaldrbkhoKy9WSWlaVnVKUWhOMWZORUNCaTArUFB3azh2Q2hmUE92dTJ5YVhVVmIxMVc1Q09iTFJaREZzcXJxU2JsN0VmeTZmN1A1SWNqcW5TZ3JrbGFYOFNLNGozWHdyK2UvL3ZMbTltbmR4a3dzTCt0RjBPLzcyOU5pVVpkZHZLM0xaYldQcGNua3RXeEZiWDdLM2FJVzlWM2NiUmRiMjhXeVdKdzJpMGxabmdYdjQxaTh1SzByazhLMjIzSmN2b25WTk5hempWY3hMazFrSzlkeFhwMFg1K0krN1lwNkl0KytYbWRaYjU5L3ZDaDNYNVBidTh1cGlNdG5KaDBUem1aVC9HYmpmMXg0dTN2QW0xVDdhYkk2S3E4dis4RHVYTFlLYzNaWjM5ZnB1RzRrcGdWUHh0SWt1b3pscU1ybmw2UDdMN2M1WjFjWDB3LzJYNk16cytPVE1udVZiTFYySmFyYm5WNS9YSnd0eThWbDFlWEpqcmJidHJHMnY5NWtSU3R1ZzJ5em1abC85MldWdHRPaUtIZWlONWxXbDJwNi9iTGIyeVR2ZHVVaUtQTkY4T0txcnNzNDdlZUhiOXFMcXBXOUVLMXBJRWE2RGROU1VjblpZdTlsYko3WmpYVzFqYy9hN3FZUmRTVWIwZC9FUG91N0pPVndaTnFPb1VOWHEyby9wU0Y3SWZYRGZ0SEVjbWZxRjJWc2J2bCtzOTFPZHEwM2hjNnlHM04xTzlGSFU3a3dMVVBPVXV1dUZkMVZ2KzB6UHg1ZDcrL1hrL2tPZ2RaSmZyMVB5dkc2RHFlbzVYTHhqemxEQ1lQNnhKK1FESTZCb3p0ZkxuT084UGdvamd3TzlTNDNmOXRYaDcvZVlyZzJMZldwekpkakhUSjZKQ2VPS3lOcHJTK3psL1BOeDVHNE12ZDRYTWtKejB0eEJWdS9zSHBuRzlJdS9pV05jclVjcmIzUmRPNTRiMllmckk2TGgvenc0KzZIR1YvR2JVd2ZmREJ1RHZsQlhSeXZybGZGb2VNdDdlNC96S055WHc4UHU5SWNVYlhMMXl6Rnc5d1krOTNqVnZUVlpOd1JGeGxtSCthMGMzT0tSUHFvVXd6WGo1MWlYN1pYc1I4blNmUlI0RzluTnpPTzdZZmsxdzhEZHIyT1pabnNjcVVxWnZQRnZXZ1RiNU9UeHM5cUdHK054MnNaMjgvUmo4WjFXODdTaXU1bi9WRS9mV1JROVBwMkhMU2pMK05rMG13bjJ6bkd3UURYcHFad1REdk14alBqYnpNcHloazMvbUZ2K3JKTS9EbkhtZmJTUlc5ZEhMZHRmd2owUTQ3eDlFVWZlUFZHcFBpOFZYY3BPcHlQcUxZWFZ4OXFjVWFpamNFL0tWRUhzSjVjakZQQ2ZuSjVjVGNkeDJPU0RYUEtRelgyRmJWNVIrK2FXTVZKZFhUQUpmbmltRGFkQmc4MEt0UW5mSnpwWm5LWTNIMU8wU2VpZVBaaVM2RXZSMm5NNW1QWGMrVXhMYWRCbkNsU3Jwd1FTMkE3Z3ZsNFo2YlJxSHpKWFFwTVFrckNySmdRNThxNWYvdDZkNXNMRHN2VTF5Uk9Ra3JDTEp3UTU4cnB2VzN2N1h4bWpaY252WnR3SDlrR2tKSXdxekloenBYYnR2dSt5blozYVhYUUNQc3E0WmN2M3h2UUJqQ1R4UFYxUWh3QytMemF6L0ptVi80SHM3S0hGenhMYUlNa3FWZC9KYlFoaEllclUyL3p5L3QrMjVsM2tZZXVvcWNYbk8zUUJwQ1NPTFZLYUVNSUQxZW5IaGJxNi83cXZNcW05NGRUV0ZjdmRMYUdOb0FrY2VwVlFoc0MrTHg2K0k3cEl1bkc3emNQNFYyOTBOa1oyZ0JTRXFkV0NXMEk0ZUhxMUR0clRPdmI4WDNOTlFMM3JJTVRLRW5OK2lLaERTRjhYSjE2YjYzSjNNMFcxSTZkM25rZDJpQkp6WTBDUWhzQytMeDZZZ1V6UklLejFSZFdNR2lESkhGcWxVSkl6S3VUQVllWGtjOStGTzdvaGFlUWFBTklTWng4cGxDRElPK2ZRdzZqUEczRmtONytRenhJa3ByMVJRbzFDUEorOWNRU3BnOERaeXNzcE1zdzdPUkZyQlJJa3RRc0x4S29RUVFmVjZjZUZqRTJDNXl0dE1odVI2a1U3dVpGTEdKSWt0UXNMeEtvUVFRZlY2ZCs4SzZKdmJYdHhMa0pQR3hRMDNjVXo3Wm9BMGhKbkh5bFVJTkFIcStlV01iWWRPN2tablk3T3QraERTQWxjZktWUWcwQ2VieDZZaDFqODhEWjZnczdHclFCcENST3ZsS29RU0NQVis4ZTN2N2FNcTA3dWJuZEQzNkZRTEoxV3J0U3FFRWdqMWNmM1VCM2NUZGY4bkNkWVBaaXc5c05raVIxKzVkNmlWbmwxY053OWFBMzEvTWtYVElKUDlJN3oxSFFCdGlacEc3OU51WUVnYVFlVms1TjQvMXR4WDAyUGJiVHoxTU5MQTN2T1VpV1JHclh1QlBFa3ZxeEd4QkhQVWlLcG43VVFrRklabEs3eHAwZ2x0UlBMRXFHZ1hDMnVzVFNXaUNwV2VNT2tFdnFpV1hKTUJGY3J1NitoeFJZR3Q2Q0FLUm1qVHRBTHFrbmxpWERSSEM2dXNUNldpQ3BXZU1Pa0V2cWlXWEpNQkZjcnI1NldGN2tFc0gxMnd0cXBZQ3lwRTZ0OFhkQkFKOVhUM3c0NmFRdS96WitQLzd4Tk5ZSlByMUEzd1ZZbHRTcDdld0ZBWHhlUGZGNWFlWmRuUDNtOUp2dXBONmZUeVB2SHIwN1JqOUJEUks3TmMrU0J3am0xajd4dldsV3BHYzMyRzFuVHRIK2JuWHc3dUhkTVhveEFoSzdOYytTQndqbTFqN3h6bW5vdFVmRkpDdnYwMmxKemVkcDN2VG1hSFpSajkvc29FRGkxS2w1bGp4QU1MUDI0WFBUL2JZYWp0bUZtQTZkK1REUk1EaDhhNHdDaWIxNjA4bzAxaEg4dkxwTHFvYUcvRFliZWhMNGRNUEoyME1VU0J3NnRaMDlJb0E3Ny9CMS8zQXhUT0NQdHcxbnJ3OVJJSEhvMUx6ZUlzSjRjMDkvTGZtOHUvazFHeDdKcDNuRDJmdDNGRWdjT2pXdnQ0Z3czdHo5Y0pLMVk0UDRma1QxWEdsdUVGQWdzVmZ2V3BuR09vS2ZWODgrbkpqQXczVDI5TDBpQ2lRT25aclhXMFFZYis1NE9LK3ZmanhmRit2cC9sUDI0QmM4Y2poN0g0Y0NpVU9uNXZVV0VjYWJlK0tiOWRYUmpjWFZ6ZmpIS1I2bWNtZnY0MUFnY2VqVXZONGl3bmh6THg1dUtIclJYK3lHaDRzNm01YkRyL0RrNTNtODdjZUpQTlNHbnJ4blNZSEVvVk83RVVXRWNlWWV1ZHhQOU9YaHdjZEs3T3RKZFpzTlplTDdUY0dSbjkzZzdFVkdDaXIyYXAzYXhrZUU4ZVllNXozaDJkV2gxay9LN0Q4U2xmZ2YrZG5ONGV3bFNnb3E5bXFkMnNaSGhQSG1mblN0LzhqZlgxNWZYRy9kM3o1OFhZczYvM3l5QWMxejh1UHlOajVmWU9GVFVCdk1uLzhIVUVzREJCUUFCZ0FJQUFBQUlRQm1oYjZ0eXdNQUFEb05BQUFQQUFBQWQyOXlaQzl6ZEhsc1pYTXVlRzFzcEpiYmJ0c3dESWJ2Qit3OUNOMW5TcHJHYVlMV1daQW02MlhRcm92YWRqY3dOdHNScGtPR3BDVE4yKy9JeWNteEMxVHRSYUpJL3Z3K0VwNHZQL1pTOEsyeGxtczFJL0dRRWM2VTBIV3JkamVNL0h4WUJCUENyYU5WUzRWV1prWU94cElQczY5ZjV1MUJXdTJONFJZakRLMW10TEZ1ZDVVa1ZqUkdVanZVTzZQZ1M2T05wQTVFczB0YWpkYTZDMUtwa3pFalY4blhiMWtONGF2WEdpejV2bFVMMWRHTk5rSllIZHJ5VkJtSWJya3dIT3pacERIQ1J4TUpuWmdRWHhNbCtiTzVuM0hld1Q1ZXBMdWZZcnZmVFJTTm4wRTlJUGpwMnZ4Ty9lK3JwN3QzbUxOMHg4NTRjSFZWN213Nk50cEgxNWJGV29tVk5wNzR3WWlMMUpGN3d5L0YzdFk2OHlUWG92TVZibSsxVVUrQmFHeDdoNjVOYXg4YlowVS9GNldnenBveVlpUklRcklnVGtoYUpISEJWNXZtbkNxT0ZrR1N6Tk1zTDlKaW1ZY0pMMTZLOERKSllJMHNEWUo0dmc3RFZUS1BpMFd4S05JMFhpVEpZclhLaWpTT2wybVJwa1h4RHB6TGxmWnJKUTZxaGRnWGVuTXdUNGg4OGVVOG5ScklIaUovM0hFMmRYQUkvTEhUcTZtRHcraVAvVFoxTUlqOU1aM3VqWVNwM082QnVwdlJHTHE5SUlxc0xLUVBMdEJGcWYxclovSERYUDh6Tnp4YjB4YTFKMCtTa1pzbU5oVk5UWTBrMStSTXcwL096NjJDK0FRdlBkakhFZzBaUDcxbFNRcW5Ed1o5aDdBWmVWZ3ZraHpMMGFIekREbTZyOGc3SkttcGNaZWF3VnBQSzd3QS9LSXpURFZkdjRwS25WMnpGcENWcVZ2YjM3TzBXME1uaEdhRTE5eVNEVks0UmI1WGo3ejIyY0pYdXVNVjFyam1XL0U0a2MwWnRjTnBMMGdUd2YyejBNRkVZNXIzckxkRGxwMlp3WTZLVEJZVzdKcGp3WFhIb1ZEQnRtbWdRd0E2RmdMY1pQZDBDOU9QdmRNVy9udGNheUZjSStHWGU0T2o1QUhqR3pmMis2N0ZYcnVEWG5uZ0w3VXc5ZWFPbW5aUWIwOGt6anQ3UVNadm9ROXZKby9NZE0yeFVHcUpkRVZhOVRRZHZRVVlwQmhpSmd6bjBCZEdQM0VPLzlWTzJIMTFqQ3hIRTZrTlROZjdEWmtMalkyN01YWlR0enRsOFJQWjllSUJqVEhVT0hQZGd0a2R3OVJZUlJiUDBKZklYV2RPUTR4UlBlQjlyT0hxbXFKdzl1QzdnTm4wQjBFK0IyR2cwdzNkYWpkVU1yd0M1L0p3aGdObGNBdy9HdlZzTzdncHdqVE44bU12aEtYY3EwYzRRTEJNUi9NNENWWS9COU0wS1paSjhYWXczSi8rL2xYeTJkNFE4UUx2OTdBMVlLL0JsZFJLcVR6TTRqek84dUorcDJrT0R4Q3g1UnNvcFcvRzBBK0grNE1XZVB0Q2JPQ3VLUisxZ1F2a2JGUjZiNkVKUURMRExaRVBUdjBCVUVzREJCUUFCZ0FJQUFBQUlRQTZxQkNFdVFZQUFEUWJBQUFSQUFBQWQyOXlaQzlrYjJOMWJXVnVkQzU0Yld5MFdOdHUyemdRZlMvUWZ5RDAzanB4YmtpZGlFbGJaTFBab2xodlAwQ1dtRmlJTElLVTQrVHZPME5LZHAzdU5zZysxSkJGY2NpZG1UTm5PT3JybC92N3hQSVVWY1drMkppRGZ0ZHlDV1NvSWliaWpYbno0MkpuWTFsVkRvbm9YVXBjRy9OY3l1cmx6ZGRmL3oySXExaFZIRVdGckhDUkcvTytxdExOVnF0a2ZqR3d1clNsNTFaOCtyay9IblR0NThudDlydkRtMEovd0xUYWRyKzMvbCswQ1krdXlDMk8zbVVCeFlrODVna1ZoVDRrREZtS1lvWUR2WnBGZWNaMU1uUENrOUYzemdLM0QyRnphUlVYZi9ZOU45TS92dFg1dzljamRqUThzWmVvQ3BuWEQwbEg2ZzhUbFhMOVdYcFpZSStENFlhS1VhOXZqYnFlOVM1dkV6aDh6Yi9KSkVrbDFHY1graDJ6Zk1mcm1CV25XMVlkYWFUREZqdDFWNjJMa1hKVlpMSk1XYURYRHZzOXkyTmpmYlZ1K2FGWFg2OGR6QkYxR2FTZG1NWjBzT3Q1cDkxVXNqeW1nY1FKNTZiajljNWNPZ2tVRlJFdlZCM1N3YTNZSlJ6SGJOY3ZDVWV4QSszYS8rUEVDUkdsVEVJdUdkUEwyY2hoTysvTVhnS2R2ak9idWVUbjhwdS81Zkt3MitudTd1NXVHNnZQdTg3T2cybG5wei9vN1g1L1A5dlJvUjVEeGU0UENERytyOFc5VVpHZEh5YVg2UkhidnpvNXY1cmRucDNOcnFiam16RmNYWTJuNTJmbmw1T3JvOG5zZnpGWVFDbnpHM2w5eFNLeHFYb2hoSXpuejhLbjY2cTJaemZFWlJyMm1XYVowbis3T0JMQmJNeHV1bkxVeGwzQzFidytZdkxQeGdrM0xIT3VOUHUwd0RsZkZTVUpWWnhwcHJxanF4SnBJdVFUTDJKWmFQSnVvTFl4QjcxQnA3OHhnLzVRajVPVVpYRGtITjVjbnJ4T0tTNFMyYlM4WTVGS0JMbVBUMytvOHBEa2g1TDV4ZXpNSGNmUjNSL3oyZm1WKy92MGVuZTBVNGVDUG04eXZUdDVjblZ4RDlOMHRWaXBud3BOU3JZenR6UWRSUXhWY3crSmtGV1lQT1hLQ2RJaTRWVzQwdkhrVmthaE82cENxbUxKQzFyV3pwNTNwQVVRcmtRWU8yd1ZhOTRKYkZYZXEvazRYOUQwWVhZYTNYbW5nZjNGdzVmV0hYMDcvdlorZEhSNVlPOC9oMFR2UnU5SGw4SDRueisrKzRmMkQrZC9Qd2FuUE9aRnhmSXFkNUowSlhudVVORVhWV1YrWXBHektqMzNnRHVPcVFpcGR2TThlME5wZTRiTU0zZlBSY2cveGJLbzlpMG9MUE1KbDdsYVB3cVpxZ0FobHFqbE54VlYyVkovS1JtbUJLdG0reXFtTEFxS3RiblJXeTdUbGNmU0gzUm1EaVdnSUxRSXFUcU02eW5UbjVtTE1SZ3pGejlrUkZHSWMxZzlvTXpCcDh5QjBMbUZpNko0cDk0elMvdk5jK1hXcytRSkpVbUdkNXhVamoxUWNKRHFZSTJWQmlwU1hCd3ZVaGJxbEttTHB5TDFzRjA1V1pRVUowMFZnRWlwaWhoVUpLQVpEUW1pdE5tRGxPbDB4bUlYYmZwU0pycGRRMHVMbllaYTFZazBVNlVpczFXdHNhclRHZTYyeXJDbUpWdldPaXVhTVhNMVo5ckFGdytJcXREcWVMM1Z6NjZZOVN5WjgvdVdCMSt0OXFWWURSV2xITXBqUXRWb1hkRUVVODVLYnpTMEc1ZExLdFBXaUdnZlFieHNIL0VWT2pRaHpiUXRXUFFhSkxuNDBEVFBYS2RCSlVmUHdOcTVHa2I2NDRmVVpVU1Q3bVZ2RXptVEpKRktyYlhNeS95QlBEcFhVTExLU2dVeExwSkZuRWRNQktYdTBMb2w5UkNuK1FKbElDRnNZWjVWTVpSVnlYWHVHOUNRc251Q2FRVWcrcUtkeVFuUnhhcXYrcWZMWUZCR2FBeld5TXNKUTFOMHE2b3JMZDdXS2hMYXdqYkNmYlhMb2xNOVJudUtyVHlsc0tOTTEycTlSZFM3R1VUeFZucXBWWkZyVmNPbEQwbDJqVXFDWTBmRVlpNWg3UDZLZzJaMXcrU20xcUZKelBGVG1GUTRrUk1PN1ViMXhiWnExQmZiYU5JWGU4QVhPMndLY21OMnF6V1Y1VkdySlZ6TVpSRUxiZkhOMTFGZnlZK1BqQy9ZeHU2cEtHWGRYVzlsSlRyMG5XOWQwRHpKT3FZSmJaMUxuckxHcFpFcjNoWGh2RzJ2TkFpOVpORnhBMXJRVXpVYzZIWnRMUnFnTlB3RDF6MzEwWm5PeUZFdEdRVTBnRVdtR2p5RXVNZFZOMGdLc3NUTnZoa1ZqT0xDc2tEM0kzOVZFWGZiWTRwTjEzbFFMVXVKVFhnVGpONHBSL08vbDFNOGJWT29SeHJ6QThzQzVkNm5QR0RFSEVCQjl5TldGR010RTFTNkY1NnB4Vm1LQzcvRHVxU3Y5R2xTWVROSmxUYjFzSXFmRVl6NFJ1SElUdzVGNENtL09CUDVIRkhnQ3FGYkFjWEdUWGZRN2ErcU9hVGRoL1I2R3RLMTBDS3N5TDF2YmNIbjhqRFFlRXlBYUh2My90d0ZEZi9GSTRZbER5aHdqUVdwZlZoajNkS3dPYjdGRStKWTNLQTkxVnA3Ty9RR01uSlJiUEpMMURaczZpM3NPWFduRms0cThKQ3BOZTNNMlhGTXREa20zZTlRbnJ5NjRwUkdEeFRtTW9xNXROUWhQTEFZekRMTjlMVEdicVR2S0J4TU5Bay9JelNRNU9ZZlVFc0RCQlFBQmdBSUFBQUFJUUJQUUlGbnBnSUFBTElHQUFBY0FBQUFkMjl5WkM5ZmNtVnNjeTl6WlhSMGFXNW5jeTU0Yld3dWNtVnNjeTJVMjI3Yk1CQkZYd2YwSHdTOU83cmxJc2FnS0JMWXlMcEJtNkFmUUVpVUpKdVhncVRzdVA5ZWxIU1R0eG5PSG5KbVo4aG5MNzlsNjMxUGJVd3hWNlpRbWxtcEk4Wk5ya3d1ZVhyKzkvamJLbDMrdmJIaTNIS2hUVEhuYXZzTEVzbnRiaHphSVFrQkY5T0ZVVlhaTkVJWVh5dXY0MktzdmVwanp3eDZiNkhyc0tuV3BtcEE3SFJaeUtkS3JhV1VuSnBRcEJhME1PV1VZN1ZWRmYxdEpEZVJ6YkUwNkpYa1RCVzFVbExHUFhWcE5ReERNZkF1OWh2d2QzSERNQitqNFNIbzRvTXNEOS9RVDBCV0xDNVc3WURRV3FuRWhRZmpXbW0yVmdwTmUzREJhMlZjcVJpR1VWQ01INHl2c05RbWhPRHdyZkJrWENGN01CVmtNQ1Z5QnhkTXhzUjRBbmNBSDR5TEplUlJZRHg0WWF5S01ycUZjUitWK3VHMHBJclRJN1hMNXZQb0dVZlA5b1BUbjZlOStQS1B6ZjRBVUVzQkFpMEFGQUFHQUFnQUFBQWhBRDN3UVM1T0FRQUF6aVlBQUFzQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUY5eVpXeHpMeTV5Wld4elVFc0JBaTBBRkFBR0FBZ0FBQUFoQUFHZTN4OUhBUUFBelFRQUFCd0FBQUFBQUFBQUFBQUFBQUFBa1FRQUFIZHZjbVF2WDNKbGJITXZaRzlqZFcxbGJuUXVlRzFzTG5KbGJITlFTd0VDTFFBVUFBWUFDQUFBQUNFQTFtU3pVZlFBQUFBeEF3QUFFUUFBQUFBQUFBQUFBQUFBQUFBQ0JnQUFaRzlqVUhKdmNITXZZMjl5WlM1NGJXeFFTd0VDTFFBVUFBWUFDQUFBQUNFQTArVGo0ZklLQUFDeGt3QUFFd0FBQUFBQUFBQUFBQUFBQUFBc0JRQUFXME52Ym5SbGJuUmZWSGx3WlhOZExuaHRiRkJMQVFJdEFCUUFCZ0FJQUFBQUlRQm1oYjZ0eXdNQUFEb05BQUFQQUFBQUFBQUFBQUFBQUFBQUFGOFRBQUIzYjNKa0wzTjBlV3hsY3k1NGJXeFFTd0VDTFFBVUFBWUFDQUFBQUNFQU9xZ1FoTGtHQUFBdkhnQUFFUUFBQUFBQUFBQUFBQUFBQUFCVEZ3QUFkMjl5WkM5a2IyTjFiV1Z1ZEM1NGJXeFFTd0VDTFFBVUFBWUFDQUFBQUNFQVQwQ0JaNllDQUFDM0JnQUFIQUFBQUFBQUFBQUFBQUFBQUFCU0hnQUFkMjl5WkM5ZmNtVnNjeTl6WlhSMGFXNW5jeTU0Yld3dWNtVnNjMUJMQlFZQUFBQUFCd0FIQVAwQkFBQldJZ0FBQUFBQSc7XG4gIFxuICAvLyBDb252ZXJ0IGJhc2U2NCB0byBBcnJheUJ1ZmZlclxuICBjb25zdCBiaW5hcnlTdHJpbmcgPSB3aW5kb3cuYXRvYihtaW5pbWFsRG9jeEJhc2U2NCk7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgfVxuICBcbiAgcmV0dXJuIGJ5dGVzLmJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJlcG9ydCBkb2N4IGZyb20gdGhlIHJlcG9ydCBkYXRhXG4gKiBAcGFyYW0gcmVwb3J0RGF0YSAtIFRoZSByZXBvcnQgZGF0YSBmcm9tIHRoZSBhcHBsaWNhdGlvblxuICogQHBhcmFtIHRlbXBsYXRlQnVmZmVyIC0gVGhlIGJpbmFyeSB0ZW1wbGF0ZSBmaWxlIGFzIGFuIEFycmF5QnVmZmVyIChvcHRpb25hbClcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBnZW5lcmF0ZWQgZmlsZSBhcyBhIEJsb2JcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUmVwb3J0RG9jeChcbiAgcmVwb3J0RGF0YTogUmVjb3JkPHN0cmluZywgYW55PixcbiAgdGVtcGxhdGVCdWZmZXI/OiBBcnJheUJ1ZmZlclxuKTogUHJvbWlzZTxCbG9iPiB7XG4gIC8vIEdlbmVyYXRlIHRoZSBmaWxlbmFtZSBiYXNlZCBvbiByZXBvcnQgZGF0YVxuICBjb25zdCBzdHVkZW50TmFtZSA9IHJlcG9ydERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24/LmZpcnN0TmFtZSBcbiAgICA/IGAke3JlcG9ydERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5maXJzdE5hbWV9XyR7cmVwb3J0RGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmxhc3ROYW1lfWBcbiAgICA6ICdzdHVkZW50JztcbiAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG4gIGNvbnN0IGZpbGVuYW1lID0gYCR7c3R1ZGVudE5hbWUucmVwbGFjZSgvXFxzKy9nLCAnXycpfV9yZXBvcnRfJHt0aW1lc3RhbXB9LmRvY3hgO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBJZiBubyB0ZW1wbGF0ZSBidWZmZXIgaXMgcHJvdmlkZWQsIHVzZSBhIGRlZmF1bHQgdGVtcGxhdGVcbiAgICBpZiAoIXRlbXBsYXRlQnVmZmVyKSB7XG4gICAgICAvLyBVc2UgZmV0Y2ggdG8gZ2V0IHRoZSB0ZW1wbGF0ZSBpZiB3ZSdyZSBpbiB0aGUgYnJvd3NlclxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ05vIHRlbXBsYXRlIGJ1ZmZlciBwcm92aWRlZCwgZmV0Y2hpbmcgZGVmYXVsdCB0ZW1wbGF0ZScpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byB1c2UgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSB3aGljaCBlbnN1cmVzIGJpbmFyeSBkYXRhIGhhbmRsaW5nXG4gICAgICAgICAgLy8gVXNlIGxhcy1hc3Nlc3NtZW50LXJlcG9ydC10ZW1wbGF0ZS5kb2N4IGluc3RlYWQgb2YgcmVwb3J0LXRlbXBsYXRlLmRvY3ggKHdoaWNoIGlzIGEgdGV4dCBmaWxlLCBub3QgYSBET0NYKVxuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy90ZW1wbGF0ZXMvbGFzLWFzc2Vzc21lbnQtcmVwb3J0LXRlbXBsYXRlLmRvY3gnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgY2FjaGU6ICduby1jYWNoZScsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLFxuICAgICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBkZWZhdWx0IHRlbXBsYXRlOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coJ0RlZmF1bHQgdGVtcGxhdGUgZmV0Y2hlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICB0ZW1wbGF0ZUJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYERlZmF1bHQgdGVtcGxhdGUgYnVmZmVyIHNpemU6ICR7dGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICBpZiAodGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWZhdWx0IHRlbXBsYXRlIGZpbGUgaXMgZW1wdHknKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVmVyaWZ5IHRoZSB0ZW1wbGF0ZSBoYXMgYSBwcm9wZXIgRE9DWCBzaWduYXR1cmVcbiAgICAgICAgICBjb25zdCBmaXJzdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodGVtcGxhdGVCdWZmZXIuc2xpY2UoMCwgNCkpO1xuICAgICAgICAgIGlmICghKGZpcnN0Qnl0ZXNbMF0gPT09IDB4NTAgJiYgZmlyc3RCeXRlc1sxXSA9PT0gMHg0QikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgRE9DWCBmaWxlIHNpZ25hdHVyZSBpbiBkZWZhdWx0IHRlbXBsYXRlLiBGaXJzdCBieXRlczonLCBBcnJheS5mcm9tKGZpcnN0Qnl0ZXMpKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVmYXVsdCB0ZW1wbGF0ZSBpcyBub3QgYSB2YWxpZCBET0NYIGZpbGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBkZWZhdWx0IHRlbXBsYXRlOicsIGVycm9yKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgYWx0ZXJuYXRpdmUgdGVtcGxhdGUgYXMgYSBsYXN0IHJlc29ydFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBsb2FkIGFsdGVybmF0aXZlIHRlbXBsYXRlOiBsYXMtYXNzZXNzbWVudC1yZXBvcnQtdGVtcGxhdGUuZG9jeCcpO1xuICAgICAgICAgICAgY29uc3QgYWx0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL3RlbXBsYXRlcy9sYXMtYXNzZXNzbWVudC1yZXBvcnQtdGVtcGxhdGUuZG9jeCcsIHtcbiAgICAgICAgICAgICAgY2FjaGU6ICduby1jYWNoZScsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50JyxcbiAgICAgICAgICAgICAgICAnQ2FjaGUtQ29udHJvbCc6ICduby1jYWNoZSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghYWx0UmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggYWx0ZXJuYXRpdmUgdGVtcGxhdGU6ICR7YWx0UmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0ZW1wbGF0ZUJ1ZmZlciA9IGF3YWl0IGFsdFJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQWx0ZXJuYXRpdmUgdGVtcGxhdGUgYnVmZmVyIHNpemU6ICR7dGVtcGxhdGVCdWZmZXIuYnl0ZUxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVmVyaWZ5IHRoZSBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgY29uc3QgYWx0Rmlyc3RCeXRlcyA9IG5ldyBVaW50OEFycmF5KHRlbXBsYXRlQnVmZmVyLnNsaWNlKDAsIDQpKTtcbiAgICAgICAgICAgIGlmICghKGFsdEZpcnN0Qnl0ZXNbMF0gPT09IDB4NTAgJiYgYWx0Rmlyc3RCeXRlc1sxXSA9PT0gMHg0QikpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBET0NYIGZpbGUgc2lnbmF0dXJlIGluIGFsdGVybmF0aXZlIHRlbXBsYXRlJyk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWx0ZXJuYXRpdmUgdGVtcGxhdGUgaXMgbm90IGEgdmFsaWQgRE9DWCBmaWxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICB9IGNhdGNoIChhbHRFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBhbHRlcm5hdGl2ZSB0ZW1wbGF0ZTonLCBhbHRFcnJvcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFzIGEgbGFzdCByZXNvcnQsIGNyZWF0ZSBhIG1pbmltYWwgdmFsaWQgRE9DWCB0ZW1wbGF0ZVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0aW5nIG1pbmltYWwgZW1wdHkgRE9DWCB0ZW1wbGF0ZScpO1xuICAgICAgICAgICAgdGVtcGxhdGVCdWZmZXIgPSBjcmVhdGVFbXB0eVRlbXBsYXRlKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQ3JlYXRlZCBtaW5pbWFsIHRlbXBsYXRlIHdpdGggc2l6ZTogJHt0ZW1wbGF0ZUJ1ZmZlci5ieXRlTGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXRlbXBsYXRlQnVmZmVyIHx8IHRlbXBsYXRlQnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgLy8gQWxsIHRlbXBsYXRlIGF0dGVtcHRzIGZhaWxlZCwgZmFsbCBiYWNrIHRvIEhUTUxcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbGwgdGVtcGxhdGUgYXR0ZW1wdHMgZmFpbGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXJ2ZXItc2lkZSBoYW5kbGluZyB3b3VsZCBiZSBkaWZmZXJlbnRcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZW1wbGF0ZSBidWZmZXIgaXMgcmVxdWlyZWQgd2hlbiBydW5uaW5nIG9uIHNlcnZlcicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvcm1hdCBhbmQgcHJlcGFyZSBkYXRhIGZvciB0aGUgdGVtcGxhdGVcbiAgICBjb25zdCBmb3JtYXR0ZWREYXRhID0gZm9ybWF0UmVwb3J0RGF0YUZvckRvY3gocmVwb3J0RGF0YSk7XG4gICAgY29uc29sZS5sb2coJ0RhdGEgZm9ybWF0dGVkIGZvciBET0NYIHRlbXBsYXRlJyk7XG5cbiAgICAvLyBHZW5lcmF0ZSB0aGUgZG9jdW1lbnRcbiAgICByZXR1cm4gYXdhaXQgZ2VuZXJhdGVEb2N4RnJvbVRlbXBsYXRlKHRlbXBsYXRlQnVmZmVyLCBmb3JtYXR0ZWREYXRhLCBmaWxlbmFtZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZ2VuZXJhdGVSZXBvcnREb2N4OicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBJZiB0aGVyZSB3YXMgYW4gZXJyb3Igd2l0aCB0aGUgdGVtcGxhdGUgb3IgZG9jeHRlbXBsYXRlcixcbiAgICAvLyB0cnkgdG8gZ2VuZXJhdGUgYSBmYWxsYmFjayBIVE1MIHJlcG9ydFxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIFxuICAgICAgICAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnemlwJykgfHwgXG4gICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCd0ZW1wbGF0ZScpIHx8IFxuICAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZG9jeHRlbXBsYXRlcicpKSkge1xuICAgICAgXG4gICAgICBjb25zb2xlLndhcm4oJ0RPQ1ggZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBIVE1MIGV4cG9ydCcpO1xuICAgICAgY29uc3QgaHRtbEJsb2IgPSBnZW5lcmF0ZUZhbGxiYWNrSHRtbFJlcG9ydChyZXBvcnREYXRhKTtcbiAgICAgIGNvbnN0IGh0bWxGaWxlbmFtZSA9IGAke3N0dWRlbnROYW1lLnJlcGxhY2UoL1xccysvZywgJ18nKX1fcmVwb3J0XyR7dGltZXN0YW1wfS5odG1sYDtcbiAgICAgIFxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNhdmVBcyhodG1sQmxvYiwgaHRtbEZpbGVuYW1lKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGh0bWxCbG9iO1xuICAgIH1cbiAgICBcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEZvcm1hdCB0aGUgcmVwb3J0IGRhdGEgZm9yIGRvY3ggdGVtcGxhdGUgcmVuZGVyaW5nXG4gKiBAcGFyYW0gcmVwb3J0RGF0YSAtIFRoZSByYXcgcmVwb3J0IGRhdGEgZnJvbSB0aGUgYXBwbGljYXRpb25cbiAqIEByZXR1cm5zIEZvcm1hdHRlZCBkYXRhIHJlYWR5IGZvciBkb2N4IHRlbXBsYXRlXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFJlcG9ydERhdGFGb3JEb2N4KHJlcG9ydERhdGE6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgLy8gQ3JlYXRlIGEgZGVlcCBjb3B5IG9mIHRoZSByZXBvcnQgZGF0YVxuICBjb25zdCBmb3JtYXR0ZWREYXRhID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXBvcnREYXRhKSk7XG5cbiAgLy8gRm9ybWF0IGFycmF5cyB0byBiZSBtb3JlIGRvY3gtdGVtcGxhdGUgZnJpZW5kbHlcbiAgLy8gQXJyYXlzIGluIGRvY3h0ZW1wbGF0ZXIgYXJlIHR5cGljYWxseSBoYW5kbGVkIHdpdGggbG9vcHMsIHNvIHdlJ2xsIGZvcm1hdCB0aGVtXG4gIC8vIHRvIGJlIHJlYWR5IGZvciB0aGUgdGVtcGxhdGUgc3ludGF4XG5cbiAgLy8gUHJvY2VzcyBzdHJlbmd0aCBhbmQgbmVlZHMgbGlzdHMgZm9yIGVhY2ggZG9tYWluXG4gIE9iamVjdC5rZXlzKGZvcm1hdHRlZERhdGEuYXNzZXNzbWVudFJlc3VsdHM/LmRvbWFpbnMgfHwge30pLmZvckVhY2goZG9tYWluID0+IHtcbiAgICBjb25zdCBkb21haW5EYXRhID0gZm9ybWF0dGVkRGF0YS5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zW2RvbWFpbl07XG4gICAgXG4gICAgLy8gRm9ybWF0IHN0cmVuZ3RocyBhcyBidWxsZXQgcG9pbnRzIGZvciBET0NYXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZG9tYWluRGF0YS5zdHJlbmd0aHMpICYmIGRvbWFpbkRhdGEuc3RyZW5ndGhzLmxlbmd0aCA+IDApIHtcbiAgICAgIGRvbWFpbkRhdGEuc3RyZW5ndGhzTGlzdCA9IGRvbWFpbkRhdGEuc3RyZW5ndGhzLm1hcCgoaXRlbTogc3RyaW5nKSA9PiAoeyB0ZXh0OiBpdGVtIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRW5zdXJlIGVtcHR5IGFycmF5IGhhcyByaWdodCBmb3JtYXQgZm9yIHRlbXBsYXRlcyB0aGF0IGV4cGVjdCBpdFxuICAgICAgZG9tYWluRGF0YS5zdHJlbmd0aHNMaXN0ID0gW107XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IG5lZWRzIGFzIGJ1bGxldCBwb2ludHMgZm9yIERPQ1hcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkb21haW5EYXRhLm5lZWRzKSAmJiBkb21haW5EYXRhLm5lZWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGRvbWFpbkRhdGEubmVlZHNMaXN0ID0gZG9tYWluRGF0YS5uZWVkcy5tYXAoKGl0ZW06IHN0cmluZykgPT4gKHsgdGV4dDogaXRlbSB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVuc3VyZSBlbXB0eSBhcnJheSBoYXMgcmlnaHQgZm9ybWF0IGZvciB0ZW1wbGF0ZXMgdGhhdCBleHBlY3QgaXRcbiAgICAgIGRvbWFpbkRhdGEubmVlZHNMaXN0ID0gW107XG4gICAgfVxuICB9KTtcblxuICAvLyBGb3JtYXQgYWNjb21tb2RhdGlvbiBhbmQgZmFjaWxpdGF0aW9uIHN0cmF0ZWdpZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkoZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uPy5yZWNvbW1lbmRhdGlvbnM/LmFjY29tbW9kYXRpb25zKSkge1xuICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuYWNjb21tb2RhdGlvbnNMaXN0ID0gXG4gICAgICBmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmFjY29tbW9kYXRpb25zLm1hcCgoaXRlbTogc3RyaW5nKSA9PiAoeyB0ZXh0OiBpdGVtIH0pKTtcbiAgfSBlbHNlIGlmIChmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24/LnJlY29tbWVuZGF0aW9ucykge1xuICAgIGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbi5yZWNvbW1lbmRhdGlvbnMuYWNjb21tb2RhdGlvbnNMaXN0ID0gW107XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24/LnJlY29tbWVuZGF0aW9ucz8uZmFjaWxpdGF0aW9uU3RyYXRlZ2llcykpIHtcbiAgICBmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmZhY2lsaXRhdGlvblN0cmF0ZWdpZXNMaXN0ID0gXG4gICAgICBmb3JtYXR0ZWREYXRhLmNvbmNsdXNpb24ucmVjb21tZW5kYXRpb25zLmZhY2lsaXRhdGlvblN0cmF0ZWdpZXMubWFwKChpdGVtOiBzdHJpbmcpID0+ICh7IHRleHQ6IGl0ZW0gfSkpO1xuICB9IGVsc2UgaWYgKGZvcm1hdHRlZERhdGEuY29uY2x1c2lvbj8ucmVjb21tZW5kYXRpb25zKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5jb25jbHVzaW9uLnJlY29tbWVuZGF0aW9ucy5mYWNpbGl0YXRpb25TdHJhdGVnaWVzTGlzdCA9IFtdO1xuICB9XG5cbiAgLy8gQ29udmVydCBwYXJlbnRzIGFycmF5IHRvIHN0cmluZyBpZiBuZWVkZWRcbiAgaWYgKEFycmF5LmlzQXJyYXkoZm9ybWF0dGVkRGF0YS5oZWFkZXI/LnN0dWRlbnRJbmZvcm1hdGlvbj8ucGFyZW50cykpIHtcbiAgICBmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ucGFyZW50c1N0cmluZyA9IFxuICAgICAgZm9ybWF0dGVkRGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLnBhcmVudHMuam9pbignLCAnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXR0ZWREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLnBhcmVudHNTdHJpbmcgPSAnJztcbiAgfVxuXG4gIC8vIEFkZCBmdWxsIHN0dWRlbnQgbmFtZSBmb3IgY29udmVuaWVuY2VcbiAgaWYgKGZvcm1hdHRlZERhdGEuaGVhZGVyPy5zdHVkZW50SW5mb3JtYXRpb24/LmZpcnN0TmFtZSkge1xuICAgIGZvcm1hdHRlZERhdGEuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5mdWxsTmFtZSA9IFxuICAgICAgYCR7Zm9ybWF0dGVkRGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmZpcnN0TmFtZX0gJHtmb3JtYXR0ZWREYXRhLmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ubGFzdE5hbWUgfHwgJyd9YDtcbiAgfSBlbHNlIGlmIChmb3JtYXR0ZWREYXRhLmhlYWRlcj8uc3R1ZGVudEluZm9ybWF0aW9uKSB7XG4gICAgZm9ybWF0dGVkRGF0YS5oZWFkZXIuc3R1ZGVudEluZm9ybWF0aW9uLmZ1bGxOYW1lID0gJ1N0dWRlbnQnO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdHRlZERhdGE7XG59Il0sIm5hbWVzIjpbIkRvY3h0ZW1wbGF0ZXIiLCJQaXpaaXAiLCJzYXZlQXMiLCJnZW5lcmF0ZURvY3hGcm9tVGVtcGxhdGUiLCJ0ZW1wbGF0ZUJ1ZmZlciIsImRhdGEiLCJvdXRwdXRGaWxlbmFtZSIsImNvbnNvbGUiLCJsb2ciLCJieXRlTGVuZ3RoIiwiRXJyb3IiLCJmaXJzdEJ5dGVzIiwiVWludDhBcnJheSIsInNsaWNlIiwiZXJyb3IiLCJBcnJheSIsImZyb20iLCJ6aXAiLCJhcnJheUJ1ZmZlciIsInppcEVycm9yIiwibWVzc2FnZSIsImRvYyIsInBhcmFncmFwaExvb3AiLCJsaW5lYnJlYWtzIiwiZXJyb3JMb2dnaW5nIiwibnVsbEdldHRlciIsInBhcnQiLCJtb2R1bGUiLCJkb2N4RXJyb3IiLCJyZW5kZXIiLCJyZW5kZXJFcnJvciIsInByb3BzIiwicHJvcGVydGllcyIsImV4cGxhbmF0aW9uIiwib3V0cHV0IiwiZ2V0WmlwIiwiZ2VuZXJhdGUiLCJ0eXBlIiwiY29tcHJlc3Npb24iLCJtaW1lVHlwZSIsInNpemUiLCJnZW5FcnJvciIsInNhdmVFcnJvciIsImluY2x1ZGVzIiwiZ2VuZXJhdGVGYWxsYmFja0h0bWxSZXBvcnQiLCJyZXBvcnREYXRhIiwic3R1ZGVudE5hbWUiLCJoZWFkZXIiLCJzdHVkZW50SW5mb3JtYXRpb24iLCJmaXJzdE5hbWUiLCJsYXN0TmFtZSIsImh0bWwiLCJET0IiLCJyZXBvcnREYXRlIiwicmVhc29uRm9yUmVmZXJyYWwiLCJhc3Nlc3NtZW50UmVzdWx0cyIsImRvbWFpbnMiLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImRvbWFpbk5hbWUiLCJkb21haW4iLCJ0b3BpY1NlbnRlbmNlIiwic3RyZW5ndGhzIiwibGVuZ3RoIiwibmVlZHMiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsImlzQ29uY2VybiIsInVuZGVmaW5lZCIsIm1hcCIsIml0ZW0iLCJqb2luIiwiaW1wYWN0U3RhdGVtZW50IiwiY29uY2x1c2lvbiIsInJlY29tbWVuZGF0aW9ucyIsImFjY29tbW9kYXRpb25zIiwiZmFjaWxpdGF0aW9uU3RyYXRlZ2llcyIsIkJsb2IiLCJjcmVhdGVFbXB0eVRlbXBsYXRlIiwibWluaW1hbERvY3hCYXNlNjQiLCJiaW5hcnlTdHJpbmciLCJ3aW5kb3ciLCJhdG9iIiwiYnl0ZXMiLCJpIiwiY2hhckNvZGVBdCIsImJ1ZmZlciIsImdlbmVyYXRlUmVwb3J0RG9jeCIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNwbGl0IiwiZmlsZW5hbWUiLCJyZXBsYWNlIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImNhY2hlIiwiaGVhZGVycyIsIm9rIiwic3RhdHVzIiwiYWx0UmVzcG9uc2UiLCJhbHRGaXJzdEJ5dGVzIiwiYWx0RXJyb3IiLCJmb3JtYXR0ZWREYXRhIiwiZm9ybWF0UmVwb3J0RGF0YUZvckRvY3giLCJ3YXJuIiwiaHRtbEJsb2IiLCJodG1sRmlsZW5hbWUiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJrZXlzIiwiZG9tYWluRGF0YSIsImlzQXJyYXkiLCJzdHJlbmd0aHNMaXN0IiwidGV4dCIsIm5lZWRzTGlzdCIsImFjY29tbW9kYXRpb25zTGlzdCIsImZhY2lsaXRhdGlvblN0cmF0ZWdpZXNMaXN0IiwicGFyZW50cyIsInBhcmVudHNTdHJpbmciLCJmdWxsTmFtZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/docx-generator.ts\n"));

/***/ })

});