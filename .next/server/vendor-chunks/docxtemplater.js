"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/docxtemplater";
exports.ids = ["vendor-chunks/docxtemplater"];
exports.modules = {

/***/ "(ssr)/./node_modules/docxtemplater/js/collect-content-types.js":
/*!****************************************************************!*\
  !*** ./node_modules/docxtemplater/js/collect-content-types.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("\n\nvar ctXML = \"[Content_Types].xml\";\nfunction collectContentTypes(overrides, defaults, zip) {\n  var partNames = {};\n  for (var _i2 = 0; _i2 < overrides.length; _i2++) {\n    var override = overrides[_i2];\n    var contentType = override.getAttribute(\"ContentType\");\n    var partName = override.getAttribute(\"PartName\").substr(1);\n    partNames[partName] = contentType;\n  }\n  var _loop = function _loop() {\n    var def = defaults[_i4];\n    var contentType = def.getAttribute(\"ContentType\");\n    var extension = def.getAttribute(\"Extension\");\n    zip.file(/./).map(function (_ref) {\n      var name = _ref.name;\n      if (name.slice(name.length - extension.length) === extension && !partNames[name] && name !== ctXML) {\n        partNames[name] = contentType;\n      }\n    });\n  };\n  for (var _i4 = 0; _i4 < defaults.length; _i4++) {\n    _loop();\n  }\n  return partNames;\n}\nmodule.exports = collectContentTypes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9jb2xsZWN0LWNvbnRlbnQtdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2NvbGxlY3QtY29udGVudC10eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGN0WE1MID0gXCJbQ29udGVudF9UeXBlc10ueG1sXCI7XG5mdW5jdGlvbiBjb2xsZWN0Q29udGVudFR5cGVzKG92ZXJyaWRlcywgZGVmYXVsdHMsIHppcCkge1xuICB2YXIgcGFydE5hbWVzID0ge307XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG92ZXJyaWRlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIG92ZXJyaWRlID0gb3ZlcnJpZGVzW19pMl07XG4gICAgdmFyIGNvbnRlbnRUeXBlID0gb3ZlcnJpZGUuZ2V0QXR0cmlidXRlKFwiQ29udGVudFR5cGVcIik7XG4gICAgdmFyIHBhcnROYW1lID0gb3ZlcnJpZGUuZ2V0QXR0cmlidXRlKFwiUGFydE5hbWVcIikuc3Vic3RyKDEpO1xuICAgIHBhcnROYW1lc1twYXJ0TmFtZV0gPSBjb250ZW50VHlwZTtcbiAgfVxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICB2YXIgZGVmID0gZGVmYXVsdHNbX2k0XTtcbiAgICB2YXIgY29udGVudFR5cGUgPSBkZWYuZ2V0QXR0cmlidXRlKFwiQ29udGVudFR5cGVcIik7XG4gICAgdmFyIGV4dGVuc2lvbiA9IGRlZi5nZXRBdHRyaWJ1dGUoXCJFeHRlbnNpb25cIik7XG4gICAgemlwLmZpbGUoLy4vKS5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgaWYgKG5hbWUuc2xpY2UobmFtZS5sZW5ndGggLSBleHRlbnNpb24ubGVuZ3RoKSA9PT0gZXh0ZW5zaW9uICYmICFwYXJ0TmFtZXNbbmFtZV0gJiYgbmFtZSAhPT0gY3RYTUwpIHtcbiAgICAgICAgcGFydE5hbWVzW25hbWVdID0gY29udGVudFR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGRlZmF1bHRzLmxlbmd0aDsgX2k0KyspIHtcbiAgICBfbG9vcCgpO1xuICB9XG4gIHJldHVybiBwYXJ0TmFtZXM7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGNvbGxlY3RDb250ZW50VHlwZXM7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/collect-content-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/content-types.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/content-types.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\n\nvar coreContentType = \"application/vnd.openxmlformats-package.core-properties+xml\";\nvar appContentType = \"application/vnd.openxmlformats-officedocument.extended-properties+xml\";\nvar customContentType = \"application/vnd.openxmlformats-officedocument.custom-properties+xml\";\nvar settingsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\";\nvar diagramDataContentType = \"application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml\";\nvar diagramDrawingContentType = \"application/vnd.ms-office.drawingml.diagramDrawing+xml\";\nmodule.exports = {\n  settingsContentType: settingsContentType,\n  coreContentType: coreContentType,\n  appContentType: appContentType,\n  customContentType: customContentType,\n  diagramDataContentType: diagramDataContentType,\n  diagramDrawingContentType: diagramDrawingContentType\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9jb250ZW50LXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvY29udGVudC10eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGNvcmVDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLXBhY2thZ2UuY29yZS1wcm9wZXJ0aWVzK3htbFwiO1xudmFyIGFwcENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZXh0ZW5kZWQtcHJvcGVydGllcyt4bWxcIjtcbnZhciBjdXN0b21Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmN1c3RvbS1wcm9wZXJ0aWVzK3htbFwiO1xudmFyIHNldHRpbmdzQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnNldHRpbmdzK3htbFwiO1xudmFyIGRpYWdyYW1EYXRhQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5kcmF3aW5nbWwuZGlhZ3JhbURhdGEreG1sXCI7XG52YXIgZGlhZ3JhbURyYXdpbmdDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm1zLW9mZmljZS5kcmF3aW5nbWwuZGlhZ3JhbURyYXdpbmcreG1sXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0dGluZ3NDb250ZW50VHlwZTogc2V0dGluZ3NDb250ZW50VHlwZSxcbiAgY29yZUNvbnRlbnRUeXBlOiBjb3JlQ29udGVudFR5cGUsXG4gIGFwcENvbnRlbnRUeXBlOiBhcHBDb250ZW50VHlwZSxcbiAgY3VzdG9tQ29udGVudFR5cGU6IGN1c3RvbUNvbnRlbnRUeXBlLFxuICBkaWFncmFtRGF0YUNvbnRlbnRUeXBlOiBkaWFncmFtRGF0YUNvbnRlbnRUeXBlLFxuICBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlOiBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/content-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/doc-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/docxtemplater/js/doc-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nvar _require = __webpack_require__(/*! @xmldom/xmldom */ \"(ssr)/./node_modules/@xmldom/xmldom/lib/index.js\"),\n  DOMParser = _require.DOMParser,\n  XMLSerializer = _require.XMLSerializer;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"),\n  throwXmlTagNotFound = _require2.throwXmlTagNotFound;\nvar _require3 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/docxtemplater/js/utils.js\"),\n  last = _require3.last,\n  first = _require3.first;\nfunction isWhiteSpace(value) {\n  return /^[ \\n\\r\\t]+$/.test(value);\n}\nfunction parser(tag) {\n  return {\n    get: function get(scope) {\n      if (tag === \".\") {\n        return scope;\n      }\n      if (scope) {\n        return scope[tag];\n      }\n      return scope;\n    }\n  };\n}\nvar attrToRegex = {};\nfunction setSingleAttribute(partValue, attr, attrValue) {\n  var regex;\n  // Stryker disable next-line all : because this is an optimisation\n  if (attrToRegex[attr]) {\n    regex = attrToRegex[attr];\n  } else {\n    regex = new RegExp(\"(<.* \".concat(attr, \"=\\\")([^\\\"]*)(\\\".*)$\"));\n    attrToRegex[attr] = regex;\n  }\n  if (regex.test(partValue)) {\n    return partValue.replace(regex, \"$1\".concat(attrValue, \"$3\"));\n  }\n  var end = partValue.lastIndexOf(\"/>\");\n  if (end === -1) {\n    end = partValue.lastIndexOf(\">\");\n  }\n  return partValue.substr(0, end) + \" \".concat(attr, \"=\\\"\").concat(attrValue, \"\\\"\") + partValue.substr(end);\n}\nfunction getSingleAttribute(value, attributeName) {\n  var index = value.indexOf(\" \".concat(attributeName, \"=\\\"\"));\n  if (index === -1) {\n    return null;\n  }\n  var startIndex = value.substr(index).search(/[\"']/) + index;\n  var endIndex = value.substr(startIndex + 1).search(/[\"']/) + startIndex;\n  return value.substr(startIndex + 1, endIndex - startIndex);\n}\nfunction endsWith(str, suffix) {\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\nfunction startsWith(str, prefix) {\n  return str.substring(0, prefix.length) === prefix;\n}\nfunction getDuplicates(arr) {\n  var duplicates = [];\n  var hash = {},\n    result = [];\n  for (var i = 0, l = arr.length; i < l; ++i) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      result.push(arr[i]);\n    } else {\n      duplicates.push(arr[i]);\n    }\n  }\n  return duplicates;\n}\nfunction uniq(arr) {\n  var hash = {},\n    result = [];\n  for (var i = 0, l = arr.length; i < l; ++i) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\nfunction chunkBy(parsed, f) {\n  var chunks = [[]];\n  for (var _i2 = 0; _i2 < parsed.length; _i2++) {\n    var p = parsed[_i2];\n    var currentChunk = chunks[chunks.length - 1];\n    var res = f(p);\n    if (res === \"start\") {\n      chunks.push([p]);\n    } else if (res === \"end\") {\n      currentChunk.push(p);\n      chunks.push([]);\n    } else {\n      currentChunk.push(p);\n    }\n  } // Remove empty chunks\n  var result = [];\n  for (var _i4 = 0; _i4 < chunks.length; _i4++) {\n    var chunk = chunks[_i4];\n    if (chunk.length > 0) {\n      result.push(chunk);\n    }\n  }\n  return result;\n}\nfunction getDefaults() {\n  return {\n    errorLogging: \"json\",\n    stripInvalidXMLChars: false,\n    paragraphLoop: false,\n    nullGetter: function nullGetter(part) {\n      return part.module ? \"\" : \"undefined\";\n    },\n    xmlFileNames: [\"[Content_Types].xml\"],\n    parser: parser,\n    linebreaks: false,\n    fileTypeConfig: null,\n    delimiters: {\n      start: \"{\",\n      end: \"}\"\n    },\n    syntax: {\n      changeDelimiterPrefix: \"=\"\n    }\n  };\n}\nfunction xml2str(xmlNode) {\n  return new XMLSerializer().serializeToString(xmlNode).replace(/xmlns(:[a-z0-9]+)?=\"\" ?/g, \"\");\n}\nfunction str2xml(str) {\n  if (str.charCodeAt(0) === 65279) {\n    // BOM sequence\n    str = str.substr(1);\n  }\n  return new DOMParser().parseFromString(str, \"text/xml\");\n}\nvar charMap = [[\"&\", \"&amp;\"], [\"<\", \"&lt;\"], [\">\", \"&gt;\"], ['\"', \"&quot;\"], [\"'\", \"&apos;\"]];\nvar charMapRegexes = charMap.map(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    endChar = _ref2[0],\n    startChar = _ref2[1];\n  return {\n    rstart: new RegExp(startChar, \"g\"),\n    rend: new RegExp(endChar, \"g\"),\n    start: startChar,\n    end: endChar\n  };\n});\nfunction wordToUtf8(string) {\n  for (var i = charMapRegexes.length - 1; i >= 0; i--) {\n    var r = charMapRegexes[i];\n    string = string.replace(r.rstart, r.end);\n  }\n  return string;\n}\nfunction utf8ToWord(string) {\n  // To make sure that the object given is a string (this is a noop for strings).\n  string = string.toString();\n  var r;\n  for (var i = 0, l = charMapRegexes.length; i < l; i++) {\n    r = charMapRegexes[i];\n    string = string.replace(r.rend, r.start);\n  }\n  return string;\n}\n\n// This function is written with for loops for performance\nfunction concatArrays(arrays) {\n  var result = [];\n  for (var _i6 = 0; _i6 < arrays.length; _i6++) {\n    var array = arrays[_i6];\n    for (var _i8 = 0; _i8 < array.length; _i8++) {\n      var el = array[_i8];\n      result.push(el);\n    }\n  }\n  return result;\n}\nfunction pushArray(array1, array2) {\n  if (!array2) {\n    return array1;\n  }\n  for (var i = 0, len = array2.length; i < len; i++) {\n    array1.push(array2[i]);\n  }\n  return array1;\n}\nvar spaceRegexp = new RegExp(String.fromCharCode(160), \"g\");\nfunction convertSpaces(s) {\n  return s.replace(spaceRegexp, \" \");\n}\nfunction pregMatchAll(regex, content) {\n  /*\n   * Regex is a string, content is the content. It returns an array of all\n   * matches with their offset, for example:\n   *\n   * regex=la\n   * content=lolalolilala\n   *\n   * Returns:\n   *\n   * [\n   *    {array: {0: 'la'}, offset: 2},\n   *    {array: {0: 'la'}, offset: 8},\n   *    {array: {0: 'la'}, offset: 10}\n   * ]\n   */\n  var matchArray = [];\n  var match;\n  while ((match = regex.exec(content)) != null) {\n    matchArray.push({\n      array: match,\n      offset: match.index\n    });\n  }\n  return matchArray;\n}\nfunction isEnding(value, element) {\n  return value === \"</\" + element + \">\";\n}\nfunction isStarting(value, element) {\n  return value.indexOf(\"<\" + element) === 0 && [\">\", \" \", \"/\"].indexOf(value[element.length + 1]) !== -1;\n}\nfunction getRight(parsed, element, index) {\n  var val = getRightOrNull(parsed, element, index);\n  if (val !== null) {\n    return val;\n  }\n  throwXmlTagNotFound({\n    position: \"right\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\nfunction getRightOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n  var level = 1;\n  for (var i = index, l = parsed.length; i < l; i++) {\n    var part = parsed[i];\n    for (var _i10 = 0, _elements2 = elements; _i10 < _elements2.length; _i10++) {\n      var element = _elements2[_i10];\n      if (isEnding(part.value, element)) {\n        level--;\n      }\n      if (isStarting(part.value, element)) {\n        level++;\n      }\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\nfunction getLeft(parsed, element, index) {\n  var val = getLeftOrNull(parsed, element, index);\n  if (val !== null) {\n    return val;\n  }\n  throwXmlTagNotFound({\n    position: \"left\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\nfunction getLeftOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n  var level = 1;\n  for (var i = index; i >= 0; i--) {\n    var part = parsed[i];\n    for (var _i12 = 0, _elements4 = elements; _i12 < _elements4.length; _i12++) {\n      var element = _elements4[_i12];\n      if (isStarting(part.value, element)) {\n        level--;\n      }\n      if (isEnding(part.value, element)) {\n        level++;\n      }\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\n\n/*\n * Stryker disable all : because those are functions that depend on the parsed\n * structure based and we don't want minimal code here, but rather code that\n * makes things clear.\n */\nfunction isTagStart(tagType, _ref3) {\n  var type = _ref3.type,\n    tag = _ref3.tag,\n    position = _ref3.position;\n  return type === \"tag\" && tag === tagType && (position === \"start\" || position === \"selfclosing\");\n}\nfunction isTagEnd(tagType, _ref4) {\n  var type = _ref4.type,\n    tag = _ref4.tag,\n    position = _ref4.position;\n  return type === \"tag\" && tag === tagType && position === \"end\";\n}\nfunction isParagraphStart(_ref5) {\n  var type = _ref5.type,\n    tag = _ref5.tag,\n    position = _ref5.position;\n  return [\"w:p\", \"a:p\"].indexOf(tag) !== -1 && type === \"tag\" && position === \"start\";\n}\nfunction isParagraphEnd(_ref6) {\n  var type = _ref6.type,\n    tag = _ref6.tag,\n    position = _ref6.position;\n  return [\"w:p\", \"a:p\"].indexOf(tag) !== -1 && type === \"tag\" && position === \"end\";\n}\nfunction isTextStart(_ref7) {\n  var type = _ref7.type,\n    position = _ref7.position,\n    text = _ref7.text;\n  return text && type === \"tag\" && position === \"start\";\n}\nfunction isTextEnd(_ref8) {\n  var type = _ref8.type,\n    position = _ref8.position,\n    text = _ref8.text;\n  return text && type === \"tag\" && position === \"end\";\n}\nfunction isContent(_ref9) {\n  var type = _ref9.type,\n    position = _ref9.position;\n  return type === \"placeholder\" || type === \"content\" && position === \"insidetag\";\n}\nfunction isModule(_ref10, modules) {\n  var module = _ref10.module,\n    type = _ref10.type;\n  if (!(modules instanceof Array)) {\n    modules = [modules];\n  }\n  return type === \"placeholder\" && modules.indexOf(module) !== -1;\n}\n// Stryker restore all\n\nvar corruptCharacters = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/;\n/*\n * 00    NUL '\\0' (null character)\n * 01    SOH (start of heading)\n * 02    STX (start of text)\n * 03    ETX (end of text)\n * 04    EOT (end of transmission)\n * 05    ENQ (enquiry)\n * 06    ACK (acknowledge)\n * 07    BEL '\\a' (bell)\n * 08    BS  '\\b' (backspace)\n * 0B    VT  '\\v' (vertical tab)\n * 0C    FF  '\\f' (form feed)\n * 0E    SO  (shift out)\n * 0F    SI  (shift in)\n * 10    DLE (data link escape)\n * 11    DC1 (device control 1)\n * 12    DC2 (device control 2)\n * 13    DC3 (device control 3)\n * 14    DC4 (device control 4)\n * 15    NAK (negative ack.)\n * 16    SYN (synchronous idle)\n * 17    ETB (end of trans. blk)\n * 18    CAN (cancel)\n * 19    EM  (end of medium)\n * 1A    SUB (substitute)\n * 1B    ESC (escape)\n * 1C    FS  (file separator)\n * 1D    GS  (group separator)\n * 1E    RS  (record separator)\n * 1F    US  (unit separator)\n */\nfunction hasCorruptCharacters(string) {\n  return corruptCharacters.test(string);\n}\nfunction removeCorruptCharacters(string) {\n  if (typeof string !== \"string\") {\n    string = String(string);\n  }\n  return string.replace(corruptCharacters, \"\");\n}\nfunction invertMap(map) {\n  var invertedMap = {};\n  for (var key in map) {\n    var value = map[key];\n    invertedMap[value] || (invertedMap[value] = []);\n    invertedMap[value].push(key);\n  }\n  return invertedMap;\n}\n/*\n * This ensures that the sort is stable. The default Array.sort of the browser\n * is not stable in firefox, as the JS spec does not enforce the sort to be\n * stable.\n */\nfunction stableSort(arr, compare) {\n  // Stryker disable all : in previous versions of Chrome, sort was not stable by itself, so we had to add this. This is to support older versions of JS runners.\n  return arr.map(function (item, index) {\n    return {\n      item: item,\n      index: index\n    };\n  }).sort(function (a, b) {\n    return compare(a.item, b.item) || a.index - b.index;\n  }).map(function (_ref11) {\n    var item = _ref11.item;\n    return item;\n  });\n  // Stryker restore all\n}\nmodule.exports = {\n  endsWith: endsWith,\n  startsWith: startsWith,\n  isContent: isContent,\n  isParagraphStart: isParagraphStart,\n  isParagraphEnd: isParagraphEnd,\n  isTagStart: isTagStart,\n  isTagEnd: isTagEnd,\n  isTextStart: isTextStart,\n  isTextEnd: isTextEnd,\n  isStarting: isStarting,\n  isEnding: isEnding,\n  isModule: isModule,\n  uniq: uniq,\n  getDuplicates: getDuplicates,\n  chunkBy: chunkBy,\n  last: last,\n  first: first,\n  xml2str: xml2str,\n  str2xml: str2xml,\n  getRightOrNull: getRightOrNull,\n  getRight: getRight,\n  getLeftOrNull: getLeftOrNull,\n  getLeft: getLeft,\n  pregMatchAll: pregMatchAll,\n  convertSpaces: convertSpaces,\n  charMapRegexes: charMapRegexes,\n  hasCorruptCharacters: hasCorruptCharacters,\n  removeCorruptCharacters: removeCorruptCharacters,\n  getDefaults: getDefaults,\n  wordToUtf8: wordToUtf8,\n  utf8ToWord: utf8ToWord,\n  concatArrays: concatArrays,\n  pushArray: pushArray,\n  invertMap: invertMap,\n  charMap: charMap,\n  getSingleAttribute: getSingleAttribute,\n  setSingleAttribute: setSingleAttribute,\n  isWhiteSpace: isWhiteSpace,\n  stableSort: stableSort\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2MtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qiw2Q0FBNkMsU0FBUywwREFBMEQsVUFBVSxnQ0FBZ0M7QUFDMUosbUNBQW1DLCtDQUErQyw4QkFBOEIsT0FBTyxrQkFBa0I7QUFDekksdUNBQXVDLGtHQUFrRyxpQkFBaUIsd0NBQXdDLE1BQU0seUNBQXlDLDZCQUE2QixVQUFVLFlBQVksa0VBQWtFLFdBQVcsWUFBWSxpQkFBaUIsVUFBVSxNQUFNLGlGQUFpRixVQUFVLG9CQUFvQjtBQUM3Z0IsOEJBQThCO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyx3RUFBZ0I7QUFDdkM7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFhO0FBQ3JDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWUsZUFBZSxpQkFBaUIsaUJBQWlCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxRQUFRLFFBQVEsWUFBWTtBQUNyQyxTQUFTLFFBQVEsUUFBUSxZQUFZO0FBQ3JDLFNBQVMsUUFBUSxRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBLDhDQUE4QywwQkFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZG9jLXV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiQHhtbGRvbS94bWxkb21cIiksXG4gIERPTVBhcnNlciA9IF9yZXF1aXJlLkRPTVBhcnNlcixcbiAgWE1MU2VyaWFsaXplciA9IF9yZXF1aXJlLlhNTFNlcmlhbGl6ZXI7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICB0aHJvd1htbFRhZ05vdEZvdW5kID0gX3JlcXVpcmUyLnRocm93WG1sVGFnTm90Rm91bmQ7XG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIiksXG4gIGxhc3QgPSBfcmVxdWlyZTMubGFzdCxcbiAgZmlyc3QgPSBfcmVxdWlyZTMuZmlyc3Q7XG5mdW5jdGlvbiBpc1doaXRlU3BhY2UodmFsdWUpIHtcbiAgcmV0dXJuIC9eWyBcXG5cXHJcXHRdKyQvLnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gcGFyc2VyKHRhZykge1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KHNjb3BlKSB7XG4gICAgICBpZiAodGFnID09PSBcIi5cIikge1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlW3RhZ107XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICB9O1xufVxudmFyIGF0dHJUb1JlZ2V4ID0ge307XG5mdW5jdGlvbiBzZXRTaW5nbGVBdHRyaWJ1dGUocGFydFZhbHVlLCBhdHRyLCBhdHRyVmFsdWUpIHtcbiAgdmFyIHJlZ2V4O1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgbmV4dC1saW5lIGFsbCA6IGJlY2F1c2UgdGhpcyBpcyBhbiBvcHRpbWlzYXRpb25cbiAgaWYgKGF0dHJUb1JlZ2V4W2F0dHJdKSB7XG4gICAgcmVnZXggPSBhdHRyVG9SZWdleFthdHRyXTtcbiAgfSBlbHNlIHtcbiAgICByZWdleCA9IG5ldyBSZWdFeHAoXCIoPC4qIFwiLmNvbmNhdChhdHRyLCBcIj1cXFwiKShbXlxcXCJdKikoXFxcIi4qKSRcIikpO1xuICAgIGF0dHJUb1JlZ2V4W2F0dHJdID0gcmVnZXg7XG4gIH1cbiAgaWYgKHJlZ2V4LnRlc3QocGFydFZhbHVlKSkge1xuICAgIHJldHVybiBwYXJ0VmFsdWUucmVwbGFjZShyZWdleCwgXCIkMVwiLmNvbmNhdChhdHRyVmFsdWUsIFwiJDNcIikpO1xuICB9XG4gIHZhciBlbmQgPSBwYXJ0VmFsdWUubGFzdEluZGV4T2YoXCIvPlwiKTtcbiAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICBlbmQgPSBwYXJ0VmFsdWUubGFzdEluZGV4T2YoXCI+XCIpO1xuICB9XG4gIHJldHVybiBwYXJ0VmFsdWUuc3Vic3RyKDAsIGVuZCkgKyBcIiBcIi5jb25jYXQoYXR0ciwgXCI9XFxcIlwiKS5jb25jYXQoYXR0clZhbHVlLCBcIlxcXCJcIikgKyBwYXJ0VmFsdWUuc3Vic3RyKGVuZCk7XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVBdHRyaWJ1dGUodmFsdWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIGluZGV4ID0gdmFsdWUuaW5kZXhPZihcIiBcIi5jb25jYXQoYXR0cmlidXRlTmFtZSwgXCI9XFxcIlwiKSk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc3RhcnRJbmRleCA9IHZhbHVlLnN1YnN0cihpbmRleCkuc2VhcmNoKC9bXCInXS8pICsgaW5kZXg7XG4gIHZhciBlbmRJbmRleCA9IHZhbHVlLnN1YnN0cihzdGFydEluZGV4ICsgMSkuc2VhcmNoKC9bXCInXS8pICsgc3RhcnRJbmRleDtcbiAgcmV0dXJuIHZhbHVlLnN1YnN0cihzdGFydEluZGV4ICsgMSwgZW5kSW5kZXggLSBzdGFydEluZGV4KTtcbn1cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc3VmZml4KSB7XG4gIHJldHVybiBzdHIuaW5kZXhPZihzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgcHJlZml4KSB7XG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXg7XG59XG5mdW5jdGlvbiBnZXREdXBsaWNhdGVzKGFycikge1xuICB2YXIgZHVwbGljYXRlcyA9IFtdO1xuICB2YXIgaGFzaCA9IHt9LFxuICAgIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoIWhhc2hbYXJyW2ldXSkge1xuICAgICAgaGFzaFthcnJbaV1dID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5wdXNoKGFycltpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cGxpY2F0ZXMucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHVwbGljYXRlcztcbn1cbmZ1bmN0aW9uIHVuaXEoYXJyKSB7XG4gIHZhciBoYXNoID0ge30sXG4gICAgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmICghaGFzaFthcnJbaV1dKSB7XG4gICAgICBoYXNoW2FycltpXV0gPSB0cnVlO1xuICAgICAgcmVzdWx0LnB1c2goYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNodW5rQnkocGFyc2VkLCBmKSB7XG4gIHZhciBjaHVua3MgPSBbW11dO1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYXJzZWQubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBwID0gcGFyc2VkW19pMl07XG4gICAgdmFyIGN1cnJlbnRDaHVuayA9IGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV07XG4gICAgdmFyIHJlcyA9IGYocCk7XG4gICAgaWYgKHJlcyA9PT0gXCJzdGFydFwiKSB7XG4gICAgICBjaHVua3MucHVzaChbcF0pO1xuICAgIH0gZWxzZSBpZiAocmVzID09PSBcImVuZFwiKSB7XG4gICAgICBjdXJyZW50Q2h1bmsucHVzaChwKTtcbiAgICAgIGNodW5rcy5wdXNoKFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudENodW5rLnB1c2gocCk7XG4gICAgfVxuICB9IC8vIFJlbW92ZSBlbXB0eSBjaHVua3NcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBjaHVua3MubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBjaHVuayA9IGNodW5rc1tfaTRdO1xuICAgIGlmIChjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQucHVzaChjaHVuayk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0cygpIHtcbiAgcmV0dXJuIHtcbiAgICBlcnJvckxvZ2dpbmc6IFwianNvblwiLFxuICAgIHN0cmlwSW52YWxpZFhNTENoYXJzOiBmYWxzZSxcbiAgICBwYXJhZ3JhcGhMb29wOiBmYWxzZSxcbiAgICBudWxsR2V0dGVyOiBmdW5jdGlvbiBudWxsR2V0dGVyKHBhcnQpIHtcbiAgICAgIHJldHVybiBwYXJ0Lm1vZHVsZSA/IFwiXCIgOiBcInVuZGVmaW5lZFwiO1xuICAgIH0sXG4gICAgeG1sRmlsZU5hbWVzOiBbXCJbQ29udGVudF9UeXBlc10ueG1sXCJdLFxuICAgIHBhcnNlcjogcGFyc2VyLFxuICAgIGxpbmVicmVha3M6IGZhbHNlLFxuICAgIGZpbGVUeXBlQ29uZmlnOiBudWxsLFxuICAgIGRlbGltaXRlcnM6IHtcbiAgICAgIHN0YXJ0OiBcIntcIixcbiAgICAgIGVuZDogXCJ9XCJcbiAgICB9LFxuICAgIHN5bnRheDoge1xuICAgICAgY2hhbmdlRGVsaW1pdGVyUHJlZml4OiBcIj1cIlxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHhtbDJzdHIoeG1sTm9kZSkge1xuICByZXR1cm4gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyh4bWxOb2RlKS5yZXBsYWNlKC94bWxucyg6W2EtejAtOV0rKT89XCJcIiA/L2csIFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyMnhtbChzdHIpIHtcbiAgaWYgKHN0ci5jaGFyQ29kZUF0KDApID09PSA2NTI3OSkge1xuICAgIC8vIEJPTSBzZXF1ZW5jZVxuICAgIHN0ciA9IHN0ci5zdWJzdHIoMSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc3RyLCBcInRleHQveG1sXCIpO1xufVxudmFyIGNoYXJNYXAgPSBbW1wiJlwiLCBcIiZhbXA7XCJdLCBbXCI8XCIsIFwiJmx0O1wiXSwgW1wiPlwiLCBcIiZndDtcIl0sIFsnXCInLCBcIiZxdW90O1wiXSwgW1wiJ1wiLCBcIiZhcG9zO1wiXV07XG52YXIgY2hhck1hcFJlZ2V4ZXMgPSBjaGFyTWFwLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICBlbmRDaGFyID0gX3JlZjJbMF0sXG4gICAgc3RhcnRDaGFyID0gX3JlZjJbMV07XG4gIHJldHVybiB7XG4gICAgcnN0YXJ0OiBuZXcgUmVnRXhwKHN0YXJ0Q2hhciwgXCJnXCIpLFxuICAgIHJlbmQ6IG5ldyBSZWdFeHAoZW5kQ2hhciwgXCJnXCIpLFxuICAgIHN0YXJ0OiBzdGFydENoYXIsXG4gICAgZW5kOiBlbmRDaGFyXG4gIH07XG59KTtcbmZ1bmN0aW9uIHdvcmRUb1V0Zjgoc3RyaW5nKSB7XG4gIGZvciAodmFyIGkgPSBjaGFyTWFwUmVnZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciByID0gY2hhck1hcFJlZ2V4ZXNbaV07XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2Uoci5yc3RhcnQsIHIuZW5kKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufVxuZnVuY3Rpb24gdXRmOFRvV29yZChzdHJpbmcpIHtcbiAgLy8gVG8gbWFrZSBzdXJlIHRoYXQgdGhlIG9iamVjdCBnaXZlbiBpcyBhIHN0cmluZyAodGhpcyBpcyBhIG5vb3AgZm9yIHN0cmluZ3MpLlxuICBzdHJpbmcgPSBzdHJpbmcudG9TdHJpbmcoKTtcbiAgdmFyIHI7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hhck1hcFJlZ2V4ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgciA9IGNoYXJNYXBSZWdleGVzW2ldO1xuICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHIucmVuZCwgci5zdGFydCk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZztcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB3cml0dGVuIHdpdGggZm9yIGxvb3BzIGZvciBwZXJmb3JtYW5jZVxuZnVuY3Rpb24gY29uY2F0QXJyYXlzKGFycmF5cykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGFycmF5cy5sZW5ndGg7IF9pNisrKSB7XG4gICAgdmFyIGFycmF5ID0gYXJyYXlzW19pNl07XG4gICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgYXJyYXkubGVuZ3RoOyBfaTgrKykge1xuICAgICAgdmFyIGVsID0gYXJyYXlbX2k4XTtcbiAgICAgIHJlc3VsdC5wdXNoKGVsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHB1c2hBcnJheShhcnJheTEsIGFycmF5Mikge1xuICBpZiAoIWFycmF5Mikge1xuICAgIHJldHVybiBhcnJheTE7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Mi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFycmF5MS5wdXNoKGFycmF5MltpXSk7XG4gIH1cbiAgcmV0dXJuIGFycmF5MTtcbn1cbnZhciBzcGFjZVJlZ2V4cCA9IG5ldyBSZWdFeHAoU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApLCBcImdcIik7XG5mdW5jdGlvbiBjb252ZXJ0U3BhY2VzKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZShzcGFjZVJlZ2V4cCwgXCIgXCIpO1xufVxuZnVuY3Rpb24gcHJlZ01hdGNoQWxsKHJlZ2V4LCBjb250ZW50KSB7XG4gIC8qXG4gICAqIFJlZ2V4IGlzIGEgc3RyaW5nLCBjb250ZW50IGlzIHRoZSBjb250ZW50LiBJdCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbFxuICAgKiBtYXRjaGVzIHdpdGggdGhlaXIgb2Zmc2V0LCBmb3IgZXhhbXBsZTpcbiAgICpcbiAgICogcmVnZXg9bGFcbiAgICogY29udGVudD1sb2xhbG9saWxhbGFcbiAgICpcbiAgICogUmV0dXJuczpcbiAgICpcbiAgICogW1xuICAgKiAgICB7YXJyYXk6IHswOiAnbGEnfSwgb2Zmc2V0OiAyfSxcbiAgICogICAge2FycmF5OiB7MDogJ2xhJ30sIG9mZnNldDogOH0sXG4gICAqICAgIHthcnJheTogezA6ICdsYSd9LCBvZmZzZXQ6IDEwfVxuICAgKiBdXG4gICAqL1xuICB2YXIgbWF0Y2hBcnJheSA9IFtdO1xuICB2YXIgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKGNvbnRlbnQpKSAhPSBudWxsKSB7XG4gICAgbWF0Y2hBcnJheS5wdXNoKHtcbiAgICAgIGFycmF5OiBtYXRjaCxcbiAgICAgIG9mZnNldDogbWF0Y2guaW5kZXhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbWF0Y2hBcnJheTtcbn1cbmZ1bmN0aW9uIGlzRW5kaW5nKHZhbHVlLCBlbGVtZW50KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gXCI8L1wiICsgZWxlbWVudCArIFwiPlwiO1xufVxuZnVuY3Rpb24gaXNTdGFydGluZyh2YWx1ZSwgZWxlbWVudCkge1xuICByZXR1cm4gdmFsdWUuaW5kZXhPZihcIjxcIiArIGVsZW1lbnQpID09PSAwICYmIFtcIj5cIiwgXCIgXCIsIFwiL1wiXS5pbmRleE9mKHZhbHVlW2VsZW1lbnQubGVuZ3RoICsgMV0pICE9PSAtMTtcbn1cbmZ1bmN0aW9uIGdldFJpZ2h0KHBhcnNlZCwgZWxlbWVudCwgaW5kZXgpIHtcbiAgdmFyIHZhbCA9IGdldFJpZ2h0T3JOdWxsKHBhcnNlZCwgZWxlbWVudCwgaW5kZXgpO1xuICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB0aHJvd1htbFRhZ05vdEZvdW5kKHtcbiAgICBwb3NpdGlvbjogXCJyaWdodFwiLFxuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgcGFyc2VkOiBwYXJzZWQsXG4gICAgaW5kZXg6IGluZGV4XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmlnaHRPck51bGwocGFyc2VkLCBlbGVtZW50cywgaW5kZXgpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcbiAgfVxuICB2YXIgbGV2ZWwgPSAxO1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGwgPSBwYXJzZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbaV07XG4gICAgZm9yICh2YXIgX2kxMCA9IDAsIF9lbGVtZW50czIgPSBlbGVtZW50czsgX2kxMCA8IF9lbGVtZW50czIubGVuZ3RoOyBfaTEwKyspIHtcbiAgICAgIHZhciBlbGVtZW50ID0gX2VsZW1lbnRzMltfaTEwXTtcbiAgICAgIGlmIChpc0VuZGluZyhwYXJ0LnZhbHVlLCBlbGVtZW50KSkge1xuICAgICAgICBsZXZlbC0tO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3RhcnRpbmcocGFydC52YWx1ZSwgZWxlbWVudCkpIHtcbiAgICAgICAgbGV2ZWwrKztcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRMZWZ0KHBhcnNlZCwgZWxlbWVudCwgaW5kZXgpIHtcbiAgdmFyIHZhbCA9IGdldExlZnRPck51bGwocGFyc2VkLCBlbGVtZW50LCBpbmRleCk7XG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHRocm93WG1sVGFnTm90Rm91bmQoe1xuICAgIHBvc2l0aW9uOiBcImxlZnRcIixcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIHBhcnNlZDogcGFyc2VkLFxuICAgIGluZGV4OiBpbmRleFxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldExlZnRPck51bGwocGFyc2VkLCBlbGVtZW50cywgaW5kZXgpIHtcbiAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gXCJzdHJpbmdcIikge1xuICAgIGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcbiAgfVxuICB2YXIgbGV2ZWwgPSAxO1xuICBmb3IgKHZhciBpID0gaW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbaV07XG4gICAgZm9yICh2YXIgX2kxMiA9IDAsIF9lbGVtZW50czQgPSBlbGVtZW50czsgX2kxMiA8IF9lbGVtZW50czQubGVuZ3RoOyBfaTEyKyspIHtcbiAgICAgIHZhciBlbGVtZW50ID0gX2VsZW1lbnRzNFtfaTEyXTtcbiAgICAgIGlmIChpc1N0YXJ0aW5nKHBhcnQudmFsdWUsIGVsZW1lbnQpKSB7XG4gICAgICAgIGxldmVsLS07XG4gICAgICB9XG4gICAgICBpZiAoaXNFbmRpbmcocGFydC52YWx1ZSwgZWxlbWVudCkpIHtcbiAgICAgICAgbGV2ZWwrKztcbiAgICAgIH1cbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qXG4gKiBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aG9zZSBhcmUgZnVuY3Rpb25zIHRoYXQgZGVwZW5kIG9uIHRoZSBwYXJzZWRcbiAqIHN0cnVjdHVyZSBiYXNlZCBhbmQgd2UgZG9uJ3Qgd2FudCBtaW5pbWFsIGNvZGUgaGVyZSwgYnV0IHJhdGhlciBjb2RlIHRoYXRcbiAqIG1ha2VzIHRoaW5ncyBjbGVhci5cbiAqL1xuZnVuY3Rpb24gaXNUYWdTdGFydCh0YWdUeXBlLCBfcmVmMykge1xuICB2YXIgdHlwZSA9IF9yZWYzLnR5cGUsXG4gICAgdGFnID0gX3JlZjMudGFnLFxuICAgIHBvc2l0aW9uID0gX3JlZjMucG9zaXRpb247XG4gIHJldHVybiB0eXBlID09PSBcInRhZ1wiICYmIHRhZyA9PT0gdGFnVHlwZSAmJiAocG9zaXRpb24gPT09IFwic3RhcnRcIiB8fCBwb3NpdGlvbiA9PT0gXCJzZWxmY2xvc2luZ1wiKTtcbn1cbmZ1bmN0aW9uIGlzVGFnRW5kKHRhZ1R5cGUsIF9yZWY0KSB7XG4gIHZhciB0eXBlID0gX3JlZjQudHlwZSxcbiAgICB0YWcgPSBfcmVmNC50YWcsXG4gICAgcG9zaXRpb24gPSBfcmVmNC5wb3NpdGlvbjtcbiAgcmV0dXJuIHR5cGUgPT09IFwidGFnXCIgJiYgdGFnID09PSB0YWdUeXBlICYmIHBvc2l0aW9uID09PSBcImVuZFwiO1xufVxuZnVuY3Rpb24gaXNQYXJhZ3JhcGhTdGFydChfcmVmNSkge1xuICB2YXIgdHlwZSA9IF9yZWY1LnR5cGUsXG4gICAgdGFnID0gX3JlZjUudGFnLFxuICAgIHBvc2l0aW9uID0gX3JlZjUucG9zaXRpb247XG4gIHJldHVybiBbXCJ3OnBcIiwgXCJhOnBcIl0uaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0eXBlID09PSBcInRhZ1wiICYmIHBvc2l0aW9uID09PSBcInN0YXJ0XCI7XG59XG5mdW5jdGlvbiBpc1BhcmFncmFwaEVuZChfcmVmNikge1xuICB2YXIgdHlwZSA9IF9yZWY2LnR5cGUsXG4gICAgdGFnID0gX3JlZjYudGFnLFxuICAgIHBvc2l0aW9uID0gX3JlZjYucG9zaXRpb247XG4gIHJldHVybiBbXCJ3OnBcIiwgXCJhOnBcIl0uaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0eXBlID09PSBcInRhZ1wiICYmIHBvc2l0aW9uID09PSBcImVuZFwiO1xufVxuZnVuY3Rpb24gaXNUZXh0U3RhcnQoX3JlZjcpIHtcbiAgdmFyIHR5cGUgPSBfcmVmNy50eXBlLFxuICAgIHBvc2l0aW9uID0gX3JlZjcucG9zaXRpb24sXG4gICAgdGV4dCA9IF9yZWY3LnRleHQ7XG4gIHJldHVybiB0ZXh0ICYmIHR5cGUgPT09IFwidGFnXCIgJiYgcG9zaXRpb24gPT09IFwic3RhcnRcIjtcbn1cbmZ1bmN0aW9uIGlzVGV4dEVuZChfcmVmOCkge1xuICB2YXIgdHlwZSA9IF9yZWY4LnR5cGUsXG4gICAgcG9zaXRpb24gPSBfcmVmOC5wb3NpdGlvbixcbiAgICB0ZXh0ID0gX3JlZjgudGV4dDtcbiAgcmV0dXJuIHRleHQgJiYgdHlwZSA9PT0gXCJ0YWdcIiAmJiBwb3NpdGlvbiA9PT0gXCJlbmRcIjtcbn1cbmZ1bmN0aW9uIGlzQ29udGVudChfcmVmOSkge1xuICB2YXIgdHlwZSA9IF9yZWY5LnR5cGUsXG4gICAgcG9zaXRpb24gPSBfcmVmOS5wb3NpdGlvbjtcbiAgcmV0dXJuIHR5cGUgPT09IFwicGxhY2Vob2xkZXJcIiB8fCB0eXBlID09PSBcImNvbnRlbnRcIiAmJiBwb3NpdGlvbiA9PT0gXCJpbnNpZGV0YWdcIjtcbn1cbmZ1bmN0aW9uIGlzTW9kdWxlKF9yZWYxMCwgbW9kdWxlcykge1xuICB2YXIgbW9kdWxlID0gX3JlZjEwLm1vZHVsZSxcbiAgICB0eXBlID0gX3JlZjEwLnR5cGU7XG4gIGlmICghKG1vZHVsZXMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICBtb2R1bGVzID0gW21vZHVsZXNdO1xuICB9XG4gIHJldHVybiB0eXBlID09PSBcInBsYWNlaG9sZGVyXCIgJiYgbW9kdWxlcy5pbmRleE9mKG1vZHVsZSkgIT09IC0xO1xufVxuLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuXG52YXIgY29ycnVwdENoYXJhY3RlcnMgPSAvW1xceDAwLVxceDA4XFx4MEJcXHgwQ1xceDBFLVxceDFGXS87XG4vKlxuICogMDAgICAgTlVMICdcXDAnIChudWxsIGNoYXJhY3RlcilcbiAqIDAxICAgIFNPSCAoc3RhcnQgb2YgaGVhZGluZylcbiAqIDAyICAgIFNUWCAoc3RhcnQgb2YgdGV4dClcbiAqIDAzICAgIEVUWCAoZW5kIG9mIHRleHQpXG4gKiAwNCAgICBFT1QgKGVuZCBvZiB0cmFuc21pc3Npb24pXG4gKiAwNSAgICBFTlEgKGVucXVpcnkpXG4gKiAwNiAgICBBQ0sgKGFja25vd2xlZGdlKVxuICogMDcgICAgQkVMICdcXGEnIChiZWxsKVxuICogMDggICAgQlMgICdcXGInIChiYWNrc3BhY2UpXG4gKiAwQiAgICBWVCAgJ1xcdicgKHZlcnRpY2FsIHRhYilcbiAqIDBDICAgIEZGICAnXFxmJyAoZm9ybSBmZWVkKVxuICogMEUgICAgU08gIChzaGlmdCBvdXQpXG4gKiAwRiAgICBTSSAgKHNoaWZ0IGluKVxuICogMTAgICAgRExFIChkYXRhIGxpbmsgZXNjYXBlKVxuICogMTEgICAgREMxIChkZXZpY2UgY29udHJvbCAxKVxuICogMTIgICAgREMyIChkZXZpY2UgY29udHJvbCAyKVxuICogMTMgICAgREMzIChkZXZpY2UgY29udHJvbCAzKVxuICogMTQgICAgREM0IChkZXZpY2UgY29udHJvbCA0KVxuICogMTUgICAgTkFLIChuZWdhdGl2ZSBhY2suKVxuICogMTYgICAgU1lOIChzeW5jaHJvbm91cyBpZGxlKVxuICogMTcgICAgRVRCIChlbmQgb2YgdHJhbnMuIGJsaylcbiAqIDE4ICAgIENBTiAoY2FuY2VsKVxuICogMTkgICAgRU0gIChlbmQgb2YgbWVkaXVtKVxuICogMUEgICAgU1VCIChzdWJzdGl0dXRlKVxuICogMUIgICAgRVNDIChlc2NhcGUpXG4gKiAxQyAgICBGUyAgKGZpbGUgc2VwYXJhdG9yKVxuICogMUQgICAgR1MgIChncm91cCBzZXBhcmF0b3IpXG4gKiAxRSAgICBSUyAgKHJlY29yZCBzZXBhcmF0b3IpXG4gKiAxRiAgICBVUyAgKHVuaXQgc2VwYXJhdG9yKVxuICovXG5mdW5jdGlvbiBoYXNDb3JydXB0Q2hhcmFjdGVycyhzdHJpbmcpIHtcbiAgcmV0dXJuIGNvcnJ1cHRDaGFyYWN0ZXJzLnRlc3Qoc3RyaW5nKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUNvcnJ1cHRDaGFyYWN0ZXJzKHN0cmluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpO1xuICB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShjb3JydXB0Q2hhcmFjdGVycywgXCJcIik7XG59XG5mdW5jdGlvbiBpbnZlcnRNYXAobWFwKSB7XG4gIHZhciBpbnZlcnRlZE1hcCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSB7XG4gICAgdmFyIHZhbHVlID0gbWFwW2tleV07XG4gICAgaW52ZXJ0ZWRNYXBbdmFsdWVdIHx8IChpbnZlcnRlZE1hcFt2YWx1ZV0gPSBbXSk7XG4gICAgaW52ZXJ0ZWRNYXBbdmFsdWVdLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gaW52ZXJ0ZWRNYXA7XG59XG4vKlxuICogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHNvcnQgaXMgc3RhYmxlLiBUaGUgZGVmYXVsdCBBcnJheS5zb3J0IG9mIHRoZSBicm93c2VyXG4gKiBpcyBub3Qgc3RhYmxlIGluIGZpcmVmb3gsIGFzIHRoZSBKUyBzcGVjIGRvZXMgbm90IGVuZm9yY2UgdGhlIHNvcnQgdG8gYmVcbiAqIHN0YWJsZS5cbiAqL1xuZnVuY3Rpb24gc3RhYmxlU29ydChhcnIsIGNvbXBhcmUpIHtcbiAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGluIHByZXZpb3VzIHZlcnNpb25zIG9mIENocm9tZSwgc29ydCB3YXMgbm90IHN0YWJsZSBieSBpdHNlbGYsIHNvIHdlIGhhZCB0byBhZGQgdGhpcy4gVGhpcyBpcyB0byBzdXBwb3J0IG9sZGVyIHZlcnNpb25zIG9mIEpTIHJ1bm5lcnMuXG4gIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtOiBpdGVtLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlKGEuaXRlbSwgYi5pdGVtKSB8fCBhLmluZGV4IC0gYi5pbmRleDtcbiAgfSkubWFwKGZ1bmN0aW9uIChfcmVmMTEpIHtcbiAgICB2YXIgaXRlbSA9IF9yZWYxMS5pdGVtO1xuICAgIHJldHVybiBpdGVtO1xuICB9KTtcbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuZHNXaXRoOiBlbmRzV2l0aCxcbiAgc3RhcnRzV2l0aDogc3RhcnRzV2l0aCxcbiAgaXNDb250ZW50OiBpc0NvbnRlbnQsXG4gIGlzUGFyYWdyYXBoU3RhcnQ6IGlzUGFyYWdyYXBoU3RhcnQsXG4gIGlzUGFyYWdyYXBoRW5kOiBpc1BhcmFncmFwaEVuZCxcbiAgaXNUYWdTdGFydDogaXNUYWdTdGFydCxcbiAgaXNUYWdFbmQ6IGlzVGFnRW5kLFxuICBpc1RleHRTdGFydDogaXNUZXh0U3RhcnQsXG4gIGlzVGV4dEVuZDogaXNUZXh0RW5kLFxuICBpc1N0YXJ0aW5nOiBpc1N0YXJ0aW5nLFxuICBpc0VuZGluZzogaXNFbmRpbmcsXG4gIGlzTW9kdWxlOiBpc01vZHVsZSxcbiAgdW5pcTogdW5pcSxcbiAgZ2V0RHVwbGljYXRlczogZ2V0RHVwbGljYXRlcyxcbiAgY2h1bmtCeTogY2h1bmtCeSxcbiAgbGFzdDogbGFzdCxcbiAgZmlyc3Q6IGZpcnN0LFxuICB4bWwyc3RyOiB4bWwyc3RyLFxuICBzdHIyeG1sOiBzdHIyeG1sLFxuICBnZXRSaWdodE9yTnVsbDogZ2V0UmlnaHRPck51bGwsXG4gIGdldFJpZ2h0OiBnZXRSaWdodCxcbiAgZ2V0TGVmdE9yTnVsbDogZ2V0TGVmdE9yTnVsbCxcbiAgZ2V0TGVmdDogZ2V0TGVmdCxcbiAgcHJlZ01hdGNoQWxsOiBwcmVnTWF0Y2hBbGwsXG4gIGNvbnZlcnRTcGFjZXM6IGNvbnZlcnRTcGFjZXMsXG4gIGNoYXJNYXBSZWdleGVzOiBjaGFyTWFwUmVnZXhlcyxcbiAgaGFzQ29ycnVwdENoYXJhY3RlcnM6IGhhc0NvcnJ1cHRDaGFyYWN0ZXJzLFxuICByZW1vdmVDb3JydXB0Q2hhcmFjdGVyczogcmVtb3ZlQ29ycnVwdENoYXJhY3RlcnMsXG4gIGdldERlZmF1bHRzOiBnZXREZWZhdWx0cyxcbiAgd29yZFRvVXRmODogd29yZFRvVXRmOCxcbiAgdXRmOFRvV29yZDogdXRmOFRvV29yZCxcbiAgY29uY2F0QXJyYXlzOiBjb25jYXRBcnJheXMsXG4gIHB1c2hBcnJheTogcHVzaEFycmF5LFxuICBpbnZlcnRNYXA6IGludmVydE1hcCxcbiAgY2hhck1hcDogY2hhck1hcCxcbiAgZ2V0U2luZ2xlQXR0cmlidXRlOiBnZXRTaW5nbGVBdHRyaWJ1dGUsXG4gIHNldFNpbmdsZUF0dHJpYnV0ZTogc2V0U2luZ2xlQXR0cmlidXRlLFxuICBpc1doaXRlU3BhY2U6IGlzV2hpdGVTcGFjZSxcbiAgc3RhYmxlU29ydDogc3RhYmxlU29ydFxufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/doc-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/docxtemplater.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/docxtemplater.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _excluded = [\"modules\"];\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar DocUtils = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\");\nDocUtils.traits = __webpack_require__(/*! ./traits.js */ \"(ssr)/./node_modules/docxtemplater/js/traits.js\");\nDocUtils.moduleWrapper = __webpack_require__(/*! ./module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar createScope = __webpack_require__(/*! ./scope-manager.js */ \"(ssr)/./node_modules/docxtemplater/js/scope-manager.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(ssr)/./node_modules/docxtemplater/js/lexer.js\");\nvar commonModule = __webpack_require__(/*! ./modules/common.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/common.js\");\nvar _require = __webpack_require__(/*! ./get-tags.js */ \"(ssr)/./node_modules/docxtemplater/js/get-tags.js\"),\n  _getTags = _require.getTags;\nfunction deprecatedMessage(obj, message) {\n  if (obj.hideDeprecations === true) {\n    return;\n  }\n  // eslint-disable-next-line no-console\n  console.warn(message);\n}\nfunction deprecatedMethod(obj, method) {\n  if (obj.hideDeprecations === true) {\n    return;\n  }\n  return deprecatedMessage(obj, \"Deprecated method \\\".\".concat(method, \"\\\", view upgrade guide : https://docxtemplater.com/docs/api/#upgrade-guide, stack : \").concat(new Error().stack));\n}\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"),\n  throwMultiError = _require2.throwMultiError,\n  throwResolveBeforeCompile = _require2.throwResolveBeforeCompile,\n  throwRenderInvalidTemplate = _require2.throwRenderInvalidTemplate,\n  throwRenderTwice = _require2.throwRenderTwice,\n  XTInternalError = _require2.XTInternalError,\n  XTTemplateError = _require2.XTTemplateError,\n  throwFileTypeNotIdentified = _require2.throwFileTypeNotIdentified,\n  throwFileTypeNotHandled = _require2.throwFileTypeNotHandled,\n  throwApiVersionError = _require2.throwApiVersionError;\nvar logErrors = __webpack_require__(/*! ./error-logger.js */ \"(ssr)/./node_modules/docxtemplater/js/error-logger.js\");\nvar collectContentTypes = __webpack_require__(/*! ./collect-content-types.js */ \"(ssr)/./node_modules/docxtemplater/js/collect-content-types.js\");\nvar getDefaults = DocUtils.getDefaults,\n  str2xml = DocUtils.str2xml,\n  xml2str = DocUtils.xml2str,\n  moduleWrapper = DocUtils.moduleWrapper,\n  concatArrays = DocUtils.concatArrays,\n  uniq = DocUtils.uniq,\n  getDuplicates = DocUtils.getDuplicates,\n  stableSort = DocUtils.stableSort,\n  pushArray = DocUtils.pushArray;\nvar ctXML = \"[Content_Types].xml\";\nvar relsFile = \"_rels/.rels\";\nvar currentModuleApiVersion = [3, 44, 0];\nfunction dropUnsupportedFileTypesModules(doc) {\n  doc.modules = doc.modules.filter(function (module) {\n    if (!module.supportedFileTypes) {\n      return true;\n    }\n    if (!Array.isArray(module.supportedFileTypes)) {\n      throw new Error(\"The supportedFileTypes field of the module must be an array\");\n    }\n    var isSupportedModule = module.supportedFileTypes.includes(doc.fileType);\n    if (!isSupportedModule) {\n      module.on(\"detached\");\n    }\n    return isSupportedModule;\n  });\n}\nfunction verifyErrors(doc) {\n  var compiled = doc.compiled;\n  doc.errors = concatArrays(Object.keys(compiled).map(function (name) {\n    return compiled[name].allErrors;\n  }));\n  if (doc.errors.length !== 0) {\n    if (doc.options.errorLogging) {\n      logErrors(doc.errors, doc.options.errorLogging);\n    }\n    throwMultiError(doc.errors);\n  }\n}\nvar Docxtemplater = /*#__PURE__*/function () {\n  function Docxtemplater(zip) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$modules = _ref.modules,\n      modules = _ref$modules === void 0 ? [] : _ref$modules,\n      options = _objectWithoutProperties(_ref, _excluded);\n    _classCallCheck(this, Docxtemplater);\n    this.targets = [];\n    this.rendered = false;\n    this.scopeManagers = {};\n    this.compiled = {};\n    this.modules = [commonModule()];\n    this.xmlDocuments = {};\n    if (arguments.length === 0) {\n      deprecatedMessage(this, \"Deprecated docxtemplater constructor with no arguments, view upgrade guide : https://docxtemplater.com/docs/api/#upgrade-guide, stack : \".concat(new Error().stack));\n      this.hideDeprecations = true;\n      this.setOptions(options);\n    } else {\n      this.hideDeprecations = true;\n      this.setOptions(options);\n      if (!zip || !zip.files || typeof zip.file !== \"function\") {\n        throw new Error(\"The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)\");\n      }\n      if (!Array.isArray(modules)) {\n        throw new Error(\"The modules argument of docxtemplater's constructor must be an array\");\n      }\n      for (var _i2 = 0; _i2 < modules.length; _i2++) {\n        var _module = modules[_i2];\n        this.attachModule(_module);\n      }\n      this.loadZip(zip);\n      this.compile();\n      this.v4Constructor = true;\n    }\n    this.hideDeprecations = false;\n  }\n  return _createClass(Docxtemplater, [{\n    key: \"verifyApiVersion\",\n    value: function verifyApiVersion(neededVersion) {\n      neededVersion = neededVersion.split(\".\").map(function (i) {\n        return parseInt(i, 10);\n      });\n      if (neededVersion.length !== 3) {\n        throwApiVersionError(\"neededVersion is not a valid version\", {\n          neededVersion: neededVersion,\n          explanation: \"the neededVersion must be an array of length 3\"\n        });\n      }\n      if (neededVersion[0] !== currentModuleApiVersion[0]) {\n        throwApiVersionError(\"The major api version do not match, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      if (neededVersion[1] > currentModuleApiVersion[1]) {\n        throwApiVersionError(\"The minor api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      if (neededVersion[1] === currentModuleApiVersion[1] && neededVersion[2] > currentModuleApiVersion[2]) {\n        throwApiVersionError(\"The patch api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      return true;\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      for (var _i4 = 0, _this$modules2 = this.modules; _i4 < _this$modules2.length; _i4++) {\n        var _module2 = _this$modules2[_i4];\n        _module2.set(obj);\n      }\n    }\n  }, {\n    key: \"sendEvent\",\n    value: function sendEvent(eventName) {\n      for (var _i6 = 0, _this$modules4 = this.modules; _i6 < _this$modules4.length; _i6++) {\n        var _module3 = _this$modules4[_i6];\n        _module3.on(eventName);\n      }\n    }\n  }, {\n    key: \"attachModule\",\n    value: function attachModule(module) {\n      if (this.v4Constructor) {\n        throw new XTInternalError(\"attachModule() should not be called manually when using the v4 constructor\");\n      }\n      deprecatedMethod(this, \"attachModule\");\n      var moduleType = _typeof(module);\n      if (moduleType === \"function\") {\n        throw new XTInternalError(\"Cannot attach a class/function as a module. Most probably you forgot to instantiate the module by using `new` on the module.\");\n      }\n      if (!module || moduleType !== \"object\") {\n        throw new XTInternalError(\"Cannot attachModule with a falsy value\");\n      }\n      if (module.requiredAPIVersion) {\n        this.verifyApiVersion(module.requiredAPIVersion);\n      }\n      if (module.attached === true) {\n        if (typeof module.clone === \"function\") {\n          module = module.clone();\n        } else {\n          throw new Error(\"Cannot attach a module that was already attached : \\\"\".concat(module.name, \"\\\". The most likely cause is that you are instantiating the module at the root level, and using it for multiple instances of Docxtemplater\"));\n        }\n      }\n      module.attached = true;\n      var wrappedModule = moduleWrapper(module);\n      this.modules.push(wrappedModule);\n      wrappedModule.on(\"attached\");\n      if (this.fileType) {\n        dropUnsupportedFileTypesModules(this);\n      }\n      return this;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var _this$delimiters, _this$delimiters2;\n      if (this.v4Constructor) {\n        throw new Error(\"setOptions() should not be called manually when using the v4 constructor\");\n      }\n      deprecatedMethod(this, \"setOptions\");\n      if (!options) {\n        throw new Error(\"setOptions should be called with an object as first parameter\");\n      }\n      this.options = {};\n      var defaults = getDefaults();\n      for (var key in defaults) {\n        var defaultValue = defaults[key];\n        this.options[key] = options[key] != null ? options[key] : this[key] || defaultValue;\n        this[key] = this.options[key];\n      }\n      (_this$delimiters = this.delimiters).start && (_this$delimiters.start = DocUtils.utf8ToWord(this.delimiters.start));\n      (_this$delimiters2 = this.delimiters).end && (_this$delimiters2.end = DocUtils.utf8ToWord(this.delimiters.end));\n      return this;\n    }\n  }, {\n    key: \"loadZip\",\n    value: function loadZip(zip) {\n      if (this.v4Constructor) {\n        throw new Error(\"loadZip() should not be called manually when using the v4 constructor\");\n      }\n      deprecatedMethod(this, \"loadZip\");\n      if (zip.loadAsync) {\n        throw new XTInternalError(\"Docxtemplater doesn't handle JSZip version >=3, please use pizzip\");\n      }\n      this.zip = zip;\n      this.updateFileTypeConfig();\n      this.modules = concatArrays([this.fileTypeConfig.baseModules.map(function (moduleFunction) {\n        return moduleFunction();\n      }), this.modules]);\n      for (var _i8 = 0, _this$modules6 = this.modules; _i8 < _this$modules6.length; _i8++) {\n        var _module4 = _this$modules6[_i8];\n        _module4.zip = this.zip;\n        _module4.docxtemplater = this;\n      }\n      dropUnsupportedFileTypesModules(this);\n      return this;\n    }\n  }, {\n    key: \"precompileFile\",\n    value: function precompileFile(fileName) {\n      var currentFile = this.createTemplateClass(fileName);\n      currentFile.preparse();\n      this.compiled[fileName] = currentFile;\n    }\n  }, {\n    key: \"compileFile\",\n    value: function compileFile(fileName) {\n      this.compiled[fileName].parse();\n    }\n  }, {\n    key: \"getScopeManager\",\n    value: function getScopeManager(to, currentFile, tags) {\n      var _this$scopeManagers;\n      (_this$scopeManagers = this.scopeManagers)[to] || (_this$scopeManagers[to] = createScope({\n        tags: tags,\n        parser: this.parser,\n        cachedParsers: currentFile.cachedParsers\n      }));\n      return this.scopeManagers[to];\n    }\n  }, {\n    key: \"resolveData\",\n    value: function resolveData(data) {\n      var _this = this;\n      deprecatedMethod(this, \"resolveData\");\n      var errors = [];\n      if (!Object.keys(this.compiled).length) {\n        throwResolveBeforeCompile();\n      }\n      return Promise.resolve(data).then(function (data) {\n        _this.data = data;\n        _this.setModules({\n          data: _this.data,\n          Lexer: Lexer\n        });\n        _this.mapper = _this.modules.reduce(function (value, module) {\n          return module.getRenderedMap(value);\n        }, {});\n        return Promise.all(Object.keys(_this.mapper).map(function (to) {\n          var _this$mapper$to = _this.mapper[to],\n            from = _this$mapper$to.from,\n            data = _this$mapper$to.data;\n          return Promise.resolve(data).then(function (data) {\n            var currentFile = _this.compiled[from];\n            currentFile.filePath = to;\n            currentFile.scopeManager = _this.getScopeManager(to, currentFile, data);\n            return currentFile.resolveTags(data).then(function (result) {\n              currentFile.scopeManager.finishedResolving = true;\n              return result;\n            }, function (errs) {\n              Array.prototype.push.apply(errors, errs);\n            });\n          });\n        })).then(function (resolved) {\n          if (errors.length !== 0) {\n            if (_this.options.errorLogging) {\n              logErrors(errors, _this.options.errorLogging);\n            }\n            throwMultiError(errors);\n          }\n          return concatArrays(resolved);\n        });\n      });\n    }\n  }, {\n    key: \"reorderModules\",\n    value: function reorderModules() {\n      /**\n       * Modules will be sorted according to priority.\n       *\n       * Input example:\n       * [\n       *   { priority: 1, name: \"FooMod\" },\n       *   { priority: -1, name: \"XMod\" },\n       *   { priority: 4, name: \"OtherMod\" }\n       * ]\n       *\n       * Output example (sorted by priority in descending order):\n       * [\n       *   { priority: 4, name: \"OtherMod\" },\n       *   { priority: 1, name: \"FooMod\" },\n       *   { priority: -1, name: \"XMod\" }\n       * ]\n       */\n      this.modules = stableSort(this.modules, function (m1, m2) {\n        return (m2.priority || 0) - (m1.priority || 0);\n      });\n    }\n  }, {\n    key: \"throwIfDuplicateModules\",\n    value: function throwIfDuplicateModules() {\n      var duplicates = getDuplicates(this.modules.map(function (_ref2) {\n        var name = _ref2.name;\n        return name;\n      }));\n      if (duplicates.length > 0) {\n        throw new XTInternalError(\"Detected duplicate module \\\"\".concat(duplicates[0], \"\\\"\"));\n      }\n    }\n  }, {\n    key: \"compile\",\n    value: function compile() {\n      var _this2 = this;\n      deprecatedMethod(this, \"compile\");\n      this.updateFileTypeConfig();\n      this.throwIfDuplicateModules();\n      this.reorderModules();\n      if (Object.keys(this.compiled).length) {\n        return this;\n      }\n      this.options = this.modules.reduce(function (options, module) {\n        return module.optionsTransformer(options, _this2);\n      }, this.options);\n      this.options.xmlFileNames = uniq(this.options.xmlFileNames);\n      for (var _i10 = 0, _this$options$xmlFile2 = this.options.xmlFileNames; _i10 < _this$options$xmlFile2.length; _i10++) {\n        var fileName = _this$options$xmlFile2[_i10];\n        var content = this.zip.files[fileName].asText();\n        this.xmlDocuments[fileName] = str2xml(content);\n      }\n      this.setModules({\n        zip: this.zip,\n        xmlDocuments: this.xmlDocuments\n      });\n      this.getTemplatedFiles();\n      /*\n       * Loop inside all templatedFiles (ie xml files with content).\n       * Sometimes they don't exist (footer.xml for example)\n       */\n      for (var _i12 = 0, _this$templatedFiles2 = this.templatedFiles; _i12 < _this$templatedFiles2.length; _i12++) {\n        var _fileName = _this$templatedFiles2[_i12];\n        if (this.zip.files[_fileName] != null) {\n          this.precompileFile(_fileName);\n        }\n      }\n      for (var _i14 = 0, _this$templatedFiles4 = this.templatedFiles; _i14 < _this$templatedFiles4.length; _i14++) {\n        var _fileName2 = _this$templatedFiles4[_i14];\n        if (this.zip.files[_fileName2] != null) {\n          this.compileFile(_fileName2);\n        }\n      }\n      this.setModules({\n        compiled: this.compiled\n      });\n      verifyErrors(this);\n      return this;\n    }\n  }, {\n    key: \"getRelsTypes\",\n    value: function getRelsTypes() {\n      var rootRels = this.zip.files[relsFile];\n      var rootRelsXml = rootRels ? str2xml(rootRels.asText()) : null;\n      var rootRelationships = rootRelsXml ? rootRelsXml.getElementsByTagName(\"Relationship\") : [];\n      var relsTypes = {};\n      for (var _i16 = 0; _i16 < rootRelationships.length; _i16++) {\n        var relation = rootRelationships[_i16];\n        relsTypes[relation.getAttribute(\"Target\")] = relation.getAttribute(\"Type\");\n      }\n      return relsTypes;\n    }\n  }, {\n    key: \"getContentTypes\",\n    value: function getContentTypes() {\n      var contentTypes = this.zip.files[ctXML];\n      var contentTypeXml = contentTypes ? str2xml(contentTypes.asText()) : null;\n      var overrides = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Override\") : null;\n      var defaults = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Default\") : null;\n      return {\n        overrides: overrides,\n        defaults: defaults,\n        contentTypes: contentTypes,\n        contentTypeXml: contentTypeXml\n      };\n    }\n  }, {\n    key: \"updateFileTypeConfig\",\n    value: function updateFileTypeConfig() {\n      var fileType;\n      if (this.zip.files.mimetype) {\n        fileType = \"odt\";\n      }\n      this.relsTypes = this.getRelsTypes();\n      var _this$getContentTypes = this.getContentTypes(),\n        overrides = _this$getContentTypes.overrides,\n        defaults = _this$getContentTypes.defaults,\n        contentTypes = _this$getContentTypes.contentTypes,\n        contentTypeXml = _this$getContentTypes.contentTypeXml;\n      if (contentTypeXml) {\n        this.filesContentTypes = collectContentTypes(overrides, defaults, this.zip);\n        this.invertedContentTypes = DocUtils.invertMap(this.filesContentTypes);\n        this.setModules({\n          contentTypes: this.contentTypes,\n          invertedContentTypes: this.invertedContentTypes\n        });\n      }\n      for (var _i18 = 0, _this$modules8 = this.modules; _i18 < _this$modules8.length; _i18++) {\n        var _module5 = _this$modules8[_i18];\n        fileType = _module5.getFileType({\n          zip: this.zip,\n          contentTypes: contentTypes,\n          contentTypeXml: contentTypeXml,\n          overrides: overrides,\n          defaults: defaults,\n          doc: this\n        }) || fileType;\n      }\n      if (fileType === \"odt\") {\n        throwFileTypeNotHandled(fileType);\n      }\n      if (!fileType) {\n        throwFileTypeNotIdentified(this.zip);\n      }\n      for (var _i20 = 0, _this$modules10 = this.modules; _i20 < _this$modules10.length; _i20++) {\n        var _module6 = _this$modules10[_i20];\n        for (var _i22 = 0, _ref4 = _module6.xmlContentTypes || []; _i22 < _ref4.length; _i22++) {\n          var contentType = _ref4[_i22];\n          pushArray(this.options.xmlFileNames, this.invertedContentTypes[contentType] || []);\n        }\n      }\n      this.fileType = fileType;\n      dropUnsupportedFileTypesModules(this);\n      this.fileTypeConfig = this.options.fileTypeConfig || this.fileTypeConfig;\n      if (!this.fileTypeConfig) {\n        if (Docxtemplater.FileTypeConfig[this.fileType]) {\n          this.fileTypeConfig = Docxtemplater.FileTypeConfig[this.fileType]();\n        } else {\n          /*\n           * Error case handled since v3.60.2\n           * Throw specific error when trying to template xlsx file without xlsxmodule\n           */\n          var message = \"Filetype \\\"\".concat(this.fileType, \"\\\" is not supported\");\n          var id = \"filetype_not_supported\";\n          if (this.fileType === \"xlsx\") {\n            message = \"Filetype \\\"\".concat(this.fileType, \"\\\" is supported only with the paid XlsxModule\");\n            id = \"xlsx_filetype_needs_xlsx_module\";\n          }\n          var err = new XTTemplateError(message);\n          err.properties = {\n            id: id,\n            explanation: message\n          };\n          throw err;\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"renderAsync\",\n    value: function renderAsync(data) {\n      var _this3 = this;\n      this.hideDeprecations = true;\n      var promise = this.resolveData(data);\n      this.hideDeprecations = false;\n      return promise.then(function () {\n        return _this3.render();\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(data) {\n      if (this.rendered) {\n        throwRenderTwice();\n      }\n      this.rendered = true;\n      if (Object.keys(this.compiled).length === 0) {\n        this.compile();\n      }\n      if (this.errors.length > 0) {\n        throwRenderInvalidTemplate();\n      }\n      if (arguments.length > 0) {\n        this.data = data;\n      }\n      this.setModules({\n        data: this.data,\n        Lexer: Lexer\n      });\n      this.mapper || (this.mapper = this.modules.reduce(function (value, module) {\n        return module.getRenderedMap(value);\n      }, {}));\n      var output = [];\n      for (var to in this.mapper) {\n        var _this$mapper$to2 = this.mapper[to],\n          from = _this$mapper$to2.from,\n          _data = _this$mapper$to2.data;\n        var currentFile = this.compiled[from];\n        currentFile.scopeManager = this.getScopeManager(to, currentFile, _data);\n        currentFile.render(to);\n        output.push([to, currentFile.content, currentFile]);\n        delete currentFile.content;\n      }\n      for (var _i24 = 0; _i24 < output.length; _i24++) {\n        var outputPart = output[_i24];\n        var _outputPart = _slicedToArray(outputPart, 3),\n          content = _outputPart[1],\n          _currentFile = _outputPart[2];\n        for (var _i26 = 0, _this$modules12 = this.modules; _i26 < _this$modules12.length; _i26++) {\n          var _module7 = _this$modules12[_i26];\n          if (_module7.preZip) {\n            var result = _module7.preZip(content, _currentFile);\n            if (typeof result === \"string\") {\n              outputPart[1] = result;\n            }\n          }\n        }\n      }\n      for (var _i28 = 0; _i28 < output.length; _i28++) {\n        var _output$_i = _slicedToArray(output[_i28], 2),\n          _to = _output$_i[0],\n          _content = _output$_i[1];\n        this.zip.file(_to, _content, {\n          createFolders: true\n        });\n      }\n      verifyErrors(this);\n      this.sendEvent(\"syncing-zip\");\n      this.syncZip();\n      // The synced-zip event is used in the subtemplate module for example\n      this.sendEvent(\"synced-zip\");\n      return this;\n    }\n  }, {\n    key: \"syncZip\",\n    value: function syncZip() {\n      for (var fileName in this.xmlDocuments) {\n        this.zip.remove(fileName);\n        var content = xml2str(this.xmlDocuments[fileName]);\n        this.zip.file(fileName, content, {\n          createFolders: true\n        });\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      deprecatedMethod(this, \"setData\");\n      this.data = data;\n      return this;\n    }\n  }, {\n    key: \"getZip\",\n    value: function getZip() {\n      return this.zip;\n    }\n  }, {\n    key: \"createTemplateClass\",\n    value: function createTemplateClass(path) {\n      var content = this.zip.files[path].asText();\n      return this.createTemplateClassFromContent(content, path);\n    }\n  }, {\n    key: \"createTemplateClassFromContent\",\n    value: function createTemplateClassFromContent(content, filePath) {\n      var xmltOptions = {\n        filePath: filePath,\n        contentType: this.filesContentTypes[filePath],\n        relsType: this.relsTypes[filePath]\n      };\n      var defaults = getDefaults();\n      var defaultKeys = pushArray(Object.keys(defaults), [\"filesContentTypes\", \"fileTypeConfig\", \"fileType\", \"modules\"]);\n      for (var _i30 = 0; _i30 < defaultKeys.length; _i30++) {\n        var key = defaultKeys[_i30];\n        xmltOptions[key] = this[key];\n      }\n      return new Docxtemplater.XmlTemplater(content, xmltOptions);\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText(path) {\n      return this.createTemplateClass(path || this.fileTypeConfig.textPath(this)).getFullText();\n    }\n  }, {\n    key: \"getTemplatedFiles\",\n    value: function getTemplatedFiles() {\n      this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);\n      pushArray(this.templatedFiles, this.targets);\n      this.templatedFiles = uniq(this.templatedFiles);\n      return this.templatedFiles;\n    }\n  }, {\n    key: \"getTags\",\n    value: function getTags() {\n      var result = {\n        headers: [],\n        footers: []\n      };\n      for (var key in this.compiled) {\n        var contentType = this.filesContentTypes[key];\n        if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\") {\n          result.document = {\n            target: key,\n            tags: _getTags(this.compiled[key].postparsed)\n          };\n        }\n        if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\") {\n          result.headers.push({\n            target: key,\n            tags: _getTags(this.compiled[key].postparsed)\n          });\n        }\n        if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\") {\n          result.footers.push({\n            target: key,\n            tags: _getTags(this.compiled[key].postparsed)\n          });\n        }\n      }\n      return result;\n    }\n  }]);\n}();\nDocxtemplater.DocUtils = DocUtils;\nDocxtemplater.Errors = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\");\nDocxtemplater.XmlTemplater = __webpack_require__(/*! ./xml-templater.js */ \"(ssr)/./node_modules/docxtemplater/js/xml-templater.js\");\nDocxtemplater.FileTypeConfig = __webpack_require__(/*! ./file-type-config.js */ \"(ssr)/./node_modules/docxtemplater/js/file-type-config.js\");\nDocxtemplater.XmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(ssr)/./node_modules/docxtemplater/js/xml-matcher.js\");\nmodule.exports = Docxtemplater;\nmodule.exports[\"default\"] = Docxtemplater;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2N4dGVtcGxhdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0EsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qiw2Q0FBNkMsU0FBUywwREFBMEQsVUFBVSxnQ0FBZ0M7QUFDMUosbUNBQW1DLCtDQUErQyw4QkFBOEIsT0FBTyxrQkFBa0I7QUFDekksdUNBQXVDLGtHQUFrRyxpQkFBaUIsd0NBQXdDLE1BQU0seUNBQXlDLDZCQUE2QixVQUFVLFlBQVksa0VBQWtFLFdBQVcsWUFBWSxpQkFBaUIsVUFBVSxNQUFNLGlGQUFpRixVQUFVLG9CQUFvQjtBQUM3Z0IsOEJBQThCO0FBQzlCLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLDBDQUEwQywwQkFBMEIsbURBQW1ELG9DQUFvQyx5Q0FBeUMsWUFBWSxjQUFjLHdDQUF3QyxxREFBcUQ7QUFDM1QsK0NBQStDLDBCQUEwQixZQUFZLHVCQUF1Qiw4QkFBOEIsbUNBQW1DLGVBQWU7QUFDNUwsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGVBQWUsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsb0VBQWE7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ3RELGtCQUFrQixtQkFBTyxDQUFDLGtGQUFvQjtBQUM5QyxZQUFZLG1CQUFPLENBQUMsa0VBQVk7QUFDaEMsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ2hELGVBQWUsbUJBQU8sQ0FBQyx3RUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQzNDLDBCQUEwQixtQkFBTyxDQUFDLGtHQUE0QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1REFBdUQsNkJBQTZCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1REFBdUQsNkJBQTZCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdURBQXVELDZCQUE2QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDLGFBQWEsNEJBQTRCO0FBQ3pDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsK0JBQStCO0FBQzVDLGFBQWEsNkJBQTZCO0FBQzFDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDZFQUE2RSxzQ0FBc0M7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxxQ0FBcUM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxxQ0FBcUM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQ0FBaUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3REFBd0QsOEJBQThCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsK0JBQStCO0FBQ3hGO0FBQ0EsbUVBQW1FLHFCQUFxQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwrQkFBK0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkJBQTJCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsb0VBQWE7QUFDNUMsNkJBQTZCLG1CQUFPLENBQUMsa0ZBQW9CO0FBQ3pELCtCQUErQixtQkFBTyxDQUFDLHdGQUF1QjtBQUM5RCwyQkFBMkIsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDckQ7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZG9jeHRlbXBsYXRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9leGNsdWRlZCA9IFtcIm1vZHVsZXNcIl07XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZSwgdCkgeyBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307IHZhciBvLCByLCBpID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgZm9yIChyID0gMDsgciA8IG4ubGVuZ3RoOyByKyspIG8gPSBuW3JdLCAtMSA9PT0gdC5pbmRleE9mKG8pICYmIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgbykgJiYgKGlbb10gPSBlW29dKTsgfSByZXR1cm4gaTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkgeyBpZiAobnVsbCA9PSByKSByZXR1cm4ge307IHZhciB0ID0ge307IGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHsgaWYgKC0xICE9PSBlLmluZGV4T2YobikpIGNvbnRpbnVlOyB0W25dID0gcltuXTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIERvY1V0aWxzID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpO1xuRG9jVXRpbHMudHJhaXRzID0gcmVxdWlyZShcIi4vdHJhaXRzLmpzXCIpO1xuRG9jVXRpbHMubW9kdWxlV3JhcHBlciA9IHJlcXVpcmUoXCIuL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIGNyZWF0ZVNjb3BlID0gcmVxdWlyZShcIi4vc2NvcGUtbWFuYWdlci5qc1wiKTtcbnZhciBMZXhlciA9IHJlcXVpcmUoXCIuL2xleGVyLmpzXCIpO1xudmFyIGNvbW1vbk1vZHVsZSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvY29tbW9uLmpzXCIpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZ2V0LXRhZ3MuanNcIiksXG4gIF9nZXRUYWdzID0gX3JlcXVpcmUuZ2V0VGFncztcbmZ1bmN0aW9uIGRlcHJlY2F0ZWRNZXNzYWdlKG9iaiwgbWVzc2FnZSkge1xuICBpZiAob2JqLmhpZGVEZXByZWNhdGlvbnMgPT09IHRydWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xufVxuZnVuY3Rpb24gZGVwcmVjYXRlZE1ldGhvZChvYmosIG1ldGhvZCkge1xuICBpZiAob2JqLmhpZGVEZXByZWNhdGlvbnMgPT09IHRydWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmV0dXJuIGRlcHJlY2F0ZWRNZXNzYWdlKG9iaiwgXCJEZXByZWNhdGVkIG1ldGhvZCBcXFwiLlwiLmNvbmNhdChtZXRob2QsIFwiXFxcIiwgdmlldyB1cGdyYWRlIGd1aWRlIDogaHR0cHM6Ly9kb2N4dGVtcGxhdGVyLmNvbS9kb2NzL2FwaS8jdXBncmFkZS1ndWlkZSwgc3RhY2sgOiBcIikuY29uY2F0KG5ldyBFcnJvcigpLnN0YWNrKSk7XG59XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICB0aHJvd011bHRpRXJyb3IgPSBfcmVxdWlyZTIudGhyb3dNdWx0aUVycm9yLFxuICB0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlID0gX3JlcXVpcmUyLnRocm93UmVzb2x2ZUJlZm9yZUNvbXBpbGUsXG4gIHRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlID0gX3JlcXVpcmUyLnRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlLFxuICB0aHJvd1JlbmRlclR3aWNlID0gX3JlcXVpcmUyLnRocm93UmVuZGVyVHdpY2UsXG4gIFhUSW50ZXJuYWxFcnJvciA9IF9yZXF1aXJlMi5YVEludGVybmFsRXJyb3IsXG4gIFhUVGVtcGxhdGVFcnJvciA9IF9yZXF1aXJlMi5YVFRlbXBsYXRlRXJyb3IsXG4gIHRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkID0gX3JlcXVpcmUyLnRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkLFxuICB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZCA9IF9yZXF1aXJlMi50aHJvd0ZpbGVUeXBlTm90SGFuZGxlZCxcbiAgdGhyb3dBcGlWZXJzaW9uRXJyb3IgPSBfcmVxdWlyZTIudGhyb3dBcGlWZXJzaW9uRXJyb3I7XG52YXIgbG9nRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3ItbG9nZ2VyLmpzXCIpO1xudmFyIGNvbGxlY3RDb250ZW50VHlwZXMgPSByZXF1aXJlKFwiLi9jb2xsZWN0LWNvbnRlbnQtdHlwZXMuanNcIik7XG52YXIgZ2V0RGVmYXVsdHMgPSBEb2NVdGlscy5nZXREZWZhdWx0cyxcbiAgc3RyMnhtbCA9IERvY1V0aWxzLnN0cjJ4bWwsXG4gIHhtbDJzdHIgPSBEb2NVdGlscy54bWwyc3RyLFxuICBtb2R1bGVXcmFwcGVyID0gRG9jVXRpbHMubW9kdWxlV3JhcHBlcixcbiAgY29uY2F0QXJyYXlzID0gRG9jVXRpbHMuY29uY2F0QXJyYXlzLFxuICB1bmlxID0gRG9jVXRpbHMudW5pcSxcbiAgZ2V0RHVwbGljYXRlcyA9IERvY1V0aWxzLmdldER1cGxpY2F0ZXMsXG4gIHN0YWJsZVNvcnQgPSBEb2NVdGlscy5zdGFibGVTb3J0LFxuICBwdXNoQXJyYXkgPSBEb2NVdGlscy5wdXNoQXJyYXk7XG52YXIgY3RYTUwgPSBcIltDb250ZW50X1R5cGVzXS54bWxcIjtcbnZhciByZWxzRmlsZSA9IFwiX3JlbHMvLnJlbHNcIjtcbnZhciBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbiA9IFszLCA0NCwgMF07XG5mdW5jdGlvbiBkcm9wVW5zdXBwb3J0ZWRGaWxlVHlwZXNNb2R1bGVzKGRvYykge1xuICBkb2MubW9kdWxlcyA9IGRvYy5tb2R1bGVzLmZpbHRlcihmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgaWYgKCFtb2R1bGUuc3VwcG9ydGVkRmlsZVR5cGVzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZHVsZS5zdXBwb3J0ZWRGaWxlVHlwZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3VwcG9ydGVkRmlsZVR5cGVzIGZpZWxkIG9mIHRoZSBtb2R1bGUgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgICB9XG4gICAgdmFyIGlzU3VwcG9ydGVkTW9kdWxlID0gbW9kdWxlLnN1cHBvcnRlZEZpbGVUeXBlcy5pbmNsdWRlcyhkb2MuZmlsZVR5cGUpO1xuICAgIGlmICghaXNTdXBwb3J0ZWRNb2R1bGUpIHtcbiAgICAgIG1vZHVsZS5vbihcImRldGFjaGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaXNTdXBwb3J0ZWRNb2R1bGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gdmVyaWZ5RXJyb3JzKGRvYykge1xuICB2YXIgY29tcGlsZWQgPSBkb2MuY29tcGlsZWQ7XG4gIGRvYy5lcnJvcnMgPSBjb25jYXRBcnJheXMoT2JqZWN0LmtleXMoY29tcGlsZWQpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBjb21waWxlZFtuYW1lXS5hbGxFcnJvcnM7XG4gIH0pKTtcbiAgaWYgKGRvYy5lcnJvcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgaWYgKGRvYy5vcHRpb25zLmVycm9yTG9nZ2luZykge1xuICAgICAgbG9nRXJyb3JzKGRvYy5lcnJvcnMsIGRvYy5vcHRpb25zLmVycm9yTG9nZ2luZyk7XG4gICAgfVxuICAgIHRocm93TXVsdGlFcnJvcihkb2MuZXJyb3JzKTtcbiAgfVxufVxudmFyIERvY3h0ZW1wbGF0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEb2N4dGVtcGxhdGVyKHppcCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYkbW9kdWxlcyA9IF9yZWYubW9kdWxlcyxcbiAgICAgIG1vZHVsZXMgPSBfcmVmJG1vZHVsZXMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRtb2R1bGVzLFxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb2N4dGVtcGxhdGVyKTtcbiAgICB0aGlzLnRhcmdldHMgPSBbXTtcbiAgICB0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5zY29wZU1hbmFnZXJzID0ge307XG4gICAgdGhpcy5jb21waWxlZCA9IHt9O1xuICAgIHRoaXMubW9kdWxlcyA9IFtjb21tb25Nb2R1bGUoKV07XG4gICAgdGhpcy54bWxEb2N1bWVudHMgPSB7fTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVwcmVjYXRlZE1lc3NhZ2UodGhpcywgXCJEZXByZWNhdGVkIGRvY3h0ZW1wbGF0ZXIgY29uc3RydWN0b3Igd2l0aCBubyBhcmd1bWVudHMsIHZpZXcgdXBncmFkZSBndWlkZSA6IGh0dHBzOi8vZG9jeHRlbXBsYXRlci5jb20vZG9jcy9hcGkvI3VwZ3JhZGUtZ3VpZGUsIHN0YWNrIDogXCIuY29uY2F0KG5ldyBFcnJvcigpLnN0YWNrKSk7XG4gICAgICB0aGlzLmhpZGVEZXByZWNhdGlvbnMgPSB0cnVlO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhpZGVEZXByZWNhdGlvbnMgPSB0cnVlO1xuICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgaWYgKCF6aXAgfHwgIXppcC5maWxlcyB8fCB0eXBlb2YgemlwLmZpbGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgb2YgZG9jeHRlbXBsYXRlcidzIGNvbnN0cnVjdG9yIG11c3QgYmUgYSB2YWxpZCB6aXAgZmlsZSAoanN6aXAgdjIgb3IgcGl6emlwIHYzKVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbW9kdWxlcyBhcmd1bWVudCBvZiBkb2N4dGVtcGxhdGVyJ3MgY29uc3RydWN0b3IgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG1vZHVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgX21vZHVsZSA9IG1vZHVsZXNbX2kyXTtcbiAgICAgICAgdGhpcy5hdHRhY2hNb2R1bGUoX21vZHVsZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRaaXAoemlwKTtcbiAgICAgIHRoaXMuY29tcGlsZSgpO1xuICAgICAgdGhpcy52NENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhEb2N4dGVtcGxhdGVyLCBbe1xuICAgIGtleTogXCJ2ZXJpZnlBcGlWZXJzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeUFwaVZlcnNpb24obmVlZGVkVmVyc2lvbikge1xuICAgICAgbmVlZGVkVmVyc2lvbiA9IG5lZWRlZFZlcnNpb24uc3BsaXQoXCIuXCIpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaSwgMTApO1xuICAgICAgfSk7XG4gICAgICBpZiAobmVlZGVkVmVyc2lvbi5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3dBcGlWZXJzaW9uRXJyb3IoXCJuZWVkZWRWZXJzaW9uIGlzIG5vdCBhIHZhbGlkIHZlcnNpb25cIiwge1xuICAgICAgICAgIG5lZWRlZFZlcnNpb246IG5lZWRlZFZlcnNpb24sXG4gICAgICAgICAgZXhwbGFuYXRpb246IFwidGhlIG5lZWRlZFZlcnNpb24gbXVzdCBiZSBhbiBhcnJheSBvZiBsZW5ndGggM1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRlZFZlcnNpb25bMF0gIT09IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uWzBdKSB7XG4gICAgICAgIHRocm93QXBpVmVyc2lvbkVycm9yKFwiVGhlIG1ham9yIGFwaSB2ZXJzaW9uIGRvIG5vdCBtYXRjaCwgeW91IHByb2JhYmx5IGhhdmUgdG8gdXBkYXRlIGRvY3h0ZW1wbGF0ZXIgd2l0aCBucG0gaW5zdGFsbCAtLXNhdmUgZG9jeHRlbXBsYXRlclwiLCB7XG4gICAgICAgICAgbmVlZGVkVmVyc2lvbjogbmVlZGVkVmVyc2lvbixcbiAgICAgICAgICBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbjogY3VycmVudE1vZHVsZUFwaVZlcnNpb24sXG4gICAgICAgICAgZXhwbGFuYXRpb246IFwibW9kdWxlQVBJVmVyc2lvbk1pc21hdGNoIDogbmVlZGVkPVwiLmNvbmNhdChuZWVkZWRWZXJzaW9uLmpvaW4oXCIuXCIpLCBcIiwgY3VycmVudD1cIikuY29uY2F0KGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLmpvaW4oXCIuXCIpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkZWRWZXJzaW9uWzFdID4gY3VycmVudE1vZHVsZUFwaVZlcnNpb25bMV0pIHtcbiAgICAgICAgdGhyb3dBcGlWZXJzaW9uRXJyb3IoXCJUaGUgbWlub3IgYXBpIHZlcnNpb24gaXMgbm90IHVwdG9kYXRlLCB5b3UgcHJvYmFibHkgaGF2ZSB0byB1cGRhdGUgZG9jeHRlbXBsYXRlciB3aXRoIG5wbSBpbnN0YWxsIC0tc2F2ZSBkb2N4dGVtcGxhdGVyXCIsIHtcbiAgICAgICAgICBuZWVkZWRWZXJzaW9uOiBuZWVkZWRWZXJzaW9uLFxuICAgICAgICAgIGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uOiBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbixcbiAgICAgICAgICBleHBsYW5hdGlvbjogXCJtb2R1bGVBUElWZXJzaW9uTWlzbWF0Y2ggOiBuZWVkZWQ9XCIuY29uY2F0KG5lZWRlZFZlcnNpb24uam9pbihcIi5cIiksIFwiLCBjdXJyZW50PVwiKS5jb25jYXQoY3VycmVudE1vZHVsZUFwaVZlcnNpb24uam9pbihcIi5cIikpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRlZFZlcnNpb25bMV0gPT09IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uWzFdICYmIG5lZWRlZFZlcnNpb25bMl0gPiBjdXJyZW50TW9kdWxlQXBpVmVyc2lvblsyXSkge1xuICAgICAgICB0aHJvd0FwaVZlcnNpb25FcnJvcihcIlRoZSBwYXRjaCBhcGkgdmVyc2lvbiBpcyBub3QgdXB0b2RhdGUsIHlvdSBwcm9iYWJseSBoYXZlIHRvIHVwZGF0ZSBkb2N4dGVtcGxhdGVyIHdpdGggbnBtIGluc3RhbGwgLS1zYXZlIGRvY3h0ZW1wbGF0ZXJcIiwge1xuICAgICAgICAgIG5lZWRlZFZlcnNpb246IG5lZWRlZFZlcnNpb24sXG4gICAgICAgICAgY3VycmVudE1vZHVsZUFwaVZlcnNpb246IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBcIm1vZHVsZUFQSVZlcnNpb25NaXNtYXRjaCA6IG5lZWRlZD1cIi5jb25jYXQobmVlZGVkVmVyc2lvbi5qb2luKFwiLlwiKSwgXCIsIGN1cnJlbnQ9XCIpLmNvbmNhdChjdXJyZW50TW9kdWxlQXBpVmVyc2lvbi5qb2luKFwiLlwiKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TW9kdWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNb2R1bGVzKG9iaikge1xuICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX3RoaXMkbW9kdWxlczIgPSB0aGlzLm1vZHVsZXM7IF9pNCA8IF90aGlzJG1vZHVsZXMyLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGUyID0gX3RoaXMkbW9kdWxlczJbX2k0XTtcbiAgICAgICAgX21vZHVsZTIuc2V0KG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbmRFdmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kRXZlbnQoZXZlbnROYW1lKSB7XG4gICAgICBmb3IgKHZhciBfaTYgPSAwLCBfdGhpcyRtb2R1bGVzNCA9IHRoaXMubW9kdWxlczsgX2k2IDwgX3RoaXMkbW9kdWxlczQubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICB2YXIgX21vZHVsZTMgPSBfdGhpcyRtb2R1bGVzNFtfaTZdO1xuICAgICAgICBfbW9kdWxlMy5vbihldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhdHRhY2hNb2R1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXR0YWNoTW9kdWxlKG1vZHVsZSkge1xuICAgICAgaWYgKHRoaXMudjRDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgWFRJbnRlcm5hbEVycm9yKFwiYXR0YWNoTW9kdWxlKCkgc2hvdWxkIG5vdCBiZSBjYWxsZWQgbWFudWFsbHkgd2hlbiB1c2luZyB0aGUgdjQgY29uc3RydWN0b3JcIik7XG4gICAgICB9XG4gICAgICBkZXByZWNhdGVkTWV0aG9kKHRoaXMsIFwiYXR0YWNoTW9kdWxlXCIpO1xuICAgICAgdmFyIG1vZHVsZVR5cGUgPSBfdHlwZW9mKG1vZHVsZSk7XG4gICAgICBpZiAobW9kdWxlVHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBYVEludGVybmFsRXJyb3IoXCJDYW5ub3QgYXR0YWNoIGEgY2xhc3MvZnVuY3Rpb24gYXMgYSBtb2R1bGUuIE1vc3QgcHJvYmFibHkgeW91IGZvcmdvdCB0byBpbnN0YW50aWF0ZSB0aGUgbW9kdWxlIGJ5IHVzaW5nIGBuZXdgIG9uIHRoZSBtb2R1bGUuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFtb2R1bGUgfHwgbW9kdWxlVHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgWFRJbnRlcm5hbEVycm9yKFwiQ2Fubm90IGF0dGFjaE1vZHVsZSB3aXRoIGEgZmFsc3kgdmFsdWVcIik7XG4gICAgICB9XG4gICAgICBpZiAobW9kdWxlLnJlcXVpcmVkQVBJVmVyc2lvbikge1xuICAgICAgICB0aGlzLnZlcmlmeUFwaVZlcnNpb24obW9kdWxlLnJlcXVpcmVkQVBJVmVyc2lvbik7XG4gICAgICB9XG4gICAgICBpZiAobW9kdWxlLmF0dGFjaGVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kdWxlLmNsb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBtb2R1bGUgPSBtb2R1bGUuY2xvbmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXR0YWNoIGEgbW9kdWxlIHRoYXQgd2FzIGFscmVhZHkgYXR0YWNoZWQgOiBcXFwiXCIuY29uY2F0KG1vZHVsZS5uYW1lLCBcIlxcXCIuIFRoZSBtb3N0IGxpa2VseSBjYXVzZSBpcyB0aGF0IHlvdSBhcmUgaW5zdGFudGlhdGluZyB0aGUgbW9kdWxlIGF0IHRoZSByb290IGxldmVsLCBhbmQgdXNpbmcgaXQgZm9yIG11bHRpcGxlIGluc3RhbmNlcyBvZiBEb2N4dGVtcGxhdGVyXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbW9kdWxlLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHZhciB3cmFwcGVkTW9kdWxlID0gbW9kdWxlV3JhcHBlcihtb2R1bGUpO1xuICAgICAgdGhpcy5tb2R1bGVzLnB1c2god3JhcHBlZE1vZHVsZSk7XG4gICAgICB3cmFwcGVkTW9kdWxlLm9uKFwiYXR0YWNoZWRcIik7XG4gICAgICBpZiAodGhpcy5maWxlVHlwZSkge1xuICAgICAgICBkcm9wVW5zdXBwb3J0ZWRGaWxlVHlwZXNNb2R1bGVzKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMkZGVsaW1pdGVycywgX3RoaXMkZGVsaW1pdGVyczI7XG4gICAgICBpZiAodGhpcy52NENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldE9wdGlvbnMoKSBzaG91bGQgbm90IGJlIGNhbGxlZCBtYW51YWxseSB3aGVuIHVzaW5nIHRoZSB2NCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgIH1cbiAgICAgIGRlcHJlY2F0ZWRNZXRob2QodGhpcywgXCJzZXRPcHRpb25zXCIpO1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldE9wdGlvbnMgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGFuIG9iamVjdCBhcyBmaXJzdCBwYXJhbWV0ZXJcIik7XG4gICAgICB9XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgIHZhciBkZWZhdWx0cyA9IGdldERlZmF1bHRzKCk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldICE9IG51bGwgPyBvcHRpb25zW2tleV0gOiB0aGlzW2tleV0gfHwgZGVmYXVsdFZhbHVlO1xuICAgICAgICB0aGlzW2tleV0gPSB0aGlzLm9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICAgIChfdGhpcyRkZWxpbWl0ZXJzID0gdGhpcy5kZWxpbWl0ZXJzKS5zdGFydCAmJiAoX3RoaXMkZGVsaW1pdGVycy5zdGFydCA9IERvY1V0aWxzLnV0ZjhUb1dvcmQodGhpcy5kZWxpbWl0ZXJzLnN0YXJ0KSk7XG4gICAgICAoX3RoaXMkZGVsaW1pdGVyczIgPSB0aGlzLmRlbGltaXRlcnMpLmVuZCAmJiAoX3RoaXMkZGVsaW1pdGVyczIuZW5kID0gRG9jVXRpbHMudXRmOFRvV29yZCh0aGlzLmRlbGltaXRlcnMuZW5kKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZFppcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkWmlwKHppcCkge1xuICAgICAgaWYgKHRoaXMudjRDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2FkWmlwKCkgc2hvdWxkIG5vdCBiZSBjYWxsZWQgbWFudWFsbHkgd2hlbiB1c2luZyB0aGUgdjQgY29uc3RydWN0b3JcIik7XG4gICAgICB9XG4gICAgICBkZXByZWNhdGVkTWV0aG9kKHRoaXMsIFwibG9hZFppcFwiKTtcbiAgICAgIGlmICh6aXAubG9hZEFzeW5jKSB7XG4gICAgICAgIHRocm93IG5ldyBYVEludGVybmFsRXJyb3IoXCJEb2N4dGVtcGxhdGVyIGRvZXNuJ3QgaGFuZGxlIEpTWmlwIHZlcnNpb24gPj0zLCBwbGVhc2UgdXNlIHBpenppcFwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuemlwID0gemlwO1xuICAgICAgdGhpcy51cGRhdGVGaWxlVHlwZUNvbmZpZygpO1xuICAgICAgdGhpcy5tb2R1bGVzID0gY29uY2F0QXJyYXlzKFt0aGlzLmZpbGVUeXBlQ29uZmlnLmJhc2VNb2R1bGVzLm1hcChmdW5jdGlvbiAobW9kdWxlRnVuY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZUZ1bmN0aW9uKCk7XG4gICAgICB9KSwgdGhpcy5tb2R1bGVzXSk7XG4gICAgICBmb3IgKHZhciBfaTggPSAwLCBfdGhpcyRtb2R1bGVzNiA9IHRoaXMubW9kdWxlczsgX2k4IDwgX3RoaXMkbW9kdWxlczYubGVuZ3RoOyBfaTgrKykge1xuICAgICAgICB2YXIgX21vZHVsZTQgPSBfdGhpcyRtb2R1bGVzNltfaThdO1xuICAgICAgICBfbW9kdWxlNC56aXAgPSB0aGlzLnppcDtcbiAgICAgICAgX21vZHVsZTQuZG9jeHRlbXBsYXRlciA9IHRoaXM7XG4gICAgICB9XG4gICAgICBkcm9wVW5zdXBwb3J0ZWRGaWxlVHlwZXNNb2R1bGVzKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZWNvbXBpbGVGaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZWNvbXBpbGVGaWxlKGZpbGVOYW1lKSB7XG4gICAgICB2YXIgY3VycmVudEZpbGUgPSB0aGlzLmNyZWF0ZVRlbXBsYXRlQ2xhc3MoZmlsZU5hbWUpO1xuICAgICAgY3VycmVudEZpbGUucHJlcGFyc2UoKTtcbiAgICAgIHRoaXMuY29tcGlsZWRbZmlsZU5hbWVdID0gY3VycmVudEZpbGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBpbGVGaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGVGaWxlKGZpbGVOYW1lKSB7XG4gICAgICB0aGlzLmNvbXBpbGVkW2ZpbGVOYW1lXS5wYXJzZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTY29wZU1hbmFnZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NvcGVNYW5hZ2VyKHRvLCBjdXJyZW50RmlsZSwgdGFncykge1xuICAgICAgdmFyIF90aGlzJHNjb3BlTWFuYWdlcnM7XG4gICAgICAoX3RoaXMkc2NvcGVNYW5hZ2VycyA9IHRoaXMuc2NvcGVNYW5hZ2VycylbdG9dIHx8IChfdGhpcyRzY29wZU1hbmFnZXJzW3RvXSA9IGNyZWF0ZVNjb3BlKHtcbiAgICAgICAgdGFnczogdGFncyxcbiAgICAgICAgcGFyc2VyOiB0aGlzLnBhcnNlcixcbiAgICAgICAgY2FjaGVkUGFyc2VyczogY3VycmVudEZpbGUuY2FjaGVkUGFyc2Vyc1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHRoaXMuc2NvcGVNYW5hZ2Vyc1t0b107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVEYXRhKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBkZXByZWNhdGVkTWV0aG9kKHRoaXMsIFwicmVzb2x2ZURhdGFcIik7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuY29tcGlsZWQpLmxlbmd0aCkge1xuICAgICAgICB0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIF90aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICAgIGRhdGE6IF90aGlzLmRhdGEsXG4gICAgICAgICAgTGV4ZXI6IExleGVyXG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5tYXBwZXIgPSBfdGhpcy5tb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAodmFsdWUsIG1vZHVsZSkge1xuICAgICAgICAgIHJldHVybiBtb2R1bGUuZ2V0UmVuZGVyZWRNYXAodmFsdWUpO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChPYmplY3Qua2V5cyhfdGhpcy5tYXBwZXIpLm1hcChmdW5jdGlvbiAodG8pIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWFwcGVyJHRvID0gX3RoaXMubWFwcGVyW3RvXSxcbiAgICAgICAgICAgIGZyb20gPSBfdGhpcyRtYXBwZXIkdG8uZnJvbSxcbiAgICAgICAgICAgIGRhdGEgPSBfdGhpcyRtYXBwZXIkdG8uZGF0YTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRhdGEpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RmlsZSA9IF90aGlzLmNvbXBpbGVkW2Zyb21dO1xuICAgICAgICAgICAgY3VycmVudEZpbGUuZmlsZVBhdGggPSB0bztcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLnNjb3BlTWFuYWdlciA9IF90aGlzLmdldFNjb3BlTWFuYWdlcih0bywgY3VycmVudEZpbGUsIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRGaWxlLnJlc29sdmVUYWdzKGRhdGEpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICBjdXJyZW50RmlsZS5zY29wZU1hbmFnZXIuZmluaXNoZWRSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycnMpIHtcbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZXJyb3JzLCBlcnJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZXJyb3JMb2dnaW5nKSB7XG4gICAgICAgICAgICAgIGxvZ0Vycm9ycyhlcnJvcnMsIF90aGlzLm9wdGlvbnMuZXJyb3JMb2dnaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93TXVsdGlFcnJvcihlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29uY2F0QXJyYXlzKHJlc29sdmVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVvcmRlck1vZHVsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVvcmRlck1vZHVsZXMoKSB7XG4gICAgICAvKipcbiAgICAgICAqIE1vZHVsZXMgd2lsbCBiZSBzb3J0ZWQgYWNjb3JkaW5nIHRvIHByaW9yaXR5LlxuICAgICAgICpcbiAgICAgICAqIElucHV0IGV4YW1wbGU6XG4gICAgICAgKiBbXG4gICAgICAgKiAgIHsgcHJpb3JpdHk6IDEsIG5hbWU6IFwiRm9vTW9kXCIgfSxcbiAgICAgICAqICAgeyBwcmlvcml0eTogLTEsIG5hbWU6IFwiWE1vZFwiIH0sXG4gICAgICAgKiAgIHsgcHJpb3JpdHk6IDQsIG5hbWU6IFwiT3RoZXJNb2RcIiB9XG4gICAgICAgKiBdXG4gICAgICAgKlxuICAgICAgICogT3V0cHV0IGV4YW1wbGUgKHNvcnRlZCBieSBwcmlvcml0eSBpbiBkZXNjZW5kaW5nIG9yZGVyKTpcbiAgICAgICAqIFtcbiAgICAgICAqICAgeyBwcmlvcml0eTogNCwgbmFtZTogXCJPdGhlck1vZFwiIH0sXG4gICAgICAgKiAgIHsgcHJpb3JpdHk6IDEsIG5hbWU6IFwiRm9vTW9kXCIgfSxcbiAgICAgICAqICAgeyBwcmlvcml0eTogLTEsIG5hbWU6IFwiWE1vZFwiIH1cbiAgICAgICAqIF1cbiAgICAgICAqL1xuICAgICAgdGhpcy5tb2R1bGVzID0gc3RhYmxlU29ydCh0aGlzLm1vZHVsZXMsIGZ1bmN0aW9uIChtMSwgbTIpIHtcbiAgICAgICAgcmV0dXJuIChtMi5wcmlvcml0eSB8fCAwKSAtIChtMS5wcmlvcml0eSB8fCAwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aHJvd0lmRHVwbGljYXRlTW9kdWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aHJvd0lmRHVwbGljYXRlTW9kdWxlcygpIHtcbiAgICAgIHZhciBkdXBsaWNhdGVzID0gZ2V0RHVwbGljYXRlcyh0aGlzLm1vZHVsZXMubWFwKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfSkpO1xuICAgICAgaWYgKGR1cGxpY2F0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgWFRJbnRlcm5hbEVycm9yKFwiRGV0ZWN0ZWQgZHVwbGljYXRlIG1vZHVsZSBcXFwiXCIuY29uY2F0KGR1cGxpY2F0ZXNbMF0sIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgZGVwcmVjYXRlZE1ldGhvZCh0aGlzLCBcImNvbXBpbGVcIik7XG4gICAgICB0aGlzLnVwZGF0ZUZpbGVUeXBlQ29uZmlnKCk7XG4gICAgICB0aGlzLnRocm93SWZEdXBsaWNhdGVNb2R1bGVzKCk7XG4gICAgICB0aGlzLnJlb3JkZXJNb2R1bGVzKCk7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5jb21waWxlZCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5tb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAob3B0aW9ucywgbW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUub3B0aW9uc1RyYW5zZm9ybWVyKG9wdGlvbnMsIF90aGlzMik7XG4gICAgICB9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5vcHRpb25zLnhtbEZpbGVOYW1lcyA9IHVuaXEodGhpcy5vcHRpb25zLnhtbEZpbGVOYW1lcyk7XG4gICAgICBmb3IgKHZhciBfaTEwID0gMCwgX3RoaXMkb3B0aW9ucyR4bWxGaWxlMiA9IHRoaXMub3B0aW9ucy54bWxGaWxlTmFtZXM7IF9pMTAgPCBfdGhpcyRvcHRpb25zJHhtbEZpbGUyLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgIHZhciBmaWxlTmFtZSA9IF90aGlzJG9wdGlvbnMkeG1sRmlsZTJbX2kxMF07XG4gICAgICAgIHZhciBjb250ZW50ID0gdGhpcy56aXAuZmlsZXNbZmlsZU5hbWVdLmFzVGV4dCgpO1xuICAgICAgICB0aGlzLnhtbERvY3VtZW50c1tmaWxlTmFtZV0gPSBzdHIyeG1sKGNvbnRlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgemlwOiB0aGlzLnppcCxcbiAgICAgICAgeG1sRG9jdW1lbnRzOiB0aGlzLnhtbERvY3VtZW50c1xuICAgICAgfSk7XG4gICAgICB0aGlzLmdldFRlbXBsYXRlZEZpbGVzKCk7XG4gICAgICAvKlxuICAgICAgICogTG9vcCBpbnNpZGUgYWxsIHRlbXBsYXRlZEZpbGVzIChpZSB4bWwgZmlsZXMgd2l0aCBjb250ZW50KS5cbiAgICAgICAqIFNvbWV0aW1lcyB0aGV5IGRvbid0IGV4aXN0IChmb290ZXIueG1sIGZvciBleGFtcGxlKVxuICAgICAgICovXG4gICAgICBmb3IgKHZhciBfaTEyID0gMCwgX3RoaXMkdGVtcGxhdGVkRmlsZXMyID0gdGhpcy50ZW1wbGF0ZWRGaWxlczsgX2kxMiA8IF90aGlzJHRlbXBsYXRlZEZpbGVzMi5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgICB2YXIgX2ZpbGVOYW1lID0gX3RoaXMkdGVtcGxhdGVkRmlsZXMyW19pMTJdO1xuICAgICAgICBpZiAodGhpcy56aXAuZmlsZXNbX2ZpbGVOYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5wcmVjb21waWxlRmlsZShfZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTE0ID0gMCwgX3RoaXMkdGVtcGxhdGVkRmlsZXM0ID0gdGhpcy50ZW1wbGF0ZWRGaWxlczsgX2kxNCA8IF90aGlzJHRlbXBsYXRlZEZpbGVzNC5sZW5ndGg7IF9pMTQrKykge1xuICAgICAgICB2YXIgX2ZpbGVOYW1lMiA9IF90aGlzJHRlbXBsYXRlZEZpbGVzNFtfaTE0XTtcbiAgICAgICAgaWYgKHRoaXMuemlwLmZpbGVzW19maWxlTmFtZTJdICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmNvbXBpbGVGaWxlKF9maWxlTmFtZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBjb21waWxlZDogdGhpcy5jb21waWxlZFxuICAgICAgfSk7XG4gICAgICB2ZXJpZnlFcnJvcnModGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVsc1R5cGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlbHNUeXBlcygpIHtcbiAgICAgIHZhciByb290UmVscyA9IHRoaXMuemlwLmZpbGVzW3JlbHNGaWxlXTtcbiAgICAgIHZhciByb290UmVsc1htbCA9IHJvb3RSZWxzID8gc3RyMnhtbChyb290UmVscy5hc1RleHQoKSkgOiBudWxsO1xuICAgICAgdmFyIHJvb3RSZWxhdGlvbnNoaXBzID0gcm9vdFJlbHNYbWwgPyByb290UmVsc1htbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIlJlbGF0aW9uc2hpcFwiKSA6IFtdO1xuICAgICAgdmFyIHJlbHNUeXBlcyA9IHt9O1xuICAgICAgZm9yICh2YXIgX2kxNiA9IDA7IF9pMTYgPCByb290UmVsYXRpb25zaGlwcy5sZW5ndGg7IF9pMTYrKykge1xuICAgICAgICB2YXIgcmVsYXRpb24gPSByb290UmVsYXRpb25zaGlwc1tfaTE2XTtcbiAgICAgICAgcmVsc1R5cGVzW3JlbGF0aW9uLmdldEF0dHJpYnV0ZShcIlRhcmdldFwiKV0gPSByZWxhdGlvbi5nZXRBdHRyaWJ1dGUoXCJUeXBlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbHNUeXBlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udGVudFR5cGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRlbnRUeXBlcygpIHtcbiAgICAgIHZhciBjb250ZW50VHlwZXMgPSB0aGlzLnppcC5maWxlc1tjdFhNTF07XG4gICAgICB2YXIgY29udGVudFR5cGVYbWwgPSBjb250ZW50VHlwZXMgPyBzdHIyeG1sKGNvbnRlbnRUeXBlcy5hc1RleHQoKSkgOiBudWxsO1xuICAgICAgdmFyIG92ZXJyaWRlcyA9IGNvbnRlbnRUeXBlWG1sID8gY29udGVudFR5cGVYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJPdmVycmlkZVwiKSA6IG51bGw7XG4gICAgICB2YXIgZGVmYXVsdHMgPSBjb250ZW50VHlwZVhtbCA/IGNvbnRlbnRUeXBlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiRGVmYXVsdFwiKSA6IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdmVycmlkZXM6IG92ZXJyaWRlcyxcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICAgICAgICBjb250ZW50VHlwZXM6IGNvbnRlbnRUeXBlcyxcbiAgICAgICAgY29udGVudFR5cGVYbWw6IGNvbnRlbnRUeXBlWG1sXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVGaWxlVHlwZUNvbmZpZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVGaWxlVHlwZUNvbmZpZygpIHtcbiAgICAgIHZhciBmaWxlVHlwZTtcbiAgICAgIGlmICh0aGlzLnppcC5maWxlcy5taW1ldHlwZSkge1xuICAgICAgICBmaWxlVHlwZSA9IFwib2R0XCI7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbHNUeXBlcyA9IHRoaXMuZ2V0UmVsc1R5cGVzKCk7XG4gICAgICB2YXIgX3RoaXMkZ2V0Q29udGVudFR5cGVzID0gdGhpcy5nZXRDb250ZW50VHlwZXMoKSxcbiAgICAgICAgb3ZlcnJpZGVzID0gX3RoaXMkZ2V0Q29udGVudFR5cGVzLm92ZXJyaWRlcyxcbiAgICAgICAgZGVmYXVsdHMgPSBfdGhpcyRnZXRDb250ZW50VHlwZXMuZGVmYXVsdHMsXG4gICAgICAgIGNvbnRlbnRUeXBlcyA9IF90aGlzJGdldENvbnRlbnRUeXBlcy5jb250ZW50VHlwZXMsXG4gICAgICAgIGNvbnRlbnRUeXBlWG1sID0gX3RoaXMkZ2V0Q29udGVudFR5cGVzLmNvbnRlbnRUeXBlWG1sO1xuICAgICAgaWYgKGNvbnRlbnRUeXBlWG1sKSB7XG4gICAgICAgIHRoaXMuZmlsZXNDb250ZW50VHlwZXMgPSBjb2xsZWN0Q29udGVudFR5cGVzKG92ZXJyaWRlcywgZGVmYXVsdHMsIHRoaXMuemlwKTtcbiAgICAgICAgdGhpcy5pbnZlcnRlZENvbnRlbnRUeXBlcyA9IERvY1V0aWxzLmludmVydE1hcCh0aGlzLmZpbGVzQ29udGVudFR5cGVzKTtcbiAgICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgICBjb250ZW50VHlwZXM6IHRoaXMuY29udGVudFR5cGVzLFxuICAgICAgICAgIGludmVydGVkQ29udGVudFR5cGVzOiB0aGlzLmludmVydGVkQ29udGVudFR5cGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kxOCA9IDAsIF90aGlzJG1vZHVsZXM4ID0gdGhpcy5tb2R1bGVzOyBfaTE4IDwgX3RoaXMkbW9kdWxlczgubGVuZ3RoOyBfaTE4KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU1ID0gX3RoaXMkbW9kdWxlczhbX2kxOF07XG4gICAgICAgIGZpbGVUeXBlID0gX21vZHVsZTUuZ2V0RmlsZVR5cGUoe1xuICAgICAgICAgIHppcDogdGhpcy56aXAsXG4gICAgICAgICAgY29udGVudFR5cGVzOiBjb250ZW50VHlwZXMsXG4gICAgICAgICAgY29udGVudFR5cGVYbWw6IGNvbnRlbnRUeXBlWG1sLFxuICAgICAgICAgIG92ZXJyaWRlczogb3ZlcnJpZGVzLFxuICAgICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgICBkb2M6IHRoaXNcbiAgICAgICAgfSkgfHwgZmlsZVR5cGU7XG4gICAgICB9XG4gICAgICBpZiAoZmlsZVR5cGUgPT09IFwib2R0XCIpIHtcbiAgICAgICAgdGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQoZmlsZVR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFmaWxlVHlwZSkge1xuICAgICAgICB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCh0aGlzLnppcCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTIwID0gMCwgX3RoaXMkbW9kdWxlczEwID0gdGhpcy5tb2R1bGVzOyBfaTIwIDwgX3RoaXMkbW9kdWxlczEwLmxlbmd0aDsgX2kyMCsrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlNiA9IF90aGlzJG1vZHVsZXMxMFtfaTIwXTtcbiAgICAgICAgZm9yICh2YXIgX2kyMiA9IDAsIF9yZWY0ID0gX21vZHVsZTYueG1sQ29udGVudFR5cGVzIHx8IFtdOyBfaTIyIDwgX3JlZjQubGVuZ3RoOyBfaTIyKyspIHtcbiAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSBfcmVmNFtfaTIyXTtcbiAgICAgICAgICBwdXNoQXJyYXkodGhpcy5vcHRpb25zLnhtbEZpbGVOYW1lcywgdGhpcy5pbnZlcnRlZENvbnRlbnRUeXBlc1tjb250ZW50VHlwZV0gfHwgW10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZpbGVUeXBlID0gZmlsZVR5cGU7XG4gICAgICBkcm9wVW5zdXBwb3J0ZWRGaWxlVHlwZXNNb2R1bGVzKHRoaXMpO1xuICAgICAgdGhpcy5maWxlVHlwZUNvbmZpZyA9IHRoaXMub3B0aW9ucy5maWxlVHlwZUNvbmZpZyB8fCB0aGlzLmZpbGVUeXBlQ29uZmlnO1xuICAgICAgaWYgKCF0aGlzLmZpbGVUeXBlQ29uZmlnKSB7XG4gICAgICAgIGlmIChEb2N4dGVtcGxhdGVyLkZpbGVUeXBlQ29uZmlnW3RoaXMuZmlsZVR5cGVdKSB7XG4gICAgICAgICAgdGhpcy5maWxlVHlwZUNvbmZpZyA9IERvY3h0ZW1wbGF0ZXIuRmlsZVR5cGVDb25maWdbdGhpcy5maWxlVHlwZV0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEVycm9yIGNhc2UgaGFuZGxlZCBzaW5jZSB2My42MC4yXG4gICAgICAgICAgICogVGhyb3cgc3BlY2lmaWMgZXJyb3Igd2hlbiB0cnlpbmcgdG8gdGVtcGxhdGUgeGxzeCBmaWxlIHdpdGhvdXQgeGxzeG1vZHVsZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJGaWxldHlwZSBcXFwiXCIuY29uY2F0KHRoaXMuZmlsZVR5cGUsIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgIHZhciBpZCA9IFwiZmlsZXR5cGVfbm90X3N1cHBvcnRlZFwiO1xuICAgICAgICAgIGlmICh0aGlzLmZpbGVUeXBlID09PSBcInhsc3hcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiRmlsZXR5cGUgXFxcIlwiLmNvbmNhdCh0aGlzLmZpbGVUeXBlLCBcIlxcXCIgaXMgc3VwcG9ydGVkIG9ubHkgd2l0aCB0aGUgcGFpZCBYbHN4TW9kdWxlXCIpO1xuICAgICAgICAgICAgaWQgPSBcInhsc3hfZmlsZXR5cGVfbmVlZHNfeGxzeF9tb2R1bGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBleHBsYW5hdGlvbjogbWVzc2FnZVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQXN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQXN5bmMoZGF0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB0aGlzLmhpZGVEZXByZWNhdGlvbnMgPSB0cnVlO1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnJlc29sdmVEYXRhKGRhdGEpO1xuICAgICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gZmFsc2U7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5yZW5kZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gICAgICAgIHRocm93UmVuZGVyVHdpY2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuY29tcGlsZWQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmNvbXBpbGUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgTGV4ZXI6IExleGVyXG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwcGVyIHx8ICh0aGlzLm1hcHBlciA9IHRoaXMubW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlLCBtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5nZXRSZW5kZXJlZE1hcCh2YWx1ZSk7XG4gICAgICB9LCB7fSkpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgZm9yICh2YXIgdG8gaW4gdGhpcy5tYXBwZXIpIHtcbiAgICAgICAgdmFyIF90aGlzJG1hcHBlciR0bzIgPSB0aGlzLm1hcHBlclt0b10sXG4gICAgICAgICAgZnJvbSA9IF90aGlzJG1hcHBlciR0bzIuZnJvbSxcbiAgICAgICAgICBfZGF0YSA9IF90aGlzJG1hcHBlciR0bzIuZGF0YTtcbiAgICAgICAgdmFyIGN1cnJlbnRGaWxlID0gdGhpcy5jb21waWxlZFtmcm9tXTtcbiAgICAgICAgY3VycmVudEZpbGUuc2NvcGVNYW5hZ2VyID0gdGhpcy5nZXRTY29wZU1hbmFnZXIodG8sIGN1cnJlbnRGaWxlLCBfZGF0YSk7XG4gICAgICAgIGN1cnJlbnRGaWxlLnJlbmRlcih0byk7XG4gICAgICAgIG91dHB1dC5wdXNoKFt0bywgY3VycmVudEZpbGUuY29udGVudCwgY3VycmVudEZpbGVdKTtcbiAgICAgICAgZGVsZXRlIGN1cnJlbnRGaWxlLmNvbnRlbnQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTI0ID0gMDsgX2kyNCA8IG91dHB1dC5sZW5ndGg7IF9pMjQrKykge1xuICAgICAgICB2YXIgb3V0cHV0UGFydCA9IG91dHB1dFtfaTI0XTtcbiAgICAgICAgdmFyIF9vdXRwdXRQYXJ0ID0gX3NsaWNlZFRvQXJyYXkob3V0cHV0UGFydCwgMyksXG4gICAgICAgICAgY29udGVudCA9IF9vdXRwdXRQYXJ0WzFdLFxuICAgICAgICAgIF9jdXJyZW50RmlsZSA9IF9vdXRwdXRQYXJ0WzJdO1xuICAgICAgICBmb3IgKHZhciBfaTI2ID0gMCwgX3RoaXMkbW9kdWxlczEyID0gdGhpcy5tb2R1bGVzOyBfaTI2IDwgX3RoaXMkbW9kdWxlczEyLmxlbmd0aDsgX2kyNisrKSB7XG4gICAgICAgICAgdmFyIF9tb2R1bGU3ID0gX3RoaXMkbW9kdWxlczEyW19pMjZdO1xuICAgICAgICAgIGlmIChfbW9kdWxlNy5wcmVaaXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfbW9kdWxlNy5wcmVaaXAoY29udGVudCwgX2N1cnJlbnRGaWxlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIG91dHB1dFBhcnRbMV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTI4ID0gMDsgX2kyOCA8IG91dHB1dC5sZW5ndGg7IF9pMjgrKykge1xuICAgICAgICB2YXIgX291dHB1dCRfaSA9IF9zbGljZWRUb0FycmF5KG91dHB1dFtfaTI4XSwgMiksXG4gICAgICAgICAgX3RvID0gX291dHB1dCRfaVswXSxcbiAgICAgICAgICBfY29udGVudCA9IF9vdXRwdXQkX2lbMV07XG4gICAgICAgIHRoaXMuemlwLmZpbGUoX3RvLCBfY29udGVudCwge1xuICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2ZXJpZnlFcnJvcnModGhpcyk7XG4gICAgICB0aGlzLnNlbmRFdmVudChcInN5bmNpbmctemlwXCIpO1xuICAgICAgdGhpcy5zeW5jWmlwKCk7XG4gICAgICAvLyBUaGUgc3luY2VkLXppcCBldmVudCBpcyB1c2VkIGluIHRoZSBzdWJ0ZW1wbGF0ZSBtb2R1bGUgZm9yIGV4YW1wbGVcbiAgICAgIHRoaXMuc2VuZEV2ZW50KFwic3luY2VkLXppcFwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzeW5jWmlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5bmNaaXAoKSB7XG4gICAgICBmb3IgKHZhciBmaWxlTmFtZSBpbiB0aGlzLnhtbERvY3VtZW50cykge1xuICAgICAgICB0aGlzLnppcC5yZW1vdmUoZmlsZU5hbWUpO1xuICAgICAgICB2YXIgY29udGVudCA9IHhtbDJzdHIodGhpcy54bWxEb2N1bWVudHNbZmlsZU5hbWVdKTtcbiAgICAgICAgdGhpcy56aXAuZmlsZShmaWxlTmFtZSwgY29udGVudCwge1xuICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShkYXRhKSB7XG4gICAgICBkZXByZWNhdGVkTWV0aG9kKHRoaXMsIFwic2V0RGF0YVwiKTtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0WmlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFppcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnppcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlVGVtcGxhdGVDbGFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZUNsYXNzKHBhdGgpIHtcbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy56aXAuZmlsZXNbcGF0aF0uYXNUZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZW1wbGF0ZUNsYXNzRnJvbUNvbnRlbnQoY29udGVudCwgcGF0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVRlbXBsYXRlQ2xhc3NGcm9tQ29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZUNsYXNzRnJvbUNvbnRlbnQoY29udGVudCwgZmlsZVBhdGgpIHtcbiAgICAgIHZhciB4bWx0T3B0aW9ucyA9IHtcbiAgICAgICAgZmlsZVBhdGg6IGZpbGVQYXRoLFxuICAgICAgICBjb250ZW50VHlwZTogdGhpcy5maWxlc0NvbnRlbnRUeXBlc1tmaWxlUGF0aF0sXG4gICAgICAgIHJlbHNUeXBlOiB0aGlzLnJlbHNUeXBlc1tmaWxlUGF0aF1cbiAgICAgIH07XG4gICAgICB2YXIgZGVmYXVsdHMgPSBnZXREZWZhdWx0cygpO1xuICAgICAgdmFyIGRlZmF1bHRLZXlzID0gcHVzaEFycmF5KE9iamVjdC5rZXlzKGRlZmF1bHRzKSwgW1wiZmlsZXNDb250ZW50VHlwZXNcIiwgXCJmaWxlVHlwZUNvbmZpZ1wiLCBcImZpbGVUeXBlXCIsIFwibW9kdWxlc1wiXSk7XG4gICAgICBmb3IgKHZhciBfaTMwID0gMDsgX2kzMCA8IGRlZmF1bHRLZXlzLmxlbmd0aDsgX2kzMCsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBkZWZhdWx0S2V5c1tfaTMwXTtcbiAgICAgICAgeG1sdE9wdGlvbnNba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRG9jeHRlbXBsYXRlci5YbWxUZW1wbGF0ZXIoY29udGVudCwgeG1sdE9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGdWxsVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGdWxsVGV4dChwYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZW1wbGF0ZUNsYXNzKHBhdGggfHwgdGhpcy5maWxlVHlwZUNvbmZpZy50ZXh0UGF0aCh0aGlzKSkuZ2V0RnVsbFRleHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGVtcGxhdGVkRmlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGVtcGxhdGVkRmlsZXMoKSB7XG4gICAgICB0aGlzLnRlbXBsYXRlZEZpbGVzID0gdGhpcy5maWxlVHlwZUNvbmZpZy5nZXRUZW1wbGF0ZWRGaWxlcyh0aGlzLnppcCk7XG4gICAgICBwdXNoQXJyYXkodGhpcy50ZW1wbGF0ZWRGaWxlcywgdGhpcy50YXJnZXRzKTtcbiAgICAgIHRoaXMudGVtcGxhdGVkRmlsZXMgPSB1bmlxKHRoaXMudGVtcGxhdGVkRmlsZXMpO1xuICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVkRmlsZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFncygpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGhlYWRlcnM6IFtdLFxuICAgICAgICBmb290ZXJzOiBbXVxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgIHZhciBjb250ZW50VHlwZSA9IHRoaXMuZmlsZXNDb250ZW50VHlwZXNba2V5XTtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50Lm1haW4reG1sXCIpIHtcbiAgICAgICAgICByZXN1bHQuZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IGtleSxcbiAgICAgICAgICAgIHRhZ3M6IF9nZXRUYWdzKHRoaXMuY29tcGlsZWRba2V5XS5wb3N0cGFyc2VkKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmhlYWRlcit4bWxcIikge1xuICAgICAgICAgIHJlc3VsdC5oZWFkZXJzLnB1c2goe1xuICAgICAgICAgICAgdGFyZ2V0OiBrZXksXG4gICAgICAgICAgICB0YWdzOiBfZ2V0VGFncyh0aGlzLmNvbXBpbGVkW2tleV0ucG9zdHBhcnNlZClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZm9vdGVyK3htbFwiKSB7XG4gICAgICAgICAgcmVzdWx0LmZvb3RlcnMucHVzaCh7XG4gICAgICAgICAgICB0YXJnZXQ6IGtleSxcbiAgICAgICAgICAgIHRhZ3M6IF9nZXRUYWdzKHRoaXMuY29tcGlsZWRba2V5XS5wb3N0cGFyc2VkKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xufSgpO1xuRG9jeHRlbXBsYXRlci5Eb2NVdGlscyA9IERvY1V0aWxzO1xuRG9jeHRlbXBsYXRlci5FcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5Eb2N4dGVtcGxhdGVyLlhtbFRlbXBsYXRlciA9IHJlcXVpcmUoXCIuL3htbC10ZW1wbGF0ZXIuanNcIik7XG5Eb2N4dGVtcGxhdGVyLkZpbGVUeXBlQ29uZmlnID0gcmVxdWlyZShcIi4vZmlsZS10eXBlLWNvbmZpZy5qc1wiKTtcbkRvY3h0ZW1wbGF0ZXIuWG1sTWF0Y2hlciA9IHJlcXVpcmUoXCIuL3htbC1tYXRjaGVyLmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBEb2N4dGVtcGxhdGVyO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRG9jeHRlbXBsYXRlcjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/docxtemplater.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/error-logger.js":
/*!*******************************************************!*\
  !*** ./node_modules/docxtemplater/js/error-logger.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray;\n// The error thrown here contains additional information when logged with JSON.stringify (it contains a properties object containing all suberrors).\nfunction replaceErrors(key, value) {\n  if (value instanceof Error) {\n    return pushArray(Object.getOwnPropertyNames(value), [\"stack\"]).reduce(function (error, key) {\n      error[key] = value[key];\n      if (key === \"stack\") {\n        // This is used because in Firefox, stack is not an own property\n        error[key] = value[key].toString();\n      }\n      return error;\n    }, {});\n  }\n  return value;\n}\nfunction logger(error, logging) {\n  // eslint-disable-next-line no-console\n  console.log(JSON.stringify({\n    error: error\n  }, replaceErrors, logging === \"json\" ? 2 : null));\n  if (error.properties && error.properties.errors instanceof Array) {\n    var errorMessages = error.properties.errors.map(function (error) {\n      return error.properties.explanation;\n    }).join(\"\\n\");\n    // eslint-disable-next-line no-console\n    console.log(\"errorMessages\", errorMessages);\n    /*\n     * errorMessages is a humanly readable message looking like this :\n     * 'The tag beginning with \"foobar\" is unopened'\n     */\n  }\n}\nmodule.exports = logger;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvci1sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDBFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvci1sb2dnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgcHVzaEFycmF5ID0gX3JlcXVpcmUucHVzaEFycmF5O1xuLy8gVGhlIGVycm9yIHRocm93biBoZXJlIGNvbnRhaW5zIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gd2hlbiBsb2dnZWQgd2l0aCBKU09OLnN0cmluZ2lmeSAoaXQgY29udGFpbnMgYSBwcm9wZXJ0aWVzIG9iamVjdCBjb250YWluaW5nIGFsbCBzdWJlcnJvcnMpLlxuZnVuY3Rpb24gcmVwbGFjZUVycm9ycyhrZXksIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIHB1c2hBcnJheShPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSksIFtcInN0YWNrXCJdKS5yZWR1Y2UoZnVuY3Rpb24gKGVycm9yLCBrZXkpIHtcbiAgICAgIGVycm9yW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgaWYgKGtleSA9PT0gXCJzdGFja1wiKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCBiZWNhdXNlIGluIEZpcmVmb3gsIHN0YWNrIGlzIG5vdCBhbiBvd24gcHJvcGVydHlcbiAgICAgICAgZXJyb3Jba2V5XSA9IHZhbHVlW2tleV0udG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9LCB7fSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gbG9nZ2VyKGVycm9yLCBsb2dnaW5nKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHtcbiAgICBlcnJvcjogZXJyb3JcbiAgfSwgcmVwbGFjZUVycm9ycywgbG9nZ2luZyA9PT0gXCJqc29uXCIgPyAyIDogbnVsbCkpO1xuICBpZiAoZXJyb3IucHJvcGVydGllcyAmJiBlcnJvci5wcm9wZXJ0aWVzLmVycm9ycyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIGVycm9yTWVzc2FnZXMgPSBlcnJvci5wcm9wZXJ0aWVzLmVycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3IucHJvcGVydGllcy5leHBsYW5hdGlvbjtcbiAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS5sb2coXCJlcnJvck1lc3NhZ2VzXCIsIGVycm9yTWVzc2FnZXMpO1xuICAgIC8qXG4gICAgICogZXJyb3JNZXNzYWdlcyBpcyBhIGh1bWFubHkgcmVhZGFibGUgbWVzc2FnZSBsb29raW5nIGxpa2UgdGhpcyA6XG4gICAgICogJ1RoZSB0YWcgYmVnaW5uaW5nIHdpdGggXCJmb29iYXJcIiBpcyB1bm9wZW5lZCdcbiAgICAgKi9cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBsb2dnZXI7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/error-logger.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/errors.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/errors.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/docxtemplater/js/utils.js\"),\n  last = _require.last,\n  first = _require.first;\nfunction XTError(message) {\n  this.name = \"GenericError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTError.prototype = Error.prototype;\nfunction XTTemplateError(message) {\n  this.name = \"TemplateError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTTemplateError.prototype = new XTError();\nfunction XTRenderingError(message) {\n  this.name = \"RenderingError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTRenderingError.prototype = new XTError();\nfunction XTScopeParserError(message) {\n  this.name = \"ScopeParserError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTScopeParserError.prototype = new XTError();\nfunction XTInternalError(message) {\n  this.name = \"InternalError\";\n  this.properties = {\n    explanation: \"InternalError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTInternalError.prototype = new XTError();\nfunction XTAPIVersionError(message) {\n  this.name = \"APIVersionError\";\n  this.properties = {\n    explanation: \"APIVersionError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTAPIVersionError.prototype = new XTError();\nfunction throwApiVersionError(msg, properties) {\n  var err = new XTAPIVersionError(msg);\n  err.properties = _objectSpread({\n    id: \"api_version_error\"\n  }, properties);\n  throw err;\n}\nfunction throwMultiError(errors) {\n  var err = new XTTemplateError(\"Multi error\");\n  err.properties = {\n    errors: errors,\n    id: \"multi_error\",\n    explanation: \"The template has multiple errors\"\n  };\n  throw err;\n}\nfunction getUnopenedTagException(options) {\n  var err = new XTTemplateError(\"Unopened tag\");\n  err.properties = {\n    xtag: last(options.xtag.split(\" \")),\n    id: \"unopened_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unopened\")\n  };\n  return err;\n}\nfunction getDuplicateOpenTagException(options) {\n  var err = new XTTemplateError(\"Duplicate open tag, expected one open tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_open_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate open tags\")\n  };\n  return err;\n}\nfunction getDuplicateCloseTagException(options) {\n  var err = new XTTemplateError(\"Duplicate close tag, expected one close tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_close_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag ending with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate close tags\")\n  };\n  return err;\n}\nfunction getUnclosedTagException(options) {\n  var err = new XTTemplateError(\"Unclosed tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")).substr(1),\n    id: \"unclosed_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unclosed\")\n  };\n  return err;\n}\nfunction throwXmlTagNotFound(options) {\n  var err = new XTTemplateError(\"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position));\n  var part = options.parsed[options.index];\n  err.properties = {\n    id: \"no_xml_tag_found_at_\".concat(options.position),\n    explanation: \"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position),\n    offset: part.offset,\n    part: part,\n    parsed: options.parsed,\n    index: options.index,\n    element: options.element\n  };\n  throw err;\n}\nfunction getCorruptCharactersException(_ref) {\n  var tag = _ref.tag,\n    value = _ref.value,\n    offset = _ref.offset;\n  var err = new XTRenderingError(\"There are some XML corrupt characters\");\n  err.properties = {\n    id: \"invalid_xml_characters\",\n    xtag: tag,\n    value: value,\n    offset: offset,\n    explanation: \"There are some corrupt characters for the field \".concat(tag)\n  };\n  return err;\n}\nfunction getInvalidRawXMLValueException(_ref2) {\n  var tag = _ref2.tag,\n    value = _ref2.value,\n    offset = _ref2.offset;\n  var err = new XTRenderingError(\"Non string values are not allowed for rawXML tags\");\n  err.properties = {\n    id: \"invalid_raw_xml_value\",\n    xtag: tag,\n    value: value,\n    offset: offset,\n    explanation: \"The value of the raw tag : '\".concat(tag, \"' is not a string\")\n  };\n  return err;\n}\nfunction throwExpandNotFound(options) {\n  var _options$part = options.part,\n    value = _options$part.value,\n    offset = _options$part.offset,\n    _options$id = options.id,\n    id = _options$id === void 0 ? \"raw_tag_outerxml_invalid\" : _options$id,\n    _options$message = options.message,\n    message = _options$message === void 0 ? \"Raw tag not in paragraph\" : _options$message;\n  var part = options.part;\n  var _options$explanation = options.explanation,\n    explanation = _options$explanation === void 0 ? \"The tag \\\"\".concat(value, \"\\\" is not inside a paragraph\") : _options$explanation;\n  if (typeof explanation === \"function\") {\n    explanation = explanation(part);\n  }\n  var err = new XTTemplateError(message);\n  err.properties = {\n    id: id,\n    explanation: explanation,\n    rootError: options.rootError,\n    xtag: value,\n    offset: offset,\n    postparsed: options.postparsed,\n    expandTo: options.expandTo,\n    index: options.index\n  };\n  throw err;\n}\nfunction throwRawTagShouldBeOnlyTextInParagraph(options) {\n  var err = new XTTemplateError(\"Raw tag should be the only text in paragraph\");\n  var tag = options.part.value;\n  err.properties = {\n    id: \"raw_xml_tag_should_be_only_text_in_paragraph\",\n    explanation: \"The raw tag \\\"\".concat(tag, \"\\\" should be the only text in this paragraph. This means that this tag should not be surrounded by any text or spaces.\"),\n    xtag: tag,\n    offset: options.part.offset,\n    paragraphParts: options.paragraphParts\n  };\n  throw err;\n}\nfunction getUnmatchedLoopException(part) {\n  var location = part.location,\n    offset = part.offset,\n    square = part.square;\n  var t = location === \"start\" ? \"unclosed\" : \"unopened\";\n  var T = location === \"start\" ? \"Unclosed\" : \"Unopened\";\n  var err = new XTTemplateError(\"\".concat(T, \" loop\"));\n  var tag = part.value;\n  err.properties = {\n    id: \"\".concat(t, \"_loop\"),\n    explanation: \"The loop with tag \\\"\".concat(tag, \"\\\" is \").concat(t),\n    xtag: tag,\n    offset: offset\n  };\n  if (square) {\n    err.properties.square = square;\n  }\n  return err;\n}\nfunction getUnbalancedLoopException(pair, lastPair) {\n  var err = new XTTemplateError(\"Unbalanced loop tag\");\n  var lastL = lastPair[0].part.value;\n  var lastR = lastPair[1].part.value;\n  var l = pair[0].part.value;\n  var r = pair[1].part.value;\n  err.properties = {\n    id: \"unbalanced_loop_tags\",\n    explanation: \"Unbalanced loop tags {#\".concat(lastL, \"}{/\").concat(lastR, \"}{#\").concat(l, \"}{/\").concat(r, \"}\"),\n    offset: [lastPair[0].part.offset, pair[1].part.offset],\n    lastPair: {\n      left: lastPair[0].part.value,\n      right: lastPair[1].part.value\n    },\n    pair: {\n      left: pair[0].part.value,\n      right: pair[1].part.value\n    }\n  };\n  return err;\n}\nfunction getClosingTagNotMatchOpeningTag(_ref3) {\n  var tags = _ref3.tags;\n  var err = new XTTemplateError(\"Closing tag does not match opening tag\");\n  err.properties = {\n    id: \"closing_tag_does_not_match_opening_tag\",\n    explanation: \"The tag \\\"\".concat(tags[0].value, \"\\\" is closed by the tag \\\"\").concat(tags[1].value, \"\\\"\"),\n    openingtag: first(tags).value,\n    offset: [first(tags).offset, last(tags).offset],\n    closingtag: last(tags).value\n  };\n  return err;\n}\nfunction getScopeCompilationError(_ref4) {\n  var tag = _ref4.tag,\n    rootError = _ref4.rootError,\n    offset = _ref4.offset;\n  var err = new XTScopeParserError(\"Scope parser compilation failed\");\n  err.properties = {\n    id: \"scopeparser_compilation_failed\",\n    offset: offset,\n    xtag: tag,\n    explanation: \"The scope parser for the tag \\\"\".concat(tag, \"\\\" failed to compile\"),\n    rootError: rootError\n  };\n  return err;\n}\nfunction getScopeParserExecutionError(_ref5) {\n  var tag = _ref5.tag,\n    scope = _ref5.scope,\n    error = _ref5.error,\n    offset = _ref5.offset;\n  var err = new XTScopeParserError(\"Scope parser execution failed\");\n  err.properties = {\n    id: \"scopeparser_execution_failed\",\n    explanation: \"The scope parser for the tag \".concat(tag, \" failed to execute\"),\n    scope: scope,\n    offset: offset,\n    xtag: tag,\n    rootError: error\n  };\n  return err;\n}\nfunction getLoopPositionProducesInvalidXMLError(_ref6) {\n  var tag = _ref6.tag,\n    offset = _ref6.offset;\n  var err = new XTTemplateError(\"The position of the loop tags \\\"\".concat(tag, \"\\\" would produce invalid XML\"));\n  err.properties = {\n    xtag: tag,\n    id: \"loop_position_invalid\",\n    explanation: \"The tags \\\"\".concat(tag, \"\\\" are misplaced in the document, for example one of them is in a table and the other one outside the table\"),\n    offset: offset\n  };\n  return err;\n}\nfunction throwUnimplementedTagType(part, index) {\n  var errorMsg = \"Unimplemented tag type \\\"\".concat(part.type, \"\\\"\");\n  if (part.module) {\n    errorMsg += \" \\\"\".concat(part.module, \"\\\"\");\n  }\n  var err = new XTTemplateError(errorMsg);\n  err.properties = {\n    part: part,\n    index: index,\n    id: \"unimplemented_tag_type\"\n  };\n  throw err;\n}\nfunction throwMalformedXml() {\n  var err = new XTInternalError(\"Malformed xml\");\n  err.properties = {\n    explanation: \"The template contains malformed xml\",\n    id: \"malformed_xml\"\n  };\n  throw err;\n}\nfunction throwResolveBeforeCompile() {\n  var err = new XTInternalError(\"You must run `.compile()` before running `.resolveData()`\");\n  err.properties = {\n    id: \"resolve_before_compile\",\n    explanation: \"You must run `.compile()` before running `.resolveData()`\"\n  };\n  throw err;\n}\nfunction throwRenderInvalidTemplate() {\n  var err = new XTInternalError(\"You should not call .render on a document that had compilation errors\");\n  err.properties = {\n    id: \"render_on_invalid_template\",\n    explanation: \"You should not call .render on a document that had compilation errors\"\n  };\n  throw err;\n}\nfunction throwRenderTwice() {\n  var err = new XTInternalError(\"You should not call .render twice on the same docxtemplater instance\");\n  err.properties = {\n    id: \"render_twice\",\n    explanation: \"You should not call .render twice on the same docxtemplater instance\"\n  };\n  throw err;\n}\nfunction throwFileTypeNotIdentified(zip) {\n  var files = Object.keys(zip.files).slice(0, 10);\n  var msg = \"\";\n  if (files.length === 0) {\n    msg = \"Empty zip file\";\n  } else {\n    msg = \"Zip file contains : \".concat(files.join(\",\"));\n  }\n  var err = new XTInternalError(\"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg));\n  err.properties = {\n    id: \"filetype_not_identified\",\n    explanation: \"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg)\n  };\n  throw err;\n}\nfunction throwXmlInvalid(content, offset) {\n  var err = new XTTemplateError(\"An XML file has invalid xml\");\n  err.properties = {\n    id: \"file_has_invalid_xml\",\n    content: content,\n    offset: offset,\n    explanation: \"The docx contains invalid XML, it is most likely corrupt\"\n  };\n  throw err;\n}\nfunction throwFileTypeNotHandled(fileType) {\n  var err = new XTInternalError(\"The filetype \\\"\".concat(fileType, \"\\\" is not handled by docxtemplater\"));\n  err.properties = {\n    id: \"filetype_not_handled\",\n    explanation: \"The file you are trying to generate is of type \\\"\".concat(fileType, \"\\\", but only docx and pptx formats are handled\"),\n    fileType: fileType\n  };\n  throw err;\n}\nmodule.exports = {\n  XTError: XTError,\n  XTTemplateError: XTTemplateError,\n  XTInternalError: XTInternalError,\n  XTScopeParserError: XTScopeParserError,\n  XTAPIVersionError: XTAPIVersionError,\n  // Remove this alias in v4\n  RenderingError: XTRenderingError,\n  XTRenderingError: XTRenderingError,\n  getClosingTagNotMatchOpeningTag: getClosingTagNotMatchOpeningTag,\n  getLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError,\n  getScopeCompilationError: getScopeCompilationError,\n  getScopeParserExecutionError: getScopeParserExecutionError,\n  getUnclosedTagException: getUnclosedTagException,\n  getUnopenedTagException: getUnopenedTagException,\n  getUnmatchedLoopException: getUnmatchedLoopException,\n  getDuplicateCloseTagException: getDuplicateCloseTagException,\n  getDuplicateOpenTagException: getDuplicateOpenTagException,\n  getCorruptCharactersException: getCorruptCharactersException,\n  getInvalidRawXMLValueException: getInvalidRawXMLValueException,\n  getUnbalancedLoopException: getUnbalancedLoopException,\n  throwApiVersionError: throwApiVersionError,\n  throwFileTypeNotHandled: throwFileTypeNotHandled,\n  throwFileTypeNotIdentified: throwFileTypeNotIdentified,\n  throwMalformedXml: throwMalformedXml,\n  throwMultiError: throwMultiError,\n  throwExpandNotFound: throwExpandNotFound,\n  throwRawTagShouldBeOnlyTextInParagraph: throwRawTagShouldBeOnlyTextInParagraph,\n  throwUnimplementedTagType: throwUnimplementedTagType,\n  throwXmlTagNotFound: throwXmlTagNotFound,\n  throwXmlInvalid: throwXmlInvalid,\n  throwResolveBeforeCompile: throwResolveBeforeCompile,\n  throwRenderInvalidTemplate: throwRenderInvalidTemplate,\n  throwRenderTwice: throwRenderTwice\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGVBQWUsbUJBQU8sQ0FBQyxrRUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0IscUJBQXFCLGlCQUFpQixnQkFBZ0I7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9lcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIiksXG4gIGxhc3QgPSBfcmVxdWlyZS5sYXN0LFxuICBmaXJzdCA9IF9yZXF1aXJlLmZpcnN0O1xuZnVuY3Rpb24gWFRFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiR2VuZXJpY0Vycm9yXCI7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVEVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbmZ1bmN0aW9uIFhUVGVtcGxhdGVFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiVGVtcGxhdGVFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRUZW1wbGF0ZUVycm9yLnByb3RvdHlwZSA9IG5ldyBYVEVycm9yKCk7XG5mdW5jdGlvbiBYVFJlbmRlcmluZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJSZW5kZXJpbmdFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRSZW5kZXJpbmdFcnJvci5wcm90b3R5cGUgPSBuZXcgWFRFcnJvcigpO1xuZnVuY3Rpb24gWFRTY29wZVBhcnNlckVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJTY29wZVBhcnNlckVycm9yXCI7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVFNjb3BlUGFyc2VyRXJyb3IucHJvdG90eXBlID0gbmV3IFhURXJyb3IoKTtcbmZ1bmN0aW9uIFhUSW50ZXJuYWxFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiSW50ZXJuYWxFcnJvclwiO1xuICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgZXhwbGFuYXRpb246IFwiSW50ZXJuYWxFcnJvclwiXG4gIH07XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVEludGVybmFsRXJyb3IucHJvdG90eXBlID0gbmV3IFhURXJyb3IoKTtcbmZ1bmN0aW9uIFhUQVBJVmVyc2lvbkVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJBUElWZXJzaW9uRXJyb3JcIjtcbiAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgIGV4cGxhbmF0aW9uOiBcIkFQSVZlcnNpb25FcnJvclwiXG4gIH07XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVEFQSVZlcnNpb25FcnJvci5wcm90b3R5cGUgPSBuZXcgWFRFcnJvcigpO1xuZnVuY3Rpb24gdGhyb3dBcGlWZXJzaW9uRXJyb3IobXNnLCBwcm9wZXJ0aWVzKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRBUElWZXJzaW9uRXJyb3IobXNnKTtcbiAgZXJyLnByb3BlcnRpZXMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICBpZDogXCJhcGlfdmVyc2lvbl9lcnJvclwiXG4gIH0sIHByb3BlcnRpZXMpO1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd011bHRpRXJyb3IoZXJyb3JzKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTXVsdGkgZXJyb3JcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGVycm9yczogZXJyb3JzLFxuICAgIGlkOiBcIm11bHRpX2Vycm9yXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRlbXBsYXRlIGhhcyBtdWx0aXBsZSBlcnJvcnNcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiBnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbihvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiVW5vcGVuZWQgdGFnXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICB4dGFnOiBsYXN0KG9wdGlvbnMueHRhZy5zcGxpdChcIiBcIikpLFxuICAgIGlkOiBcInVub3BlbmVkX3RhZ1wiLFxuICAgIGNvbnRleHQ6IG9wdGlvbnMueHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgIGxJbmRleDogb3B0aW9ucy5sSW5kZXgsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZyBiZWdpbm5pbmcgd2l0aCBcXFwiXCIuY29uY2F0KG9wdGlvbnMueHRhZy5zdWJzdHIoMCwgMTApLCBcIlxcXCIgaXMgdW5vcGVuZWRcIilcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24ob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIkR1cGxpY2F0ZSBvcGVuIHRhZywgZXhwZWN0ZWQgb25lIG9wZW4gdGFnXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICB4dGFnOiBmaXJzdChvcHRpb25zLnh0YWcuc3BsaXQoXCIgXCIpKSxcbiAgICBpZDogXCJkdXBsaWNhdGVfb3Blbl90YWdcIixcbiAgICBjb250ZXh0OiBvcHRpb25zLnh0YWcsXG4gICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldCxcbiAgICBsSW5kZXg6IG9wdGlvbnMubEluZGV4LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0YWcgYmVnaW5uaW5nIHdpdGggXFxcIlwiLmNvbmNhdChvcHRpb25zLnh0YWcuc3Vic3RyKDAsIDEwKSwgXCJcXFwiIGhhcyBkdXBsaWNhdGUgb3BlbiB0YWdzXCIpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbihvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiRHVwbGljYXRlIGNsb3NlIHRhZywgZXhwZWN0ZWQgb25lIGNsb3NlIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgeHRhZzogZmlyc3Qob3B0aW9ucy54dGFnLnNwbGl0KFwiIFwiKSksXG4gICAgaWQ6IFwiZHVwbGljYXRlX2Nsb3NlX3RhZ1wiLFxuICAgIGNvbnRleHQ6IG9wdGlvbnMueHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgIGxJbmRleDogb3B0aW9ucy5sSW5kZXgsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZyBlbmRpbmcgd2l0aCBcXFwiXCIuY29uY2F0KG9wdGlvbnMueHRhZy5zdWJzdHIoMCwgMTApLCBcIlxcXCIgaGFzIGR1cGxpY2F0ZSBjbG9zZSB0YWdzXCIpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbihvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiVW5jbG9zZWQgdGFnXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICB4dGFnOiBmaXJzdChvcHRpb25zLnh0YWcuc3BsaXQoXCIgXCIpKS5zdWJzdHIoMSksXG4gICAgaWQ6IFwidW5jbG9zZWRfdGFnXCIsXG4gICAgY29udGV4dDogb3B0aW9ucy54dGFnLFxuICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQsXG4gICAgbEluZGV4OiBvcHRpb25zLmxJbmRleCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFnIGJlZ2lubmluZyB3aXRoIFxcXCJcIi5jb25jYXQob3B0aW9ucy54dGFnLnN1YnN0cigwLCAxMCksIFwiXFxcIiBpcyB1bmNsb3NlZFwiKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dYbWxUYWdOb3RGb3VuZChvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTm8gdGFnIFxcXCJcIi5jb25jYXQob3B0aW9ucy5lbGVtZW50LCBcIlxcXCIgd2FzIGZvdW5kIGF0IHRoZSBcIikuY29uY2F0KG9wdGlvbnMucG9zaXRpb24pKTtcbiAgdmFyIHBhcnQgPSBvcHRpb25zLnBhcnNlZFtvcHRpb25zLmluZGV4XTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwibm9feG1sX3RhZ19mb3VuZF9hdF9cIi5jb25jYXQob3B0aW9ucy5wb3NpdGlvbiksXG4gICAgZXhwbGFuYXRpb246IFwiTm8gdGFnIFxcXCJcIi5jb25jYXQob3B0aW9ucy5lbGVtZW50LCBcIlxcXCIgd2FzIGZvdW5kIGF0IHRoZSBcIikuY29uY2F0KG9wdGlvbnMucG9zaXRpb24pLFxuICAgIG9mZnNldDogcGFydC5vZmZzZXQsXG4gICAgcGFydDogcGFydCxcbiAgICBwYXJzZWQ6IG9wdGlvbnMucGFyc2VkLFxuICAgIGluZGV4OiBvcHRpb25zLmluZGV4LFxuICAgIGVsZW1lbnQ6IG9wdGlvbnMuZWxlbWVudFxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiBnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbihfcmVmKSB7XG4gIHZhciB0YWcgPSBfcmVmLnRhZyxcbiAgICB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBlcnIgPSBuZXcgWFRSZW5kZXJpbmdFcnJvcihcIlRoZXJlIGFyZSBzb21lIFhNTCBjb3JydXB0IGNoYXJhY3RlcnNcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImludmFsaWRfeG1sX2NoYXJhY3RlcnNcIixcbiAgICB4dGFnOiB0YWcsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZXJlIGFyZSBzb21lIGNvcnJ1cHQgY2hhcmFjdGVycyBmb3IgdGhlIGZpZWxkIFwiLmNvbmNhdCh0YWcpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb24oX3JlZjIpIHtcbiAgdmFyIHRhZyA9IF9yZWYyLnRhZyxcbiAgICB2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgIG9mZnNldCA9IF9yZWYyLm9mZnNldDtcbiAgdmFyIGVyciA9IG5ldyBYVFJlbmRlcmluZ0Vycm9yKFwiTm9uIHN0cmluZyB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkIGZvciByYXdYTUwgdGFnc1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiaW52YWxpZF9yYXdfeG1sX3ZhbHVlXCIsXG4gICAgeHRhZzogdGFnLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdmFsdWUgb2YgdGhlIHJhdyB0YWcgOiAnXCIuY29uY2F0KHRhZywgXCInIGlzIG5vdCBhIHN0cmluZ1wiKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dFeHBhbmROb3RGb3VuZChvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRwYXJ0ID0gb3B0aW9ucy5wYXJ0LFxuICAgIHZhbHVlID0gX29wdGlvbnMkcGFydC52YWx1ZSxcbiAgICBvZmZzZXQgPSBfb3B0aW9ucyRwYXJ0Lm9mZnNldCxcbiAgICBfb3B0aW9ucyRpZCA9IG9wdGlvbnMuaWQsXG4gICAgaWQgPSBfb3B0aW9ucyRpZCA9PT0gdm9pZCAwID8gXCJyYXdfdGFnX291dGVyeG1sX2ludmFsaWRcIiA6IF9vcHRpb25zJGlkLFxuICAgIF9vcHRpb25zJG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UsXG4gICAgbWVzc2FnZSA9IF9vcHRpb25zJG1lc3NhZ2UgPT09IHZvaWQgMCA/IFwiUmF3IHRhZyBub3QgaW4gcGFyYWdyYXBoXCIgOiBfb3B0aW9ucyRtZXNzYWdlO1xuICB2YXIgcGFydCA9IG9wdGlvbnMucGFydDtcbiAgdmFyIF9vcHRpb25zJGV4cGxhbmF0aW9uID0gb3B0aW9ucy5leHBsYW5hdGlvbixcbiAgICBleHBsYW5hdGlvbiA9IF9vcHRpb25zJGV4cGxhbmF0aW9uID09PSB2b2lkIDAgPyBcIlRoZSB0YWcgXFxcIlwiLmNvbmNhdCh2YWx1ZSwgXCJcXFwiIGlzIG5vdCBpbnNpZGUgYSBwYXJhZ3JhcGhcIikgOiBfb3B0aW9ucyRleHBsYW5hdGlvbjtcbiAgaWYgKHR5cGVvZiBleHBsYW5hdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZXhwbGFuYXRpb24gPSBleHBsYW5hdGlvbihwYXJ0KTtcbiAgfVxuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihtZXNzYWdlKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IGlkLFxuICAgIGV4cGxhbmF0aW9uOiBleHBsYW5hdGlvbixcbiAgICByb290RXJyb3I6IG9wdGlvbnMucm9vdEVycm9yLFxuICAgIHh0YWc6IHZhbHVlLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHBvc3RwYXJzZWQ6IG9wdGlvbnMucG9zdHBhcnNlZCxcbiAgICBleHBhbmRUbzogb3B0aW9ucy5leHBhbmRUbyxcbiAgICBpbmRleDogb3B0aW9ucy5pbmRleFxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaChvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiUmF3IHRhZyBzaG91bGQgYmUgdGhlIG9ubHkgdGV4dCBpbiBwYXJhZ3JhcGhcIik7XG4gIHZhciB0YWcgPSBvcHRpb25zLnBhcnQudmFsdWU7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInJhd194bWxfdGFnX3Nob3VsZF9iZV9vbmx5X3RleHRfaW5fcGFyYWdyYXBoXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHJhdyB0YWcgXFxcIlwiLmNvbmNhdCh0YWcsIFwiXFxcIiBzaG91bGQgYmUgdGhlIG9ubHkgdGV4dCBpbiB0aGlzIHBhcmFncmFwaC4gVGhpcyBtZWFucyB0aGF0IHRoaXMgdGFnIHNob3VsZCBub3QgYmUgc3Vycm91bmRlZCBieSBhbnkgdGV4dCBvciBzcGFjZXMuXCIpLFxuICAgIHh0YWc6IHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMucGFydC5vZmZzZXQsXG4gICAgcGFyYWdyYXBoUGFydHM6IG9wdGlvbnMucGFyYWdyYXBoUGFydHNcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbihwYXJ0KSB7XG4gIHZhciBsb2NhdGlvbiA9IHBhcnQubG9jYXRpb24sXG4gICAgb2Zmc2V0ID0gcGFydC5vZmZzZXQsXG4gICAgc3F1YXJlID0gcGFydC5zcXVhcmU7XG4gIHZhciB0ID0gbG9jYXRpb24gPT09IFwic3RhcnRcIiA/IFwidW5jbG9zZWRcIiA6IFwidW5vcGVuZWRcIjtcbiAgdmFyIFQgPSBsb2NhdGlvbiA9PT0gXCJzdGFydFwiID8gXCJVbmNsb3NlZFwiIDogXCJVbm9wZW5lZFwiO1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlwiLmNvbmNhdChULCBcIiBsb29wXCIpKTtcbiAgdmFyIHRhZyA9IHBhcnQudmFsdWU7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcIlwiLmNvbmNhdCh0LCBcIl9sb29wXCIpLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSBsb29wIHdpdGggdGFnIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgaXMgXCIpLmNvbmNhdCh0KSxcbiAgICB4dGFnOiB0YWcsXG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfTtcbiAgaWYgKHNxdWFyZSkge1xuICAgIGVyci5wcm9wZXJ0aWVzLnNxdWFyZSA9IHNxdWFyZTtcbiAgfVxuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb24ocGFpciwgbGFzdFBhaXIpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJVbmJhbGFuY2VkIGxvb3AgdGFnXCIpO1xuICB2YXIgbGFzdEwgPSBsYXN0UGFpclswXS5wYXJ0LnZhbHVlO1xuICB2YXIgbGFzdFIgPSBsYXN0UGFpclsxXS5wYXJ0LnZhbHVlO1xuICB2YXIgbCA9IHBhaXJbMF0ucGFydC52YWx1ZTtcbiAgdmFyIHIgPSBwYWlyWzFdLnBhcnQudmFsdWU7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInVuYmFsYW5jZWRfbG9vcF90YWdzXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVW5iYWxhbmNlZCBsb29wIHRhZ3MgeyNcIi5jb25jYXQobGFzdEwsIFwifXsvXCIpLmNvbmNhdChsYXN0UiwgXCJ9eyNcIikuY29uY2F0KGwsIFwifXsvXCIpLmNvbmNhdChyLCBcIn1cIiksXG4gICAgb2Zmc2V0OiBbbGFzdFBhaXJbMF0ucGFydC5vZmZzZXQsIHBhaXJbMV0ucGFydC5vZmZzZXRdLFxuICAgIGxhc3RQYWlyOiB7XG4gICAgICBsZWZ0OiBsYXN0UGFpclswXS5wYXJ0LnZhbHVlLFxuICAgICAgcmlnaHQ6IGxhc3RQYWlyWzFdLnBhcnQudmFsdWVcbiAgICB9LFxuICAgIHBhaXI6IHtcbiAgICAgIGxlZnQ6IHBhaXJbMF0ucGFydC52YWx1ZSxcbiAgICAgIHJpZ2h0OiBwYWlyWzFdLnBhcnQudmFsdWVcbiAgICB9XG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRDbG9zaW5nVGFnTm90TWF0Y2hPcGVuaW5nVGFnKF9yZWYzKSB7XG4gIHZhciB0YWdzID0gX3JlZjMudGFncztcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJDbG9zaW5nIHRhZyBkb2VzIG5vdCBtYXRjaCBvcGVuaW5nIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiY2xvc2luZ190YWdfZG9lc19ub3RfbWF0Y2hfb3BlbmluZ190YWdcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFnIFxcXCJcIi5jb25jYXQodGFnc1swXS52YWx1ZSwgXCJcXFwiIGlzIGNsb3NlZCBieSB0aGUgdGFnIFxcXCJcIikuY29uY2F0KHRhZ3NbMV0udmFsdWUsIFwiXFxcIlwiKSxcbiAgICBvcGVuaW5ndGFnOiBmaXJzdCh0YWdzKS52YWx1ZSxcbiAgICBvZmZzZXQ6IFtmaXJzdCh0YWdzKS5vZmZzZXQsIGxhc3QodGFncykub2Zmc2V0XSxcbiAgICBjbG9zaW5ndGFnOiBsYXN0KHRhZ3MpLnZhbHVlXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRTY29wZUNvbXBpbGF0aW9uRXJyb3IoX3JlZjQpIHtcbiAgdmFyIHRhZyA9IF9yZWY0LnRhZyxcbiAgICByb290RXJyb3IgPSBfcmVmNC5yb290RXJyb3IsXG4gICAgb2Zmc2V0ID0gX3JlZjQub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUU2NvcGVQYXJzZXJFcnJvcihcIlNjb3BlIHBhcnNlciBjb21waWxhdGlvbiBmYWlsZWRcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInNjb3BlcGFyc2VyX2NvbXBpbGF0aW9uX2ZhaWxlZFwiLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHh0YWc6IHRhZyxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgc2NvcGUgcGFyc2VyIGZvciB0aGUgdGFnIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgZmFpbGVkIHRvIGNvbXBpbGVcIiksXG4gICAgcm9vdEVycm9yOiByb290RXJyb3JcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3IoX3JlZjUpIHtcbiAgdmFyIHRhZyA9IF9yZWY1LnRhZyxcbiAgICBzY29wZSA9IF9yZWY1LnNjb3BlLFxuICAgIGVycm9yID0gX3JlZjUuZXJyb3IsXG4gICAgb2Zmc2V0ID0gX3JlZjUub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUU2NvcGVQYXJzZXJFcnJvcihcIlNjb3BlIHBhcnNlciBleGVjdXRpb24gZmFpbGVkXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJzY29wZXBhcnNlcl9leGVjdXRpb25fZmFpbGVkXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHNjb3BlIHBhcnNlciBmb3IgdGhlIHRhZyBcIi5jb25jYXQodGFnLCBcIiBmYWlsZWQgdG8gZXhlY3V0ZVwiKSxcbiAgICBzY29wZTogc2NvcGUsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgeHRhZzogdGFnLFxuICAgIHJvb3RFcnJvcjogZXJyb3JcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yKF9yZWY2KSB7XG4gIHZhciB0YWcgPSBfcmVmNi50YWcsXG4gICAgb2Zmc2V0ID0gX3JlZjYub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlRoZSBwb3NpdGlvbiBvZiB0aGUgbG9vcCB0YWdzIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgd291bGQgcHJvZHVjZSBpbnZhbGlkIFhNTFwiKSk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIHh0YWc6IHRhZyxcbiAgICBpZDogXCJsb29wX3Bvc2l0aW9uX2ludmFsaWRcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFncyBcXFwiXCIuY29uY2F0KHRhZywgXCJcXFwiIGFyZSBtaXNwbGFjZWQgaW4gdGhlIGRvY3VtZW50LCBmb3IgZXhhbXBsZSBvbmUgb2YgdGhlbSBpcyBpbiBhIHRhYmxlIGFuZCB0aGUgb3RoZXIgb25lIG91dHNpZGUgdGhlIHRhYmxlXCIpLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlKHBhcnQsIGluZGV4KSB7XG4gIHZhciBlcnJvck1zZyA9IFwiVW5pbXBsZW1lbnRlZCB0YWcgdHlwZSBcXFwiXCIuY29uY2F0KHBhcnQudHlwZSwgXCJcXFwiXCIpO1xuICBpZiAocGFydC5tb2R1bGUpIHtcbiAgICBlcnJvck1zZyArPSBcIiBcXFwiXCIuY29uY2F0KHBhcnQubW9kdWxlLCBcIlxcXCJcIik7XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoZXJyb3JNc2cpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBwYXJ0OiBwYXJ0LFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBpZDogXCJ1bmltcGxlbWVudGVkX3RhZ190eXBlXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dNYWxmb3JtZWRYbWwoKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiTWFsZm9ybWVkIHhtbFwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRlbXBsYXRlIGNvbnRhaW5zIG1hbGZvcm1lZCB4bWxcIixcbiAgICBpZDogXCJtYWxmb3JtZWRfeG1sXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZSgpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJZb3UgbXVzdCBydW4gYC5jb21waWxlKClgIGJlZm9yZSBydW5uaW5nIGAucmVzb2x2ZURhdGEoKWBcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInJlc29sdmVfYmVmb3JlX2NvbXBpbGVcIixcbiAgICBleHBsYW5hdGlvbjogXCJZb3UgbXVzdCBydW4gYC5jb21waWxlKClgIGJlZm9yZSBydW5uaW5nIGAucmVzb2x2ZURhdGEoKWBcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSgpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJZb3Ugc2hvdWxkIG5vdCBjYWxsIC5yZW5kZXIgb24gYSBkb2N1bWVudCB0aGF0IGhhZCBjb21waWxhdGlvbiBlcnJvcnNcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInJlbmRlcl9vbl9pbnZhbGlkX3RlbXBsYXRlXCIsXG4gICAgZXhwbGFuYXRpb246IFwiWW91IHNob3VsZCBub3QgY2FsbCAucmVuZGVyIG9uIGEgZG9jdW1lbnQgdGhhdCBoYWQgY29tcGlsYXRpb24gZXJyb3JzXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dSZW5kZXJUd2ljZSgpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJZb3Ugc2hvdWxkIG5vdCBjYWxsIC5yZW5kZXIgdHdpY2Ugb24gdGhlIHNhbWUgZG9jeHRlbXBsYXRlciBpbnN0YW5jZVwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwicmVuZGVyX3R3aWNlXCIsXG4gICAgZXhwbGFuYXRpb246IFwiWW91IHNob3VsZCBub3QgY2FsbCAucmVuZGVyIHR3aWNlIG9uIHRoZSBzYW1lIGRvY3h0ZW1wbGF0ZXIgaW5zdGFuY2VcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCh6aXApIHtcbiAgdmFyIGZpbGVzID0gT2JqZWN0LmtleXMoemlwLmZpbGVzKS5zbGljZSgwLCAxMCk7XG4gIHZhciBtc2cgPSBcIlwiO1xuICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgbXNnID0gXCJFbXB0eSB6aXAgZmlsZVwiO1xuICB9IGVsc2Uge1xuICAgIG1zZyA9IFwiWmlwIGZpbGUgY29udGFpbnMgOiBcIi5jb25jYXQoZmlsZXMuam9pbihcIixcIikpO1xuICB9XG4gIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiVGhlIGZpbGV0eXBlIGZvciB0aGlzIGZpbGUgY291bGQgbm90IGJlIGlkZW50aWZpZWQsIGlzIHRoaXMgZmlsZSBjb3JydXB0ZWQgPyBcIi5jb25jYXQobXNnKSk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImZpbGV0eXBlX25vdF9pZGVudGlmaWVkXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIGZpbGV0eXBlIGZvciB0aGlzIGZpbGUgY291bGQgbm90IGJlIGlkZW50aWZpZWQsIGlzIHRoaXMgZmlsZSBjb3JydXB0ZWQgPyBcIi5jb25jYXQobXNnKVxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1htbEludmFsaWQoY29udGVudCwgb2Zmc2V0KSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiQW4gWE1MIGZpbGUgaGFzIGludmFsaWQgeG1sXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJmaWxlX2hhc19pbnZhbGlkX3htbFwiLFxuICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIGRvY3ggY29udGFpbnMgaW52YWxpZCBYTUwsIGl0IGlzIG1vc3QgbGlrZWx5IGNvcnJ1cHRcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZChmaWxlVHlwZSkge1xuICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIlRoZSBmaWxldHlwZSBcXFwiXCIuY29uY2F0KGZpbGVUeXBlLCBcIlxcXCIgaXMgbm90IGhhbmRsZWQgYnkgZG9jeHRlbXBsYXRlclwiKSk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImZpbGV0eXBlX25vdF9oYW5kbGVkXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIGZpbGUgeW91IGFyZSB0cnlpbmcgdG8gZ2VuZXJhdGUgaXMgb2YgdHlwZSBcXFwiXCIuY29uY2F0KGZpbGVUeXBlLCBcIlxcXCIsIGJ1dCBvbmx5IGRvY3ggYW5kIHBwdHggZm9ybWF0cyBhcmUgaGFuZGxlZFwiKSxcbiAgICBmaWxlVHlwZTogZmlsZVR5cGVcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFhURXJyb3I6IFhURXJyb3IsXG4gIFhUVGVtcGxhdGVFcnJvcjogWFRUZW1wbGF0ZUVycm9yLFxuICBYVEludGVybmFsRXJyb3I6IFhUSW50ZXJuYWxFcnJvcixcbiAgWFRTY29wZVBhcnNlckVycm9yOiBYVFNjb3BlUGFyc2VyRXJyb3IsXG4gIFhUQVBJVmVyc2lvbkVycm9yOiBYVEFQSVZlcnNpb25FcnJvcixcbiAgLy8gUmVtb3ZlIHRoaXMgYWxpYXMgaW4gdjRcbiAgUmVuZGVyaW5nRXJyb3I6IFhUUmVuZGVyaW5nRXJyb3IsXG4gIFhUUmVuZGVyaW5nRXJyb3I6IFhUUmVuZGVyaW5nRXJyb3IsXG4gIGdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWc6IGdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWcsXG4gIGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yOiBnZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvcixcbiAgZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yOiBnZXRTY29wZUNvbXBpbGF0aW9uRXJyb3IsXG4gIGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3I6IGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3IsXG4gIGdldFVuY2xvc2VkVGFnRXhjZXB0aW9uOiBnZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbixcbiAgZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb246IGdldFVub3BlbmVkVGFnRXhjZXB0aW9uLFxuICBnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uOiBnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uLFxuICBnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbjogZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24sXG4gIGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb246IGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24sXG4gIGdldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uOiBnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbixcbiAgZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uOiBnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb24sXG4gIGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uOiBnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbixcbiAgdGhyb3dBcGlWZXJzaW9uRXJyb3I6IHRocm93QXBpVmVyc2lvbkVycm9yLFxuICB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZDogdGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQsXG4gIHRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkOiB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCxcbiAgdGhyb3dNYWxmb3JtZWRYbWw6IHRocm93TWFsZm9ybWVkWG1sLFxuICB0aHJvd011bHRpRXJyb3I6IHRocm93TXVsdGlFcnJvcixcbiAgdGhyb3dFeHBhbmROb3RGb3VuZDogdGhyb3dFeHBhbmROb3RGb3VuZCxcbiAgdGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGg6IHRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoLFxuICB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlOiB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlLFxuICB0aHJvd1htbFRhZ05vdEZvdW5kOiB0aHJvd1htbFRhZ05vdEZvdW5kLFxuICB0aHJvd1htbEludmFsaWQ6IHRocm93WG1sSW52YWxpZCxcbiAgdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZTogdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZSxcbiAgdGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGU6IHRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlLFxuICB0aHJvd1JlbmRlclR3aWNlOiB0aHJvd1JlbmRlclR3aWNlXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/file-type-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/docxtemplater/js/file-type-config.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar loopModule = __webpack_require__(/*! ./modules/loop.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/loop.js\");\nvar spacePreserveModule = __webpack_require__(/*! ./modules/space-preserve.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/space-preserve.js\");\nvar rawXmlModule = __webpack_require__(/*! ./modules/rawxml.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/rawxml.js\");\nvar expandPairTrait = __webpack_require__(/*! ./modules/expand-pair-trait.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js\");\nvar render = __webpack_require__(/*! ./modules/render.js */ \"(ssr)/./node_modules/docxtemplater/js/modules/render.js\");\nfunction DocXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles() {\n      return [];\n    },\n    textPath: function textPath(doc) {\n      return doc.textTarget;\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"cp:contentStatus\", \"w:t\", \"a:t\", \"m:t\", \"vt:lpstr\", \"vt:lpwstr\"],\n    tagsXmlLexedArray: [\"w:proofState\", \"w:tc\", \"w:tr\", \"w:tbl\", \"w:body\", \"w:document\", \"w:p\", \"w:r\", \"w:br\", \"w:rPr\", \"w:pPr\", \"w:spacing\", \"w:sdtContent\", \"w:sdt\", \"w:drawing\", \"w:sectPr\", \"w:type\", \"w:headerReference\", \"w:footerReference\", \"w:bookmarkStart\", \"w:bookmarkEnd\", \"w:commentRangeStart\", \"w:commentRangeEnd\", \"w:commentReference\"],\n    droppedTagsInsidePlaceholder: [\"w:p\", \"w:br\", \"w:bookmarkStart\", \"w:bookmarkEnd\"],\n    expandTags: [{\n      contains: \"w:tc\",\n      expand: \"w:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"w:p\",\n      expand: \"w:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"w:p\",\n    baseModules: [loopModule, spacePreserveModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"w:sdtContent\",\n      shouldContain: [\"w:p\", \"w:r\", \"w:commentRangeStart\", \"w:sdt\"],\n      value: \"<w:p></w:p>\"\n    }, {\n      tag: \"w:tc\",\n      shouldContain: [\"w:p\"],\n      value: \"<w:p></w:p>\"\n    }, {\n      tag: \"w:tr\",\n      shouldContain: [\"w:tc\"],\n      drop: true\n    }, {\n      tag: \"w:tbl\",\n      shouldContain: [\"w:tr\"],\n      drop: true\n    }]\n  };\n}\nfunction PptXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles() {\n      return [];\n    },\n    textPath: function textPath(doc) {\n      return doc.textTarget;\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"a:t\", \"m:t\", \"vt:lpstr\", \"vt:lpwstr\"],\n    tagsXmlLexedArray: [\"p:sp\", \"a:tc\", \"a:tr\", \"a:tbl\", \"a:graphicData\", \"a:p\", \"a:r\", \"a:rPr\", \"p:txBody\", \"a:txBody\", \"a:off\", \"a:ext\", \"p:graphicFrame\", \"p:xfrm\", \"a16:rowId\", \"a:endParaRPr\"],\n    droppedTagsInsidePlaceholder: [\"a:p\", \"a:endParaRPr\"],\n    expandTags: [{\n      contains: \"a:tc\",\n      expand: \"a:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"a:p\",\n      expand: \"a:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"p:sp\",\n    baseModules: [loopModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"a:tbl\",\n      shouldContain: [\"a:tr\"],\n      dropParent: \"p:graphicFrame\"\n    }, {\n      tag: \"p:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }, {\n      tag: \"a:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }]\n  };\n}\nmodule.exports = {\n  docx: DocXFileTypeConfig,\n  pptx: PptXFileTypeConfig\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9maWxlLXR5cGUtY29uZmlnLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGlCQUFpQixtQkFBTyxDQUFDLGdGQUFtQjtBQUM1QywwQkFBMEIsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDL0QsbUJBQW1CLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ2hELHNCQUFzQixtQkFBTyxDQUFDLDBHQUFnQztBQUM5RCxhQUFhLG1CQUFPLENBQUMsb0ZBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2ZpbGUtdHlwZS1jb25maWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBsb29wTW9kdWxlID0gcmVxdWlyZShcIi4vbW9kdWxlcy9sb29wLmpzXCIpO1xudmFyIHNwYWNlUHJlc2VydmVNb2R1bGUgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3NwYWNlLXByZXNlcnZlLmpzXCIpO1xudmFyIHJhd1htbE1vZHVsZSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvcmF3eG1sLmpzXCIpO1xudmFyIGV4cGFuZFBhaXJUcmFpdCA9IHJlcXVpcmUoXCIuL21vZHVsZXMvZXhwYW5kLXBhaXItdHJhaXQuanNcIik7XG52YXIgcmVuZGVyID0gcmVxdWlyZShcIi4vbW9kdWxlcy9yZW5kZXIuanNcIik7XG5mdW5jdGlvbiBEb2NYRmlsZVR5cGVDb25maWcoKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0VGVtcGxhdGVkRmlsZXM6IGZ1bmN0aW9uIGdldFRlbXBsYXRlZEZpbGVzKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgdGV4dFBhdGg6IGZ1bmN0aW9uIHRleHRQYXRoKGRvYykge1xuICAgICAgcmV0dXJuIGRvYy50ZXh0VGFyZ2V0O1xuICAgIH0sXG4gICAgdGFnc1htbFRleHRBcnJheTogW1wiQ29tcGFueVwiLCBcIkh5cGVybGlua0Jhc2VcIiwgXCJNYW5hZ2VyXCIsIFwiY3A6Y2F0ZWdvcnlcIiwgXCJjcDprZXl3b3Jkc1wiLCBcImRjOmNyZWF0b3JcIiwgXCJkYzpkZXNjcmlwdGlvblwiLCBcImRjOnN1YmplY3RcIiwgXCJkYzp0aXRsZVwiLCBcImNwOmNvbnRlbnRTdGF0dXNcIiwgXCJ3OnRcIiwgXCJhOnRcIiwgXCJtOnRcIiwgXCJ2dDpscHN0clwiLCBcInZ0Omxwd3N0clwiXSxcbiAgICB0YWdzWG1sTGV4ZWRBcnJheTogW1widzpwcm9vZlN0YXRlXCIsIFwidzp0Y1wiLCBcInc6dHJcIiwgXCJ3OnRibFwiLCBcInc6Ym9keVwiLCBcInc6ZG9jdW1lbnRcIiwgXCJ3OnBcIiwgXCJ3OnJcIiwgXCJ3OmJyXCIsIFwidzpyUHJcIiwgXCJ3OnBQclwiLCBcInc6c3BhY2luZ1wiLCBcInc6c2R0Q29udGVudFwiLCBcInc6c2R0XCIsIFwidzpkcmF3aW5nXCIsIFwidzpzZWN0UHJcIiwgXCJ3OnR5cGVcIiwgXCJ3OmhlYWRlclJlZmVyZW5jZVwiLCBcInc6Zm9vdGVyUmVmZXJlbmNlXCIsIFwidzpib29rbWFya1N0YXJ0XCIsIFwidzpib29rbWFya0VuZFwiLCBcInc6Y29tbWVudFJhbmdlU3RhcnRcIiwgXCJ3OmNvbW1lbnRSYW5nZUVuZFwiLCBcInc6Y29tbWVudFJlZmVyZW5jZVwiXSxcbiAgICBkcm9wcGVkVGFnc0luc2lkZVBsYWNlaG9sZGVyOiBbXCJ3OnBcIiwgXCJ3OmJyXCIsIFwidzpib29rbWFya1N0YXJ0XCIsIFwidzpib29rbWFya0VuZFwiXSxcbiAgICBleHBhbmRUYWdzOiBbe1xuICAgICAgY29udGFpbnM6IFwidzp0Y1wiLFxuICAgICAgZXhwYW5kOiBcInc6dHJcIlxuICAgIH1dLFxuICAgIG9uUGFyYWdyYXBoTG9vcDogW3tcbiAgICAgIGNvbnRhaW5zOiBcInc6cFwiLFxuICAgICAgZXhwYW5kOiBcInc6cFwiLFxuICAgICAgb25seVRleHRJblRhZzogdHJ1ZVxuICAgIH1dLFxuICAgIHRhZ1Jhd1htbDogXCJ3OnBcIixcbiAgICBiYXNlTW9kdWxlczogW2xvb3BNb2R1bGUsIHNwYWNlUHJlc2VydmVNb2R1bGUsIGV4cGFuZFBhaXJUcmFpdCwgcmF3WG1sTW9kdWxlLCByZW5kZXJdLFxuICAgIHRhZ1Nob3VsZENvbnRhaW46IFt7XG4gICAgICB0YWc6IFwidzpzZHRDb250ZW50XCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJ3OnBcIiwgXCJ3OnJcIiwgXCJ3OmNvbW1lbnRSYW5nZVN0YXJ0XCIsIFwidzpzZHRcIl0sXG4gICAgICB2YWx1ZTogXCI8dzpwPjwvdzpwPlwiXG4gICAgfSwge1xuICAgICAgdGFnOiBcInc6dGNcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcInc6cFwiXSxcbiAgICAgIHZhbHVlOiBcIjx3OnA+PC93OnA+XCJcbiAgICB9LCB7XG4gICAgICB0YWc6IFwidzp0clwiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1widzp0Y1wiXSxcbiAgICAgIGRyb3A6IHRydWVcbiAgICB9LCB7XG4gICAgICB0YWc6IFwidzp0YmxcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcInc6dHJcIl0sXG4gICAgICBkcm9wOiB0cnVlXG4gICAgfV1cbiAgfTtcbn1cbmZ1bmN0aW9uIFBwdFhGaWxlVHlwZUNvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXRUZW1wbGF0ZWRGaWxlczogZnVuY3Rpb24gZ2V0VGVtcGxhdGVkRmlsZXMoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICB0ZXh0UGF0aDogZnVuY3Rpb24gdGV4dFBhdGgoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLnRleHRUYXJnZXQ7XG4gICAgfSxcbiAgICB0YWdzWG1sVGV4dEFycmF5OiBbXCJDb21wYW55XCIsIFwiSHlwZXJsaW5rQmFzZVwiLCBcIk1hbmFnZXJcIiwgXCJjcDpjYXRlZ29yeVwiLCBcImNwOmtleXdvcmRzXCIsIFwiZGM6Y3JlYXRvclwiLCBcImRjOmRlc2NyaXB0aW9uXCIsIFwiZGM6c3ViamVjdFwiLCBcImRjOnRpdGxlXCIsIFwiYTp0XCIsIFwibTp0XCIsIFwidnQ6bHBzdHJcIiwgXCJ2dDpscHdzdHJcIl0sXG4gICAgdGFnc1htbExleGVkQXJyYXk6IFtcInA6c3BcIiwgXCJhOnRjXCIsIFwiYTp0clwiLCBcImE6dGJsXCIsIFwiYTpncmFwaGljRGF0YVwiLCBcImE6cFwiLCBcImE6clwiLCBcImE6clByXCIsIFwicDp0eEJvZHlcIiwgXCJhOnR4Qm9keVwiLCBcImE6b2ZmXCIsIFwiYTpleHRcIiwgXCJwOmdyYXBoaWNGcmFtZVwiLCBcInA6eGZybVwiLCBcImExNjpyb3dJZFwiLCBcImE6ZW5kUGFyYVJQclwiXSxcbiAgICBkcm9wcGVkVGFnc0luc2lkZVBsYWNlaG9sZGVyOiBbXCJhOnBcIiwgXCJhOmVuZFBhcmFSUHJcIl0sXG4gICAgZXhwYW5kVGFnczogW3tcbiAgICAgIGNvbnRhaW5zOiBcImE6dGNcIixcbiAgICAgIGV4cGFuZDogXCJhOnRyXCJcbiAgICB9XSxcbiAgICBvblBhcmFncmFwaExvb3A6IFt7XG4gICAgICBjb250YWluczogXCJhOnBcIixcbiAgICAgIGV4cGFuZDogXCJhOnBcIixcbiAgICAgIG9ubHlUZXh0SW5UYWc6IHRydWVcbiAgICB9XSxcbiAgICB0YWdSYXdYbWw6IFwicDpzcFwiLFxuICAgIGJhc2VNb2R1bGVzOiBbbG9vcE1vZHVsZSwgZXhwYW5kUGFpclRyYWl0LCByYXdYbWxNb2R1bGUsIHJlbmRlcl0sXG4gICAgdGFnU2hvdWxkQ29udGFpbjogW3tcbiAgICAgIHRhZzogXCJhOnRibFwiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1wiYTp0clwiXSxcbiAgICAgIGRyb3BQYXJlbnQ6IFwicDpncmFwaGljRnJhbWVcIlxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJwOnR4Qm9keVwiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1wiYTpwXCJdLFxuICAgICAgdmFsdWU6IFwiPGE6cD48L2E6cD5cIlxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJhOnR4Qm9keVwiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1wiYTpwXCJdLFxuICAgICAgdmFsdWU6IFwiPGE6cD48L2E6cD5cIlxuICAgIH1dXG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZG9jeDogRG9jWEZpbGVUeXBlQ29uZmlnLFxuICBwcHR4OiBQcHRYRmlsZVR5cGVDb25maWdcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/file-type-config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/filetypes.js":
/*!****************************************************!*\
  !*** ./node_modules/docxtemplater/js/filetypes.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\n\nvar docxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\";\nvar docxmContentType = \"application/vnd.ms-word.document.macroEnabled.main+xml\";\nvar dotxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\";\nvar dotmContentType = \"application/vnd.ms-word.template.macroEnabledTemplate.main+xml\";\nvar headerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\";\nvar footnotesContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\";\nvar commentsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml\";\nvar footerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\";\nvar pptxContentType = \"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\";\nvar pptxSlideMaster = \"application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml\";\nvar pptxSlideLayout = \"application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml\";\nvar pptxPresentationContentType = \"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\";\nvar xlsxContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\";\nvar xlsmContentType = \"application/vnd.ms-excel.sheet.macroEnabled.main+xml\";\nvar xlsxWorksheetContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\";\n/*\n * This is used for the main part of the document, ie usually that would be the\n * type of word/document.xml\n */\nvar main = [docxContentType, docxmContentType, dotxContentType, dotmContentType];\nvar filetypes = {\n  main: main,\n  docx: [headerContentType].concat(main, [footerContentType, footnotesContentType, commentsContentType]),\n  pptx: [pptxContentType, pptxSlideMaster, pptxSlideLayout, pptxPresentationContentType],\n  xlsx: [xlsxContentType, xlsmContentType, xlsxWorksheetContentType]\n};\nmodule.exports = filetypes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9maWxldHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2ZpbGV0eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGRvY3hDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQubWFpbit4bWxcIjtcbnZhciBkb2N4bUNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQubXMtd29yZC5kb2N1bWVudC5tYWNyb0VuYWJsZWQubWFpbit4bWxcIjtcbnZhciBkb3R4Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLnRlbXBsYXRlLm1haW4reG1sXCI7XG52YXIgZG90bUNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQubXMtd29yZC50ZW1wbGF0ZS5tYWNyb0VuYWJsZWRUZW1wbGF0ZS5tYWluK3htbFwiO1xudmFyIGhlYWRlckNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5oZWFkZXIreG1sXCI7XG52YXIgZm9vdG5vdGVzQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmZvb3Rub3Rlcyt4bWxcIjtcbnZhciBjb21tZW50c0NvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5jb21tZW50cyt4bWxcIjtcbnZhciBmb290ZXJDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZm9vdGVyK3htbFwiO1xudmFyIHBwdHhDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlK3htbFwiO1xudmFyIHBwdHhTbGlkZU1hc3RlciA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlTWFzdGVyK3htbFwiO1xudmFyIHBwdHhTbGlkZUxheW91dCA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlTGF5b3V0K3htbFwiO1xudmFyIHBwdHhQcmVzZW50YXRpb25Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvbi5tYWluK3htbFwiO1xudmFyIHhsc3hDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQubWFpbit4bWxcIjtcbnZhciB4bHNtQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5tYWNyb0VuYWJsZWQubWFpbit4bWxcIjtcbnZhciB4bHN4V29ya3NoZWV0Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLndvcmtzaGVldCt4bWxcIjtcbi8qXG4gKiBUaGlzIGlzIHVzZWQgZm9yIHRoZSBtYWluIHBhcnQgb2YgdGhlIGRvY3VtZW50LCBpZSB1c3VhbGx5IHRoYXQgd291bGQgYmUgdGhlXG4gKiB0eXBlIG9mIHdvcmQvZG9jdW1lbnQueG1sXG4gKi9cbnZhciBtYWluID0gW2RvY3hDb250ZW50VHlwZSwgZG9jeG1Db250ZW50VHlwZSwgZG90eENvbnRlbnRUeXBlLCBkb3RtQ29udGVudFR5cGVdO1xudmFyIGZpbGV0eXBlcyA9IHtcbiAgbWFpbjogbWFpbixcbiAgZG9jeDogW2hlYWRlckNvbnRlbnRUeXBlXS5jb25jYXQobWFpbiwgW2Zvb3RlckNvbnRlbnRUeXBlLCBmb290bm90ZXNDb250ZW50VHlwZSwgY29tbWVudHNDb250ZW50VHlwZV0pLFxuICBwcHR4OiBbcHB0eENvbnRlbnRUeXBlLCBwcHR4U2xpZGVNYXN0ZXIsIHBwdHhTbGlkZUxheW91dCwgcHB0eFByZXNlbnRhdGlvbkNvbnRlbnRUeXBlXSxcbiAgeGxzeDogW3hsc3hDb250ZW50VHlwZSwgeGxzbUNvbnRlbnRUeXBlLCB4bHN4V29ya3NoZWV0Q29udGVudFR5cGVdXG59O1xubW9kdWxlLmV4cG9ydHMgPSBmaWxldHlwZXM7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/filetypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/get-resolved-id.js":
/*!**********************************************************!*\
  !*** ./node_modules/docxtemplater/js/get-resolved-id.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("\n\nfunction getResolvedId(part, options) {\n  if (part.lIndex == null) {\n    return null;\n  }\n  var path = options.scopeManager.scopePathItem;\n  if (part.parentPart) {\n    path = path.slice(0, path.length - 1);\n  }\n  var res = options.filePath + \"@\" + part.lIndex.toString() + \"-\" + path.join(\"-\");\n  return res;\n}\nmodule.exports = getResolvedId;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtcmVzb2x2ZWQtaWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2dldC1yZXNvbHZlZC1pZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0UmVzb2x2ZWRJZChwYXJ0LCBvcHRpb25zKSB7XG4gIGlmIChwYXJ0LmxJbmRleCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHBhdGggPSBvcHRpb25zLnNjb3BlTWFuYWdlci5zY29wZVBhdGhJdGVtO1xuICBpZiAocGFydC5wYXJlbnRQYXJ0KSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcGF0aC5sZW5ndGggLSAxKTtcbiAgfVxuICB2YXIgcmVzID0gb3B0aW9ucy5maWxlUGF0aCArIFwiQFwiICsgcGFydC5sSW5kZXgudG9TdHJpbmcoKSArIFwiLVwiICsgcGF0aC5qb2luKFwiLVwiKTtcbiAgcmV0dXJuIHJlcztcbn1cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmVzb2x2ZWRJZDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/get-resolved-id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/get-tags.js":
/*!***************************************************!*\
  !*** ./node_modules/docxtemplater/js/get-tags.js ***!
  \***************************************************/
/***/ ((module) => {

eval("\n\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction isPlaceholder(part) {\n  return part.type === \"placeholder\";\n}\n\n/* eslint-disable-next-line complexity */\nfunction getTags(postParsed) {\n  var tags = {};\n  var stack = [{\n    items: postParsed.filter(isPlaceholder),\n    parents: [],\n    path: []\n  }];\n  function processFiltered(part, current, filtered) {\n    if (filtered.length) {\n      stack.push({\n        items: filtered,\n        parents: [].concat(_toConsumableArray(current.parents), [part]),\n        path: part.dataBound !== false && !part.attrParsed && part.value && !part.attrParsed ? [].concat(_toConsumableArray(current.path), [part.value]) : _toConsumableArray(current.path)\n      });\n    }\n  }\n  function getLocalTags(tags, path) {\n    var sizeScope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.length;\n    var localTags = tags;\n    for (var i = 0; i < sizeScope; i++) {\n      localTags = localTags[path[i]];\n    }\n    return localTags;\n  }\n  function getScopeSize(part, parents) {\n    return parents.reduce(function (size, parent) {\n      var lIndexLoop = typeof parent.lIndex === \"number\" ? parent.lIndex : parseInt(parent.lIndex.split(\"-\")[0], 10);\n      return lIndexLoop > part.lIndex ? size - 1 : size;\n    }, parents.length);\n  }\n  while (stack.length > 0) {\n    var current = stack.pop();\n    var localTags = getLocalTags(tags, current.path);\n    for (var _i2 = 0, _current$items2 = current.items; _i2 < _current$items2.length; _i2++) {\n      var _localTags4, _part$value2;\n      var part = _current$items2[_i2];\n      if (part.attrParsed) {\n        for (var key in part.attrParsed) {\n          processFiltered(part, current, part.attrParsed[key].filter(isPlaceholder));\n        }\n        continue;\n      }\n      if (part.subparsed) {\n        if (part.dataBound !== false) {\n          var _localTags, _part$value;\n          (_localTags = localTags)[_part$value = part.value] || (_localTags[_part$value] = {});\n        }\n        processFiltered(part, current, part.subparsed.filter(isPlaceholder));\n        continue;\n      }\n      if (part.cellParsed) {\n        for (var _i4 = 0, _part$cellPostParsed2 = part.cellPostParsed; _i4 < _part$cellPostParsed2.length; _i4++) {\n          var cp = _part$cellPostParsed2[_i4];\n          if (cp.type === \"placeholder\") {\n            if (cp.module === \"pro-xml-templating/xls-module-loop\") {\n              continue;\n            } else if (cp.subparsed) {\n              var _localTags2, _cp$value;\n              (_localTags2 = localTags)[_cp$value = cp.value] || (_localTags2[_cp$value] = {});\n              processFiltered(cp, current, cp.subparsed.filter(isPlaceholder));\n            } else {\n              var _localTags3, _cp$value2;\n              var sizeScope = getScopeSize(part, current.parents);\n              localTags = getLocalTags(tags, current.path, sizeScope);\n              (_localTags3 = localTags)[_cp$value2 = cp.value] || (_localTags3[_cp$value2] = {});\n            }\n          }\n        }\n        continue;\n      }\n      if (part.dataBound === false) {\n        continue;\n      }\n      (_localTags4 = localTags)[_part$value2 = part.value] || (_localTags4[_part$value2] = {});\n    }\n  }\n  return tags;\n}\nmodule.exports = {\n  getTags: getTags,\n  isPlaceholder: isPlaceholder\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtdGFncy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsOEJBQThCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxvQ0FBb0M7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9nZXQtdGFncy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7IGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIGlzUGxhY2Vob2xkZXIocGFydCkge1xuICByZXR1cm4gcGFydC50eXBlID09PSBcInBsYWNlaG9sZGVyXCI7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5ICovXG5mdW5jdGlvbiBnZXRUYWdzKHBvc3RQYXJzZWQpIHtcbiAgdmFyIHRhZ3MgPSB7fTtcbiAgdmFyIHN0YWNrID0gW3tcbiAgICBpdGVtczogcG9zdFBhcnNlZC5maWx0ZXIoaXNQbGFjZWhvbGRlciksXG4gICAgcGFyZW50czogW10sXG4gICAgcGF0aDogW11cbiAgfV07XG4gIGZ1bmN0aW9uIHByb2Nlc3NGaWx0ZXJlZChwYXJ0LCBjdXJyZW50LCBmaWx0ZXJlZCkge1xuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICBpdGVtczogZmlsdGVyZWQsXG4gICAgICAgIHBhcmVudHM6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY3VycmVudC5wYXJlbnRzKSwgW3BhcnRdKSxcbiAgICAgICAgcGF0aDogcGFydC5kYXRhQm91bmQgIT09IGZhbHNlICYmICFwYXJ0LmF0dHJQYXJzZWQgJiYgcGFydC52YWx1ZSAmJiAhcGFydC5hdHRyUGFyc2VkID8gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjdXJyZW50LnBhdGgpLCBbcGFydC52YWx1ZV0pIDogX3RvQ29uc3VtYWJsZUFycmF5KGN1cnJlbnQucGF0aClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRMb2NhbFRhZ3ModGFncywgcGF0aCkge1xuICAgIHZhciBzaXplU2NvcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHBhdGgubGVuZ3RoO1xuICAgIHZhciBsb2NhbFRhZ3MgPSB0YWdzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVNjb3BlOyBpKyspIHtcbiAgICAgIGxvY2FsVGFncyA9IGxvY2FsVGFnc1twYXRoW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsVGFncztcbiAgfVxuICBmdW5jdGlvbiBnZXRTY29wZVNpemUocGFydCwgcGFyZW50cykge1xuICAgIHJldHVybiBwYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgcGFyZW50KSB7XG4gICAgICB2YXIgbEluZGV4TG9vcCA9IHR5cGVvZiBwYXJlbnQubEluZGV4ID09PSBcIm51bWJlclwiID8gcGFyZW50LmxJbmRleCA6IHBhcnNlSW50KHBhcmVudC5sSW5kZXguc3BsaXQoXCItXCIpWzBdLCAxMCk7XG4gICAgICByZXR1cm4gbEluZGV4TG9vcCA+IHBhcnQubEluZGV4ID8gc2l6ZSAtIDEgOiBzaXplO1xuICAgIH0sIHBhcmVudHMubGVuZ3RoKTtcbiAgfVxuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIHZhciBjdXJyZW50ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGxvY2FsVGFncyA9IGdldExvY2FsVGFncyh0YWdzLCBjdXJyZW50LnBhdGgpO1xuICAgIGZvciAodmFyIF9pMiA9IDAsIF9jdXJyZW50JGl0ZW1zMiA9IGN1cnJlbnQuaXRlbXM7IF9pMiA8IF9jdXJyZW50JGl0ZW1zMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgX2xvY2FsVGFnczQsIF9wYXJ0JHZhbHVlMjtcbiAgICAgIHZhciBwYXJ0ID0gX2N1cnJlbnQkaXRlbXMyW19pMl07XG4gICAgICBpZiAocGFydC5hdHRyUGFyc2VkKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwYXJ0LmF0dHJQYXJzZWQpIHtcbiAgICAgICAgICBwcm9jZXNzRmlsdGVyZWQocGFydCwgY3VycmVudCwgcGFydC5hdHRyUGFyc2VkW2tleV0uZmlsdGVyKGlzUGxhY2Vob2xkZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LnN1YnBhcnNlZCkge1xuICAgICAgICBpZiAocGFydC5kYXRhQm91bmQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIF9sb2NhbFRhZ3MsIF9wYXJ0JHZhbHVlO1xuICAgICAgICAgIChfbG9jYWxUYWdzID0gbG9jYWxUYWdzKVtfcGFydCR2YWx1ZSA9IHBhcnQudmFsdWVdIHx8IChfbG9jYWxUYWdzW19wYXJ0JHZhbHVlXSA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzRmlsdGVyZWQocGFydCwgY3VycmVudCwgcGFydC5zdWJwYXJzZWQuZmlsdGVyKGlzUGxhY2Vob2xkZXIpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocGFydC5jZWxsUGFyc2VkKSB7XG4gICAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9wYXJ0JGNlbGxQb3N0UGFyc2VkMiA9IHBhcnQuY2VsbFBvc3RQYXJzZWQ7IF9pNCA8IF9wYXJ0JGNlbGxQb3N0UGFyc2VkMi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgdmFyIGNwID0gX3BhcnQkY2VsbFBvc3RQYXJzZWQyW19pNF07XG4gICAgICAgICAgaWYgKGNwLnR5cGUgPT09IFwicGxhY2Vob2xkZXJcIikge1xuICAgICAgICAgICAgaWYgKGNwLm1vZHVsZSA9PT0gXCJwcm8teG1sLXRlbXBsYXRpbmcveGxzLW1vZHVsZS1sb29wXCIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNwLnN1YnBhcnNlZCkge1xuICAgICAgICAgICAgICB2YXIgX2xvY2FsVGFnczIsIF9jcCR2YWx1ZTtcbiAgICAgICAgICAgICAgKF9sb2NhbFRhZ3MyID0gbG9jYWxUYWdzKVtfY3AkdmFsdWUgPSBjcC52YWx1ZV0gfHwgKF9sb2NhbFRhZ3MyW19jcCR2YWx1ZV0gPSB7fSk7XG4gICAgICAgICAgICAgIHByb2Nlc3NGaWx0ZXJlZChjcCwgY3VycmVudCwgY3Auc3VicGFyc2VkLmZpbHRlcihpc1BsYWNlaG9sZGVyKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2xvY2FsVGFnczMsIF9jcCR2YWx1ZTI7XG4gICAgICAgICAgICAgIHZhciBzaXplU2NvcGUgPSBnZXRTY29wZVNpemUocGFydCwgY3VycmVudC5wYXJlbnRzKTtcbiAgICAgICAgICAgICAgbG9jYWxUYWdzID0gZ2V0TG9jYWxUYWdzKHRhZ3MsIGN1cnJlbnQucGF0aCwgc2l6ZVNjb3BlKTtcbiAgICAgICAgICAgICAgKF9sb2NhbFRhZ3MzID0gbG9jYWxUYWdzKVtfY3AkdmFsdWUyID0gY3AudmFsdWVdIHx8IChfbG9jYWxUYWdzM1tfY3AkdmFsdWUyXSA9IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocGFydC5kYXRhQm91bmQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgKF9sb2NhbFRhZ3M0ID0gbG9jYWxUYWdzKVtfcGFydCR2YWx1ZTIgPSBwYXJ0LnZhbHVlXSB8fCAoX2xvY2FsVGFnczRbX3BhcnQkdmFsdWUyXSA9IHt9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhZ3M7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0VGFnczogZ2V0VGFncyxcbiAgaXNQbGFjZWhvbGRlcjogaXNQbGFjZWhvbGRlclxufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/get-tags.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/join-uncorrupt.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/join-uncorrupt.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  startsWith = _require.startsWith,\n  endsWith = _require.endsWith,\n  isStarting = _require.isStarting,\n  isEnding = _require.isEnding,\n  isWhiteSpace = _require.isWhiteSpace;\nvar filetypes = __webpack_require__(/*! ./filetypes.js */ \"(ssr)/./node_modules/docxtemplater/js/filetypes.js\");\nfunction addEmptyParagraphAfterTable(parts) {\n  var lastNonEmpty = \"\";\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var p = parts[i];\n    if (isWhiteSpace(p) || startsWith(p, \"<w:bookmarkEnd\")) {\n      continue;\n    }\n    if (endsWith(lastNonEmpty, \"</w:tbl>\")) {\n      if (!startsWith(p, \"<w:p\") && !startsWith(p, \"<w:tbl\") && !startsWith(p, \"<w:sectPr\")) {\n        p = \"<w:p/>\".concat(p);\n      }\n    }\n    lastNonEmpty = p;\n    parts[i] = p;\n  }\n  return parts;\n}\n\n// eslint-disable-next-line complexity\nfunction joinUncorrupt(parts, options) {\n  var contains = options.fileTypeConfig.tagShouldContain || [];\n  /*\n   * Before doing this \"uncorruption\" method here, this was done with the\n   * `part.emptyValue` trick, however, there were some corruptions that were\n   * not handled, for example with a template like this :\n   *\n   * ------------------------------------------------\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * ------------------------------------------------\n   */\n  var collecting = \"\";\n  var currentlyCollecting = -1;\n  if (filetypes.docx.indexOf(options.contentType) !== -1) {\n    parts = addEmptyParagraphAfterTable(parts);\n  }\n  var startIndex = -1;\n  for (var j = 0, len2 = contains.length; j < len2; j++) {\n    var _contains$j = contains[j],\n      tag = _contains$j.tag,\n      shouldContain = _contains$j.shouldContain,\n      value = _contains$j.value,\n      drop = _contains$j.drop,\n      dropParent = _contains$j.dropParent;\n    for (var i = 0, len = parts.length; i < len; i++) {\n      var part = parts[i];\n      if (currentlyCollecting === j) {\n        if (isEnding(part, tag)) {\n          currentlyCollecting = -1;\n          if (dropParent) {\n            var start = -1;\n            for (var k = startIndex; k > 0; k--) {\n              if (isStarting(parts[k], dropParent)) {\n                start = k;\n                break;\n              }\n            }\n            for (var _k = start; _k <= parts.length; _k++) {\n              if (isEnding(parts[_k], dropParent)) {\n                parts[_k] = \"\";\n                break;\n              }\n              parts[_k] = \"\";\n            }\n          } else {\n            for (var _k2 = startIndex; _k2 <= i; _k2++) {\n              parts[_k2] = \"\";\n            }\n            if (!drop) {\n              parts[i] = collecting + value + part;\n            }\n          }\n        }\n        collecting += part;\n        for (var _k3 = 0, len3 = shouldContain.length; _k3 < len3; _k3++) {\n          var sc = shouldContain[_k3];\n          if (isStarting(part, sc)) {\n            currentlyCollecting = -1;\n            break;\n          }\n        }\n      }\n      if (currentlyCollecting === -1 && isStarting(part, tag) &&\n      /*\n       * To verify that the part doesn't have multiple tags,\n       * such as <w:tc><w:p>\n       */\n      part.substr(1).indexOf(\"<\") === -1) {\n        // self-closing tag such as <w:t/>\n        if (part[part.length - 2] === \"/\") {\n          parts[i] = \"\";\n        } else {\n          startIndex = i;\n          currentlyCollecting = j;\n          collecting = part;\n        }\n      }\n    }\n  }\n  return parts;\n}\nmodule.exports = joinUncorrupt;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9qb2luLXVuY29ycnVwdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDeEM7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXLFFBQVEsVUFBVTtBQUNyQyxRQUFRLFdBQVcsUUFBUSxVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osdUNBQXVDLFVBQVU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2pvaW4tdW5jb3JydXB0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHN0YXJ0c1dpdGggPSBfcmVxdWlyZS5zdGFydHNXaXRoLFxuICBlbmRzV2l0aCA9IF9yZXF1aXJlLmVuZHNXaXRoLFxuICBpc1N0YXJ0aW5nID0gX3JlcXVpcmUuaXNTdGFydGluZyxcbiAgaXNFbmRpbmcgPSBfcmVxdWlyZS5pc0VuZGluZyxcbiAgaXNXaGl0ZVNwYWNlID0gX3JlcXVpcmUuaXNXaGl0ZVNwYWNlO1xudmFyIGZpbGV0eXBlcyA9IHJlcXVpcmUoXCIuL2ZpbGV0eXBlcy5qc1wiKTtcbmZ1bmN0aW9uIGFkZEVtcHR5UGFyYWdyYXBoQWZ0ZXJUYWJsZShwYXJ0cykge1xuICB2YXIgbGFzdE5vbkVtcHR5ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHAgPSBwYXJ0c1tpXTtcbiAgICBpZiAoaXNXaGl0ZVNwYWNlKHApIHx8IHN0YXJ0c1dpdGgocCwgXCI8dzpib29rbWFya0VuZFwiKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChlbmRzV2l0aChsYXN0Tm9uRW1wdHksIFwiPC93OnRibD5cIikpIHtcbiAgICAgIGlmICghc3RhcnRzV2l0aChwLCBcIjx3OnBcIikgJiYgIXN0YXJ0c1dpdGgocCwgXCI8dzp0YmxcIikgJiYgIXN0YXJ0c1dpdGgocCwgXCI8dzpzZWN0UHJcIikpIHtcbiAgICAgICAgcCA9IFwiPHc6cC8+XCIuY29uY2F0KHApO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0Tm9uRW1wdHkgPSBwO1xuICAgIHBhcnRzW2ldID0gcDtcbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBqb2luVW5jb3JydXB0KHBhcnRzLCBvcHRpb25zKSB7XG4gIHZhciBjb250YWlucyA9IG9wdGlvbnMuZmlsZVR5cGVDb25maWcudGFnU2hvdWxkQ29udGFpbiB8fCBbXTtcbiAgLypcbiAgICogQmVmb3JlIGRvaW5nIHRoaXMgXCJ1bmNvcnJ1cHRpb25cIiBtZXRob2QgaGVyZSwgdGhpcyB3YXMgZG9uZSB3aXRoIHRoZVxuICAgKiBgcGFydC5lbXB0eVZhbHVlYCB0cmljaywgaG93ZXZlciwgdGhlcmUgd2VyZSBzb21lIGNvcnJ1cHRpb25zIHRoYXQgd2VyZVxuICAgKiBub3QgaGFuZGxlZCwgZm9yIGV4YW1wbGUgd2l0aCBhIHRlbXBsYXRlIGxpa2UgdGhpcyA6XG4gICAqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiB8IHstdzpwIGZhbHN5fU15IHBhcmF7L2ZhbHN5fSAgIHwgICAgICAgICAgICAgIHxcbiAgICogfCB7LXc6cCBmYWxzeX1NeSBwYXJhey9mYWxzeX0gICB8ICAgICAgICAgICAgICB8XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgdmFyIGNvbGxlY3RpbmcgPSBcIlwiO1xuICB2YXIgY3VycmVudGx5Q29sbGVjdGluZyA9IC0xO1xuICBpZiAoZmlsZXR5cGVzLmRvY3guaW5kZXhPZihvcHRpb25zLmNvbnRlbnRUeXBlKSAhPT0gLTEpIHtcbiAgICBwYXJ0cyA9IGFkZEVtcHR5UGFyYWdyYXBoQWZ0ZXJUYWJsZShwYXJ0cyk7XG4gIH1cbiAgdmFyIHN0YXJ0SW5kZXggPSAtMTtcbiAgZm9yICh2YXIgaiA9IDAsIGxlbjIgPSBjb250YWlucy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgICB2YXIgX2NvbnRhaW5zJGogPSBjb250YWluc1tqXSxcbiAgICAgIHRhZyA9IF9jb250YWlucyRqLnRhZyxcbiAgICAgIHNob3VsZENvbnRhaW4gPSBfY29udGFpbnMkai5zaG91bGRDb250YWluLFxuICAgICAgdmFsdWUgPSBfY29udGFpbnMkai52YWx1ZSxcbiAgICAgIGRyb3AgPSBfY29udGFpbnMkai5kcm9wLFxuICAgICAgZHJvcFBhcmVudCA9IF9jb250YWlucyRqLmRyb3BQYXJlbnQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKGN1cnJlbnRseUNvbGxlY3RpbmcgPT09IGopIHtcbiAgICAgICAgaWYgKGlzRW5kaW5nKHBhcnQsIHRhZykpIHtcbiAgICAgICAgICBjdXJyZW50bHlDb2xsZWN0aW5nID0gLTE7XG4gICAgICAgICAgaWYgKGRyb3BQYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IHN0YXJ0SW5kZXg7IGsgPiAwOyBrLS0pIHtcbiAgICAgICAgICAgICAgaWYgKGlzU3RhcnRpbmcocGFydHNba10sIGRyb3BQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfayA9IHN0YXJ0OyBfayA8PSBwYXJ0cy5sZW5ndGg7IF9rKyspIHtcbiAgICAgICAgICAgICAgaWYgKGlzRW5kaW5nKHBhcnRzW19rXSwgZHJvcFBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1tfa10gPSBcIlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnRzW19rXSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9rMiA9IHN0YXJ0SW5kZXg7IF9rMiA8PSBpOyBfazIrKykge1xuICAgICAgICAgICAgICBwYXJ0c1tfazJdID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHJvcCkge1xuICAgICAgICAgICAgICBwYXJ0c1tpXSA9IGNvbGxlY3RpbmcgKyB2YWx1ZSArIHBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbGxlY3RpbmcgKz0gcGFydDtcbiAgICAgICAgZm9yICh2YXIgX2szID0gMCwgbGVuMyA9IHNob3VsZENvbnRhaW4ubGVuZ3RoOyBfazMgPCBsZW4zOyBfazMrKykge1xuICAgICAgICAgIHZhciBzYyA9IHNob3VsZENvbnRhaW5bX2szXTtcbiAgICAgICAgICBpZiAoaXNTdGFydGluZyhwYXJ0LCBzYykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRseUNvbGxlY3RpbmcgPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRseUNvbGxlY3RpbmcgPT09IC0xICYmIGlzU3RhcnRpbmcocGFydCwgdGFnKSAmJlxuICAgICAgLypcbiAgICAgICAqIFRvIHZlcmlmeSB0aGF0IHRoZSBwYXJ0IGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSB0YWdzLFxuICAgICAgICogc3VjaCBhcyA8dzp0Yz48dzpwPlxuICAgICAgICovXG4gICAgICBwYXJ0LnN1YnN0cigxKS5pbmRleE9mKFwiPFwiKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gc2VsZi1jbG9zaW5nIHRhZyBzdWNoIGFzIDx3OnQvPlxuICAgICAgICBpZiAocGFydFtwYXJ0Lmxlbmd0aCAtIDJdID09PSBcIi9cIikge1xuICAgICAgICAgIHBhcnRzW2ldID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydEluZGV4ID0gaTtcbiAgICAgICAgICBjdXJyZW50bHlDb2xsZWN0aW5nID0gajtcbiAgICAgICAgICBjb2xsZWN0aW5nID0gcGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGpvaW5VbmNvcnJ1cHQ7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/join-uncorrupt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/lexer.js":
/*!************************************************!*\
  !*** ./node_modules/docxtemplater/js/lexer.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"),\n  getUnclosedTagException = _require.getUnclosedTagException,\n  getUnopenedTagException = _require.getUnopenedTagException,\n  getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n  getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n  throwMalformedXml = _require.throwMalformedXml,\n  throwXmlInvalid = _require.throwXmlInvalid,\n  XTTemplateError = _require.XTTemplateError;\nvar _require2 = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  isTextStart = _require2.isTextStart,\n  isTextEnd = _require2.isTextEnd,\n  wordToUtf8 = _require2.wordToUtf8;\nvar DELIMITER_NONE = 0,\n  DELIMITER_EQUAL = 1,\n  DELIMITER_START = 2,\n  DELIMITER_END = 3;\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml();\n    }\n    return true;\n  }\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml();\n    }\n    return false;\n  }\n  return inTextTag;\n}\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = {};\n  for (var _i2 = 0; _i2 < textMatchArray.length; _i2++) {\n    var m = textMatchArray[_i2];\n    allMatches[m] = true;\n  }\n  for (var _i4 = 0; _i4 < othersMatchArray.length; _i4++) {\n    var _m = othersMatchArray[_i4];\n    allMatches[_m] = false;\n  }\n  var totalMatches = [];\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n    if (cursor === -1) {\n      break;\n    }\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n    var tagText = content.slice(offset, cursor + 1);\n    var _getTag = getTag(tagText),\n      tag = _getTag.tag,\n      position = _getTag.position;\n    var text = allMatches[tag];\n    if (text == null) {\n      continue;\n    }\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n  return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText, syntaxOptions) {\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  var delimiterWithErrors = delimiterMatches.reduce(function (delimiterAcc, currDelimiterMatch) {\n    var position = currDelimiterMatch.position;\n    var delimiterOffset = currDelimiterMatch.offset;\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    var lastDelimiterLength = lastDelimiterMatch.length;\n    xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset);\n    if (inDelimiter && position === \"start\") {\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        if (!syntaxOptions.allowUnclosedTag) {\n          errors.push(getDuplicateOpenTagException({\n            xtag: xtag,\n            offset: lastDelimiterOffset\n          }));\n          lastDelimiterMatch = currDelimiterMatch;\n          delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n            error: true\n          }));\n          return delimiterAcc;\n        }\n      }\n      if (!syntaxOptions.allowUnclosedTag) {\n        errors.push(getUnclosedTagException({\n          xtag: wordToUtf8(xtag),\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      delimiterAcc.pop();\n    }\n    if (!inDelimiter && position === \"end\") {\n      if (syntaxOptions.allowUnopenedTag) {\n        return delimiterAcc;\n      }\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset - 4, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        errors.push(getDuplicateCloseTagException({\n          xtag: xtag,\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      errors.push(getUnopenedTagException({\n        xtag: xtag,\n        offset: delimiterOffset\n      }));\n      lastDelimiterMatch = currDelimiterMatch;\n      delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n        error: true\n      }));\n      return delimiterAcc;\n    }\n    inDelimiter = position === \"start\";\n    lastDelimiterMatch = currDelimiterMatch;\n    delimiterAcc.push(currDelimiterMatch);\n    return delimiterAcc;\n  }, []);\n  if (inDelimiter) {\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    xtag = fullText.substr(lastDelimiterOffset, fullText.length - lastDelimiterOffset);\n    if (!syntaxOptions.allowUnclosedTag) {\n      errors.push(getUnclosedTagException({\n        xtag: wordToUtf8(xtag),\n        offset: lastDelimiterOffset\n      }));\n    } else {\n      delimiterWithErrors.pop();\n    }\n  }\n  return {\n    delimiterWithErrors: delimiterWithErrors,\n    errors: errors\n  };\n}\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return DELIMITER_NONE;\n  }\n  if (startOffset === endOffset) {\n    return DELIMITER_EQUAL;\n  }\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n  }\n  return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n  if (newDelimiters.length !== 2) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n    start = _newDelimiters[0],\n    end = _newDelimiters[1];\n  if (start.length === 0 || end.length === 0) {\n    var _err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    _err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw _err;\n  }\n  return [start, end];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters, syntaxOptions) {\n  var indexes = [];\n  var start = delimiters.start,\n    end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n  if (start == null && end == null) {\n    // Special case of delimiter set to null/null, no templating is done\n    return [];\n  }\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n    if (compareResult === DELIMITER_EQUAL) {\n      compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n    }\n    switch (compareResult) {\n      case DELIMITER_NONE:\n        return indexes;\n      case DELIMITER_END:\n        insideTag = false;\n        offset = endOffset;\n        position = \"end\";\n        len = end.length;\n        break;\n      case DELIMITER_START:\n        insideTag = true;\n        offset = startOffset;\n        position = \"start\";\n        len = start.length;\n        break;\n    }\n    /*\n     * If tag starts with =, such as {=[ ]=}\n     * then the delimiters will change right after that tag.\n     *\n     * For example, with the following template :\n     *\n     * Hello {foo}, {=[ ]=}what's up with [name] ?\n     *\n     * The \"foo\" tag is a normal tag, the \"=[ ]=\" is a tag to change the\n     * delimiters to \"[\" and \"]\", and the last \"name\" is a tag with the new\n     * delimiters\n     */\n    if (syntaxOptions.changeDelimiterPrefix && compareResult === DELIMITER_START && fullText[offset + start.length] === syntaxOptions.changeDelimiterPrefix) {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(syntaxOptions.changeDelimiterPrefix, offset + start.length + 1);\n      var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n      indexes.push({\n        offset: nextEndOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n      var _splitDelimiters = splitDelimiters(_insideTag);\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = nextEndOffset;\n      continue;\n    }\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\nfunction parseDelimiters(innerContentParts, delimiters, syntaxOptions) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllDelimiterIndexes(full, delimiters, syntaxOptions);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var _getDelimiterErrors = getDelimiterErrors(delimiterMatches, full, syntaxOptions),\n    delimiterWithErrors = _getDelimiterErrors.delimiterWithErrors,\n    errors = _getDelimiterErrors.errors;\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n    while (delimiterIndex < delimiterWithErrors.length && inRange(range, delimiterWithErrors[delimiterIndex])) {\n      delimitersInOffset.push(delimiterWithErrors[delimiterIndex]);\n      delimiterIndex++;\n    }\n    var parts = [];\n    var cursor = 0;\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n    for (var _i6 = 0; _i6 < delimitersInOffset.length; _i6++) {\n      var delimiterInOffset = delimitersInOffset[_i6];\n      var _value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n      if (delimiterInOffset.changedelimiter) {\n        if (delimiterInOffset.position === \"start\") {\n          if (_value.length > 0) {\n            parts.push({\n              type: \"content\",\n              value: _value\n            });\n          }\n        } else {\n          cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        continue;\n      }\n      if (_value.length > 0) {\n        parts.push({\n          type: \"content\",\n          value: _value\n        });\n        cursor += _value.length;\n      }\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    }\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\nfunction isInsideContent(part) {\n  // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n  return part.type === \"content\" && part.position === \"insidetag\";\n  // Stryker restore all\n}\nfunction getContentParts(xmlparsed) {\n  return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed, fileType) {\n  var inTextTag = false;\n  for (var _i8 = 0; _i8 < xmlparsed.length; _i8++) {\n    var part = xmlparsed[_i8];\n    inTextTag = updateInTextTag(part, inTextTag);\n    if (part.type === \"content\") {\n      part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n    }\n    if (fileType !== \"text\" && isInsideContent(part)) {\n      part.value = part.value.replace(/>/g, \"&gt;\");\n    }\n  }\n}\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmllexed, delimiters, syntax, fileType) {\n    decodeContentParts(xmllexed, fileType);\n    var _parseDelimiters = parseDelimiters(getContentParts(xmllexed), delimiters, syntax),\n      delimiterParsed = _parseDelimiters.parsed,\n      errors = _parseDelimiters.errors;\n    var lexed = [];\n    var index = 0;\n    var lIndex = 0;\n    for (var _i10 = 0; _i10 < xmllexed.length; _i10++) {\n      var part = xmllexed[_i10];\n      if (isInsideContent(part)) {\n        for (var _i12 = 0, _delimiterParsed$inde2 = delimiterParsed[index]; _i12 < _delimiterParsed$inde2.length; _i12++) {\n          var p = _delimiterParsed$inde2[_i12];\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n          p.lIndex = lIndex++;\n        }\n        Array.prototype.push.apply(lexed, delimiterParsed[index]);\n        index++;\n      } else {\n        part.lIndex = lIndex++;\n        lexed.push(part);\n      }\n    }\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = matches.reduce(function (parsed, match) {\n      if (content.length > cursor && match.offset - cursor > 0) {\n        parsed.push({\n          type: \"content\",\n          value: content.substr(cursor, match.offset - cursor)\n        });\n      }\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n      parsed.push(match);\n      return parsed;\n    }, []);\n    if (content.length > cursor) {\n      parsed.push({\n        type: \"content\",\n        value: content.substr(cursor)\n      });\n    }\n    return parsed;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9sZXhlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSixtQ0FBbUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUN6SSx1Q0FBdUMsa0dBQWtHLGlCQUFpQix3Q0FBd0MsTUFBTSx5Q0FBeUMsNkJBQTZCLFVBQVUsWUFBWSxrRUFBa0UsV0FBVyxZQUFZLGlCQUFpQixVQUFVLE1BQU0saUZBQWlGLFVBQVUsb0JBQW9CO0FBQzdnQiw4QkFBOEI7QUFDOUIseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGVBQWUsbUJBQU8sQ0FBQyxvRUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSwwREFBMEQseUJBQXlCO0FBQ25GO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0RBQXdELHlCQUF5QjtBQUNqRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdEQUF3RCx5QkFBeUI7QUFDakY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNEQUFzRCx5QkFBeUI7QUFDL0U7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSSxHQUFHLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0EsNEVBQTRFLHNDQUFzQztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2xleGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24gPSBfcmVxdWlyZS5nZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbixcbiAgZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb24gPSBfcmVxdWlyZS5nZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbixcbiAgZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24sXG4gIGdldER1cGxpY2F0ZUNsb3NlVGFnRXhjZXB0aW9uID0gX3JlcXVpcmUuZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24sXG4gIHRocm93TWFsZm9ybWVkWG1sID0gX3JlcXVpcmUudGhyb3dNYWxmb3JtZWRYbWwsXG4gIHRocm93WG1sSW52YWxpZCA9IF9yZXF1aXJlLnRocm93WG1sSW52YWxpZCxcbiAgWFRUZW1wbGF0ZUVycm9yID0gX3JlcXVpcmUuWFRUZW1wbGF0ZUVycm9yO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgaXNUZXh0U3RhcnQgPSBfcmVxdWlyZTIuaXNUZXh0U3RhcnQsXG4gIGlzVGV4dEVuZCA9IF9yZXF1aXJlMi5pc1RleHRFbmQsXG4gIHdvcmRUb1V0ZjggPSBfcmVxdWlyZTIud29yZFRvVXRmODtcbnZhciBERUxJTUlURVJfTk9ORSA9IDAsXG4gIERFTElNSVRFUl9FUVVBTCA9IDEsXG4gIERFTElNSVRFUl9TVEFSVCA9IDIsXG4gIERFTElNSVRFUl9FTkQgPSAzO1xuZnVuY3Rpb24gaW5SYW5nZShyYW5nZSwgbWF0Y2gpIHtcbiAgcmV0dXJuIHJhbmdlWzBdIDw9IG1hdGNoLm9mZnNldCAmJiBtYXRjaC5vZmZzZXQgPCByYW5nZVsxXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUluVGV4dFRhZyhwYXJ0LCBpblRleHRUYWcpIHtcbiAgaWYgKGlzVGV4dFN0YXJ0KHBhcnQpKSB7XG4gICAgaWYgKGluVGV4dFRhZykge1xuICAgICAgdGhyb3dNYWxmb3JtZWRYbWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzVGV4dEVuZChwYXJ0KSkge1xuICAgIGlmICghaW5UZXh0VGFnKSB7XG4gICAgICB0aHJvd01hbGZvcm1lZFhtbCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGluVGV4dFRhZztcbn1cbmZ1bmN0aW9uIGdldFRhZyh0YWcpIHtcbiAgdmFyIHBvc2l0aW9uID0gXCJcIjtcbiAgdmFyIHN0YXJ0ID0gMTtcbiAgdmFyIGVuZCA9IHRhZy5pbmRleE9mKFwiIFwiKTtcbiAgaWYgKHRhZ1t0YWcubGVuZ3RoIC0gMl0gPT09IFwiL1wiKSB7XG4gICAgcG9zaXRpb24gPSBcInNlbGZjbG9zaW5nXCI7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIGVuZCA9IHRhZy5sZW5ndGggLSAyO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YWdbMV0gPT09IFwiL1wiKSB7XG4gICAgc3RhcnQgPSAyO1xuICAgIHBvc2l0aW9uID0gXCJlbmRcIjtcbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgZW5kID0gdGFnLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBvc2l0aW9uID0gXCJzdGFydFwiO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICBlbmQgPSB0YWcubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0YWc6IHRhZy5zbGljZShzdGFydCwgZW5kKSxcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIHRhZ01hdGNoZXIoY29udGVudCwgdGV4dE1hdGNoQXJyYXksIG90aGVyc01hdGNoQXJyYXkpIHtcbiAgdmFyIGN1cnNvciA9IDA7XG4gIHZhciBjb250ZW50TGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHZhciBhbGxNYXRjaGVzID0ge307XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRleHRNYXRjaEFycmF5Lmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgbSA9IHRleHRNYXRjaEFycmF5W19pMl07XG4gICAgYWxsTWF0Y2hlc1ttXSA9IHRydWU7XG4gIH1cbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgb3RoZXJzTWF0Y2hBcnJheS5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIF9tID0gb3RoZXJzTWF0Y2hBcnJheVtfaTRdO1xuICAgIGFsbE1hdGNoZXNbX21dID0gZmFsc2U7XG4gIH1cbiAgdmFyIHRvdGFsTWF0Y2hlcyA9IFtdO1xuICB3aGlsZSAoY3Vyc29yIDwgY29udGVudExlbmd0aCkge1xuICAgIGN1cnNvciA9IGNvbnRlbnQuaW5kZXhPZihcIjxcIiwgY3Vyc29yKTtcbiAgICBpZiAoY3Vyc29yID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSBjdXJzb3I7XG4gICAgdmFyIG5leHRPcGVuaW5nID0gY29udGVudC5pbmRleE9mKFwiPFwiLCBjdXJzb3IgKyAxKTtcbiAgICBjdXJzb3IgPSBjb250ZW50LmluZGV4T2YoXCI+XCIsIGN1cnNvcik7XG4gICAgaWYgKGN1cnNvciA9PT0gLTEgfHwgbmV4dE9wZW5pbmcgIT09IC0xICYmIGN1cnNvciA+IG5leHRPcGVuaW5nKSB7XG4gICAgICB0aHJvd1htbEludmFsaWQoY29udGVudCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdmFyIHRhZ1RleHQgPSBjb250ZW50LnNsaWNlKG9mZnNldCwgY3Vyc29yICsgMSk7XG4gICAgdmFyIF9nZXRUYWcgPSBnZXRUYWcodGFnVGV4dCksXG4gICAgICB0YWcgPSBfZ2V0VGFnLnRhZyxcbiAgICAgIHBvc2l0aW9uID0gX2dldFRhZy5wb3NpdGlvbjtcbiAgICB2YXIgdGV4dCA9IGFsbE1hdGNoZXNbdGFnXTtcbiAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdG90YWxNYXRjaGVzLnB1c2goe1xuICAgICAgdHlwZTogXCJ0YWdcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIHZhbHVlOiB0YWdUZXh0LFxuICAgICAgdGFnOiB0YWdcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdG90YWxNYXRjaGVzO1xufVxuZnVuY3Rpb24gZ2V0RGVsaW1pdGVyRXJyb3JzKGRlbGltaXRlck1hdGNoZXMsIGZ1bGxUZXh0LCBzeW50YXhPcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIGluRGVsaW1pdGVyID0gZmFsc2U7XG4gIHZhciBsYXN0RGVsaW1pdGVyTWF0Y2ggPSB7XG4gICAgb2Zmc2V0OiAwXG4gIH07XG4gIHZhciB4dGFnO1xuICB2YXIgZGVsaW1pdGVyV2l0aEVycm9ycyA9IGRlbGltaXRlck1hdGNoZXMucmVkdWNlKGZ1bmN0aW9uIChkZWxpbWl0ZXJBY2MsIGN1cnJEZWxpbWl0ZXJNYXRjaCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGN1cnJEZWxpbWl0ZXJNYXRjaC5wb3NpdGlvbjtcbiAgICB2YXIgZGVsaW1pdGVyT2Zmc2V0ID0gY3VyckRlbGltaXRlck1hdGNoLm9mZnNldDtcbiAgICB2YXIgbGFzdERlbGltaXRlck9mZnNldCA9IGxhc3REZWxpbWl0ZXJNYXRjaC5vZmZzZXQ7XG4gICAgdmFyIGxhc3REZWxpbWl0ZXJMZW5ndGggPSBsYXN0RGVsaW1pdGVyTWF0Y2gubGVuZ3RoO1xuICAgIHh0YWcgPSBmdWxsVGV4dC5zdWJzdHIobGFzdERlbGltaXRlck9mZnNldCwgZGVsaW1pdGVyT2Zmc2V0IC0gbGFzdERlbGltaXRlck9mZnNldCk7XG4gICAgaWYgKGluRGVsaW1pdGVyICYmIHBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcbiAgICAgIGlmIChsYXN0RGVsaW1pdGVyT2Zmc2V0ICsgbGFzdERlbGltaXRlckxlbmd0aCA9PT0gZGVsaW1pdGVyT2Zmc2V0KSB7XG4gICAgICAgIHh0YWcgPSBmdWxsVGV4dC5zdWJzdHIobGFzdERlbGltaXRlck9mZnNldCwgZGVsaW1pdGVyT2Zmc2V0IC0gbGFzdERlbGltaXRlck9mZnNldCArIGxhc3REZWxpbWl0ZXJMZW5ndGggKyA0KTtcbiAgICAgICAgaWYgKCFzeW50YXhPcHRpb25zLmFsbG93VW5jbG9zZWRUYWcpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChnZXREdXBsaWNhdGVPcGVuVGFnRXhjZXB0aW9uKHtcbiAgICAgICAgICAgIHh0YWc6IHh0YWcsXG4gICAgICAgICAgICBvZmZzZXQ6IGxhc3REZWxpbWl0ZXJPZmZzZXRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgICAgICAgIGRlbGltaXRlckFjYy5wdXNoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3VyckRlbGltaXRlck1hdGNoKSwge30sIHtcbiAgICAgICAgICAgIGVycm9yOiB0cnVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghc3ludGF4T3B0aW9ucy5hbGxvd1VuY2xvc2VkVGFnKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGdldFVuY2xvc2VkVGFnRXhjZXB0aW9uKHtcbiAgICAgICAgICB4dGFnOiB3b3JkVG9VdGY4KHh0YWcpLFxuICAgICAgICAgIG9mZnNldDogbGFzdERlbGltaXRlck9mZnNldFxuICAgICAgICB9KSk7XG4gICAgICAgIGxhc3REZWxpbWl0ZXJNYXRjaCA9IGN1cnJEZWxpbWl0ZXJNYXRjaDtcbiAgICAgICAgZGVsaW1pdGVyQWNjLnB1c2goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjdXJyRGVsaW1pdGVyTWF0Y2gpLCB7fSwge1xuICAgICAgICAgIGVycm9yOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgICAgIH1cbiAgICAgIGRlbGltaXRlckFjYy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKCFpbkRlbGltaXRlciAmJiBwb3NpdGlvbiA9PT0gXCJlbmRcIikge1xuICAgICAgaWYgKHN5bnRheE9wdGlvbnMuYWxsb3dVbm9wZW5lZFRhZykge1xuICAgICAgICByZXR1cm4gZGVsaW1pdGVyQWNjO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3REZWxpbWl0ZXJPZmZzZXQgKyBsYXN0RGVsaW1pdGVyTGVuZ3RoID09PSBkZWxpbWl0ZXJPZmZzZXQpIHtcbiAgICAgICAgeHRhZyA9IGZ1bGxUZXh0LnN1YnN0cihsYXN0RGVsaW1pdGVyT2Zmc2V0IC0gNCwgZGVsaW1pdGVyT2Zmc2V0IC0gbGFzdERlbGltaXRlck9mZnNldCArIGxhc3REZWxpbWl0ZXJMZW5ndGggKyA0KTtcbiAgICAgICAgZXJyb3JzLnB1c2goZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24oe1xuICAgICAgICAgIHh0YWc6IHh0YWcsXG4gICAgICAgICAgb2Zmc2V0OiBsYXN0RGVsaW1pdGVyT2Zmc2V0XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgICAgICBkZWxpbWl0ZXJBY2MucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGN1cnJEZWxpbWl0ZXJNYXRjaCksIHt9LCB7XG4gICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZGVsaW1pdGVyQWNjO1xuICAgICAgfVxuICAgICAgZXJyb3JzLnB1c2goZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb24oe1xuICAgICAgICB4dGFnOiB4dGFnLFxuICAgICAgICBvZmZzZXQ6IGRlbGltaXRlck9mZnNldFxuICAgICAgfSkpO1xuICAgICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgICAgZGVsaW1pdGVyQWNjLnB1c2goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjdXJyRGVsaW1pdGVyTWF0Y2gpLCB7fSwge1xuICAgICAgICBlcnJvcjogdHJ1ZVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgICB9XG4gICAgaW5EZWxpbWl0ZXIgPSBwb3NpdGlvbiA9PT0gXCJzdGFydFwiO1xuICAgIGxhc3REZWxpbWl0ZXJNYXRjaCA9IGN1cnJEZWxpbWl0ZXJNYXRjaDtcbiAgICBkZWxpbWl0ZXJBY2MucHVzaChjdXJyRGVsaW1pdGVyTWF0Y2gpO1xuICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gIH0sIFtdKTtcbiAgaWYgKGluRGVsaW1pdGVyKSB7XG4gICAgdmFyIGxhc3REZWxpbWl0ZXJPZmZzZXQgPSBsYXN0RGVsaW1pdGVyTWF0Y2gub2Zmc2V0O1xuICAgIHh0YWcgPSBmdWxsVGV4dC5zdWJzdHIobGFzdERlbGltaXRlck9mZnNldCwgZnVsbFRleHQubGVuZ3RoIC0gbGFzdERlbGltaXRlck9mZnNldCk7XG4gICAgaWYgKCFzeW50YXhPcHRpb25zLmFsbG93VW5jbG9zZWRUYWcpIHtcbiAgICAgIGVycm9ycy5wdXNoKGdldFVuY2xvc2VkVGFnRXhjZXB0aW9uKHtcbiAgICAgICAgeHRhZzogd29yZFRvVXRmOCh4dGFnKSxcbiAgICAgICAgb2Zmc2V0OiBsYXN0RGVsaW1pdGVyT2Zmc2V0XG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGltaXRlcldpdGhFcnJvcnMucG9wKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZGVsaW1pdGVyV2l0aEVycm9yczogZGVsaW1pdGVyV2l0aEVycm9ycyxcbiAgICBlcnJvcnM6IGVycm9yc1xuICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZU9mZnNldHMoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICBpZiAoc3RhcnRPZmZzZXQgPT09IC0xICYmIGVuZE9mZnNldCA9PT0gLTEpIHtcbiAgICByZXR1cm4gREVMSU1JVEVSX05PTkU7XG4gIH1cbiAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQpIHtcbiAgICByZXR1cm4gREVMSU1JVEVSX0VRVUFMO1xuICB9XG4gIGlmIChzdGFydE9mZnNldCA9PT0gLTEgfHwgZW5kT2Zmc2V0ID09PSAtMSkge1xuICAgIHJldHVybiBlbmRPZmZzZXQgPCBzdGFydE9mZnNldCA/IERFTElNSVRFUl9TVEFSVCA6IERFTElNSVRFUl9FTkQ7XG4gIH1cbiAgcmV0dXJuIHN0YXJ0T2Zmc2V0IDwgZW5kT2Zmc2V0ID8gREVMSU1JVEVSX1NUQVJUIDogREVMSU1JVEVSX0VORDtcbn1cbmZ1bmN0aW9uIHNwbGl0RGVsaW1pdGVycyhpbnNpZGUpIHtcbiAgdmFyIG5ld0RlbGltaXRlcnMgPSBpbnNpZGUuc3BsaXQoXCIgXCIpO1xuICBpZiAobmV3RGVsaW1pdGVycy5sZW5ndGggIT09IDIpIHtcbiAgICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIk5ldyBEZWxpbWl0ZXJzIGNhbm5vdCBiZSBwYXJzZWRcIik7XG4gICAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgICBpZDogXCJjaGFuZ2VfZGVsaW1pdGVyc19pbnZhbGlkXCIsXG4gICAgICBleHBsYW5hdGlvbjogXCJDYW5ub3QgcGFyc2VyIGRlbGltaXRlcnNcIlxuICAgIH07XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHZhciBfbmV3RGVsaW1pdGVycyA9IF9zbGljZWRUb0FycmF5KG5ld0RlbGltaXRlcnMsIDIpLFxuICAgIHN0YXJ0ID0gX25ld0RlbGltaXRlcnNbMF0sXG4gICAgZW5kID0gX25ld0RlbGltaXRlcnNbMV07XG4gIGlmIChzdGFydC5sZW5ndGggPT09IDAgfHwgZW5kLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBfZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIk5ldyBEZWxpbWl0ZXJzIGNhbm5vdCBiZSBwYXJzZWRcIik7XG4gICAgX2Vyci5wcm9wZXJ0aWVzID0ge1xuICAgICAgaWQ6IFwiY2hhbmdlX2RlbGltaXRlcnNfaW52YWxpZFwiLFxuICAgICAgZXhwbGFuYXRpb246IFwiQ2Fubm90IHBhcnNlciBkZWxpbWl0ZXJzXCJcbiAgICB9O1xuICAgIHRocm93IF9lcnI7XG4gIH1cbiAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbn1cbmZ1bmN0aW9uIGdldEFsbERlbGltaXRlckluZGV4ZXMoZnVsbFRleHQsIGRlbGltaXRlcnMsIHN5bnRheE9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gZGVsaW1pdGVycy5zdGFydCxcbiAgICBlbmQgPSBkZWxpbWl0ZXJzLmVuZDtcbiAgdmFyIG9mZnNldCA9IC0xO1xuICB2YXIgaW5zaWRlVGFnID0gZmFsc2U7XG4gIGlmIChzdGFydCA9PSBudWxsICYmIGVuZCA9PSBudWxsKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIG9mIGRlbGltaXRlciBzZXQgdG8gbnVsbC9udWxsLCBubyB0ZW1wbGF0aW5nIGlzIGRvbmVcbiAgICByZXR1cm4gW107XG4gIH1cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBmdWxsVGV4dC5pbmRleE9mKHN0YXJ0LCBvZmZzZXQgKyAxKTtcbiAgICB2YXIgZW5kT2Zmc2V0ID0gZnVsbFRleHQuaW5kZXhPZihlbmQsIG9mZnNldCArIDEpO1xuICAgIHZhciBwb3NpdGlvbiA9IG51bGw7XG4gICAgdmFyIGxlbiA9IHZvaWQgMDtcbiAgICB2YXIgY29tcGFyZVJlc3VsdCA9IGNvbXBhcmVPZmZzZXRzKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgIGlmIChjb21wYXJlUmVzdWx0ID09PSBERUxJTUlURVJfRVFVQUwpIHtcbiAgICAgIGNvbXBhcmVSZXN1bHQgPSBpbnNpZGVUYWcgPyBERUxJTUlURVJfRU5EIDogREVMSU1JVEVSX1NUQVJUO1xuICAgIH1cbiAgICBzd2l0Y2ggKGNvbXBhcmVSZXN1bHQpIHtcbiAgICAgIGNhc2UgREVMSU1JVEVSX05PTkU6XG4gICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgICAgY2FzZSBERUxJTUlURVJfRU5EOlxuICAgICAgICBpbnNpZGVUYWcgPSBmYWxzZTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kT2Zmc2V0O1xuICAgICAgICBwb3NpdGlvbiA9IFwiZW5kXCI7XG4gICAgICAgIGxlbiA9IGVuZC5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBERUxJTUlURVJfU1RBUlQ6XG4gICAgICAgIGluc2lkZVRhZyA9IHRydWU7XG4gICAgICAgIG9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICBwb3NpdGlvbiA9IFwic3RhcnRcIjtcbiAgICAgICAgbGVuID0gc3RhcnQubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLypcbiAgICAgKiBJZiB0YWcgc3RhcnRzIHdpdGggPSwgc3VjaCBhcyB7PVsgXT19XG4gICAgICogdGhlbiB0aGUgZGVsaW1pdGVycyB3aWxsIGNoYW5nZSByaWdodCBhZnRlciB0aGF0IHRhZy5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB3aXRoIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgOlxuICAgICAqXG4gICAgICogSGVsbG8ge2Zvb30sIHs9WyBdPX13aGF0J3MgdXAgd2l0aCBbbmFtZV0gP1xuICAgICAqXG4gICAgICogVGhlIFwiZm9vXCIgdGFnIGlzIGEgbm9ybWFsIHRhZywgdGhlIFwiPVsgXT1cIiBpcyBhIHRhZyB0byBjaGFuZ2UgdGhlXG4gICAgICogZGVsaW1pdGVycyB0byBcIltcIiBhbmQgXCJdXCIsIGFuZCB0aGUgbGFzdCBcIm5hbWVcIiBpcyBhIHRhZyB3aXRoIHRoZSBuZXdcbiAgICAgKiBkZWxpbWl0ZXJzXG4gICAgICovXG4gICAgaWYgKHN5bnRheE9wdGlvbnMuY2hhbmdlRGVsaW1pdGVyUHJlZml4ICYmIGNvbXBhcmVSZXN1bHQgPT09IERFTElNSVRFUl9TVEFSVCAmJiBmdWxsVGV4dFtvZmZzZXQgKyBzdGFydC5sZW5ndGhdID09PSBzeW50YXhPcHRpb25zLmNoYW5nZURlbGltaXRlclByZWZpeCkge1xuICAgICAgaW5kZXhlcy5wdXNoKHtcbiAgICAgICAgb2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgcG9zaXRpb246IFwic3RhcnRcIixcbiAgICAgICAgbGVuZ3RoOiBzdGFydC5sZW5ndGgsXG4gICAgICAgIGNoYW5nZWRlbGltaXRlcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2YXIgbmV4dEVxdWFsID0gZnVsbFRleHQuaW5kZXhPZihzeW50YXhPcHRpb25zLmNoYW5nZURlbGltaXRlclByZWZpeCwgb2Zmc2V0ICsgc3RhcnQubGVuZ3RoICsgMSk7XG4gICAgICB2YXIgbmV4dEVuZE9mZnNldCA9IGZ1bGxUZXh0LmluZGV4T2YoZW5kLCBuZXh0RXF1YWwgKyAxKTtcbiAgICAgIGluZGV4ZXMucHVzaCh7XG4gICAgICAgIG9mZnNldDogbmV4dEVuZE9mZnNldCxcbiAgICAgICAgcG9zaXRpb246IFwiZW5kXCIsXG4gICAgICAgIGxlbmd0aDogZW5kLmxlbmd0aCxcbiAgICAgICAgY2hhbmdlZGVsaW1pdGVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhciBfaW5zaWRlVGFnID0gZnVsbFRleHQuc3Vic3RyKG9mZnNldCArIHN0YXJ0Lmxlbmd0aCArIDEsIG5leHRFcXVhbCAtIG9mZnNldCAtIHN0YXJ0Lmxlbmd0aCAtIDEpO1xuICAgICAgdmFyIF9zcGxpdERlbGltaXRlcnMgPSBzcGxpdERlbGltaXRlcnMoX2luc2lkZVRhZyk7XG4gICAgICB2YXIgX3NwbGl0RGVsaW1pdGVyczIgPSBfc2xpY2VkVG9BcnJheShfc3BsaXREZWxpbWl0ZXJzLCAyKTtcbiAgICAgIHN0YXJ0ID0gX3NwbGl0RGVsaW1pdGVyczJbMF07XG4gICAgICBlbmQgPSBfc3BsaXREZWxpbWl0ZXJzMlsxXTtcbiAgICAgIG9mZnNldCA9IG5leHRFbmRPZmZzZXQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaW5kZXhlcy5wdXNoKHtcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgbGVuZ3RoOiBsZW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VEZWxpbWl0ZXJzKGlubmVyQ29udGVudFBhcnRzLCBkZWxpbWl0ZXJzLCBzeW50YXhPcHRpb25zKSB7XG4gIHZhciBmdWxsID0gaW5uZXJDb250ZW50UGFydHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAudmFsdWU7XG4gIH0pLmpvaW4oXCJcIik7XG4gIHZhciBkZWxpbWl0ZXJNYXRjaGVzID0gZ2V0QWxsRGVsaW1pdGVySW5kZXhlcyhmdWxsLCBkZWxpbWl0ZXJzLCBzeW50YXhPcHRpb25zKTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciByYW5nZXMgPSBpbm5lckNvbnRlbnRQYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICBvZmZzZXQgKz0gcGFydC52YWx1ZS5sZW5ndGg7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldDogb2Zmc2V0IC0gcGFydC52YWx1ZS5sZW5ndGgsXG4gICAgICBsSW5kZXg6IHBhcnQubEluZGV4XG4gICAgfTtcbiAgfSk7XG4gIHZhciBfZ2V0RGVsaW1pdGVyRXJyb3JzID0gZ2V0RGVsaW1pdGVyRXJyb3JzKGRlbGltaXRlck1hdGNoZXMsIGZ1bGwsIHN5bnRheE9wdGlvbnMpLFxuICAgIGRlbGltaXRlcldpdGhFcnJvcnMgPSBfZ2V0RGVsaW1pdGVyRXJyb3JzLmRlbGltaXRlcldpdGhFcnJvcnMsXG4gICAgZXJyb3JzID0gX2dldERlbGltaXRlckVycm9ycy5lcnJvcnM7XG4gIHZhciBjdXROZXh0ID0gMDtcbiAgdmFyIGRlbGltaXRlckluZGV4ID0gMDtcbiAgdmFyIHBhcnNlZCA9IHJhbmdlcy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICB2YXIgb2Zmc2V0ID0gcC5vZmZzZXQ7XG4gICAgdmFyIHJhbmdlID0gW29mZnNldCwgb2Zmc2V0ICsgaW5uZXJDb250ZW50UGFydHNbaV0udmFsdWUubGVuZ3RoXTtcbiAgICB2YXIgcGFydENvbnRlbnQgPSBpbm5lckNvbnRlbnRQYXJ0c1tpXS52YWx1ZTtcbiAgICB2YXIgZGVsaW1pdGVyc0luT2Zmc2V0ID0gW107XG4gICAgd2hpbGUgKGRlbGltaXRlckluZGV4IDwgZGVsaW1pdGVyV2l0aEVycm9ycy5sZW5ndGggJiYgaW5SYW5nZShyYW5nZSwgZGVsaW1pdGVyV2l0aEVycm9yc1tkZWxpbWl0ZXJJbmRleF0pKSB7XG4gICAgICBkZWxpbWl0ZXJzSW5PZmZzZXQucHVzaChkZWxpbWl0ZXJXaXRoRXJyb3JzW2RlbGltaXRlckluZGV4XSk7XG4gICAgICBkZWxpbWl0ZXJJbmRleCsrO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB2YXIgY3Vyc29yID0gMDtcbiAgICBpZiAoY3V0TmV4dCA+IDApIHtcbiAgICAgIGN1cnNvciA9IGN1dE5leHQ7XG4gICAgICBjdXROZXh0ID0gMDtcbiAgICB9XG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZGVsaW1pdGVyc0luT2Zmc2V0Lmxlbmd0aDsgX2k2KyspIHtcbiAgICAgIHZhciBkZWxpbWl0ZXJJbk9mZnNldCA9IGRlbGltaXRlcnNJbk9mZnNldFtfaTZdO1xuICAgICAgdmFyIF92YWx1ZSA9IHBhcnRDb250ZW50LnN1YnN0cihjdXJzb3IsIGRlbGltaXRlckluT2Zmc2V0Lm9mZnNldCAtIG9mZnNldCAtIGN1cnNvcik7XG4gICAgICBpZiAoZGVsaW1pdGVySW5PZmZzZXQuY2hhbmdlZGVsaW1pdGVyKSB7XG4gICAgICAgIGlmIChkZWxpbWl0ZXJJbk9mZnNldC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgaWYgKF92YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJzb3IgPSBkZWxpbWl0ZXJJbk9mZnNldC5vZmZzZXQgLSBvZmZzZXQgKyBkZWxpbWl0ZXJJbk9mZnNldC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoX3ZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJjb250ZW50XCIsXG4gICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY3Vyc29yICs9IF92YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgZGVsaW1pdGVyUGFydCA9IHtcbiAgICAgICAgdHlwZTogXCJkZWxpbWl0ZXJcIixcbiAgICAgICAgcG9zaXRpb246IGRlbGltaXRlckluT2Zmc2V0LnBvc2l0aW9uLFxuICAgICAgICBvZmZzZXQ6IGN1cnNvciArIG9mZnNldFxuICAgICAgfTtcbiAgICAgIHBhcnRzLnB1c2goZGVsaW1pdGVyUGFydCk7XG4gICAgICBjdXJzb3IgPSBkZWxpbWl0ZXJJbk9mZnNldC5vZmZzZXQgLSBvZmZzZXQgKyBkZWxpbWl0ZXJJbk9mZnNldC5sZW5ndGg7XG4gICAgfVxuICAgIGN1dE5leHQgPSBjdXJzb3IgLSBwYXJ0Q29udGVudC5sZW5ndGg7XG4gICAgdmFyIHZhbHVlID0gcGFydENvbnRlbnQuc3Vic3RyKGN1cnNvcik7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9LCB0aGlzKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJzZWQ6IHBhcnNlZCxcbiAgICBlcnJvcnM6IGVycm9yc1xuICB9O1xufVxuZnVuY3Rpb24gaXNJbnNpZGVDb250ZW50KHBhcnQpIHtcbiAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhlIHBhcnQucG9zaXRpb24gPT09IFwiaW5zaWRldGFnXCIgd291bGQgYmUgZW5vdWdoIGJ1dCB3ZSB3YW50IHRvIG1ha2UgdGhlIEFQSSBmdXR1cmUgcHJvb2ZcbiAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJjb250ZW50XCIgJiYgcGFydC5wb3NpdGlvbiA9PT0gXCJpbnNpZGV0YWdcIjtcbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxufVxuZnVuY3Rpb24gZ2V0Q29udGVudFBhcnRzKHhtbHBhcnNlZCkge1xuICByZXR1cm4geG1scGFyc2VkLmZpbHRlcihpc0luc2lkZUNvbnRlbnQpO1xufVxuZnVuY3Rpb24gZGVjb2RlQ29udGVudFBhcnRzKHhtbHBhcnNlZCwgZmlsZVR5cGUpIHtcbiAgdmFyIGluVGV4dFRhZyA9IGZhbHNlO1xuICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCB4bWxwYXJzZWQubGVuZ3RoOyBfaTgrKykge1xuICAgIHZhciBwYXJ0ID0geG1scGFyc2VkW19pOF07XG4gICAgaW5UZXh0VGFnID0gdXBkYXRlSW5UZXh0VGFnKHBhcnQsIGluVGV4dFRhZyk7XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgIHBhcnQucG9zaXRpb24gPSBpblRleHRUYWcgPyBcImluc2lkZXRhZ1wiIDogXCJvdXRzaWRldGFnXCI7XG4gICAgfVxuICAgIGlmIChmaWxlVHlwZSAhPT0gXCJ0ZXh0XCIgJiYgaXNJbnNpZGVDb250ZW50KHBhcnQpKSB7XG4gICAgICBwYXJ0LnZhbHVlID0gcGFydC52YWx1ZS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbiAgICB9XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZURlbGltaXRlcnM6IHBhcnNlRGVsaW1pdGVycyxcbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHhtbGxleGVkLCBkZWxpbWl0ZXJzLCBzeW50YXgsIGZpbGVUeXBlKSB7XG4gICAgZGVjb2RlQ29udGVudFBhcnRzKHhtbGxleGVkLCBmaWxlVHlwZSk7XG4gICAgdmFyIF9wYXJzZURlbGltaXRlcnMgPSBwYXJzZURlbGltaXRlcnMoZ2V0Q29udGVudFBhcnRzKHhtbGxleGVkKSwgZGVsaW1pdGVycywgc3ludGF4KSxcbiAgICAgIGRlbGltaXRlclBhcnNlZCA9IF9wYXJzZURlbGltaXRlcnMucGFyc2VkLFxuICAgICAgZXJyb3JzID0gX3BhcnNlRGVsaW1pdGVycy5lcnJvcnM7XG4gICAgdmFyIGxleGVkID0gW107XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbEluZGV4ID0gMDtcbiAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IHhtbGxleGVkLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICB2YXIgcGFydCA9IHhtbGxleGVkW19pMTBdO1xuICAgICAgaWYgKGlzSW5zaWRlQ29udGVudChwYXJ0KSkge1xuICAgICAgICBmb3IgKHZhciBfaTEyID0gMCwgX2RlbGltaXRlclBhcnNlZCRpbmRlMiA9IGRlbGltaXRlclBhcnNlZFtpbmRleF07IF9pMTIgPCBfZGVsaW1pdGVyUGFyc2VkJGluZGUyLmxlbmd0aDsgX2kxMisrKSB7XG4gICAgICAgICAgdmFyIHAgPSBfZGVsaW1pdGVyUGFyc2VkJGluZGUyW19pMTJdO1xuICAgICAgICAgIGlmIChwLnR5cGUgPT09IFwiY29udGVudFwiKSB7XG4gICAgICAgICAgICBwLnBvc2l0aW9uID0gXCJpbnNpZGV0YWdcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcC5sSW5kZXggPSBsSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsZXhlZCwgZGVsaW1pdGVyUGFyc2VkW2luZGV4XSk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0LmxJbmRleCA9IGxJbmRleCsrO1xuICAgICAgICBsZXhlZC5wdXNoKHBhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICBsZXhlZDogbGV4ZWRcbiAgICB9O1xuICB9LFxuICB4bWxwYXJzZTogZnVuY3Rpb24geG1scGFyc2UoY29udGVudCwgeG1sdGFncykge1xuICAgIHZhciBtYXRjaGVzID0gdGFnTWF0Y2hlcihjb250ZW50LCB4bWx0YWdzLnRleHQsIHhtbHRhZ3Mub3RoZXIpO1xuICAgIHZhciBjdXJzb3IgPSAwO1xuICAgIHZhciBwYXJzZWQgPSBtYXRjaGVzLnJlZHVjZShmdW5jdGlvbiAocGFyc2VkLCBtYXRjaCkge1xuICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoID4gY3Vyc29yICYmIG1hdGNoLm9mZnNldCAtIGN1cnNvciA+IDApIHtcbiAgICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwiY29udGVudFwiLFxuICAgICAgICAgIHZhbHVlOiBjb250ZW50LnN1YnN0cihjdXJzb3IsIG1hdGNoLm9mZnNldCAtIGN1cnNvcilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjdXJzb3IgPSBtYXRjaC5vZmZzZXQgKyBtYXRjaC52YWx1ZS5sZW5ndGg7XG4gICAgICBkZWxldGUgbWF0Y2gub2Zmc2V0O1xuICAgICAgcGFyc2VkLnB1c2gobWF0Y2gpO1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9LCBbXSk7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID4gY3Vyc29yKSB7XG4gICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiY29udGVudFwiLFxuICAgICAgICB2YWx1ZTogY29udGVudC5zdWJzdHIoY3Vyc29yKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/lexer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/merge-sort.js":
/*!*****************************************************!*\
  !*** ./node_modules/docxtemplater/js/merge-sort.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\nfunction getMinFromArrays(arrays, state) {\n  var minIndex = -1;\n  for (var i = 0, l = arrays.length; i < l; i++) {\n    if (state[i] >= arrays[i].length) {\n      continue;\n    }\n    if (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n}\nmodule.exports = function (arrays) {\n  var totalLength = arrays.reduce(function (sum, array) {\n    return sum + array.length;\n  }, 0);\n  arrays = arrays.filter(function (array) {\n    return array.length > 0;\n  });\n  var resultArray = new Array(totalLength);\n  var state = arrays.map(function () {\n    return 0;\n  });\n  for (var i = 0; i < totalLength; i++) {\n    var arrayIndex = getMinFromArrays(arrays, state);\n    resultArray[i] = arrays[arrayIndex][state[arrayIndex]];\n    state[arrayIndex]++;\n  }\n  return resultArray;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tZXJnZS1zb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbWVyZ2Utc29ydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0TWluRnJvbUFycmF5cyhhcnJheXMsIHN0YXRlKSB7XG4gIHZhciBtaW5JbmRleCA9IC0xO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RhdGVbaV0gPj0gYXJyYXlzW2ldLmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtaW5JbmRleCA9PT0gLTEgfHwgYXJyYXlzW2ldW3N0YXRlW2ldXS5vZmZzZXQgPCBhcnJheXNbbWluSW5kZXhdW3N0YXRlW21pbkluZGV4XV0ub2Zmc2V0KSB7XG4gICAgICBtaW5JbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5JbmRleDtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFycmF5cykge1xuICB2YXIgdG90YWxMZW5ndGggPSBhcnJheXMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIGFycmF5KSB7XG4gICAgcmV0dXJuIHN1bSArIGFycmF5Lmxlbmd0aDtcbiAgfSwgMCk7XG4gIGFycmF5cyA9IGFycmF5cy5maWx0ZXIoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5Lmxlbmd0aCA+IDA7XG4gIH0pO1xuICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgQXJyYXkodG90YWxMZW5ndGgpO1xuICB2YXIgc3RhdGUgPSBhcnJheXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMDtcbiAgfSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxMZW5ndGg7IGkrKykge1xuICAgIHZhciBhcnJheUluZGV4ID0gZ2V0TWluRnJvbUFycmF5cyhhcnJheXMsIHN0YXRlKTtcbiAgICByZXN1bHRBcnJheVtpXSA9IGFycmF5c1thcnJheUluZGV4XVtzdGF0ZVthcnJheUluZGV4XV07XG4gICAgc3RhdGVbYXJyYXlJbmRleF0rKztcbiAgfVxuICByZXR1cm4gcmVzdWx0QXJyYXk7XG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/merge-sort.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/module-wrapper.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/module-wrapper.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"),\n  XTInternalError = _require.XTInternalError;\nfunction emptyFun() {}\nfunction identity(i) {\n  return i;\n}\nmodule.exports = function (module) {\n  var defaults = {\n    set: emptyFun,\n    matchers: function matchers() {\n      return [];\n    },\n    parse: emptyFun,\n    render: emptyFun,\n    getTraits: emptyFun,\n    getFileType: emptyFun,\n    nullGetter: emptyFun,\n    optionsTransformer: identity,\n    postrender: identity,\n    errorsTransformer: identity,\n    getRenderedMap: identity,\n    preparse: identity,\n    postparse: identity,\n    on: emptyFun,\n    resolve: emptyFun,\n    preResolve: emptyFun\n  };\n  if (Object.keys(defaults).every(function (key) {\n    return !module[key];\n  })) {\n    var err = new XTInternalError(\"This module cannot be wrapped, because it doesn't define any of the necessary functions\");\n    err.properties = {\n      id: \"module_cannot_be_wrapped\",\n      explanation: \"This module cannot be wrapped, because it doesn't define any of the necessary functions\"\n    };\n    throw err;\n  }\n  for (var key in defaults) {\n    module[key] || (module[key] = defaults[key]);\n  }\n  return module;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGUtd3JhcHBlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsb0VBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlLXdyYXBwZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgWFRJbnRlcm5hbEVycm9yID0gX3JlcXVpcmUuWFRJbnRlcm5hbEVycm9yO1xuZnVuY3Rpb24gZW1wdHlGdW4oKSB7fVxuZnVuY3Rpb24gaWRlbnRpdHkoaSkge1xuICByZXR1cm4gaTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgc2V0OiBlbXB0eUZ1bixcbiAgICBtYXRjaGVyczogZnVuY3Rpb24gbWF0Y2hlcnMoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBwYXJzZTogZW1wdHlGdW4sXG4gICAgcmVuZGVyOiBlbXB0eUZ1bixcbiAgICBnZXRUcmFpdHM6IGVtcHR5RnVuLFxuICAgIGdldEZpbGVUeXBlOiBlbXB0eUZ1bixcbiAgICBudWxsR2V0dGVyOiBlbXB0eUZ1bixcbiAgICBvcHRpb25zVHJhbnNmb3JtZXI6IGlkZW50aXR5LFxuICAgIHBvc3RyZW5kZXI6IGlkZW50aXR5LFxuICAgIGVycm9yc1RyYW5zZm9ybWVyOiBpZGVudGl0eSxcbiAgICBnZXRSZW5kZXJlZE1hcDogaWRlbnRpdHksXG4gICAgcHJlcGFyc2U6IGlkZW50aXR5LFxuICAgIHBvc3RwYXJzZTogaWRlbnRpdHksXG4gICAgb246IGVtcHR5RnVuLFxuICAgIHJlc29sdmU6IGVtcHR5RnVuLFxuICAgIHByZVJlc29sdmU6IGVtcHR5RnVuXG4gIH07XG4gIGlmIChPYmplY3Qua2V5cyhkZWZhdWx0cykuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhbW9kdWxlW2tleV07XG4gIH0pKSB7XG4gICAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJUaGlzIG1vZHVsZSBjYW5ub3QgYmUgd3JhcHBlZCwgYmVjYXVzZSBpdCBkb2Vzbid0IGRlZmluZSBhbnkgb2YgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbnNcIik7XG4gICAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgICBpZDogXCJtb2R1bGVfY2Fubm90X2JlX3dyYXBwZWRcIixcbiAgICAgIGV4cGxhbmF0aW9uOiBcIlRoaXMgbW9kdWxlIGNhbm5vdCBiZSB3cmFwcGVkLCBiZWNhdXNlIGl0IGRvZXNuJ3QgZGVmaW5lIGFueSBvZiB0aGUgbmVjZXNzYXJ5IGZ1bmN0aW9uc1wiXG4gICAgfTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgbW9kdWxlW2tleV0gfHwgKG1vZHVsZVtrZXldID0gZGVmYXVsdHNba2V5XSk7XG4gIH1cbiAgcmV0dXJuIG1vZHVsZTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/common.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/common.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(ssr)/./node_modules/docxtemplater/js/filetypes.js\");\nvar _require = __webpack_require__(/*! ../content-types.js */ \"(ssr)/./node_modules/docxtemplater/js/content-types.js\"),\n  settingsContentType = _require.settingsContentType,\n  coreContentType = _require.coreContentType,\n  appContentType = _require.appContentType,\n  customContentType = _require.customContentType,\n  diagramDataContentType = _require.diagramDataContentType,\n  diagramDrawingContentType = _require.diagramDrawingContentType;\nvar commonContentTypes = [settingsContentType, coreContentType, appContentType, customContentType, diagramDataContentType, diagramDrawingContentType];\nvar Common = /*#__PURE__*/function () {\n  function Common() {\n    _classCallCheck(this, Common);\n    this.name = \"Common\";\n  }\n  return _createClass(Common, [{\n    key: \"getFileType\",\n    value: function getFileType(_ref) {\n      var doc = _ref.doc;\n      var invertedContentTypes = doc.invertedContentTypes;\n      if (!invertedContentTypes) {\n        return;\n      }\n      for (var _i2 = 0; _i2 < commonContentTypes.length; _i2++) {\n        var ct = commonContentTypes[_i2];\n        if (invertedContentTypes[ct]) {\n          Array.prototype.push.apply(doc.targets, invertedContentTypes[ct]);\n        }\n      }\n      var keys = [\"docx\", \"pptx\", \"xlsx\"];\n      var ftCandidate;\n      for (var _i4 = 0; _i4 < keys.length; _i4++) {\n        var key = keys[_i4];\n        var contentTypes = filetypes[key];\n        for (var _i6 = 0; _i6 < contentTypes.length; _i6++) {\n          var _ct = contentTypes[_i6];\n          if (invertedContentTypes[_ct]) {\n            for (var _i8 = 0, _invertedContentTypes2 = invertedContentTypes[_ct]; _i8 < _invertedContentTypes2.length; _i8++) {\n              var target = _invertedContentTypes2[_i8];\n              if (doc.relsTypes[target] && [\"http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument\", \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\"].indexOf(doc.relsTypes[target]) === -1) {\n                continue;\n              }\n              ftCandidate = key;\n              if (filetypes.main.indexOf(_ct) !== -1 || _ct === filetypes.pptx[0]) {\n                doc.textTarget || (doc.textTarget = target);\n              }\n              if (ftCandidate === \"xlsx\") {\n                continue;\n              }\n              doc.targets.push(target);\n            }\n          }\n        }\n        if (ftCandidate) {\n          return ftCandidate;\n        }\n      }\n      return ftCandidate;\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new Common());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2NvbW1vbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsY0FBYyxtQkFBTyxDQUFDLHFGQUFzQjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBaUI7QUFDekMsZUFBZSxtQkFBTyxDQUFDLG1GQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLDBCQUEwQiwyQkFBMkI7QUFDckQ7QUFDQTtBQUNBLGtGQUFrRixxQ0FBcUM7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9jb21tb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIGZpbGV0eXBlcyA9IHJlcXVpcmUoXCIuLi9maWxldHlwZXMuanNcIik7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vY29udGVudC10eXBlcy5qc1wiKSxcbiAgc2V0dGluZ3NDb250ZW50VHlwZSA9IF9yZXF1aXJlLnNldHRpbmdzQ29udGVudFR5cGUsXG4gIGNvcmVDb250ZW50VHlwZSA9IF9yZXF1aXJlLmNvcmVDb250ZW50VHlwZSxcbiAgYXBwQ29udGVudFR5cGUgPSBfcmVxdWlyZS5hcHBDb250ZW50VHlwZSxcbiAgY3VzdG9tQ29udGVudFR5cGUgPSBfcmVxdWlyZS5jdXN0b21Db250ZW50VHlwZSxcbiAgZGlhZ3JhbURhdGFDb250ZW50VHlwZSA9IF9yZXF1aXJlLmRpYWdyYW1EYXRhQ29udGVudFR5cGUsXG4gIGRpYWdyYW1EcmF3aW5nQ29udGVudFR5cGUgPSBfcmVxdWlyZS5kaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlO1xudmFyIGNvbW1vbkNvbnRlbnRUeXBlcyA9IFtzZXR0aW5nc0NvbnRlbnRUeXBlLCBjb3JlQ29udGVudFR5cGUsIGFwcENvbnRlbnRUeXBlLCBjdXN0b21Db250ZW50VHlwZSwgZGlhZ3JhbURhdGFDb250ZW50VHlwZSwgZGlhZ3JhbURyYXdpbmdDb250ZW50VHlwZV07XG52YXIgQ29tbW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29tbW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21tb24pO1xuICAgIHRoaXMubmFtZSA9IFwiQ29tbW9uXCI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDb21tb24sIFt7XG4gICAga2V5OiBcImdldEZpbGVUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZpbGVUeXBlKF9yZWYpIHtcbiAgICAgIHZhciBkb2MgPSBfcmVmLmRvYztcbiAgICAgIHZhciBpbnZlcnRlZENvbnRlbnRUeXBlcyA9IGRvYy5pbnZlcnRlZENvbnRlbnRUeXBlcztcbiAgICAgIGlmICghaW52ZXJ0ZWRDb250ZW50VHlwZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY29tbW9uQ29udGVudFR5cGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIGN0ID0gY29tbW9uQ29udGVudFR5cGVzW19pMl07XG4gICAgICAgIGlmIChpbnZlcnRlZENvbnRlbnRUeXBlc1tjdF0pIHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShkb2MudGFyZ2V0cywgaW52ZXJ0ZWRDb250ZW50VHlwZXNbY3RdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGtleXMgPSBbXCJkb2N4XCIsIFwicHB0eFwiLCBcInhsc3hcIl07XG4gICAgICB2YXIgZnRDYW5kaWRhdGU7XG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBrZXlzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbX2k0XTtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlcyA9IGZpbGV0eXBlc1trZXldO1xuICAgICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBjb250ZW50VHlwZXMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICAgIHZhciBfY3QgPSBjb250ZW50VHlwZXNbX2k2XTtcbiAgICAgICAgICBpZiAoaW52ZXJ0ZWRDb250ZW50VHlwZXNbX2N0XSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX2ludmVydGVkQ29udGVudFR5cGVzMiA9IGludmVydGVkQ29udGVudFR5cGVzW19jdF07IF9pOCA8IF9pbnZlcnRlZENvbnRlbnRUeXBlczIubGVuZ3RoOyBfaTgrKykge1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX2ludmVydGVkQ29udGVudFR5cGVzMltfaThdO1xuICAgICAgICAgICAgICBpZiAoZG9jLnJlbHNUeXBlc1t0YXJnZXRdICYmIFtcImh0dHA6Ly9wdXJsLm9jbGMub3JnL29veG1sL29mZmljZURvY3VtZW50L3JlbGF0aW9uc2hpcHMvb2ZmaWNlRG9jdW1lbnRcIiwgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL29mZmljZURvY3VtZW50XCJdLmluZGV4T2YoZG9jLnJlbHNUeXBlc1t0YXJnZXRdKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdENhbmRpZGF0ZSA9IGtleTtcbiAgICAgICAgICAgICAgaWYgKGZpbGV0eXBlcy5tYWluLmluZGV4T2YoX2N0KSAhPT0gLTEgfHwgX2N0ID09PSBmaWxldHlwZXMucHB0eFswXSkge1xuICAgICAgICAgICAgICAgIGRvYy50ZXh0VGFyZ2V0IHx8IChkb2MudGV4dFRhcmdldCA9IHRhcmdldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZ0Q2FuZGlkYXRlID09PSBcInhsc3hcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvYy50YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ0Q2FuZGlkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ0Q2FuZGlkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnRDYW5kaWRhdGU7XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IENvbW1vbigpKTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js":
/*!********************************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/expand-pair-trait.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar traitName = \"expandPair\";\nvar mergeSort = __webpack_require__(/*! ../merge-sort.js */ \"(ssr)/./node_modules/docxtemplater/js/merge-sort.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  getLeft = _require.getLeft,\n  getRight = _require.getRight,\n  pushArray = _require.pushArray;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require2 = __webpack_require__(/*! ../traits.js */ \"(ssr)/./node_modules/docxtemplater/js/traits.js\"),\n  getExpandToDefault = _require2.getExpandToDefault;\nvar _require3 = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"),\n  getUnmatchedLoopException = _require3.getUnmatchedLoopException,\n  getClosingTagNotMatchOpeningTag = _require3.getClosingTagNotMatchOpeningTag,\n  getUnbalancedLoopException = _require3.getUnbalancedLoopException;\nfunction getOpenCountChange(part) {\n  switch (part.location) {\n    case \"start\":\n      return 1;\n    case \"end\":\n      return -1;\n  }\n}\nfunction match(start, end) {\n  return start != null && end != null && (start.part.location === \"start\" && end.part.location === \"end\" && start.part.value === end.part.value || end.part.value === \"\");\n}\nfunction transformer(traits) {\n  var i = 0;\n  var errors = [];\n  while (i < traits.length) {\n    var part = traits[i].part;\n    if (part.location === \"end\") {\n      if (i === 0) {\n        traits.splice(0, 1);\n        errors.push(getUnmatchedLoopException(part));\n        return {\n          traits: traits,\n          errors: errors\n        };\n      }\n      var endIndex = i;\n      var startIndex = i - 1;\n      var offseter = 1;\n      if (match(traits[startIndex], traits[endIndex])) {\n        traits.splice(endIndex, 1);\n        traits.splice(startIndex, 1);\n        return {\n          errors: errors,\n          traits: traits\n        };\n      }\n      while (offseter < 50) {\n        var startCandidate = traits[startIndex - offseter];\n        var endCandidate = traits[endIndex + offseter];\n        if (match(startCandidate, traits[endIndex])) {\n          traits.splice(endIndex, 1);\n          traits.splice(startIndex - offseter, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n        if (match(traits[startIndex], endCandidate)) {\n          traits.splice(endIndex + offseter, 1);\n          traits.splice(startIndex, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n        offseter++;\n      }\n      errors.push(getClosingTagNotMatchOpeningTag({\n        tags: [traits[startIndex].part, traits[endIndex].part]\n      }));\n      traits.splice(endIndex, 1);\n      traits.splice(startIndex, 1);\n      return {\n        traits: traits,\n        errors: errors\n      };\n    }\n    i++;\n  }\n  for (var _i2 = 0; _i2 < traits.length; _i2++) {\n    var _part = traits[_i2].part;\n    errors.push(getUnmatchedLoopException(_part));\n  }\n  return {\n    traits: [],\n    errors: errors\n  };\n}\nfunction getPairs(traits) {\n  var levelTraits = {};\n  var errors = [];\n  var pairs = [];\n  var transformedTraits = [];\n  pushArray(transformedTraits, traits);\n  while (transformedTraits.length > 0) {\n    var result = transformer(transformedTraits);\n    pushArray(errors, result.errors);\n    transformedTraits = result.traits;\n  }\n\n  // Stryker disable all : because this check makes the function return quicker\n  if (errors.length > 0) {\n    return {\n      pairs: pairs,\n      errors: errors\n    };\n  }\n  // Stryker restore all\n  var countOpen = 0;\n  for (var _i4 = 0; _i4 < traits.length; _i4++) {\n    var currentTrait = traits[_i4];\n    var part = currentTrait.part;\n    var change = getOpenCountChange(part);\n    countOpen += change;\n    if (change === 1) {\n      levelTraits[countOpen] = currentTrait;\n    } else {\n      var startTrait = levelTraits[countOpen + 1];\n      if (countOpen === 0) {\n        pairs.push([startTrait, currentTrait]);\n      }\n    }\n    countOpen = countOpen >= 0 ? countOpen : 0;\n  }\n  return {\n    pairs: pairs,\n    errors: errors\n  };\n}\nvar ExpandPairTrait = /*#__PURE__*/function () {\n  function ExpandPairTrait() {\n    _classCallCheck(this, ExpandPairTrait);\n    this.name = \"ExpandPairTrait\";\n  }\n  return _createClass(ExpandPairTrait, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      if (docxtemplater.options.paragraphLoop) {\n        pushArray(docxtemplater.fileTypeConfig.expandTags, docxtemplater.fileTypeConfig.onParagraphLoop);\n      }\n      this.expandTags = docxtemplater.fileTypeConfig.expandTags;\n      return options;\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, _ref) {\n      var _this = this;\n      var getTraits = _ref.getTraits,\n        _postparse = _ref.postparse,\n        fileType = _ref.fileType;\n      var traits = getTraits(traitName, postparsed);\n      traits = traits.map(function (trait) {\n        return trait || [];\n      });\n      traits = mergeSort(traits);\n      var _getPairs = getPairs(traits),\n        pairs = _getPairs.pairs,\n        errors = _getPairs.errors;\n      var lastRight = 0;\n      var lastPair = null;\n      var expandedPairs = pairs.map(function (pair) {\n        var expandTo = pair[0].part.expandTo;\n        if (expandTo === \"auto\" && fileType !== \"text\") {\n          var result = getExpandToDefault(postparsed, pair, _this.expandTags);\n          if (result.error) {\n            errors.push(result.error);\n          }\n          expandTo = result.value;\n        }\n        if (!expandTo || fileType === \"text\") {\n          var _left = pair[0].offset;\n          var _right = pair[1].offset;\n          if (_left < lastRight && !_this.docxtemplater.options.syntax.allowUnbalancedLoops) {\n            errors.push(getUnbalancedLoopException(pair, lastPair));\n          }\n          lastPair = pair;\n          lastRight = _right;\n          return [_left, _right];\n        }\n        var left, right;\n        try {\n          left = getLeft(postparsed, expandTo, pair[0].offset);\n        } catch (e) {\n          errors.push(e);\n        }\n        try {\n          right = getRight(postparsed, expandTo, pair[1].offset);\n        } catch (e) {\n          errors.push(e);\n        }\n        if (left < lastRight && !_this.docxtemplater.options.syntax.allowUnbalancedLoops) {\n          errors.push(getUnbalancedLoopException(pair, lastPair));\n        }\n        lastRight = right;\n        lastPair = pair;\n        return [left, right];\n      });\n\n      // Stryker disable all : because this check makes the function return quicker\n      if (errors.length > 0) {\n        return {\n          postparsed: postparsed,\n          errors: errors\n        };\n      }\n      // Stryker restore all\n      var currentPairIndex = 0;\n      var innerParts;\n      var newParsed = postparsed.reduce(function (newParsed, part, i) {\n        var inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i && i <= expandedPairs[currentPairIndex][1];\n        var pair = pairs[currentPairIndex];\n        var expandedPair = expandedPairs[currentPairIndex];\n        if (!inPair) {\n          newParsed.push(part);\n          return newParsed;\n        }\n        // We're inside the pair\n        if (expandedPair[0] === i) {\n          // Start pair\n          innerParts = [];\n        }\n        if (pair[0].offset !== i && pair[1].offset !== i) {\n          // Exclude inner pair indexes\n          innerParts.push(part);\n        }\n        if (expandedPair[1] === i) {\n          // End pair\n          var basePart = postparsed[pair[0].offset];\n          basePart.subparsed = _postparse(innerParts, {\n            basePart: basePart\n          });\n          basePart.endLindex = pair[1].part.lIndex;\n          delete basePart.location;\n          delete basePart.expandTo;\n          newParsed.push(basePart);\n          currentPairIndex++;\n          var _expandedPair = expandedPairs[currentPairIndex];\n          while (_expandedPair && _expandedPair[0] < i) {\n            /*\n             * If we have :\n             * expandedPairs =[[5,72],[51,67],[90,106]]\n             * Then after treating [5,72], we need to treat [90,106]\n             * Fixed since v3.58.4\n             */\n            currentPairIndex++;\n            _expandedPair = expandedPairs[currentPairIndex];\n          }\n        }\n        return newParsed;\n      }, []);\n      return {\n        postparsed: newParsed,\n        errors: errors\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new ExpandPairTrait());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2V4cGFuZC1wYWlyLXRyYWl0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3UTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDZFQUFrQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsMkVBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxxRkFBc0I7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMscUVBQWM7QUFDdEM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvZXhwYW5kLXBhaXItdHJhaXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB0cmFpdE5hbWUgPSBcImV4cGFuZFBhaXJcIjtcbnZhciBtZXJnZVNvcnQgPSByZXF1aXJlKFwiLi4vbWVyZ2Utc29ydC5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIGdldExlZnQgPSBfcmVxdWlyZS5nZXRMZWZ0LFxuICBnZXRSaWdodCA9IF9yZXF1aXJlLmdldFJpZ2h0LFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi4vdHJhaXRzLmpzXCIpLFxuICBnZXRFeHBhbmRUb0RlZmF1bHQgPSBfcmVxdWlyZTIuZ2V0RXhwYW5kVG9EZWZhdWx0O1xudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuLi9lcnJvcnMuanNcIiksXG4gIGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24gPSBfcmVxdWlyZTMuZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbixcbiAgZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyA9IF9yZXF1aXJlMy5nZXRDbG9zaW5nVGFnTm90TWF0Y2hPcGVuaW5nVGFnLFxuICBnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbiA9IF9yZXF1aXJlMy5nZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbjtcbmZ1bmN0aW9uIGdldE9wZW5Db3VudENoYW5nZShwYXJ0KSB7XG4gIHN3aXRjaCAocGFydC5sb2NhdGlvbikge1xuICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBcImVuZFwiOlxuICAgICAgcmV0dXJuIC0xO1xuICB9XG59XG5mdW5jdGlvbiBtYXRjaChzdGFydCwgZW5kKSB7XG4gIHJldHVybiBzdGFydCAhPSBudWxsICYmIGVuZCAhPSBudWxsICYmIChzdGFydC5wYXJ0LmxvY2F0aW9uID09PSBcInN0YXJ0XCIgJiYgZW5kLnBhcnQubG9jYXRpb24gPT09IFwiZW5kXCIgJiYgc3RhcnQucGFydC52YWx1ZSA9PT0gZW5kLnBhcnQudmFsdWUgfHwgZW5kLnBhcnQudmFsdWUgPT09IFwiXCIpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtZXIodHJhaXRzKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB3aGlsZSAoaSA8IHRyYWl0cy5sZW5ndGgpIHtcbiAgICB2YXIgcGFydCA9IHRyYWl0c1tpXS5wYXJ0O1xuICAgIGlmIChwYXJ0LmxvY2F0aW9uID09PSBcImVuZFwiKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICB0cmFpdHMuc3BsaWNlKDAsIDEpO1xuICAgICAgICBlcnJvcnMucHVzaChnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uKHBhcnQpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFpdHM6IHRyYWl0cyxcbiAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGVuZEluZGV4ID0gaTtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gaSAtIDE7XG4gICAgICB2YXIgb2Zmc2V0ZXIgPSAxO1xuICAgICAgaWYgKG1hdGNoKHRyYWl0c1tzdGFydEluZGV4XSwgdHJhaXRzW2VuZEluZGV4XSkpIHtcbiAgICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCwgMSk7XG4gICAgICAgIHRyYWl0cy5zcGxpY2Uoc3RhcnRJbmRleCwgMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgdHJhaXRzOiB0cmFpdHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvZmZzZXRlciA8IDUwKSB7XG4gICAgICAgIHZhciBzdGFydENhbmRpZGF0ZSA9IHRyYWl0c1tzdGFydEluZGV4IC0gb2Zmc2V0ZXJdO1xuICAgICAgICB2YXIgZW5kQ2FuZGlkYXRlID0gdHJhaXRzW2VuZEluZGV4ICsgb2Zmc2V0ZXJdO1xuICAgICAgICBpZiAobWF0Y2goc3RhcnRDYW5kaWRhdGUsIHRyYWl0c1tlbmRJbmRleF0pKSB7XG4gICAgICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCwgMSk7XG4gICAgICAgICAgdHJhaXRzLnNwbGljZShzdGFydEluZGV4IC0gb2Zmc2V0ZXIsIDEpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgIHRyYWl0czogdHJhaXRzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2godHJhaXRzW3N0YXJ0SW5kZXhdLCBlbmRDYW5kaWRhdGUpKSB7XG4gICAgICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCArIG9mZnNldGVyLCAxKTtcbiAgICAgICAgICB0cmFpdHMuc3BsaWNlKHN0YXJ0SW5kZXgsIDEpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgIHRyYWl0czogdHJhaXRzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXRlcisrO1xuICAgICAgfVxuICAgICAgZXJyb3JzLnB1c2goZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyh7XG4gICAgICAgIHRhZ3M6IFt0cmFpdHNbc3RhcnRJbmRleF0ucGFydCwgdHJhaXRzW2VuZEluZGV4XS5wYXJ0XVxuICAgICAgfSkpO1xuICAgICAgdHJhaXRzLnNwbGljZShlbmRJbmRleCwgMSk7XG4gICAgICB0cmFpdHMuc3BsaWNlKHN0YXJ0SW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhaXRzOiB0cmFpdHMsXG4gICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICB9O1xuICAgIH1cbiAgICBpKys7XG4gIH1cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdHJhaXRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX3BhcnQgPSB0cmFpdHNbX2kyXS5wYXJ0O1xuICAgIGVycm9ycy5wdXNoKGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24oX3BhcnQpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRyYWl0czogW10sXG4gICAgZXJyb3JzOiBlcnJvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhaXJzKHRyYWl0cykge1xuICB2YXIgbGV2ZWxUcmFpdHMgPSB7fTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgcGFpcnMgPSBbXTtcbiAgdmFyIHRyYW5zZm9ybWVkVHJhaXRzID0gW107XG4gIHB1c2hBcnJheSh0cmFuc2Zvcm1lZFRyYWl0cywgdHJhaXRzKTtcbiAgd2hpbGUgKHRyYW5zZm9ybWVkVHJhaXRzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtZXIodHJhbnNmb3JtZWRUcmFpdHMpO1xuICAgIHB1c2hBcnJheShlcnJvcnMsIHJlc3VsdC5lcnJvcnMpO1xuICAgIHRyYW5zZm9ybWVkVHJhaXRzID0gcmVzdWx0LnRyYWl0cztcbiAgfVxuXG4gIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgY2hlY2sgbWFrZXMgdGhlIGZ1bmN0aW9uIHJldHVybiBxdWlja2VyXG4gIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYWlyczogcGFpcnMsXG4gICAgICBlcnJvcnM6IGVycm9yc1xuICAgIH07XG4gIH1cbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuICB2YXIgY291bnRPcGVuID0gMDtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgdHJhaXRzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgY3VycmVudFRyYWl0ID0gdHJhaXRzW19pNF07XG4gICAgdmFyIHBhcnQgPSBjdXJyZW50VHJhaXQucGFydDtcbiAgICB2YXIgY2hhbmdlID0gZ2V0T3BlbkNvdW50Q2hhbmdlKHBhcnQpO1xuICAgIGNvdW50T3BlbiArPSBjaGFuZ2U7XG4gICAgaWYgKGNoYW5nZSA9PT0gMSkge1xuICAgICAgbGV2ZWxUcmFpdHNbY291bnRPcGVuXSA9IGN1cnJlbnRUcmFpdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0VHJhaXQgPSBsZXZlbFRyYWl0c1tjb3VudE9wZW4gKyAxXTtcbiAgICAgIGlmIChjb3VudE9wZW4gPT09IDApIHtcbiAgICAgICAgcGFpcnMucHVzaChbc3RhcnRUcmFpdCwgY3VycmVudFRyYWl0XSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvdW50T3BlbiA9IGNvdW50T3BlbiA+PSAwID8gY291bnRPcGVuIDogMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBhaXJzOiBwYWlycyxcbiAgICBlcnJvcnM6IGVycm9yc1xuICB9O1xufVxudmFyIEV4cGFuZFBhaXJUcmFpdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV4cGFuZFBhaXJUcmFpdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhwYW5kUGFpclRyYWl0KTtcbiAgICB0aGlzLm5hbWUgPSBcIkV4cGFuZFBhaXJUcmFpdFwiO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRXhwYW5kUGFpclRyYWl0LCBbe1xuICAgIGtleTogXCJvcHRpb25zVHJhbnNmb3JtZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW9uc1RyYW5zZm9ybWVyKG9wdGlvbnMsIGRvY3h0ZW1wbGF0ZXIpIHtcbiAgICAgIGlmIChkb2N4dGVtcGxhdGVyLm9wdGlvbnMucGFyYWdyYXBoTG9vcCkge1xuICAgICAgICBwdXNoQXJyYXkoZG9jeHRlbXBsYXRlci5maWxlVHlwZUNvbmZpZy5leHBhbmRUYWdzLCBkb2N4dGVtcGxhdGVyLmZpbGVUeXBlQ29uZmlnLm9uUGFyYWdyYXBoTG9vcCk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4cGFuZFRhZ3MgPSBkb2N4dGVtcGxhdGVyLmZpbGVUeXBlQ29uZmlnLmV4cGFuZFRhZ3M7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdHBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RwYXJzZShwb3N0cGFyc2VkLCBfcmVmKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGdldFRyYWl0cyA9IF9yZWYuZ2V0VHJhaXRzLFxuICAgICAgICBfcG9zdHBhcnNlID0gX3JlZi5wb3N0cGFyc2UsXG4gICAgICAgIGZpbGVUeXBlID0gX3JlZi5maWxlVHlwZTtcbiAgICAgIHZhciB0cmFpdHMgPSBnZXRUcmFpdHModHJhaXROYW1lLCBwb3N0cGFyc2VkKTtcbiAgICAgIHRyYWl0cyA9IHRyYWl0cy5tYXAoZnVuY3Rpb24gKHRyYWl0KSB7XG4gICAgICAgIHJldHVybiB0cmFpdCB8fCBbXTtcbiAgICAgIH0pO1xuICAgICAgdHJhaXRzID0gbWVyZ2VTb3J0KHRyYWl0cyk7XG4gICAgICB2YXIgX2dldFBhaXJzID0gZ2V0UGFpcnModHJhaXRzKSxcbiAgICAgICAgcGFpcnMgPSBfZ2V0UGFpcnMucGFpcnMsXG4gICAgICAgIGVycm9ycyA9IF9nZXRQYWlycy5lcnJvcnM7XG4gICAgICB2YXIgbGFzdFJpZ2h0ID0gMDtcbiAgICAgIHZhciBsYXN0UGFpciA9IG51bGw7XG4gICAgICB2YXIgZXhwYW5kZWRQYWlycyA9IHBhaXJzLm1hcChmdW5jdGlvbiAocGFpcikge1xuICAgICAgICB2YXIgZXhwYW5kVG8gPSBwYWlyWzBdLnBhcnQuZXhwYW5kVG87XG4gICAgICAgIGlmIChleHBhbmRUbyA9PT0gXCJhdXRvXCIgJiYgZmlsZVR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGdldEV4cGFuZFRvRGVmYXVsdChwb3N0cGFyc2VkLCBwYWlyLCBfdGhpcy5leHBhbmRUYWdzKTtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChyZXN1bHQuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBhbmRUbyA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWV4cGFuZFRvIHx8IGZpbGVUeXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgIHZhciBfbGVmdCA9IHBhaXJbMF0ub2Zmc2V0O1xuICAgICAgICAgIHZhciBfcmlnaHQgPSBwYWlyWzFdLm9mZnNldDtcbiAgICAgICAgICBpZiAoX2xlZnQgPCBsYXN0UmlnaHQgJiYgIV90aGlzLmRvY3h0ZW1wbGF0ZXIub3B0aW9ucy5zeW50YXguYWxsb3dVbmJhbGFuY2VkTG9vcHMpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uKHBhaXIsIGxhc3RQYWlyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RQYWlyID0gcGFpcjtcbiAgICAgICAgICBsYXN0UmlnaHQgPSBfcmlnaHQ7XG4gICAgICAgICAgcmV0dXJuIFtfbGVmdCwgX3JpZ2h0XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVmdCwgcmlnaHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGVmdCA9IGdldExlZnQocG9zdHBhcnNlZCwgZXhwYW5kVG8sIHBhaXJbMF0ub2Zmc2V0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmlnaHQgPSBnZXRSaWdodChwb3N0cGFyc2VkLCBleHBhbmRUbywgcGFpclsxXS5vZmZzZXQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnQgPCBsYXN0UmlnaHQgJiYgIV90aGlzLmRvY3h0ZW1wbGF0ZXIub3B0aW9ucy5zeW50YXguYWxsb3dVbmJhbGFuY2VkTG9vcHMpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbihwYWlyLCBsYXN0UGFpcikpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RSaWdodCA9IHJpZ2h0O1xuICAgICAgICBsYXN0UGFpciA9IHBhaXI7XG4gICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgY2hlY2sgbWFrZXMgdGhlIGZ1bmN0aW9uIHJldHVybiBxdWlja2VyXG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkLFxuICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG4gICAgICB2YXIgY3VycmVudFBhaXJJbmRleCA9IDA7XG4gICAgICB2YXIgaW5uZXJQYXJ0cztcbiAgICAgIHZhciBuZXdQYXJzZWQgPSBwb3N0cGFyc2VkLnJlZHVjZShmdW5jdGlvbiAobmV3UGFyc2VkLCBwYXJ0LCBpKSB7XG4gICAgICAgIHZhciBpblBhaXIgPSBjdXJyZW50UGFpckluZGV4IDwgcGFpcnMubGVuZ3RoICYmIGV4cGFuZGVkUGFpcnNbY3VycmVudFBhaXJJbmRleF1bMF0gPD0gaSAmJiBpIDw9IGV4cGFuZGVkUGFpcnNbY3VycmVudFBhaXJJbmRleF1bMV07XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbY3VycmVudFBhaXJJbmRleF07XG4gICAgICAgIHZhciBleHBhbmRlZFBhaXIgPSBleHBhbmRlZFBhaXJzW2N1cnJlbnRQYWlySW5kZXhdO1xuICAgICAgICBpZiAoIWluUGFpcikge1xuICAgICAgICAgIG5ld1BhcnNlZC5wdXNoKHBhcnQpO1xuICAgICAgICAgIHJldHVybiBuZXdQYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UncmUgaW5zaWRlIHRoZSBwYWlyXG4gICAgICAgIGlmIChleHBhbmRlZFBhaXJbMF0gPT09IGkpIHtcbiAgICAgICAgICAvLyBTdGFydCBwYWlyXG4gICAgICAgICAgaW5uZXJQYXJ0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWlyWzBdLm9mZnNldCAhPT0gaSAmJiBwYWlyWzFdLm9mZnNldCAhPT0gaSkge1xuICAgICAgICAgIC8vIEV4Y2x1ZGUgaW5uZXIgcGFpciBpbmRleGVzXG4gICAgICAgICAgaW5uZXJQYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBhbmRlZFBhaXJbMV0gPT09IGkpIHtcbiAgICAgICAgICAvLyBFbmQgcGFpclxuICAgICAgICAgIHZhciBiYXNlUGFydCA9IHBvc3RwYXJzZWRbcGFpclswXS5vZmZzZXRdO1xuICAgICAgICAgIGJhc2VQYXJ0LnN1YnBhcnNlZCA9IF9wb3N0cGFyc2UoaW5uZXJQYXJ0cywge1xuICAgICAgICAgICAgYmFzZVBhcnQ6IGJhc2VQYXJ0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYmFzZVBhcnQuZW5kTGluZGV4ID0gcGFpclsxXS5wYXJ0LmxJbmRleDtcbiAgICAgICAgICBkZWxldGUgYmFzZVBhcnQubG9jYXRpb247XG4gICAgICAgICAgZGVsZXRlIGJhc2VQYXJ0LmV4cGFuZFRvO1xuICAgICAgICAgIG5ld1BhcnNlZC5wdXNoKGJhc2VQYXJ0KTtcbiAgICAgICAgICBjdXJyZW50UGFpckluZGV4Kys7XG4gICAgICAgICAgdmFyIF9leHBhbmRlZFBhaXIgPSBleHBhbmRlZFBhaXJzW2N1cnJlbnRQYWlySW5kZXhdO1xuICAgICAgICAgIHdoaWxlIChfZXhwYW5kZWRQYWlyICYmIF9leHBhbmRlZFBhaXJbMF0gPCBpKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSA6XG4gICAgICAgICAgICAgKiBleHBhbmRlZFBhaXJzID1bWzUsNzJdLFs1MSw2N10sWzkwLDEwNl1dXG4gICAgICAgICAgICAgKiBUaGVuIGFmdGVyIHRyZWF0aW5nIFs1LDcyXSwgd2UgbmVlZCB0byB0cmVhdCBbOTAsMTA2XVxuICAgICAgICAgICAgICogRml4ZWQgc2luY2UgdjMuNTguNFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjdXJyZW50UGFpckluZGV4Kys7XG4gICAgICAgICAgICBfZXhwYW5kZWRQYWlyID0gZXhwYW5kZWRQYWlyc1tjdXJyZW50UGFpckluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1BhcnNlZDtcbiAgICAgIH0sIFtdKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc3RwYXJzZWQ6IG5ld1BhcnNlZCxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IEV4cGFuZFBhaXJUcmFpdCgpKTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/expand-pair-trait.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/loop.js":
/*!*******************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/loop.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  chunkBy = _require.chunkBy,\n  last = _require.last,\n  isParagraphStart = _require.isParagraphStart,\n  isModule = _require.isModule,\n  pushArray = _require.pushArray,\n  isParagraphEnd = _require.isParagraphEnd,\n  isContent = _require.isContent,\n  startsWith = _require.startsWith,\n  isTagEnd = _require.isTagEnd,\n  isTagStart = _require.isTagStart,\n  getSingleAttribute = _require.getSingleAttribute,\n  setSingleAttribute = _require.setSingleAttribute;\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(ssr)/./node_modules/docxtemplater/js/filetypes.js\");\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar moduleName = \"loop\";\nfunction hasContent(parts) {\n  return parts.some(function (part) {\n    return isContent(part);\n  });\n}\nfunction getFirstMeaningFulPart(parsed) {\n  for (var _i2 = 0; _i2 < parsed.length; _i2++) {\n    var part = parsed[_i2];\n    if (part.type !== \"content\") {\n      return part;\n    }\n  }\n  return null;\n}\nfunction isInsideParagraphLoop(part) {\n  var firstMeaningfulPart = getFirstMeaningFulPart(part.subparsed);\n  return firstMeaningfulPart != null && firstMeaningfulPart.tag !== \"w:t\";\n}\nfunction getPageBreakIfApplies(part) {\n  return part.hasPageBreak && isInsideParagraphLoop(part) ? '<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>' : \"\";\n}\nfunction isEnclosedByParagraphs(parsed) {\n  return parsed.length && isParagraphStart(parsed[0]) && isParagraphEnd(last(parsed));\n}\nfunction getOffset(chunk) {\n  return hasContent(chunk) ? 0 : chunk.length;\n}\nfunction addPageBreakAtEnd(subRendered) {\n  var j = subRendered.parts.length - 1;\n  if (subRendered.parts[j] === \"</w:p>\") {\n    subRendered.parts.splice(j, 0, '<w:r><w:br w:type=\"page\"/></w:r>');\n  } else {\n    subRendered.parts.push('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n  }\n}\nfunction addPageBreakAtBeginning(subRendered) {\n  subRendered.parts.unshift('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n}\nfunction isContinuous(parts) {\n  return parts.some(function (part) {\n    return isTagStart(\"w:type\", part) && part.value.indexOf(\"continuous\") !== -1;\n  });\n}\nfunction isNextPage(parts) {\n  return parts.some(function (part) {\n    return isTagStart(\"w:type\", part) && part.value.indexOf('w:val=\"nextPage\"') !== -1;\n  });\n}\nfunction addSectionBefore(parts, sect) {\n  return pushArray([\"<w:p><w:pPr>\".concat(sect.map(function (_ref) {\n    var value = _ref.value;\n    return value;\n  }).join(\"\"), \"</w:pPr></w:p>\")], parts);\n}\nfunction addContinuousType(parts) {\n  var stop = false;\n  var inSectPr = false;\n  return parts.reduce(function (result, part) {\n    if (stop === false && startsWith(part, \"<w:sectPr\")) {\n      inSectPr = true;\n    }\n    if (inSectPr) {\n      if (startsWith(part, \"<w:type\")) {\n        stop = true;\n      }\n      if (stop === false && startsWith(part, \"</w:sectPr\")) {\n        result.push('<w:type w:val=\"continuous\"/>');\n      }\n    }\n    result.push(part);\n    return result;\n  }, []);\n}\nfunction dropHeaderFooterRefs(parts) {\n  return parts.filter(function (text) {\n    return !startsWith(text, \"<w:headerReference\") && !startsWith(text, \"<w:footerReference\");\n  });\n}\nfunction hasPageBreak(chunk) {\n  return chunk.some(function (part) {\n    return part.tag === \"w:br\" && part.value.indexOf('w:type=\"page\"') !== -1;\n  });\n}\nfunction hasImage(chunk) {\n  return chunk.some(function (_ref2) {\n    var tag = _ref2.tag;\n    return tag === \"w:drawing\";\n  });\n}\nfunction getSectPr(chunks) {\n  var collectSectPr = false;\n  var sectPrs = [];\n  for (var _i4 = 0; _i4 < chunks.length; _i4++) {\n    var part = chunks[_i4];\n    if (isTagStart(\"w:sectPr\", part)) {\n      sectPrs.push([]);\n      collectSectPr = true;\n    }\n    if (collectSectPr) {\n      sectPrs[sectPrs.length - 1].push(part);\n    }\n    if (isTagEnd(\"w:sectPr\", part)) {\n      collectSectPr = false;\n    }\n  }\n  return sectPrs;\n}\nfunction getSectPrHeaderFooterChangeCount(chunks) {\n  var collectSectPr = false;\n  var sectPrCount = 0;\n  for (var _i6 = 0; _i6 < chunks.length; _i6++) {\n    var part = chunks[_i6];\n    if (isTagStart(\"w:sectPr\", part)) {\n      collectSectPr = true;\n    }\n    if (collectSectPr) {\n      if (part.tag === \"w:headerReference\" || part.tag === \"w:footerReference\") {\n        sectPrCount++;\n        collectSectPr = false;\n      }\n    }\n    if (isTagEnd(\"w:sectPr\", part)) {\n      collectSectPr = false;\n    }\n  }\n  return sectPrCount;\n}\nfunction getLastSectPr(parsed) {\n  var sectPr = [];\n  var inSectPr = false;\n  for (var i = parsed.length - 1; i >= 0; i--) {\n    var part = parsed[i];\n    if (isTagEnd(\"w:sectPr\", part)) {\n      inSectPr = true;\n    }\n    if (isTagStart(\"w:sectPr\", part)) {\n      sectPr.unshift(part.value);\n      inSectPr = false;\n    }\n    if (inSectPr) {\n      sectPr.unshift(part.value);\n    }\n    if (isParagraphStart(part)) {\n      if (sectPr.length > 0) {\n        return sectPr.join(\"\");\n      }\n      break;\n    }\n  }\n  return \"\";\n}\nvar LoopModule = /*#__PURE__*/function () {\n  function LoopModule() {\n    _classCallCheck(this, LoopModule);\n    this.name = \"LoopModule\";\n    this.inXfrm = false;\n    this.totalSectPr = 0;\n    this.prefix = {\n      start: \"#\",\n      end: \"/\",\n      dash: /^-([^\\s]+)\\s(.+)/,\n      inverted: \"^\"\n    };\n  }\n  return _createClass(LoopModule, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(opts, docxtemplater) {\n      this.docxtemplater = docxtemplater;\n      return opts;\n    }\n  }, {\n    key: \"preparse\",\n    value: function preparse(parsed, _ref3) {\n      var contentType = _ref3.contentType;\n      if (filetypes.main.indexOf(contentType) !== -1) {\n        this.sects = getSectPr(parsed);\n      }\n    }\n  }, {\n    key: \"matchers\",\n    value: function matchers() {\n      var module = moduleName;\n      return [[this.prefix.start, module, {\n        expandTo: \"auto\",\n        location: \"start\",\n        inverted: false\n      }], [this.prefix.inverted, module, {\n        expandTo: \"auto\",\n        location: \"start\",\n        inverted: true\n      }], [this.prefix.end, module, {\n        location: \"end\"\n      }], [this.prefix.dash, module, function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 3),\n          expandTo = _ref5[1],\n          value = _ref5[2];\n        return {\n          location: \"start\",\n          inverted: false,\n          expandTo: expandTo,\n          value: value\n        };\n      }]];\n    }\n  }, {\n    key: \"getTraits\",\n    value: function getTraits(traitName, parsed) {\n      // Stryker disable all : because getTraits should disappear in v4\n      if (traitName !== \"expandPair\") {\n        return;\n      }\n      // Stryker restore all\n\n      return parsed.reduce(function (tags, part, offset) {\n        if (isModule(part, moduleName) && part.subparsed == null) {\n          tags.push({\n            part: part,\n            offset: offset\n          });\n        }\n        return tags;\n      }, []);\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(parsed, _ref6) {\n      var basePart = _ref6.basePart;\n      if (basePart && this.docxtemplater.fileType === \"docx\" && parsed.length > 0) {\n        basePart.sectPrCount = getSectPrHeaderFooterChangeCount(parsed);\n        this.totalSectPr += basePart.sectPrCount;\n        var sects = this.sects;\n        sects.some(function (sect, index) {\n          if (basePart.lIndex < sect[0].lIndex) {\n            if (index + 1 < sects.length && isContinuous(sects[index + 1])) {\n              basePart.addContinuousType = true;\n            }\n            return true;\n          }\n          if (parsed[0].lIndex < sect[0].lIndex && sect[0].lIndex < basePart.lIndex) {\n            if (isNextPage(sects[index])) {\n              basePart.addNextPage = {\n                index: index\n              };\n            }\n            return true;\n          }\n        });\n        basePart.lastParagrapSectPr = getLastSectPr(parsed);\n      }\n      if (!basePart || basePart.expandTo !== \"auto\" || basePart.module !== moduleName || !isEnclosedByParagraphs(parsed)) {\n        return parsed;\n      }\n      basePart.paragraphLoop = true;\n      var level = 0;\n      var chunks = chunkBy(parsed, function (p) {\n        if (isParagraphStart(p)) {\n          level++;\n          if (level === 1) {\n            return \"start\";\n          }\n        }\n        if (isParagraphEnd(p)) {\n          level--;\n          if (level === 0) {\n            return \"end\";\n          }\n        }\n        return null;\n      });\n      var firstChunk = chunks[0];\n      var lastChunk = last(chunks);\n      var firstOffset = getOffset(firstChunk);\n      var lastOffset = getOffset(lastChunk);\n      basePart.hasPageBreakBeginning = hasPageBreak(firstChunk);\n      basePart.hasPageBreak = hasPageBreak(lastChunk);\n      if (hasImage(firstChunk)) {\n        firstOffset = 0;\n      }\n      if (hasImage(lastChunk)) {\n        lastOffset = 0;\n      }\n      return parsed.slice(firstOffset, parsed.length - lastOffset);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(part, options) {\n      if (!isModule(part, moduleName)) {\n        return null;\n      }\n      var sm = options.scopeManager;\n      var promisedValue = sm.getValueAsync(part.value, {\n        part: part\n      });\n      var promises = [];\n      function loopOver(scope, i, length) {\n        var scopeManager = sm.createSubScopeManager(scope, part.value, i, part, length);\n        promises.push(options.resolve(_objectSpread(_objectSpread({}, options), {}, {\n          compiled: part.subparsed,\n          tags: {},\n          scopeManager: scopeManager\n        })));\n      }\n      var errorList = [];\n      return promisedValue.then(function (values) {\n        return new Promise(function (resolve) {\n          if (values instanceof Array) {\n            Promise.all(values).then(resolve);\n          } else {\n            resolve(values);\n          }\n        }).then(function (values) {\n          sm.loopOverValue(values, loopOver, part.inverted);\n          return Promise.all(promises).then(function (r) {\n            return r.map(function (_ref7) {\n              var resolved = _ref7.resolved,\n                errors = _ref7.errors;\n              errorList.push.apply(errorList, _toConsumableArray(errors));\n              return resolved;\n            });\n          }).then(function (value) {\n            if (errorList.length > 0) {\n              throw errorList;\n            }\n            return value;\n          });\n        });\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      if (part.tag === \"p:xfrm\") {\n        this.inXfrm = part.position === \"start\";\n      }\n      if (part.tag === \"a:ext\" && this.inXfrm) {\n        this.lastExt = part;\n        return part;\n      }\n      if (!isModule(part, moduleName)) {\n        return null;\n      }\n      var totalValue = [];\n      var errors = [];\n      var heightOffset = 0;\n      var self = this;\n      var firstTag = part.subparsed[0];\n      var tagHeight = 0;\n      if ((firstTag === null || firstTag === void 0 ? void 0 : firstTag.tag) === \"a:tr\") {\n        tagHeight = +getSingleAttribute(firstTag.value, \"h\");\n      }\n      heightOffset -= tagHeight;\n      var a16RowIdOffset = 0;\n      var insideParagraphLoop = isInsideParagraphLoop(part);\n      function loopOver(scope, i, length) {\n        heightOffset += tagHeight;\n        var scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i, part, length);\n        for (var _i8 = 0, _part$subparsed2 = part.subparsed; _i8 < _part$subparsed2.length; _i8++) {\n          var pp = _part$subparsed2[_i8];\n          if (isTagStart(\"a16:rowId\", pp)) {\n            var val = +getSingleAttribute(pp.value, \"val\") + a16RowIdOffset;\n            a16RowIdOffset = 1;\n            pp.value = setSingleAttribute(pp.value, \"val\", val);\n          }\n        }\n        var subRendered = options.render(_objectSpread(_objectSpread({}, options), {}, {\n          compiled: part.subparsed,\n          tags: {},\n          scopeManager: scopeManager\n        }));\n        if (part.hasPageBreak && i === length - 1 && insideParagraphLoop) {\n          addPageBreakAtEnd(subRendered);\n        }\n        var isNotFirst = scopeManager.scopePathItem.some(function (i) {\n          return i !== 0;\n        });\n        if (isNotFirst) {\n          if (part.sectPrCount === 1) {\n            subRendered.parts = dropHeaderFooterRefs(subRendered.parts);\n          }\n          if (part.addContinuousType) {\n            subRendered.parts = addContinuousType(subRendered.parts);\n          }\n        } else if (part.addNextPage) {\n          subRendered.parts = addSectionBefore(subRendered.parts, self.sects[part.addNextPage.index]);\n        }\n        if (part.addNextPage) {\n          addPageBreakAtEnd(subRendered);\n        }\n        if (part.hasPageBreakBeginning && insideParagraphLoop) {\n          addPageBreakAtBeginning(subRendered);\n        }\n        for (var _i10 = 0, _subRendered$parts2 = subRendered.parts; _i10 < _subRendered$parts2.length; _i10++) {\n          var _val = _subRendered$parts2[_i10];\n          totalValue.push(_val);\n        }\n        Array.prototype.push.apply(errors, subRendered.errors);\n      }\n      var result = options.scopeManager.loopOver(part.value, loopOver, part.inverted, {\n        part: part\n      });\n      // if the loop is showing empty content\n      if (result === false) {\n        if (part.lastParagrapSectPr) {\n          if (part.paragraphLoop) {\n            return {\n              value: \"<w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr></w:p>\")\n            };\n          }\n          return {\n            value: \"</w:t></w:r></w:p><w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr><w:r><w:t>\")\n          };\n        }\n        return {\n          value: getPageBreakIfApplies(part) || \"\",\n          errors: errors\n        };\n      }\n      if (heightOffset !== 0) {\n        var cy = +getSingleAttribute(this.lastExt.value, \"cy\");\n        this.lastExt.value = setSingleAttribute(this.lastExt.value, \"cy\", cy + heightOffset);\n      }\n      return {\n        value: options.joinUncorrupt(totalValue, _objectSpread(_objectSpread({}, options), {}, {\n          basePart: part\n        })),\n        errors: errors\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new LoopModule());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2xvb3AuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSixtQ0FBbUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUN6SSx1Q0FBdUMsa0dBQWtHLGlCQUFpQix3Q0FBd0MsTUFBTSx5Q0FBeUMsNkJBQTZCLFVBQVUsWUFBWSxrRUFBa0UsV0FBVyxZQUFZLGlCQUFpQixVQUFVLE1BQU0saUZBQWlGLFVBQVUsb0JBQW9CO0FBQzdnQiw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGVBQWUsbUJBQU8sQ0FBQywyRUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsMkVBQWlCO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyxxRkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxjQUFjO0FBQ2xGO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCwrQkFBK0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsY0FBYztBQUNyRjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsbUNBQW1DO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGNBQWM7QUFDN0Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9sb29wLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHsgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIGNodW5rQnkgPSBfcmVxdWlyZS5jaHVua0J5LFxuICBsYXN0ID0gX3JlcXVpcmUubGFzdCxcbiAgaXNQYXJhZ3JhcGhTdGFydCA9IF9yZXF1aXJlLmlzUGFyYWdyYXBoU3RhcnQsXG4gIGlzTW9kdWxlID0gX3JlcXVpcmUuaXNNb2R1bGUsXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlLnB1c2hBcnJheSxcbiAgaXNQYXJhZ3JhcGhFbmQgPSBfcmVxdWlyZS5pc1BhcmFncmFwaEVuZCxcbiAgaXNDb250ZW50ID0gX3JlcXVpcmUuaXNDb250ZW50LFxuICBzdGFydHNXaXRoID0gX3JlcXVpcmUuc3RhcnRzV2l0aCxcbiAgaXNUYWdFbmQgPSBfcmVxdWlyZS5pc1RhZ0VuZCxcbiAgaXNUYWdTdGFydCA9IF9yZXF1aXJlLmlzVGFnU3RhcnQsXG4gIGdldFNpbmdsZUF0dHJpYnV0ZSA9IF9yZXF1aXJlLmdldFNpbmdsZUF0dHJpYnV0ZSxcbiAgc2V0U2luZ2xlQXR0cmlidXRlID0gX3JlcXVpcmUuc2V0U2luZ2xlQXR0cmlidXRlO1xudmFyIGZpbGV0eXBlcyA9IHJlcXVpcmUoXCIuLi9maWxldHlwZXMuanNcIik7XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBtb2R1bGVOYW1lID0gXCJsb29wXCI7XG5mdW5jdGlvbiBoYXNDb250ZW50KHBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5zb21lKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIGlzQ29udGVudChwYXJ0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRGaXJzdE1lYW5pbmdGdWxQYXJ0KHBhcnNlZCkge1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYXJzZWQubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBwYXJ0ID0gcGFyc2VkW19pMl07XG4gICAgaWYgKHBhcnQudHlwZSAhPT0gXCJjb250ZW50XCIpIHtcbiAgICAgIHJldHVybiBwYXJ0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlUGFyYWdyYXBoTG9vcChwYXJ0KSB7XG4gIHZhciBmaXJzdE1lYW5pbmdmdWxQYXJ0ID0gZ2V0Rmlyc3RNZWFuaW5nRnVsUGFydChwYXJ0LnN1YnBhcnNlZCk7XG4gIHJldHVybiBmaXJzdE1lYW5pbmdmdWxQYXJ0ICE9IG51bGwgJiYgZmlyc3RNZWFuaW5nZnVsUGFydC50YWcgIT09IFwidzp0XCI7XG59XG5mdW5jdGlvbiBnZXRQYWdlQnJlYWtJZkFwcGxpZXMocGFydCkge1xuICByZXR1cm4gcGFydC5oYXNQYWdlQnJlYWsgJiYgaXNJbnNpZGVQYXJhZ3JhcGhMb29wKHBhcnQpID8gJzx3OnA+PHc6cj48dzpiciB3OnR5cGU9XCJwYWdlXCIvPjwvdzpyPjwvdzpwPicgOiBcIlwiO1xufVxuZnVuY3Rpb24gaXNFbmNsb3NlZEJ5UGFyYWdyYXBocyhwYXJzZWQpIHtcbiAgcmV0dXJuIHBhcnNlZC5sZW5ndGggJiYgaXNQYXJhZ3JhcGhTdGFydChwYXJzZWRbMF0pICYmIGlzUGFyYWdyYXBoRW5kKGxhc3QocGFyc2VkKSk7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXQoY2h1bmspIHtcbiAgcmV0dXJuIGhhc0NvbnRlbnQoY2h1bmspID8gMCA6IGNodW5rLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIGFkZFBhZ2VCcmVha0F0RW5kKHN1YlJlbmRlcmVkKSB7XG4gIHZhciBqID0gc3ViUmVuZGVyZWQucGFydHMubGVuZ3RoIC0gMTtcbiAgaWYgKHN1YlJlbmRlcmVkLnBhcnRzW2pdID09PSBcIjwvdzpwPlwiKSB7XG4gICAgc3ViUmVuZGVyZWQucGFydHMuc3BsaWNlKGosIDAsICc8dzpyPjx3OmJyIHc6dHlwZT1cInBhZ2VcIi8+PC93OnI+Jyk7XG4gIH0gZWxzZSB7XG4gICAgc3ViUmVuZGVyZWQucGFydHMucHVzaCgnPHc6cD48dzpyPjx3OmJyIHc6dHlwZT1cInBhZ2VcIi8+PC93OnI+PC93OnA+Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFBhZ2VCcmVha0F0QmVnaW5uaW5nKHN1YlJlbmRlcmVkKSB7XG4gIHN1YlJlbmRlcmVkLnBhcnRzLnVuc2hpZnQoJzx3OnA+PHc6cj48dzpiciB3OnR5cGU9XCJwYWdlXCIvPjwvdzpyPjwvdzpwPicpO1xufVxuZnVuY3Rpb24gaXNDb250aW51b3VzKHBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5zb21lKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIGlzVGFnU3RhcnQoXCJ3OnR5cGVcIiwgcGFydCkgJiYgcGFydC52YWx1ZS5pbmRleE9mKFwiY29udGludW91c1wiKSAhPT0gLTE7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNOZXh0UGFnZShwYXJ0cykge1xuICByZXR1cm4gcGFydHMuc29tZShmdW5jdGlvbiAocGFydCkge1xuICAgIHJldHVybiBpc1RhZ1N0YXJ0KFwidzp0eXBlXCIsIHBhcnQpICYmIHBhcnQudmFsdWUuaW5kZXhPZigndzp2YWw9XCJuZXh0UGFnZVwiJykgIT09IC0xO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZFNlY3Rpb25CZWZvcmUocGFydHMsIHNlY3QpIHtcbiAgcmV0dXJuIHB1c2hBcnJheShbXCI8dzpwPjx3OnBQcj5cIi5jb25jYXQoc2VjdC5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSkuam9pbihcIlwiKSwgXCI8L3c6cFByPjwvdzpwPlwiKV0sIHBhcnRzKTtcbn1cbmZ1bmN0aW9uIGFkZENvbnRpbnVvdXNUeXBlKHBhcnRzKSB7XG4gIHZhciBzdG9wID0gZmFsc2U7XG4gIHZhciBpblNlY3RQciA9IGZhbHNlO1xuICByZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHBhcnQpIHtcbiAgICBpZiAoc3RvcCA9PT0gZmFsc2UgJiYgc3RhcnRzV2l0aChwYXJ0LCBcIjx3OnNlY3RQclwiKSkge1xuICAgICAgaW5TZWN0UHIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW5TZWN0UHIpIHtcbiAgICAgIGlmIChzdGFydHNXaXRoKHBhcnQsIFwiPHc6dHlwZVwiKSkge1xuICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdG9wID09PSBmYWxzZSAmJiBzdGFydHNXaXRoKHBhcnQsIFwiPC93OnNlY3RQclwiKSkge1xuICAgICAgICByZXN1bHQucHVzaCgnPHc6dHlwZSB3OnZhbD1cImNvbnRpbnVvdXNcIi8+Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHBhcnQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sIFtdKTtcbn1cbmZ1bmN0aW9uIGRyb3BIZWFkZXJGb290ZXJSZWZzKHBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5maWx0ZXIoZnVuY3Rpb24gKHRleHQpIHtcbiAgICByZXR1cm4gIXN0YXJ0c1dpdGgodGV4dCwgXCI8dzpoZWFkZXJSZWZlcmVuY2VcIikgJiYgIXN0YXJ0c1dpdGgodGV4dCwgXCI8dzpmb290ZXJSZWZlcmVuY2VcIik7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFzUGFnZUJyZWFrKGNodW5rKSB7XG4gIHJldHVybiBjaHVuay5zb21lKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIHBhcnQudGFnID09PSBcInc6YnJcIiAmJiBwYXJ0LnZhbHVlLmluZGV4T2YoJ3c6dHlwZT1cInBhZ2VcIicpICE9PSAtMTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYXNJbWFnZShjaHVuaykge1xuICByZXR1cm4gY2h1bmsuc29tZShmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgdGFnID0gX3JlZjIudGFnO1xuICAgIHJldHVybiB0YWcgPT09IFwidzpkcmF3aW5nXCI7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VjdFByKGNodW5rcykge1xuICB2YXIgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICB2YXIgc2VjdFBycyA9IFtdO1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBjaHVua3MubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBwYXJ0ID0gY2h1bmtzW19pNF07XG4gICAgaWYgKGlzVGFnU3RhcnQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgc2VjdFBycy5wdXNoKFtdKTtcbiAgICAgIGNvbGxlY3RTZWN0UHIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdFNlY3RQcikge1xuICAgICAgc2VjdFByc1tzZWN0UHJzLmxlbmd0aCAtIDFdLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGlmIChpc1RhZ0VuZChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWN0UHJzO1xufVxuZnVuY3Rpb24gZ2V0U2VjdFBySGVhZGVyRm9vdGVyQ2hhbmdlQ291bnQoY2h1bmtzKSB7XG4gIHZhciBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gIHZhciBzZWN0UHJDb3VudCA9IDA7XG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGNodW5rcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgdmFyIHBhcnQgPSBjaHVua3NbX2k2XTtcbiAgICBpZiAoaXNUYWdTdGFydChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBjb2xsZWN0U2VjdFByID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3RTZWN0UHIpIHtcbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJ3OmhlYWRlclJlZmVyZW5jZVwiIHx8IHBhcnQudGFnID09PSBcInc6Zm9vdGVyUmVmZXJlbmNlXCIpIHtcbiAgICAgICAgc2VjdFByQ291bnQrKztcbiAgICAgICAgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNUYWdFbmQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VjdFByQ291bnQ7XG59XG5mdW5jdGlvbiBnZXRMYXN0U2VjdFByKHBhcnNlZCkge1xuICB2YXIgc2VjdFByID0gW107XG4gIHZhciBpblNlY3RQciA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gcGFyc2VkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbaV07XG4gICAgaWYgKGlzVGFnRW5kKFwidzpzZWN0UHJcIiwgcGFydCkpIHtcbiAgICAgIGluU2VjdFByID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzVGFnU3RhcnQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgc2VjdFByLnVuc2hpZnQocGFydC52YWx1ZSk7XG4gICAgICBpblNlY3RQciA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5TZWN0UHIpIHtcbiAgICAgIHNlY3RQci51bnNoaWZ0KHBhcnQudmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNQYXJhZ3JhcGhTdGFydChwYXJ0KSkge1xuICAgICAgaWYgKHNlY3RQci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzZWN0UHIuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbnZhciBMb29wTW9kdWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9vcE1vZHVsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9vcE1vZHVsZSk7XG4gICAgdGhpcy5uYW1lID0gXCJMb29wTW9kdWxlXCI7XG4gICAgdGhpcy5pblhmcm0gPSBmYWxzZTtcbiAgICB0aGlzLnRvdGFsU2VjdFByID0gMDtcbiAgICB0aGlzLnByZWZpeCA9IHtcbiAgICAgIHN0YXJ0OiBcIiNcIixcbiAgICAgIGVuZDogXCIvXCIsXG4gICAgICBkYXNoOiAvXi0oW15cXHNdKylcXHMoLispLyxcbiAgICAgIGludmVydGVkOiBcIl5cIlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMb29wTW9kdWxlLCBbe1xuICAgIGtleTogXCJvcHRpb25zVHJhbnNmb3JtZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW9uc1RyYW5zZm9ybWVyKG9wdHMsIGRvY3h0ZW1wbGF0ZXIpIHtcbiAgICAgIHRoaXMuZG9jeHRlbXBsYXRlciA9IGRvY3h0ZW1wbGF0ZXI7XG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyc2UocGFyc2VkLCBfcmVmMykge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gX3JlZjMuY29udGVudFR5cGU7XG4gICAgICBpZiAoZmlsZXR5cGVzLm1haW4uaW5kZXhPZihjb250ZW50VHlwZSkgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2VjdHMgPSBnZXRTZWN0UHIocGFyc2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlcnMoKSB7XG4gICAgICB2YXIgbW9kdWxlID0gbW9kdWxlTmFtZTtcbiAgICAgIHJldHVybiBbW3RoaXMucHJlZml4LnN0YXJ0LCBtb2R1bGUsIHtcbiAgICAgICAgZXhwYW5kVG86IFwiYXV0b1wiLFxuICAgICAgICBsb2NhdGlvbjogXCJzdGFydFwiLFxuICAgICAgICBpbnZlcnRlZDogZmFsc2VcbiAgICAgIH1dLCBbdGhpcy5wcmVmaXguaW52ZXJ0ZWQsIG1vZHVsZSwge1xuICAgICAgICBleHBhbmRUbzogXCJhdXRvXCIsXG4gICAgICAgIGxvY2F0aW9uOiBcInN0YXJ0XCIsXG4gICAgICAgIGludmVydGVkOiB0cnVlXG4gICAgICB9XSwgW3RoaXMucHJlZml4LmVuZCwgbW9kdWxlLCB7XG4gICAgICAgIGxvY2F0aW9uOiBcImVuZFwiXG4gICAgICB9XSwgW3RoaXMucHJlZml4LmRhc2gsIG1vZHVsZSwgZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgIHZhciBfcmVmNSA9IF9zbGljZWRUb0FycmF5KF9yZWY0LCAzKSxcbiAgICAgICAgICBleHBhbmRUbyA9IF9yZWY1WzFdLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjVbMl07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbG9jYXRpb246IFwic3RhcnRcIixcbiAgICAgICAgICBpbnZlcnRlZDogZmFsc2UsXG4gICAgICAgICAgZXhwYW5kVG86IGV4cGFuZFRvLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfV1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFpdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhaXRzKHRyYWl0TmFtZSwgcGFyc2VkKSB7XG4gICAgICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSBnZXRUcmFpdHMgc2hvdWxkIGRpc2FwcGVhciBpbiB2NFxuICAgICAgaWYgKHRyYWl0TmFtZSAhPT0gXCJleHBhbmRQYWlyXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuXG4gICAgICByZXR1cm4gcGFyc2VkLnJlZHVjZShmdW5jdGlvbiAodGFncywgcGFydCwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChpc01vZHVsZShwYXJ0LCBtb2R1bGVOYW1lKSAmJiBwYXJ0LnN1YnBhcnNlZCA9PSBudWxsKSB7XG4gICAgICAgICAgdGFncy5wdXNoKHtcbiAgICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWdzO1xuICAgICAgfSwgW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBhcnNlZCwgX3JlZjYpIHtcbiAgICAgIHZhciBiYXNlUGFydCA9IF9yZWY2LmJhc2VQYXJ0O1xuICAgICAgaWYgKGJhc2VQYXJ0ICYmIHRoaXMuZG9jeHRlbXBsYXRlci5maWxlVHlwZSA9PT0gXCJkb2N4XCIgJiYgcGFyc2VkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmFzZVBhcnQuc2VjdFByQ291bnQgPSBnZXRTZWN0UHJIZWFkZXJGb290ZXJDaGFuZ2VDb3VudChwYXJzZWQpO1xuICAgICAgICB0aGlzLnRvdGFsU2VjdFByICs9IGJhc2VQYXJ0LnNlY3RQckNvdW50O1xuICAgICAgICB2YXIgc2VjdHMgPSB0aGlzLnNlY3RzO1xuICAgICAgICBzZWN0cy5zb21lKGZ1bmN0aW9uIChzZWN0LCBpbmRleCkge1xuICAgICAgICAgIGlmIChiYXNlUGFydC5sSW5kZXggPCBzZWN0WzBdLmxJbmRleCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA8IHNlY3RzLmxlbmd0aCAmJiBpc0NvbnRpbnVvdXMoc2VjdHNbaW5kZXggKyAxXSkpIHtcbiAgICAgICAgICAgICAgYmFzZVBhcnQuYWRkQ29udGludW91c1R5cGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJzZWRbMF0ubEluZGV4IDwgc2VjdFswXS5sSW5kZXggJiYgc2VjdFswXS5sSW5kZXggPCBiYXNlUGFydC5sSW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpc05leHRQYWdlKHNlY3RzW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgYmFzZVBhcnQuYWRkTmV4dFBhZ2UgPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBiYXNlUGFydC5sYXN0UGFyYWdyYXBTZWN0UHIgPSBnZXRMYXN0U2VjdFByKHBhcnNlZCk7XG4gICAgICB9XG4gICAgICBpZiAoIWJhc2VQYXJ0IHx8IGJhc2VQYXJ0LmV4cGFuZFRvICE9PSBcImF1dG9cIiB8fCBiYXNlUGFydC5tb2R1bGUgIT09IG1vZHVsZU5hbWUgfHwgIWlzRW5jbG9zZWRCeVBhcmFncmFwaHMocGFyc2VkKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgICAgYmFzZVBhcnQucGFyYWdyYXBoTG9vcCA9IHRydWU7XG4gICAgICB2YXIgbGV2ZWwgPSAwO1xuICAgICAgdmFyIGNodW5rcyA9IGNodW5rQnkocGFyc2VkLCBmdW5jdGlvbiAocCkge1xuICAgICAgICBpZiAoaXNQYXJhZ3JhcGhTdGFydChwKSkge1xuICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgaWYgKGxldmVsID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJzdGFydFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQYXJhZ3JhcGhFbmQocCkpIHtcbiAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiZW5kXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgICB2YXIgZmlyc3RDaHVuayA9IGNodW5rc1swXTtcbiAgICAgIHZhciBsYXN0Q2h1bmsgPSBsYXN0KGNodW5rcyk7XG4gICAgICB2YXIgZmlyc3RPZmZzZXQgPSBnZXRPZmZzZXQoZmlyc3RDaHVuayk7XG4gICAgICB2YXIgbGFzdE9mZnNldCA9IGdldE9mZnNldChsYXN0Q2h1bmspO1xuICAgICAgYmFzZVBhcnQuaGFzUGFnZUJyZWFrQmVnaW5uaW5nID0gaGFzUGFnZUJyZWFrKGZpcnN0Q2h1bmspO1xuICAgICAgYmFzZVBhcnQuaGFzUGFnZUJyZWFrID0gaGFzUGFnZUJyZWFrKGxhc3RDaHVuayk7XG4gICAgICBpZiAoaGFzSW1hZ2UoZmlyc3RDaHVuaykpIHtcbiAgICAgICAgZmlyc3RPZmZzZXQgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0ltYWdlKGxhc3RDaHVuaykpIHtcbiAgICAgICAgbGFzdE9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VkLnNsaWNlKGZpcnN0T2Zmc2V0LCBwYXJzZWQubGVuZ3RoIC0gbGFzdE9mZnNldCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZShwYXJ0LCBvcHRpb25zKSB7XG4gICAgICBpZiAoIWlzTW9kdWxlKHBhcnQsIG1vZHVsZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHNtID0gb3B0aW9ucy5zY29wZU1hbmFnZXI7XG4gICAgICB2YXIgcHJvbWlzZWRWYWx1ZSA9IHNtLmdldFZhbHVlQXN5bmMocGFydC52YWx1ZSwge1xuICAgICAgICBwYXJ0OiBwYXJ0XG4gICAgICB9KTtcbiAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgZnVuY3Rpb24gbG9vcE92ZXIoc2NvcGUsIGksIGxlbmd0aCkge1xuICAgICAgICB2YXIgc2NvcGVNYW5hZ2VyID0gc20uY3JlYXRlU3ViU2NvcGVNYW5hZ2VyKHNjb3BlLCBwYXJ0LnZhbHVlLCBpLCBwYXJ0LCBsZW5ndGgpO1xuICAgICAgICBwcm9taXNlcy5wdXNoKG9wdGlvbnMucmVzb2x2ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGNvbXBpbGVkOiBwYXJ0LnN1YnBhcnNlZCxcbiAgICAgICAgICB0YWdzOiB7fSxcbiAgICAgICAgICBzY29wZU1hbmFnZXI6IHNjb3BlTWFuYWdlclxuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yTGlzdCA9IFtdO1xuICAgICAgcmV0dXJuIHByb21pc2VkVmFsdWUudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwodmFsdWVzKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICBzbS5sb29wT3ZlclZhbHVlKHZhbHVlcywgbG9vcE92ZXIsIHBhcnQuaW52ZXJ0ZWQpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHIubWFwKGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSBfcmVmNy5yZXNvbHZlZCxcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBfcmVmNy5lcnJvcnM7XG4gICAgICAgICAgICAgIGVycm9yTGlzdC5wdXNoLmFwcGx5KGVycm9yTGlzdCwgX3RvQ29uc3VtYWJsZUFycmF5KGVycm9ycykpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGVycm9yTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRocm93IGVycm9yTGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihwYXJ0LCBvcHRpb25zKSB7XG4gICAgICBpZiAocGFydC50YWcgPT09IFwicDp4ZnJtXCIpIHtcbiAgICAgICAgdGhpcy5pblhmcm0gPSBwYXJ0LnBvc2l0aW9uID09PSBcInN0YXJ0XCI7XG4gICAgICB9XG4gICAgICBpZiAocGFydC50YWcgPT09IFwiYTpleHRcIiAmJiB0aGlzLmluWGZybSkge1xuICAgICAgICB0aGlzLmxhc3RFeHQgPSBwYXJ0O1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNNb2R1bGUocGFydCwgbW9kdWxlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgdG90YWxWYWx1ZSA9IFtdO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIGhlaWdodE9mZnNldCA9IDA7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgZmlyc3RUYWcgPSBwYXJ0LnN1YnBhcnNlZFswXTtcbiAgICAgIHZhciB0YWdIZWlnaHQgPSAwO1xuICAgICAgaWYgKChmaXJzdFRhZyA9PT0gbnVsbCB8fCBmaXJzdFRhZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlyc3RUYWcudGFnKSA9PT0gXCJhOnRyXCIpIHtcbiAgICAgICAgdGFnSGVpZ2h0ID0gK2dldFNpbmdsZUF0dHJpYnV0ZShmaXJzdFRhZy52YWx1ZSwgXCJoXCIpO1xuICAgICAgfVxuICAgICAgaGVpZ2h0T2Zmc2V0IC09IHRhZ0hlaWdodDtcbiAgICAgIHZhciBhMTZSb3dJZE9mZnNldCA9IDA7XG4gICAgICB2YXIgaW5zaWRlUGFyYWdyYXBoTG9vcCA9IGlzSW5zaWRlUGFyYWdyYXBoTG9vcChwYXJ0KTtcbiAgICAgIGZ1bmN0aW9uIGxvb3BPdmVyKHNjb3BlLCBpLCBsZW5ndGgpIHtcbiAgICAgICAgaGVpZ2h0T2Zmc2V0ICs9IHRhZ0hlaWdodDtcbiAgICAgICAgdmFyIHNjb3BlTWFuYWdlciA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyLmNyZWF0ZVN1YlNjb3BlTWFuYWdlcihzY29wZSwgcGFydC52YWx1ZSwgaSwgcGFydCwgbGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX3BhcnQkc3VicGFyc2VkMiA9IHBhcnQuc3VicGFyc2VkOyBfaTggPCBfcGFydCRzdWJwYXJzZWQyLmxlbmd0aDsgX2k4KyspIHtcbiAgICAgICAgICB2YXIgcHAgPSBfcGFydCRzdWJwYXJzZWQyW19pOF07XG4gICAgICAgICAgaWYgKGlzVGFnU3RhcnQoXCJhMTY6cm93SWRcIiwgcHApKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gK2dldFNpbmdsZUF0dHJpYnV0ZShwcC52YWx1ZSwgXCJ2YWxcIikgKyBhMTZSb3dJZE9mZnNldDtcbiAgICAgICAgICAgIGExNlJvd0lkT2Zmc2V0ID0gMTtcbiAgICAgICAgICAgIHBwLnZhbHVlID0gc2V0U2luZ2xlQXR0cmlidXRlKHBwLnZhbHVlLCBcInZhbFwiLCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3ViUmVuZGVyZWQgPSBvcHRpb25zLnJlbmRlcihfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGNvbXBpbGVkOiBwYXJ0LnN1YnBhcnNlZCxcbiAgICAgICAgICB0YWdzOiB7fSxcbiAgICAgICAgICBzY29wZU1hbmFnZXI6IHNjb3BlTWFuYWdlclxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChwYXJ0Lmhhc1BhZ2VCcmVhayAmJiBpID09PSBsZW5ndGggLSAxICYmIGluc2lkZVBhcmFncmFwaExvb3ApIHtcbiAgICAgICAgICBhZGRQYWdlQnJlYWtBdEVuZChzdWJSZW5kZXJlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzTm90Rmlyc3QgPSBzY29wZU1hbmFnZXIuc2NvcGVQYXRoSXRlbS5zb21lKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgcmV0dXJuIGkgIT09IDA7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNOb3RGaXJzdCkge1xuICAgICAgICAgIGlmIChwYXJ0LnNlY3RQckNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICBzdWJSZW5kZXJlZC5wYXJ0cyA9IGRyb3BIZWFkZXJGb290ZXJSZWZzKHN1YlJlbmRlcmVkLnBhcnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnQuYWRkQ29udGludW91c1R5cGUpIHtcbiAgICAgICAgICAgIHN1YlJlbmRlcmVkLnBhcnRzID0gYWRkQ29udGludW91c1R5cGUoc3ViUmVuZGVyZWQucGFydHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYXJ0LmFkZE5leHRQYWdlKSB7XG4gICAgICAgICAgc3ViUmVuZGVyZWQucGFydHMgPSBhZGRTZWN0aW9uQmVmb3JlKHN1YlJlbmRlcmVkLnBhcnRzLCBzZWxmLnNlY3RzW3BhcnQuYWRkTmV4dFBhZ2UuaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC5hZGROZXh0UGFnZSkge1xuICAgICAgICAgIGFkZFBhZ2VCcmVha0F0RW5kKHN1YlJlbmRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC5oYXNQYWdlQnJlYWtCZWdpbm5pbmcgJiYgaW5zaWRlUGFyYWdyYXBoTG9vcCkge1xuICAgICAgICAgIGFkZFBhZ2VCcmVha0F0QmVnaW5uaW5nKHN1YlJlbmRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaTEwID0gMCwgX3N1YlJlbmRlcmVkJHBhcnRzMiA9IHN1YlJlbmRlcmVkLnBhcnRzOyBfaTEwIDwgX3N1YlJlbmRlcmVkJHBhcnRzMi5sZW5ndGg7IF9pMTArKykge1xuICAgICAgICAgIHZhciBfdmFsID0gX3N1YlJlbmRlcmVkJHBhcnRzMltfaTEwXTtcbiAgICAgICAgICB0b3RhbFZhbHVlLnB1c2goX3ZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZXJyb3JzLCBzdWJSZW5kZXJlZC5lcnJvcnMpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyLmxvb3BPdmVyKHBhcnQudmFsdWUsIGxvb3BPdmVyLCBwYXJ0LmludmVydGVkLCB7XG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pO1xuICAgICAgLy8gaWYgdGhlIGxvb3AgaXMgc2hvd2luZyBlbXB0eSBjb250ZW50XG4gICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICBpZiAocGFydC5sYXN0UGFyYWdyYXBTZWN0UHIpIHtcbiAgICAgICAgICBpZiAocGFydC5wYXJhZ3JhcGhMb29wKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB2YWx1ZTogXCI8dzpwPjx3OnBQcj5cIi5jb25jYXQocGFydC5sYXN0UGFyYWdyYXBTZWN0UHIsIFwiPC93OnBQcj48L3c6cD5cIilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogXCI8L3c6dD48L3c6cj48L3c6cD48dzpwPjx3OnBQcj5cIi5jb25jYXQocGFydC5sYXN0UGFyYWdyYXBTZWN0UHIsIFwiPC93OnBQcj48dzpyPjx3OnQ+XCIpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBnZXRQYWdlQnJlYWtJZkFwcGxpZXMocGFydCkgfHwgXCJcIixcbiAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodE9mZnNldCAhPT0gMCkge1xuICAgICAgICB2YXIgY3kgPSArZ2V0U2luZ2xlQXR0cmlidXRlKHRoaXMubGFzdEV4dC52YWx1ZSwgXCJjeVwiKTtcbiAgICAgICAgdGhpcy5sYXN0RXh0LnZhbHVlID0gc2V0U2luZ2xlQXR0cmlidXRlKHRoaXMubGFzdEV4dC52YWx1ZSwgXCJjeVwiLCBjeSArIGhlaWdodE9mZnNldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogb3B0aW9ucy5qb2luVW5jb3JydXB0KHRvdGFsVmFsdWUsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgYmFzZVBhcnQ6IHBhcnRcbiAgICAgICAgfSkpLFxuICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd3JhcHBlcihuZXcgTG9vcE1vZHVsZSgpKTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/loop.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/rawxml.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/rawxml.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar traits = __webpack_require__(/*! ../traits.js */ \"(ssr)/./node_modules/docxtemplater/js/traits.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  isContent = _require.isContent;\nvar _require2 = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"),\n  throwRawTagShouldBeOnlyTextInParagraph = _require2.throwRawTagShouldBeOnlyTextInParagraph,\n  getInvalidRawXMLValueException = _require2.getInvalidRawXMLValueException;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar moduleName = \"rawxml\";\nfunction getInner(_ref) {\n  var part = _ref.part,\n    left = _ref.left,\n    right = _ref.right,\n    postparsed = _ref.postparsed,\n    index = _ref.index;\n  var paragraphParts = postparsed.slice(left + 1, right);\n  for (var i = 0, len = paragraphParts.length; i < len; i++) {\n    if (i === index - left - 1) {\n      continue;\n    }\n    var p = paragraphParts[i];\n    if (isContent(p)) {\n      throwRawTagShouldBeOnlyTextInParagraph({\n        paragraphParts: paragraphParts,\n        part: part\n      });\n    }\n  }\n  return part;\n}\nvar RawXmlModule = /*#__PURE__*/function () {\n  function RawXmlModule() {\n    _classCallCheck(this, RawXmlModule);\n    this.name = \"RawXmlModule\";\n    this.prefix = \"@\";\n  }\n  return _createClass(RawXmlModule, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.fileTypeConfig = docxtemplater.fileTypeConfig;\n      return options;\n    }\n  }, {\n    key: \"matchers\",\n    value: function matchers() {\n      return [[this.prefix, moduleName]];\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed) {\n      return traits.expandToOne(postparsed, {\n        moduleName: moduleName,\n        getInner: getInner,\n        expandTo: this.fileTypeConfig.tagRawXml,\n        error: {\n          message: \"Raw tag not in paragraph\",\n          id: \"raw_tag_outerxml_invalid\",\n          explanation: function explanation(part) {\n            return \"The tag \\\"\".concat(part.value, \"\\\" is not inside a paragraph, putting raw tags inside an inline loop is disallowed.\");\n          }\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      if (part.module !== moduleName) {\n        return null;\n      }\n      var value;\n      var errors = [];\n      try {\n        value = options.scopeManager.getValue(part.value, {\n          part: part\n        });\n        value !== null && value !== void 0 ? value : value = options.nullGetter(part);\n      } catch (e) {\n        errors.push(e);\n        return {\n          errors: errors\n        };\n      }\n      value = value ? value : \"\";\n      if (typeof value === \"string\") {\n        return {\n          value: value\n        };\n      }\n      return {\n        errors: [getInvalidRawXMLValueException({\n          tag: part.value,\n          value: value,\n          offset: part.offset\n        })]\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new RawXmlModule());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3Jhd3htbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsYUFBYSxtQkFBTyxDQUFDLHFFQUFjO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQywyRUFBaUI7QUFDeEM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBYztBQUN0QztBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHFGQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9yYXd4bWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB0cmFpdHMgPSByZXF1aXJlKFwiLi4vdHJhaXRzLmpzXCIpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2RvYy11dGlscy5qc1wiKSxcbiAgaXNDb250ZW50ID0gX3JlcXVpcmUuaXNDb250ZW50O1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuLi9lcnJvcnMuanNcIiksXG4gIHRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoID0gX3JlcXVpcmUyLnRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoLFxuICBnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb24gPSBfcmVxdWlyZTIuZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uO1xudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgbW9kdWxlTmFtZSA9IFwicmF3eG1sXCI7XG5mdW5jdGlvbiBnZXRJbm5lcihfcmVmKSB7XG4gIHZhciBwYXJ0ID0gX3JlZi5wYXJ0LFxuICAgIGxlZnQgPSBfcmVmLmxlZnQsXG4gICAgcmlnaHQgPSBfcmVmLnJpZ2h0LFxuICAgIHBvc3RwYXJzZWQgPSBfcmVmLnBvc3RwYXJzZWQsXG4gICAgaW5kZXggPSBfcmVmLmluZGV4O1xuICB2YXIgcGFyYWdyYXBoUGFydHMgPSBwb3N0cGFyc2VkLnNsaWNlKGxlZnQgKyAxLCByaWdodCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJhZ3JhcGhQYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpID09PSBpbmRleCAtIGxlZnQgLSAxKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHAgPSBwYXJhZ3JhcGhQYXJ0c1tpXTtcbiAgICBpZiAoaXNDb250ZW50KHApKSB7XG4gICAgICB0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaCh7XG4gICAgICAgIHBhcmFncmFwaFBhcnRzOiBwYXJhZ3JhcGhQYXJ0cyxcbiAgICAgICAgcGFydDogcGFydFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0O1xufVxudmFyIFJhd1htbE1vZHVsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJhd1htbE1vZHVsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmF3WG1sTW9kdWxlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlJhd1htbE1vZHVsZVwiO1xuICAgIHRoaXMucHJlZml4ID0gXCJAXCI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSYXdYbWxNb2R1bGUsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNUcmFuc2Zvcm1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpb25zVHJhbnNmb3JtZXIob3B0aW9ucywgZG9jeHRlbXBsYXRlcikge1xuICAgICAgdGhpcy5maWxlVHlwZUNvbmZpZyA9IGRvY3h0ZW1wbGF0ZXIuZmlsZVR5cGVDb25maWc7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlcnMoKSB7XG4gICAgICByZXR1cm4gW1t0aGlzLnByZWZpeCwgbW9kdWxlTmFtZV1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQpIHtcbiAgICAgIHJldHVybiB0cmFpdHMuZXhwYW5kVG9PbmUocG9zdHBhcnNlZCwge1xuICAgICAgICBtb2R1bGVOYW1lOiBtb2R1bGVOYW1lLFxuICAgICAgICBnZXRJbm5lcjogZ2V0SW5uZXIsXG4gICAgICAgIGV4cGFuZFRvOiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ1Jhd1htbCxcbiAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICBtZXNzYWdlOiBcIlJhdyB0YWcgbm90IGluIHBhcmFncmFwaFwiLFxuICAgICAgICAgIGlkOiBcInJhd190YWdfb3V0ZXJ4bWxfaW52YWxpZFwiLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBmdW5jdGlvbiBleHBsYW5hdGlvbihwYXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJUaGUgdGFnIFxcXCJcIi5jb25jYXQocGFydC52YWx1ZSwgXCJcXFwiIGlzIG5vdCBpbnNpZGUgYSBwYXJhZ3JhcGgsIHB1dHRpbmcgcmF3IHRhZ3MgaW5zaWRlIGFuIGlubGluZSBsb29wIGlzIGRpc2FsbG93ZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFydCwgb3B0aW9ucykge1xuICAgICAgaWYgKHBhcnQubW9kdWxlICE9PSBtb2R1bGVOYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSBvcHRpb25zLnNjb3BlTWFuYWdlci5nZXRWYWx1ZShwYXJ0LnZhbHVlLCB7XG4gICAgICAgICAgcGFydDogcGFydFxuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogdmFsdWUgPSBvcHRpb25zLm51bGxHZXR0ZXIocGFydCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUgOiBcIlwiO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JzOiBbZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uKHtcbiAgICAgICAgICB0YWc6IHBhcnQudmFsdWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIG9mZnNldDogcGFydC5vZmZzZXRcbiAgICAgICAgfSldXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBSYXdYbWxNb2R1bGUoKSk7XG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/rawxml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/render.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/render.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"),\n  getScopeCompilationError = _require.getScopeCompilationError,\n  getCorruptCharactersException = _require.getCorruptCharactersException;\nvar _require2 = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  utf8ToWord = _require2.utf8ToWord,\n  hasCorruptCharacters = _require2.hasCorruptCharacters,\n  removeCorruptCharacters = _require2.removeCorruptCharacters;\nvar _require3 = __webpack_require__(/*! ../content-types.js */ \"(ssr)/./node_modules/docxtemplater/js/content-types.js\"),\n  settingsContentType = _require3.settingsContentType,\n  coreContentType = _require3.coreContentType,\n  appContentType = _require3.appContentType,\n  customContentType = _require3.customContentType;\nvar ftprefix = {\n  docx: \"w\",\n  pptx: \"a\"\n};\nvar Render = /*#__PURE__*/function () {\n  function Render() {\n    _classCallCheck(this, Render);\n    this.name = \"Render\";\n    this.recordRun = false;\n    this.recordedRun = [];\n  }\n  return _createClass(Render, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.parser = docxtemplater.parser;\n      this.fileType = docxtemplater.fileType;\n      return options;\n    }\n  }, {\n    key: \"set\",\n    value: function set(obj) {\n      if (obj.compiled) {\n        this.compiled = obj.compiled;\n      }\n      if (obj.data != null) {\n        this.data = obj.data;\n      }\n    }\n  }, {\n    key: \"getRenderedMap\",\n    value: function getRenderedMap(mapper) {\n      var _this = this;\n      return Object.keys(this.compiled).reduce(function (mapper, from) {\n        mapper[from] = {\n          from: from,\n          data: _this.data\n        };\n        return mapper;\n      }, mapper);\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, options) {\n      var errors = [];\n      for (var _i2 = 0; _i2 < postparsed.length; _i2++) {\n        var p = postparsed[_i2];\n        if (p.type === \"placeholder\") {\n          var tag = p.value;\n          try {\n            options.cachedParsers[p.lIndex] = this.parser(tag, {\n              tag: p\n            });\n          } catch (rootError) {\n            errors.push(getScopeCompilationError({\n              tag: tag,\n              rootError: rootError,\n              offset: p.offset\n            }));\n          }\n        }\n      }\n      return {\n        postparsed: postparsed,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, _ref) {\n      var contentType = _ref.contentType,\n        scopeManager = _ref.scopeManager,\n        linebreaks = _ref.linebreaks,\n        nullGetter = _ref.nullGetter,\n        fileType = _ref.fileType,\n        stripInvalidXMLChars = _ref.stripInvalidXMLChars;\n      if (linebreaks && [settingsContentType, coreContentType, appContentType, customContentType].indexOf(contentType) !== -1) {\n        // Fixes issue tested in #docprops-linebreak\n        linebreaks = false;\n      }\n      if (linebreaks) {\n        this.recordRuns(part);\n      }\n      if (part.type !== \"placeholder\" || part.module) {\n        return;\n      }\n      var value;\n      try {\n        value = scopeManager.getValue(part.value, {\n          part: part\n        });\n      } catch (e) {\n        return {\n          errors: [e]\n        };\n      }\n      value !== null && value !== void 0 ? value : value = nullGetter(part);\n      if (typeof value === \"string\") {\n        if (stripInvalidXMLChars) {\n          value = removeCorruptCharacters(value);\n        } else if ([\"docx\", \"pptx\", \"xlsx\"].indexOf(fileType) !== -1 && hasCorruptCharacters(value)) {\n          return {\n            errors: [getCorruptCharactersException({\n              tag: part.value,\n              value: value,\n              offset: part.offset\n            })]\n          };\n        }\n      }\n      if (fileType === \"text\") {\n        return {\n          value: value\n        };\n      }\n      return {\n        value: linebreaks && typeof value === \"string\" ? this.renderLineBreaks(value) : utf8ToWord(value)\n      };\n    }\n  }, {\n    key: \"recordRuns\",\n    value: function recordRuns(part) {\n      if (part.tag === \"\".concat(ftprefix[this.fileType], \":r\")) {\n        this.recordedRun = [];\n      } else if (part.tag === \"\".concat(ftprefix[this.fileType], \":rPr\")) {\n        if (part.position === \"start\") {\n          this.recordRun = true;\n          this.recordedRun = [part.value];\n        }\n        if (part.position === \"end\" || part.position === \"selfclosing\") {\n          this.recordedRun.push(part.value);\n          this.recordRun = false;\n        }\n      } else if (this.recordRun) {\n        this.recordedRun.push(part.value);\n      }\n    }\n  }, {\n    key: \"renderLineBreaks\",\n    value: function renderLineBreaks(value) {\n      var _this2 = this;\n      var p = ftprefix[this.fileType];\n      var br = this.fileType === \"docx\" ? \"<w:r><w:br/></w:r>\" : \"<a:br/>\";\n      var lines = value.split(\"\\n\");\n      var runprops = this.recordedRun.join(\"\");\n      return lines.map(function (line) {\n        return utf8ToWord(line);\n      }).reduce(function (result, line, i) {\n        result.push(line);\n        if (i < lines.length - 1) {\n          result.push(\"</\".concat(p, \":t></\").concat(p, \":r>\").concat(br, \"<\").concat(p, \":r>\").concat(runprops, \"<\").concat(p, \":t\").concat(_this2.fileType === \"docx\" ? ' xml:space=\"preserve\"' : \"\", \">\"));\n        }\n        return result;\n      }, []);\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new Render());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3JlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsY0FBYyxtQkFBTyxDQUFDLHFGQUFzQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMscUVBQWM7QUFDckM7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvcmVuZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9lcnJvcnMuanNcIiksXG4gIGdldFNjb3BlQ29tcGlsYXRpb25FcnJvciA9IF9yZXF1aXJlLmdldFNjb3BlQ29tcGlsYXRpb25FcnJvcixcbiAgZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb24gPSBfcmVxdWlyZS5nZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbjtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi4vZG9jLXV0aWxzLmpzXCIpLFxuICB1dGY4VG9Xb3JkID0gX3JlcXVpcmUyLnV0ZjhUb1dvcmQsXG4gIGhhc0NvcnJ1cHRDaGFyYWN0ZXJzID0gX3JlcXVpcmUyLmhhc0NvcnJ1cHRDaGFyYWN0ZXJzLFxuICByZW1vdmVDb3JydXB0Q2hhcmFjdGVycyA9IF9yZXF1aXJlMi5yZW1vdmVDb3JydXB0Q2hhcmFjdGVycztcbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKFwiLi4vY29udGVudC10eXBlcy5qc1wiKSxcbiAgc2V0dGluZ3NDb250ZW50VHlwZSA9IF9yZXF1aXJlMy5zZXR0aW5nc0NvbnRlbnRUeXBlLFxuICBjb3JlQ29udGVudFR5cGUgPSBfcmVxdWlyZTMuY29yZUNvbnRlbnRUeXBlLFxuICBhcHBDb250ZW50VHlwZSA9IF9yZXF1aXJlMy5hcHBDb250ZW50VHlwZSxcbiAgY3VzdG9tQ29udGVudFR5cGUgPSBfcmVxdWlyZTMuY3VzdG9tQ29udGVudFR5cGU7XG52YXIgZnRwcmVmaXggPSB7XG4gIGRvY3g6IFwid1wiLFxuICBwcHR4OiBcImFcIlxufTtcbnZhciBSZW5kZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZW5kZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlcik7XG4gICAgdGhpcy5uYW1lID0gXCJSZW5kZXJcIjtcbiAgICB0aGlzLnJlY29yZFJ1biA9IGZhbHNlO1xuICAgIHRoaXMucmVjb3JkZWRSdW4gPSBbXTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJlbmRlciwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1RyYW5zZm9ybWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGlvbnNUcmFuc2Zvcm1lcihvcHRpb25zLCBkb2N4dGVtcGxhdGVyKSB7XG4gICAgICB0aGlzLnBhcnNlciA9IGRvY3h0ZW1wbGF0ZXIucGFyc2VyO1xuICAgICAgdGhpcy5maWxlVHlwZSA9IGRvY3h0ZW1wbGF0ZXIuZmlsZVR5cGU7XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChvYmopIHtcbiAgICAgIGlmIChvYmouY29tcGlsZWQpIHtcbiAgICAgICAgdGhpcy5jb21waWxlZCA9IG9iai5jb21waWxlZDtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG9iai5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZW5kZXJlZE1hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZW5kZXJlZE1hcChtYXBwZXIpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jb21waWxlZCkucmVkdWNlKGZ1bmN0aW9uIChtYXBwZXIsIGZyb20pIHtcbiAgICAgICAgbWFwcGVyW2Zyb21dID0ge1xuICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgZGF0YTogX3RoaXMuZGF0YVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbWFwcGVyO1xuICAgICAgfSwgbWFwcGVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdHBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RwYXJzZShwb3N0cGFyc2VkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwb3N0cGFyc2VkLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHAgPSBwb3N0cGFyc2VkW19pMl07XG4gICAgICAgIGlmIChwLnR5cGUgPT09IFwicGxhY2Vob2xkZXJcIikge1xuICAgICAgICAgIHZhciB0YWcgPSBwLnZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvcHRpb25zLmNhY2hlZFBhcnNlcnNbcC5sSW5kZXhdID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICAgICAgICAgIHRhZzogcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAocm9vdEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChnZXRTY29wZUNvbXBpbGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgICAgcm9vdEVycm9yOiByb290RXJyb3IsXG4gICAgICAgICAgICAgIG9mZnNldDogcC5vZmZzZXRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvc3RwYXJzZWQ6IHBvc3RwYXJzZWQsXG4gICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcnQsIF9yZWYpIHtcbiAgICAgIHZhciBjb250ZW50VHlwZSA9IF9yZWYuY29udGVudFR5cGUsXG4gICAgICAgIHNjb3BlTWFuYWdlciA9IF9yZWYuc2NvcGVNYW5hZ2VyLFxuICAgICAgICBsaW5lYnJlYWtzID0gX3JlZi5saW5lYnJlYWtzLFxuICAgICAgICBudWxsR2V0dGVyID0gX3JlZi5udWxsR2V0dGVyLFxuICAgICAgICBmaWxlVHlwZSA9IF9yZWYuZmlsZVR5cGUsXG4gICAgICAgIHN0cmlwSW52YWxpZFhNTENoYXJzID0gX3JlZi5zdHJpcEludmFsaWRYTUxDaGFycztcbiAgICAgIGlmIChsaW5lYnJlYWtzICYmIFtzZXR0aW5nc0NvbnRlbnRUeXBlLCBjb3JlQ29udGVudFR5cGUsIGFwcENvbnRlbnRUeXBlLCBjdXN0b21Db250ZW50VHlwZV0uaW5kZXhPZihjb250ZW50VHlwZSkgIT09IC0xKSB7XG4gICAgICAgIC8vIEZpeGVzIGlzc3VlIHRlc3RlZCBpbiAjZG9jcHJvcHMtbGluZWJyZWFrXG4gICAgICAgIGxpbmVicmVha3MgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lYnJlYWtzKSB7XG4gICAgICAgIHRoaXMucmVjb3JkUnVucyhwYXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LnR5cGUgIT09IFwicGxhY2Vob2xkZXJcIiB8fCBwYXJ0Lm1vZHVsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZSA9IHNjb3BlTWFuYWdlci5nZXRWYWx1ZShwYXJ0LnZhbHVlLCB7XG4gICAgICAgICAgcGFydDogcGFydFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcnM6IFtlXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogdmFsdWUgPSBudWxsR2V0dGVyKHBhcnQpO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoc3RyaXBJbnZhbGlkWE1MQ2hhcnMpIHtcbiAgICAgICAgICB2YWx1ZSA9IHJlbW92ZUNvcnJ1cHRDaGFyYWN0ZXJzKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChbXCJkb2N4XCIsIFwicHB0eFwiLCBcInhsc3hcIl0uaW5kZXhPZihmaWxlVHlwZSkgIT09IC0xICYmIGhhc0NvcnJ1cHRDaGFyYWN0ZXJzKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IFtnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbih7XG4gICAgICAgICAgICAgIHRhZzogcGFydC52YWx1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICBvZmZzZXQ6IHBhcnQub2Zmc2V0XG4gICAgICAgICAgICB9KV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsZVR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbGluZWJyZWFrcyAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB0aGlzLnJlbmRlckxpbmVCcmVha3ModmFsdWUpIDogdXRmOFRvV29yZCh2YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlY29yZFJ1bnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb3JkUnVucyhwYXJ0KSB7XG4gICAgICBpZiAocGFydC50YWcgPT09IFwiXCIuY29uY2F0KGZ0cHJlZml4W3RoaXMuZmlsZVR5cGVdLCBcIjpyXCIpKSB7XG4gICAgICAgIHRoaXMucmVjb3JkZWRSdW4gPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAocGFydC50YWcgPT09IFwiXCIuY29uY2F0KGZ0cHJlZml4W3RoaXMuZmlsZVR5cGVdLCBcIjpyUHJcIikpIHtcbiAgICAgICAgaWYgKHBhcnQucG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuICAgICAgICAgIHRoaXMucmVjb3JkUnVuID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJlY29yZGVkUnVuID0gW3BhcnQudmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnBvc2l0aW9uID09PSBcImVuZFwiIHx8IHBhcnQucG9zaXRpb24gPT09IFwic2VsZmNsb3NpbmdcIikge1xuICAgICAgICAgIHRoaXMucmVjb3JkZWRSdW4ucHVzaChwYXJ0LnZhbHVlKTtcbiAgICAgICAgICB0aGlzLnJlY29yZFJ1biA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucmVjb3JkUnVuKSB7XG4gICAgICAgIHRoaXMucmVjb3JkZWRSdW4ucHVzaChwYXJ0LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyTGluZUJyZWFrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMaW5lQnJlYWtzKHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBwID0gZnRwcmVmaXhbdGhpcy5maWxlVHlwZV07XG4gICAgICB2YXIgYnIgPSB0aGlzLmZpbGVUeXBlID09PSBcImRvY3hcIiA/IFwiPHc6cj48dzpici8+PC93OnI+XCIgOiBcIjxhOmJyLz5cIjtcbiAgICAgIHZhciBsaW5lcyA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgdmFyIHJ1bnByb3BzID0gdGhpcy5yZWNvcmRlZFJ1bi5qb2luKFwiXCIpO1xuICAgICAgcmV0dXJuIGxpbmVzLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICByZXR1cm4gdXRmOFRvV29yZChsaW5lKTtcbiAgICAgIH0pLnJlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBsaW5lLCBpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgICBpZiAoaSA8IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcIjwvXCIuY29uY2F0KHAsIFwiOnQ+PC9cIikuY29uY2F0KHAsIFwiOnI+XCIpLmNvbmNhdChiciwgXCI8XCIpLmNvbmNhdChwLCBcIjpyPlwiKS5jb25jYXQocnVucHJvcHMsIFwiPFwiKS5jb25jYXQocCwgXCI6dFwiKS5jb25jYXQoX3RoaXMyLmZpbGVUeXBlID09PSBcImRvY3hcIiA/ICcgeG1sOnNwYWNlPVwicHJlc2VydmVcIicgOiBcIlwiLCBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LCBbXSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IFJlbmRlcigpKTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/render.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/modules/space-preserve.js":
/*!*****************************************************************!*\
  !*** ./node_modules/docxtemplater/js/modules/space-preserve.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  isTextStart = _require.isTextStart,\n  isTextEnd = _require.isTextEnd,\n  endsWith = _require.endsWith,\n  startsWith = _require.startsWith;\nvar wTpreserve = '<w:t xml:space=\"preserve\">';\nvar wTpreservelen = wTpreserve.length;\nvar wtEnd = \"</w:t>\";\nvar wtEndlen = wtEnd.length;\nfunction isWtStart(part) {\n  return isTextStart(part) && part.tag === \"w:t\";\n}\nfunction addXMLPreserve(chunk, index) {\n  var tag = chunk[index].value;\n  if (chunk[index + 1].value === \"</w:t>\") {\n    return tag;\n  }\n  if (tag.indexOf('xml:space=\"preserve\"') !== -1) {\n    return tag;\n  }\n  return tag.substr(0, tag.length - 1) + ' xml:space=\"preserve\">';\n}\nfunction isInsideLoop(meta, chunk) {\n  return meta && meta.basePart && chunk.length > 1;\n}\nvar SpacePreserve = /*#__PURE__*/function () {\n  function SpacePreserve() {\n    _classCallCheck(this, SpacePreserve);\n    this.name = \"SpacePreserveModule\";\n  }\n  return _createClass(SpacePreserve, [{\n    key: \"postparse\",\n    value: function postparse(postparsed, meta) {\n      var chunk = [],\n        inTextTag = false,\n        endLindex = 0,\n        lastTextTag = 0;\n      function isStartingPlaceHolder(part, chunk) {\n        return part.type === \"placeholder\" && chunk.length > 1;\n      }\n      var result = postparsed.reduce(function (postparsed, part) {\n        if (isWtStart(part)) {\n          inTextTag = true;\n          lastTextTag = chunk.length;\n        }\n        if (!inTextTag) {\n          postparsed.push(part);\n          return postparsed;\n        }\n        chunk.push(part);\n        if (isInsideLoop(meta, chunk)) {\n          endLindex = meta.basePart.endLindex;\n          chunk[0].value = addXMLPreserve(chunk, 0);\n        }\n        if (isStartingPlaceHolder(part, chunk)) {\n          chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n          endLindex = part.endLindex;\n        }\n        if (isTextEnd(part) && part.lIndex > endLindex) {\n          if (endLindex !== 0) {\n            chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n          }\n          Array.prototype.push.apply(postparsed, chunk);\n          chunk = [];\n          inTextTag = false;\n          endLindex = 0;\n          lastTextTag = 0;\n        }\n        return postparsed;\n      }, []);\n      Array.prototype.push.apply(result, chunk);\n      return result;\n    }\n  }, {\n    key: \"postrender\",\n    value: function postrender(parts) {\n      var lastNonEmpty = \"\";\n      var lastNonEmptyIndex = 0;\n      for (var i = 0, len = parts.length; i < len; i++) {\n        var p = parts[i];\n        if (p === \"\") {\n          continue;\n        }\n        if (endsWith(lastNonEmpty, wTpreserve) && startsWith(p, wtEnd)) {\n          parts[lastNonEmptyIndex] = lastNonEmpty.substr(0, lastNonEmpty.length - wTpreservelen) + \"<w:t/>\";\n          p = p.substr(wtEndlen);\n        }\n        lastNonEmpty = p;\n        lastNonEmptyIndex = i;\n        parts[i] = p;\n      }\n      return parts;\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new SpacePreserve());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3NwYWNlLXByZXNlcnZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxjQUFjLG1CQUFPLENBQUMscUZBQXNCO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQywyRUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9zcGFjZS1wcmVzZXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vZG9jLXV0aWxzLmpzXCIpLFxuICBpc1RleHRTdGFydCA9IF9yZXF1aXJlLmlzVGV4dFN0YXJ0LFxuICBpc1RleHRFbmQgPSBfcmVxdWlyZS5pc1RleHRFbmQsXG4gIGVuZHNXaXRoID0gX3JlcXVpcmUuZW5kc1dpdGgsXG4gIHN0YXJ0c1dpdGggPSBfcmVxdWlyZS5zdGFydHNXaXRoO1xudmFyIHdUcHJlc2VydmUgPSAnPHc6dCB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPic7XG52YXIgd1RwcmVzZXJ2ZWxlbiA9IHdUcHJlc2VydmUubGVuZ3RoO1xudmFyIHd0RW5kID0gXCI8L3c6dD5cIjtcbnZhciB3dEVuZGxlbiA9IHd0RW5kLmxlbmd0aDtcbmZ1bmN0aW9uIGlzV3RTdGFydChwYXJ0KSB7XG4gIHJldHVybiBpc1RleHRTdGFydChwYXJ0KSAmJiBwYXJ0LnRhZyA9PT0gXCJ3OnRcIjtcbn1cbmZ1bmN0aW9uIGFkZFhNTFByZXNlcnZlKGNodW5rLCBpbmRleCkge1xuICB2YXIgdGFnID0gY2h1bmtbaW5kZXhdLnZhbHVlO1xuICBpZiAoY2h1bmtbaW5kZXggKyAxXS52YWx1ZSA9PT0gXCI8L3c6dD5cIikge1xuICAgIHJldHVybiB0YWc7XG4gIH1cbiAgaWYgKHRhZy5pbmRleE9mKCd4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiJykgIT09IC0xKSB7XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuICByZXR1cm4gdGFnLnN1YnN0cigwLCB0YWcubGVuZ3RoIC0gMSkgKyAnIHhtbDpzcGFjZT1cInByZXNlcnZlXCI+Jztcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlTG9vcChtZXRhLCBjaHVuaykge1xuICByZXR1cm4gbWV0YSAmJiBtZXRhLmJhc2VQYXJ0ICYmIGNodW5rLmxlbmd0aCA+IDE7XG59XG52YXIgU3BhY2VQcmVzZXJ2ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNwYWNlUHJlc2VydmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwYWNlUHJlc2VydmUpO1xuICAgIHRoaXMubmFtZSA9IFwiU3BhY2VQcmVzZXJ2ZU1vZHVsZVwiO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoU3BhY2VQcmVzZXJ2ZSwgW3tcbiAgICBrZXk6IFwicG9zdHBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RwYXJzZShwb3N0cGFyc2VkLCBtZXRhKSB7XG4gICAgICB2YXIgY2h1bmsgPSBbXSxcbiAgICAgICAgaW5UZXh0VGFnID0gZmFsc2UsXG4gICAgICAgIGVuZExpbmRleCA9IDAsXG4gICAgICAgIGxhc3RUZXh0VGFnID0gMDtcbiAgICAgIGZ1bmN0aW9uIGlzU3RhcnRpbmdQbGFjZUhvbGRlcihwYXJ0LCBjaHVuaykge1xuICAgICAgICByZXR1cm4gcGFydC50eXBlID09PSBcInBsYWNlaG9sZGVyXCIgJiYgY2h1bmsubGVuZ3RoID4gMTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBwb3N0cGFyc2VkLnJlZHVjZShmdW5jdGlvbiAocG9zdHBhcnNlZCwgcGFydCkge1xuICAgICAgICBpZiAoaXNXdFN0YXJ0KHBhcnQpKSB7XG4gICAgICAgICAgaW5UZXh0VGFnID0gdHJ1ZTtcbiAgICAgICAgICBsYXN0VGV4dFRhZyA9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWluVGV4dFRhZykge1xuICAgICAgICAgIHBvc3RwYXJzZWQucHVzaChwYXJ0KTtcbiAgICAgICAgICByZXR1cm4gcG9zdHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBjaHVuay5wdXNoKHBhcnQpO1xuICAgICAgICBpZiAoaXNJbnNpZGVMb29wKG1ldGEsIGNodW5rKSkge1xuICAgICAgICAgIGVuZExpbmRleCA9IG1ldGEuYmFzZVBhcnQuZW5kTGluZGV4O1xuICAgICAgICAgIGNodW5rWzBdLnZhbHVlID0gYWRkWE1MUHJlc2VydmUoY2h1bmssIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0YXJ0aW5nUGxhY2VIb2xkZXIocGFydCwgY2h1bmspKSB7XG4gICAgICAgICAgY2h1bmtbbGFzdFRleHRUYWddLnZhbHVlID0gYWRkWE1MUHJlc2VydmUoY2h1bmssIGxhc3RUZXh0VGFnKTtcbiAgICAgICAgICBlbmRMaW5kZXggPSBwYXJ0LmVuZExpbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUZXh0RW5kKHBhcnQpICYmIHBhcnQubEluZGV4ID4gZW5kTGluZGV4KSB7XG4gICAgICAgICAgaWYgKGVuZExpbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgY2h1bmtbbGFzdFRleHRUYWddLnZhbHVlID0gYWRkWE1MUHJlc2VydmUoY2h1bmssIGxhc3RUZXh0VGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocG9zdHBhcnNlZCwgY2h1bmspO1xuICAgICAgICAgIGNodW5rID0gW107XG4gICAgICAgICAgaW5UZXh0VGFnID0gZmFsc2U7XG4gICAgICAgICAgZW5kTGluZGV4ID0gMDtcbiAgICAgICAgICBsYXN0VGV4dFRhZyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc3RwYXJzZWQ7XG4gICAgICB9LCBbXSk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIGNodW5rKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHJlbmRlcihwYXJ0cykge1xuICAgICAgdmFyIGxhc3ROb25FbXB0eSA9IFwiXCI7XG4gICAgICB2YXIgbGFzdE5vbkVtcHR5SW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gcGFydHNbaV07XG4gICAgICAgIGlmIChwID09PSBcIlwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZHNXaXRoKGxhc3ROb25FbXB0eSwgd1RwcmVzZXJ2ZSkgJiYgc3RhcnRzV2l0aChwLCB3dEVuZCkpIHtcbiAgICAgICAgICBwYXJ0c1tsYXN0Tm9uRW1wdHlJbmRleF0gPSBsYXN0Tm9uRW1wdHkuc3Vic3RyKDAsIGxhc3ROb25FbXB0eS5sZW5ndGggLSB3VHByZXNlcnZlbGVuKSArIFwiPHc6dC8+XCI7XG4gICAgICAgICAgcCA9IHAuc3Vic3RyKHd0RW5kbGVuKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0Tm9uRW1wdHkgPSBwO1xuICAgICAgICBsYXN0Tm9uRW1wdHlJbmRleCA9IGk7XG4gICAgICAgIHBhcnRzW2ldID0gcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd3JhcHBlcihuZXcgU3BhY2VQcmVzZXJ2ZSgpKTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/modules/space-preserve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/parser.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/parser.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  wordToUtf8 = _require.wordToUtf8;\nvar _require2 = __webpack_require__(/*! ./prefix-matcher.js */ \"(ssr)/./node_modules/docxtemplater/js/prefix-matcher.js\"),\n  match = _require2.match,\n  getValue = _require2.getValue,\n  getValues = _require2.getValues;\nfunction getMatchers(modules, options) {\n  var matchers = [];\n  for (var _i2 = 0; _i2 < modules.length; _i2++) {\n    var _module = modules[_i2];\n    if (_module.matchers) {\n      var mmm = _module.matchers(options);\n      if (!(mmm instanceof Array)) {\n        throw new Error(\"module matcher returns a non array\");\n      }\n      matchers.push.apply(matchers, _toConsumableArray(mmm));\n    }\n  }\n  return matchers;\n}\nfunction getMatches(matchers, placeHolderContent, options) {\n  var matches = [];\n  for (var _i4 = 0; _i4 < matchers.length; _i4++) {\n    var matcher = matchers[_i4];\n    var _matcher = _slicedToArray(matcher, 2),\n      prefix = _matcher[0],\n      _module2 = _matcher[1];\n    var properties = matcher[2] || {};\n    if (options.match(prefix, placeHolderContent)) {\n      var values = options.getValues(prefix, placeHolderContent);\n      if (typeof properties === \"function\") {\n        properties = properties(values);\n      }\n      if (!properties.value) {\n        var _values = _slicedToArray(values, 2);\n        properties.value = _values[1];\n      }\n      matches.push(_objectSpread({\n        type: \"placeholder\",\n        prefix: prefix,\n        module: _module2,\n        onMatch: properties.onMatch,\n        priority: properties.priority\n      }, properties));\n    }\n  }\n  return matches;\n}\nfunction moduleParse(placeHolderContent, options) {\n  var modules = options.modules;\n  var startOffset = options.startOffset;\n  var endLindex = options.lIndex;\n  var moduleParsed;\n  options.offset = startOffset;\n  options.match = match;\n  options.getValue = getValue;\n  options.getValues = getValues;\n  var matchers = getMatchers(modules, options);\n  var matches = getMatches(matchers, placeHolderContent, options);\n  if (matches.length > 0) {\n    var bestMatch = null;\n    for (var _i6 = 0; _i6 < matches.length; _i6++) {\n      var _match = matches[_i6];\n      _match.priority || (_match.priority = -_match.value.length);\n      if (!bestMatch || _match.priority > bestMatch.priority) {\n        bestMatch = _match;\n      }\n    }\n    bestMatch.offset = startOffset;\n    delete bestMatch.priority;\n    bestMatch.endLindex = endLindex;\n    bestMatch.lIndex = endLindex;\n    bestMatch.raw = placeHolderContent;\n    if (bestMatch.onMatch) {\n      bestMatch.onMatch(bestMatch);\n    }\n    delete bestMatch.onMatch;\n    delete bestMatch.prefix;\n    return bestMatch;\n  }\n  for (var _i8 = 0; _i8 < modules.length; _i8++) {\n    var _module3 = modules[_i8];\n    moduleParsed = _module3.parse(placeHolderContent, options);\n    if (moduleParsed) {\n      moduleParsed.offset = startOffset;\n      moduleParsed.endLindex = endLindex;\n      moduleParsed.lIndex = endLindex;\n      moduleParsed.raw = placeHolderContent;\n      return moduleParsed;\n    }\n  }\n  return {\n    type: \"placeholder\",\n    value: placeHolderContent,\n    offset: startOffset,\n    endLindex: endLindex,\n    lIndex: endLindex\n  };\n}\nvar parser = {\n  preparse: function preparse(parsed, modules, options) {\n    function preparse(parsed, options) {\n      for (var _i10 = 0; _i10 < modules.length; _i10++) {\n        var _module4 = modules[_i10];\n        parsed = _module4.preparse(parsed, options) || parsed;\n      }\n      return parsed;\n    }\n    return preparse(parsed, options);\n  },\n  parse: function parse(lexed, modules, options) {\n    var inPlaceHolder = false;\n    var placeHolderContent = \"\";\n    var startOffset;\n    var tailParts = [];\n    var droppedTags = options.fileTypeConfig.droppedTagsInsidePlaceholder || [];\n    return lexed.reduce(function (parsed, token) {\n      if (token.type === \"delimiter\") {\n        inPlaceHolder = token.position === \"start\";\n        if (token.position === \"end\") {\n          options.parse = function (placeHolderContent) {\n            return moduleParse(placeHolderContent, _objectSpread(_objectSpread(_objectSpread({}, options), token), {}, {\n              startOffset: startOffset,\n              modules: modules\n            }));\n          };\n          parsed.push(options.parse(wordToUtf8(placeHolderContent)));\n          Array.prototype.push.apply(parsed, tailParts);\n          tailParts = [];\n        }\n        if (token.position === \"start\") {\n          tailParts = [];\n          startOffset = token.offset;\n        }\n        placeHolderContent = \"\";\n        return parsed;\n      }\n      if (!inPlaceHolder) {\n        parsed.push(token);\n        return parsed;\n      }\n      if (token.type !== \"content\" || token.position !== \"insidetag\") {\n        if (droppedTags.indexOf(token.tag) !== -1) {\n          return parsed;\n        }\n        tailParts.push(token);\n        return parsed;\n      }\n      placeHolderContent += token.value;\n      return parsed;\n    }, []);\n  },\n  postparse: function postparse(postparsed, modules, options) {\n    function getTraits(traitName, postparsed) {\n      return modules.map(function (module) {\n        return module.getTraits(traitName, postparsed);\n      });\n    }\n    var errors = [];\n    function _postparse(postparsed, options) {\n      return modules.reduce(function (postparsed, module) {\n        var r = module.postparse(postparsed, _objectSpread(_objectSpread({}, options), {}, {\n          postparse: function postparse(parsed, opts) {\n            return _postparse(parsed, _objectSpread(_objectSpread({}, options), opts));\n          },\n          getTraits: getTraits\n        }));\n        if (r == null) {\n          return postparsed;\n        }\n        if (r.errors) {\n          Array.prototype.push.apply(errors, r.errors);\n          return r.postparsed;\n        }\n        return r;\n      }, postparsed);\n    }\n    return {\n      postparsed: _postparse(postparsed, options),\n      errors: errors\n    };\n  }\n};\nmodule.exports = parser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsdUNBQXVDLGtHQUFrRyxpQkFBaUIsd0NBQXdDLE1BQU0seUNBQXlDLDZCQUE2QixVQUFVLFlBQVksa0VBQWtFLFdBQVcsWUFBWSxpQkFBaUIsVUFBVSxNQUFNLGlGQUFpRixVQUFVLG9CQUFvQjtBQUM3Z0IsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsbUNBQW1DLCtDQUErQyw4QkFBOEIsT0FBTyxrQkFBa0I7QUFDekksZUFBZSxtQkFBTyxDQUFDLDBFQUFnQjtBQUN2QztBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG9GQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Ysc0JBQXNCO0FBQ3JIO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGNBQWM7QUFDekY7QUFDQSxvRUFBb0U7QUFDcEUsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjsgfVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7IGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgd29yZFRvVXRmOCA9IF9yZXF1aXJlLndvcmRUb1V0Zjg7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vcHJlZml4LW1hdGNoZXIuanNcIiksXG4gIG1hdGNoID0gX3JlcXVpcmUyLm1hdGNoLFxuICBnZXRWYWx1ZSA9IF9yZXF1aXJlMi5nZXRWYWx1ZSxcbiAgZ2V0VmFsdWVzID0gX3JlcXVpcmUyLmdldFZhbHVlcztcbmZ1bmN0aW9uIGdldE1hdGNoZXJzKG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgdmFyIG1hdGNoZXJzID0gW107XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG1vZHVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfbW9kdWxlID0gbW9kdWxlc1tfaTJdO1xuICAgIGlmIChfbW9kdWxlLm1hdGNoZXJzKSB7XG4gICAgICB2YXIgbW1tID0gX21vZHVsZS5tYXRjaGVycyhvcHRpb25zKTtcbiAgICAgIGlmICghKG1tbSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2R1bGUgbWF0Y2hlciByZXR1cm5zIGEgbm9uIGFycmF5XCIpO1xuICAgICAgfVxuICAgICAgbWF0Y2hlcnMucHVzaC5hcHBseShtYXRjaGVycywgX3RvQ29uc3VtYWJsZUFycmF5KG1tbSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hlcnM7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVzKG1hdGNoZXJzLCBwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbWF0Y2hlcnMubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBtYXRjaGVyID0gbWF0Y2hlcnNbX2k0XTtcbiAgICB2YXIgX21hdGNoZXIgPSBfc2xpY2VkVG9BcnJheShtYXRjaGVyLCAyKSxcbiAgICAgIHByZWZpeCA9IF9tYXRjaGVyWzBdLFxuICAgICAgX21vZHVsZTIgPSBfbWF0Y2hlclsxXTtcbiAgICB2YXIgcHJvcGVydGllcyA9IG1hdGNoZXJbMl0gfHwge307XG4gICAgaWYgKG9wdGlvbnMubWF0Y2gocHJlZml4LCBwbGFjZUhvbGRlckNvbnRlbnQpKSB7XG4gICAgICB2YXIgdmFsdWVzID0gb3B0aW9ucy5nZXRWYWx1ZXMocHJlZml4LCBwbGFjZUhvbGRlckNvbnRlbnQpO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXModmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmICghcHJvcGVydGllcy52YWx1ZSkge1xuICAgICAgICB2YXIgX3ZhbHVlcyA9IF9zbGljZWRUb0FycmF5KHZhbHVlcywgMik7XG4gICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSBfdmFsdWVzWzFdO1xuICAgICAgfVxuICAgICAgbWF0Y2hlcy5wdXNoKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICB0eXBlOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICBtb2R1bGU6IF9tb2R1bGUyLFxuICAgICAgICBvbk1hdGNoOiBwcm9wZXJ0aWVzLm9uTWF0Y2gsXG4gICAgICAgIHByaW9yaXR5OiBwcm9wZXJ0aWVzLnByaW9yaXR5XG4gICAgICB9LCBwcm9wZXJ0aWVzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gbW9kdWxlUGFyc2UocGxhY2VIb2xkZXJDb250ZW50LCBvcHRpb25zKSB7XG4gIHZhciBtb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzO1xuICB2YXIgc3RhcnRPZmZzZXQgPSBvcHRpb25zLnN0YXJ0T2Zmc2V0O1xuICB2YXIgZW5kTGluZGV4ID0gb3B0aW9ucy5sSW5kZXg7XG4gIHZhciBtb2R1bGVQYXJzZWQ7XG4gIG9wdGlvbnMub2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gIG9wdGlvbnMubWF0Y2ggPSBtYXRjaDtcbiAgb3B0aW9ucy5nZXRWYWx1ZSA9IGdldFZhbHVlO1xuICBvcHRpb25zLmdldFZhbHVlcyA9IGdldFZhbHVlcztcbiAgdmFyIG1hdGNoZXJzID0gZ2V0TWF0Y2hlcnMobW9kdWxlcywgb3B0aW9ucyk7XG4gIHZhciBtYXRjaGVzID0gZ2V0TWF0Y2hlcyhtYXRjaGVycywgcGxhY2VIb2xkZXJDb250ZW50LCBvcHRpb25zKTtcbiAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBiZXN0TWF0Y2ggPSBudWxsO1xuICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG1hdGNoZXMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgdmFyIF9tYXRjaCA9IG1hdGNoZXNbX2k2XTtcbiAgICAgIF9tYXRjaC5wcmlvcml0eSB8fCAoX21hdGNoLnByaW9yaXR5ID0gLV9tYXRjaC52YWx1ZS5sZW5ndGgpO1xuICAgICAgaWYgKCFiZXN0TWF0Y2ggfHwgX21hdGNoLnByaW9yaXR5ID4gYmVzdE1hdGNoLnByaW9yaXR5KSB7XG4gICAgICAgIGJlc3RNYXRjaCA9IF9tYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gICAgYmVzdE1hdGNoLm9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgIGRlbGV0ZSBiZXN0TWF0Y2gucHJpb3JpdHk7XG4gICAgYmVzdE1hdGNoLmVuZExpbmRleCA9IGVuZExpbmRleDtcbiAgICBiZXN0TWF0Y2gubEluZGV4ID0gZW5kTGluZGV4O1xuICAgIGJlc3RNYXRjaC5yYXcgPSBwbGFjZUhvbGRlckNvbnRlbnQ7XG4gICAgaWYgKGJlc3RNYXRjaC5vbk1hdGNoKSB7XG4gICAgICBiZXN0TWF0Y2gub25NYXRjaChiZXN0TWF0Y2gpO1xuICAgIH1cbiAgICBkZWxldGUgYmVzdE1hdGNoLm9uTWF0Y2g7XG4gICAgZGVsZXRlIGJlc3RNYXRjaC5wcmVmaXg7XG4gICAgcmV0dXJuIGJlc3RNYXRjaDtcbiAgfVxuICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBtb2R1bGVzLmxlbmd0aDsgX2k4KyspIHtcbiAgICB2YXIgX21vZHVsZTMgPSBtb2R1bGVzW19pOF07XG4gICAgbW9kdWxlUGFyc2VkID0gX21vZHVsZTMucGFyc2UocGxhY2VIb2xkZXJDb250ZW50LCBvcHRpb25zKTtcbiAgICBpZiAobW9kdWxlUGFyc2VkKSB7XG4gICAgICBtb2R1bGVQYXJzZWQub2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICBtb2R1bGVQYXJzZWQuZW5kTGluZGV4ID0gZW5kTGluZGV4O1xuICAgICAgbW9kdWxlUGFyc2VkLmxJbmRleCA9IGVuZExpbmRleDtcbiAgICAgIG1vZHVsZVBhcnNlZC5yYXcgPSBwbGFjZUhvbGRlckNvbnRlbnQ7XG4gICAgICByZXR1cm4gbW9kdWxlUGFyc2VkO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicGxhY2Vob2xkZXJcIixcbiAgICB2YWx1ZTogcGxhY2VIb2xkZXJDb250ZW50LFxuICAgIG9mZnNldDogc3RhcnRPZmZzZXQsXG4gICAgZW5kTGluZGV4OiBlbmRMaW5kZXgsXG4gICAgbEluZGV4OiBlbmRMaW5kZXhcbiAgfTtcbn1cbnZhciBwYXJzZXIgPSB7XG4gIHByZXBhcnNlOiBmdW5jdGlvbiBwcmVwYXJzZShwYXJzZWQsIG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBwcmVwYXJzZShwYXJzZWQsIG9wdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgbW9kdWxlcy5sZW5ndGg7IF9pMTArKykge1xuICAgICAgICB2YXIgX21vZHVsZTQgPSBtb2R1bGVzW19pMTBdO1xuICAgICAgICBwYXJzZWQgPSBfbW9kdWxlNC5wcmVwYXJzZShwYXJzZWQsIG9wdGlvbnMpIHx8IHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIHJldHVybiBwcmVwYXJzZShwYXJzZWQsIG9wdGlvbnMpO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UobGV4ZWQsIG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5QbGFjZUhvbGRlciA9IGZhbHNlO1xuICAgIHZhciBwbGFjZUhvbGRlckNvbnRlbnQgPSBcIlwiO1xuICAgIHZhciBzdGFydE9mZnNldDtcbiAgICB2YXIgdGFpbFBhcnRzID0gW107XG4gICAgdmFyIGRyb3BwZWRUYWdzID0gb3B0aW9ucy5maWxlVHlwZUNvbmZpZy5kcm9wcGVkVGFnc0luc2lkZVBsYWNlaG9sZGVyIHx8IFtdO1xuICAgIHJldHVybiBsZXhlZC5yZWR1Y2UoZnVuY3Rpb24gKHBhcnNlZCwgdG9rZW4pIHtcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBcImRlbGltaXRlclwiKSB7XG4gICAgICAgIGluUGxhY2VIb2xkZXIgPSB0b2tlbi5wb3NpdGlvbiA9PT0gXCJzdGFydFwiO1xuICAgICAgICBpZiAodG9rZW4ucG9zaXRpb24gPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICBvcHRpb25zLnBhcnNlID0gZnVuY3Rpb24gKHBsYWNlSG9sZGVyQ29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVBhcnNlKHBsYWNlSG9sZGVyQ29udGVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB0b2tlbiksIHt9LCB7XG4gICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgbW9kdWxlczogbW9kdWxlc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcGFyc2VkLnB1c2gob3B0aW9ucy5wYXJzZSh3b3JkVG9VdGY4KHBsYWNlSG9sZGVyQ29udGVudCkpKTtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShwYXJzZWQsIHRhaWxQYXJ0cyk7XG4gICAgICAgICAgdGFpbFBhcnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLnBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICB0YWlsUGFydHMgPSBbXTtcbiAgICAgICAgICBzdGFydE9mZnNldCA9IHRva2VuLm9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBwbGFjZUhvbGRlckNvbnRlbnQgPSBcIlwiO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgICAgaWYgKCFpblBsYWNlSG9sZGVyKSB7XG4gICAgICAgIHBhcnNlZC5wdXNoKHRva2VuKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSBcImNvbnRlbnRcIiB8fCB0b2tlbi5wb3NpdGlvbiAhPT0gXCJpbnNpZGV0YWdcIikge1xuICAgICAgICBpZiAoZHJvcHBlZFRhZ3MuaW5kZXhPZih0b2tlbi50YWcpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGFpbFBhcnRzLnB1c2godG9rZW4pO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgICAgcGxhY2VIb2xkZXJDb250ZW50ICs9IHRva2VuLnZhbHVlO1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9LCBbXSk7XG4gIH0sXG4gIHBvc3RwYXJzZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBnZXRUcmFpdHModHJhaXROYW1lLCBwb3N0cGFyc2VkKSB7XG4gICAgICByZXR1cm4gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLmdldFRyYWl0cyh0cmFpdE5hbWUsIHBvc3RwYXJzZWQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICBmdW5jdGlvbiBfcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAocG9zdHBhcnNlZCwgbW9kdWxlKSB7XG4gICAgICAgIHZhciByID0gbW9kdWxlLnBvc3RwYXJzZShwb3N0cGFyc2VkLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIHBvc3RwYXJzZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBhcnNlZCwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIF9wb3N0cGFyc2UocGFyc2VkLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCBvcHRzKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRUcmFpdHM6IGdldFRyYWl0c1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChyID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gcG9zdHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoci5lcnJvcnMpIHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlcnJvcnMsIHIuZXJyb3JzKTtcbiAgICAgICAgICByZXR1cm4gci5wb3N0cGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSwgcG9zdHBhcnNlZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwb3N0cGFyc2VkOiBfcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG9wdGlvbnMpLFxuICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICB9O1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBwYXJzZXI7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/postrender.js":
/*!*****************************************************!*\
  !*** ./node_modules/docxtemplater/js/postrender.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n * Convert string to array (typed, when possible)\n * Stryker disable all : because this is a utility function that was copied\n * from\n * https://github.com/open-xml-templating/pizzip/blob/34a840553c604980859dc6d0dcd1f89b6e5527b3/es6/utf8.js#L33\n */\nfunction string2buf(str) {\n  var c,\n    c2,\n    mPos,\n    i,\n    bufLen = 0;\n  var strLen = str.length;\n\n  // count binary size\n  for (mPos = 0; mPos < strLen; mPos++) {\n    c = str.charCodeAt(mPos);\n    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n      c2 = str.charCodeAt(mPos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        mPos++;\n      }\n    }\n    bufLen += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  var buf = new Uint8Array(bufLen);\n\n  // convert\n  for (i = 0, mPos = 0; i < bufLen; mPos++) {\n    c = str.charCodeAt(mPos);\n    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n      c2 = str.charCodeAt(mPos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        mPos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xc0 | c >>> 6;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xe0 | c >>> 12;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | c >>> 18;\n      buf[i++] = 0x80 | c >>> 12 & 0x3f;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    }\n  }\n  return buf;\n}\n// Stryker restore all\n\nfunction postrender(parts, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    parts = _module.postrender(parts, options);\n  }\n  var fullLength = 0;\n  var newParts = options.joinUncorrupt(parts, options);\n  var longStr = \"\";\n  var lenStr = 0;\n  var maxCompact = 65536;\n  var uintArrays = [];\n  for (var i = 0, len = newParts.length; i < len; i++) {\n    var part = newParts[i];\n\n    /*\n     * This condition should be hit in the integration test at :\n     * it(\"should not regress with long file (hit maxCompact value of 65536)\", function () {\n     * Stryker disable all : because this is an optimisation that won't make any tests fail\n     */\n    if (part.length + lenStr > maxCompact) {\n      var _arr = string2buf(longStr);\n      fullLength += _arr.length;\n      uintArrays.push(_arr);\n      longStr = \"\";\n    }\n    // Stryker restore all\n\n    longStr += part;\n    lenStr += part.length;\n    delete newParts[i];\n  }\n  var arr = string2buf(longStr);\n  fullLength += arr.length;\n  uintArrays.push(arr);\n  var array = new Uint8Array(fullLength);\n  var j = 0;\n\n  // Stryker disable all : because this is an optimisation that won't make any tests fail\n  for (var _i4 = 0; _i4 < uintArrays.length; _i4++) {\n    var buf = uintArrays[_i4];\n    for (var _i5 = 0; _i5 < buf.length; ++_i5) {\n      array[_i5 + j] = buf[_i5];\n    }\n    j += buf.length;\n  } // Stryker restore all\n  return array;\n}\nmodule.exports = postrender;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wb3N0cmVuZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlELGdDQUFnQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wb3N0cmVuZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICogQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgKHR5cGVkLCB3aGVuIHBvc3NpYmxlKVxuICogU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhpcyBpcyBhIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCB3YXMgY29waWVkXG4gKiBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi14bWwtdGVtcGxhdGluZy9waXp6aXAvYmxvYi8zNGE4NDA1NTNjNjA0OTgwODU5ZGM2ZDBkY2QxZjg5YjZlNTUyN2IzL2VzNi91dGY4LmpzI0wzM1xuICovXG5mdW5jdGlvbiBzdHJpbmcyYnVmKHN0cikge1xuICB2YXIgYyxcbiAgICBjMixcbiAgICBtUG9zLFxuICAgIGksXG4gICAgYnVmTGVuID0gMDtcbiAgdmFyIHN0ckxlbiA9IHN0ci5sZW5ndGg7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtUG9zID0gMDsgbVBvcyA8IHN0ckxlbjsgbVBvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1Qb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiBtUG9zICsgMSA8IHN0ckxlbikge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtUG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKGMgLSAweGQ4MDAgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbVBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZMZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gIH1cblxuICAvLyBhbGxvY2F0ZSBidWZmZXJcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGJ1Zkxlbik7XG5cbiAgLy8gY29udmVydFxuICBmb3IgKGkgPSAwLCBtUG9zID0gMDsgaSA8IGJ1ZkxlbjsgbVBvcysrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KG1Qb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiBtUG9zICsgMSA8IHN0ckxlbikge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtUG9zICsgMSk7XG4gICAgICBpZiAoKGMyICYgMHhmYzAwKSA9PT0gMHhkYzAwKSB7XG4gICAgICAgIGMgPSAweDEwMDAwICsgKGMgLSAweGQ4MDAgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbVBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgIC8qIG9uZSBieXRlICovXG4gICAgICBidWZbaSsrXSA9IGM7XG4gICAgfSBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgIC8qIHR3byBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGMwIHwgYyA+Pj4gNjtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZTAgfCBjID4+PiAxMjtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgPj4+IDYgJiAweDNmO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IGMgPj4+IDE4O1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyA+Pj4gMTIgJiAweDNmO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyA+Pj4gNiAmIDB4M2Y7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1Zjtcbn1cbi8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcblxuZnVuY3Rpb24gcG9zdHJlbmRlcihwYXJ0cywgb3B0aW9ucykge1xuICBmb3IgKHZhciBfaTIgPSAwLCBfb3B0aW9ucyRtb2R1bGVzMiA9IG9wdGlvbnMubW9kdWxlczsgX2kyIDwgX29wdGlvbnMkbW9kdWxlczIubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfbW9kdWxlID0gX29wdGlvbnMkbW9kdWxlczJbX2kyXTtcbiAgICBwYXJ0cyA9IF9tb2R1bGUucG9zdHJlbmRlcihwYXJ0cywgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGZ1bGxMZW5ndGggPSAwO1xuICB2YXIgbmV3UGFydHMgPSBvcHRpb25zLmpvaW5VbmNvcnJ1cHQocGFydHMsIG9wdGlvbnMpO1xuICB2YXIgbG9uZ1N0ciA9IFwiXCI7XG4gIHZhciBsZW5TdHIgPSAwO1xuICB2YXIgbWF4Q29tcGFjdCA9IDY1NTM2O1xuICB2YXIgdWludEFycmF5cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbmV3UGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IG5ld1BhcnRzW2ldO1xuXG4gICAgLypcbiAgICAgKiBUaGlzIGNvbmRpdGlvbiBzaG91bGQgYmUgaGl0IGluIHRoZSBpbnRlZ3JhdGlvbiB0ZXN0IGF0IDpcbiAgICAgKiBpdChcInNob3VsZCBub3QgcmVncmVzcyB3aXRoIGxvbmcgZmlsZSAoaGl0IG1heENvbXBhY3QgdmFsdWUgb2YgNjU1MzYpXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgKiBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGlzIGFuIG9wdGltaXNhdGlvbiB0aGF0IHdvbid0IG1ha2UgYW55IHRlc3RzIGZhaWxcbiAgICAgKi9cbiAgICBpZiAocGFydC5sZW5ndGggKyBsZW5TdHIgPiBtYXhDb21wYWN0KSB7XG4gICAgICB2YXIgX2FyciA9IHN0cmluZzJidWYobG9uZ1N0cik7XG4gICAgICBmdWxsTGVuZ3RoICs9IF9hcnIubGVuZ3RoO1xuICAgICAgdWludEFycmF5cy5wdXNoKF9hcnIpO1xuICAgICAgbG9uZ1N0ciA9IFwiXCI7XG4gICAgfVxuICAgIC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcblxuICAgIGxvbmdTdHIgKz0gcGFydDtcbiAgICBsZW5TdHIgKz0gcGFydC5sZW5ndGg7XG4gICAgZGVsZXRlIG5ld1BhcnRzW2ldO1xuICB9XG4gIHZhciBhcnIgPSBzdHJpbmcyYnVmKGxvbmdTdHIpO1xuICBmdWxsTGVuZ3RoICs9IGFyci5sZW5ndGg7XG4gIHVpbnRBcnJheXMucHVzaChhcnIpO1xuICB2YXIgYXJyYXkgPSBuZXcgVWludDhBcnJheShmdWxsTGVuZ3RoKTtcbiAgdmFyIGogPSAwO1xuXG4gIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uIHRoYXQgd29uJ3QgbWFrZSBhbnkgdGVzdHMgZmFpbFxuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCB1aW50QXJyYXlzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgYnVmID0gdWludEFycmF5c1tfaTRdO1xuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGJ1Zi5sZW5ndGg7ICsrX2k1KSB7XG4gICAgICBhcnJheVtfaTUgKyBqXSA9IGJ1ZltfaTVdO1xuICAgIH1cbiAgICBqICs9IGJ1Zi5sZW5ndGg7XG4gIH0gLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuICByZXR1cm4gYXJyYXk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHBvc3RyZW5kZXI7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/postrender.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/prefix-matcher.js":
/*!*********************************************************!*\
  !*** ./node_modules/docxtemplater/js/prefix-matcher.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar nbspRegex = new RegExp(String.fromCharCode(160), \"g\");\nfunction replaceNbsps(str) {\n  return str.replace(nbspRegex, \" \");\n}\nfunction match(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return replaceNbsps(placeHolderContent.substr(0, condition.length)) === condition;\n  }\n  if (condition instanceof RegExp) {\n    return condition.test(replaceNbsps(placeHolderContent));\n  }\n  if (type === \"function\") {\n    return !!condition(placeHolderContent);\n  }\n}\nfunction getValue(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return replaceNbsps(placeHolderContent).substr(condition.length);\n  }\n  if (condition instanceof RegExp) {\n    return replaceNbsps(placeHolderContent).match(condition)[1];\n  }\n  if (type === \"function\") {\n    return condition(placeHolderContent);\n  }\n}\nfunction getValues(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return [placeHolderContent, replaceNbsps(placeHolderContent).substr(condition.length)];\n  }\n  if (condition instanceof RegExp) {\n    return replaceNbsps(placeHolderContent).match(condition);\n  }\n  if (type === \"function\") {\n    return [placeHolderContent, condition(placeHolderContent)];\n  }\n}\nmodule.exports = {\n  match: match,\n  getValue: getValue,\n  getValues: getValues\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wcmVmaXgtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcHJlZml4LW1hdGNoZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbnZhciBuYnNwUmVnZXggPSBuZXcgUmVnRXhwKFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSwgXCJnXCIpO1xuZnVuY3Rpb24gcmVwbGFjZU5ic3BzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UobmJzcFJlZ2V4LCBcIiBcIik7XG59XG5mdW5jdGlvbiBtYXRjaChjb25kaXRpb24sIHBsYWNlSG9sZGVyQ29udGVudCkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YoY29uZGl0aW9uKTtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudC5zdWJzdHIoMCwgY29uZGl0aW9uLmxlbmd0aCkpID09PSBjb25kaXRpb247XG4gIH1cbiAgaWYgKGNvbmRpdGlvbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBjb25kaXRpb24udGVzdChyZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50KSk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiAhIWNvbmRpdGlvbihwbGFjZUhvbGRlckNvbnRlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZShjb25kaXRpb24sIHBsYWNlSG9sZGVyQ29udGVudCkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YoY29uZGl0aW9uKTtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudCkuc3Vic3RyKGNvbmRpdGlvbi5sZW5ndGgpO1xuICB9XG4gIGlmIChjb25kaXRpb24gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudCkubWF0Y2goY29uZGl0aW9uKVsxXTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbihwbGFjZUhvbGRlckNvbnRlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZXMoY29uZGl0aW9uLCBwbGFjZUhvbGRlckNvbnRlbnQpIHtcbiAgdmFyIHR5cGUgPSBfdHlwZW9mKGNvbmRpdGlvbik7XG4gIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIFtwbGFjZUhvbGRlckNvbnRlbnQsIHJlcGxhY2VOYnNwcyhwbGFjZUhvbGRlckNvbnRlbnQpLnN1YnN0cihjb25kaXRpb24ubGVuZ3RoKV07XG4gIH1cbiAgaWYgKGNvbmRpdGlvbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50KS5tYXRjaChjb25kaXRpb24pO1xuICB9XG4gIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gW3BsYWNlSG9sZGVyQ29udGVudCwgY29uZGl0aW9uKHBsYWNlSG9sZGVyQ29udGVudCldO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWF0Y2g6IG1hdGNoLFxuICBnZXRWYWx1ZTogZ2V0VmFsdWUsXG4gIGdldFZhbHVlczogZ2V0VmFsdWVzXG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/prefix-matcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/render.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/render.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"),\n  throwUnimplementedTagType = _require.throwUnimplementedTagType,\n  XTScopeParserError = _require.XTScopeParserError;\nvar _require2 = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require2.pushArray;\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(ssr)/./node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleRender(part, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    var moduleRendered = _module.render(part, options);\n    if (moduleRendered) {\n      return moduleRendered;\n    }\n  }\n  return false;\n}\nfunction render(options) {\n  var baseNullGetter = options.baseNullGetter;\n  var compiled = options.compiled,\n    scopeManager = options.scopeManager;\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n  var errors = [];\n  var parts = compiled.map(function (part, i) {\n    options.index = i;\n    options.resolvedId = getResolvedId(part, options);\n    var moduleRendered;\n    try {\n      moduleRendered = moduleRender(part, options);\n    } catch (e) {\n      if (e instanceof XTScopeParserError) {\n        errors.push(e);\n        return part;\n      }\n      throw e;\n    }\n    if (moduleRendered) {\n      if (moduleRendered.errors) {\n        Array.prototype.push.apply(errors, moduleRendered.errors);\n      }\n      return moduleRendered;\n    }\n    if (part.type === \"content\" || part.type === \"tag\") {\n      return part;\n    }\n    throwUnimplementedTagType(part, i);\n  }).reduce(function (parts, _ref) {\n    var value = _ref.value;\n    if (value instanceof Array) {\n      pushArray(parts, value);\n    } else if (value) {\n      parts.push(value);\n    }\n    return parts;\n  }, []);\n  return {\n    errors: errors,\n    parts: parts\n  };\n}\nmodule.exports = render;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9yZW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLG9FQUFhO0FBQ3BDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDeEM7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxzRkFBc0I7QUFDbEQ7QUFDQSx5REFBeUQsZ0NBQWdDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3JlbmRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlID0gX3JlcXVpcmUudGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZSxcbiAgWFRTY29wZVBhcnNlckVycm9yID0gX3JlcXVpcmUuWFRTY29wZVBhcnNlckVycm9yO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgcHVzaEFycmF5ID0gX3JlcXVpcmUyLnB1c2hBcnJheTtcbnZhciBnZXRSZXNvbHZlZElkID0gcmVxdWlyZShcIi4vZ2V0LXJlc29sdmVkLWlkLmpzXCIpO1xuZnVuY3Rpb24gbW9kdWxlUmVuZGVyKHBhcnQsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgX2kyID0gMCwgX29wdGlvbnMkbW9kdWxlczIgPSBvcHRpb25zLm1vZHVsZXM7IF9pMiA8IF9vcHRpb25zJG1vZHVsZXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX21vZHVsZSA9IF9vcHRpb25zJG1vZHVsZXMyW19pMl07XG4gICAgdmFyIG1vZHVsZVJlbmRlcmVkID0gX21vZHVsZS5yZW5kZXIocGFydCwgb3B0aW9ucyk7XG4gICAgaWYgKG1vZHVsZVJlbmRlcmVkKSB7XG4gICAgICByZXR1cm4gbW9kdWxlUmVuZGVyZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihvcHRpb25zKSB7XG4gIHZhciBiYXNlTnVsbEdldHRlciA9IG9wdGlvbnMuYmFzZU51bGxHZXR0ZXI7XG4gIHZhciBjb21waWxlZCA9IG9wdGlvbnMuY29tcGlsZWQsXG4gICAgc2NvcGVNYW5hZ2VyID0gb3B0aW9ucy5zY29wZU1hbmFnZXI7XG4gIG9wdGlvbnMubnVsbEdldHRlciA9IGZ1bmN0aW9uIChwYXJ0LCBzbSkge1xuICAgIHJldHVybiBiYXNlTnVsbEdldHRlcihwYXJ0LCBzbSB8fCBzY29wZU1hbmFnZXIpO1xuICB9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBwYXJ0cyA9IGNvbXBpbGVkLm1hcChmdW5jdGlvbiAocGFydCwgaSkge1xuICAgIG9wdGlvbnMuaW5kZXggPSBpO1xuICAgIG9wdGlvbnMucmVzb2x2ZWRJZCA9IGdldFJlc29sdmVkSWQocGFydCwgb3B0aW9ucyk7XG4gICAgdmFyIG1vZHVsZVJlbmRlcmVkO1xuICAgIHRyeSB7XG4gICAgICBtb2R1bGVSZW5kZXJlZCA9IG1vZHVsZVJlbmRlcihwYXJ0LCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFhUU2NvcGVQYXJzZXJFcnJvcikge1xuICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBpZiAobW9kdWxlUmVuZGVyZWQpIHtcbiAgICAgIGlmIChtb2R1bGVSZW5kZXJlZC5lcnJvcnMpIHtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZXJyb3JzLCBtb2R1bGVSZW5kZXJlZC5lcnJvcnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1vZHVsZVJlbmRlcmVkO1xuICAgIH1cbiAgICBpZiAocGFydC50eXBlID09PSBcImNvbnRlbnRcIiB8fCBwYXJ0LnR5cGUgPT09IFwidGFnXCIpIHtcbiAgICAgIHJldHVybiBwYXJ0O1xuICAgIH1cbiAgICB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlKHBhcnQsIGkpO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKHBhcnRzLCBfcmVmKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcHVzaEFycmF5KHBhcnRzLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgcGFydHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIGVycm9yczogZXJyb3JzLFxuICAgIHBhcnRzOiBwYXJ0c1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSByZW5kZXI7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/render.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/resolve.js":
/*!**************************************************!*\
  !*** ./node_modules/docxtemplater/js/resolve.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(ssr)/./node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleResolve(part, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    var moduleResolved = _module.resolve(part, options);\n    if (moduleResolved) {\n      return moduleResolved;\n    }\n  }\n  return false;\n}\nfunction resolve(options) {\n  var resolved = [];\n  var baseNullGetter = options.baseNullGetter;\n  var compiled = options.compiled,\n    scopeManager = options.scopeManager;\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n  options.resolved = resolved;\n  var errors = [];\n  return Promise.all(compiled.filter(function (part) {\n    return [\"content\", \"tag\"].indexOf(part.type) === -1;\n  }).reduce(function (promises, part) {\n    var moduleResolved = moduleResolve(part, _objectSpread(_objectSpread({}, options), {}, {\n      resolvedId: getResolvedId(part, options)\n    }));\n    var result;\n    if (moduleResolved) {\n      result = moduleResolved.then(function (value) {\n        resolved.push({\n          tag: part.value,\n          lIndex: part.lIndex,\n          value: value\n        });\n      });\n    } else if (part.type === \"placeholder\") {\n      result = scopeManager.getValueAsync(part.value, {\n        part: part\n      }).then(function (value) {\n        return value == null ? options.nullGetter(part) : value;\n      }).then(function (value) {\n        resolved.push({\n          tag: part.value,\n          lIndex: part.lIndex,\n          value: value\n        });\n        return value;\n      });\n    } else {\n      return;\n    }\n    promises.push(result[\"catch\"](function (e) {\n      if (e instanceof Array) {\n        errors.push.apply(errors, _toConsumableArray(e));\n      } else {\n        errors.push(e);\n      }\n    }));\n    return promises;\n  }, [])).then(function () {\n    return {\n      errors: errors,\n      resolved: resolved\n    };\n  });\n}\nmodule.exports = resolve;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9yZXNvbHZlLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsbUNBQW1DLCtDQUErQyw4QkFBOEIsT0FBTyxrQkFBa0I7QUFDekkseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLG9CQUFvQixtQkFBTyxDQUFDLHNGQUFzQjtBQUNsRDtBQUNBLHlEQUF5RCxnQ0FBZ0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyRUFBMkUsY0FBYztBQUN6RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3Jlc29sdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheShyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikgeyBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBnZXRSZXNvbHZlZElkID0gcmVxdWlyZShcIi4vZ2V0LXJlc29sdmVkLWlkLmpzXCIpO1xuZnVuY3Rpb24gbW9kdWxlUmVzb2x2ZShwYXJ0LCBvcHRpb25zKSB7XG4gIGZvciAodmFyIF9pMiA9IDAsIF9vcHRpb25zJG1vZHVsZXMyID0gb3B0aW9ucy5tb2R1bGVzOyBfaTIgPCBfb3B0aW9ucyRtb2R1bGVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9tb2R1bGUgPSBfb3B0aW9ucyRtb2R1bGVzMltfaTJdO1xuICAgIHZhciBtb2R1bGVSZXNvbHZlZCA9IF9tb2R1bGUucmVzb2x2ZShwYXJ0LCBvcHRpb25zKTtcbiAgICBpZiAobW9kdWxlUmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybiBtb2R1bGVSZXNvbHZlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZShvcHRpb25zKSB7XG4gIHZhciByZXNvbHZlZCA9IFtdO1xuICB2YXIgYmFzZU51bGxHZXR0ZXIgPSBvcHRpb25zLmJhc2VOdWxsR2V0dGVyO1xuICB2YXIgY29tcGlsZWQgPSBvcHRpb25zLmNvbXBpbGVkLFxuICAgIHNjb3BlTWFuYWdlciA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyO1xuICBvcHRpb25zLm51bGxHZXR0ZXIgPSBmdW5jdGlvbiAocGFydCwgc20pIHtcbiAgICByZXR1cm4gYmFzZU51bGxHZXR0ZXIocGFydCwgc20gfHwgc2NvcGVNYW5hZ2VyKTtcbiAgfTtcbiAgb3B0aW9ucy5yZXNvbHZlZCA9IHJlc29sdmVkO1xuICB2YXIgZXJyb3JzID0gW107XG4gIHJldHVybiBQcm9taXNlLmFsbChjb21waWxlZC5maWx0ZXIoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gW1wiY29udGVudFwiLCBcInRhZ1wiXS5pbmRleE9mKHBhcnQudHlwZSkgPT09IC0xO1xuICB9KS5yZWR1Y2UoZnVuY3Rpb24gKHByb21pc2VzLCBwYXJ0KSB7XG4gICAgdmFyIG1vZHVsZVJlc29sdmVkID0gbW9kdWxlUmVzb2x2ZShwYXJ0LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgcmVzb2x2ZWRJZDogZ2V0UmVzb2x2ZWRJZChwYXJ0LCBvcHRpb25zKVxuICAgIH0pKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChtb2R1bGVSZXNvbHZlZCkge1xuICAgICAgcmVzdWx0ID0gbW9kdWxlUmVzb2x2ZWQudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZWQucHVzaCh7XG4gICAgICAgICAgdGFnOiBwYXJ0LnZhbHVlLFxuICAgICAgICAgIGxJbmRleDogcGFydC5sSW5kZXgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IFwicGxhY2Vob2xkZXJcIikge1xuICAgICAgcmVzdWx0ID0gc2NvcGVNYW5hZ2VyLmdldFZhbHVlQXN5bmMocGFydC52YWx1ZSwge1xuICAgICAgICBwYXJ0OiBwYXJ0XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IG9wdGlvbnMubnVsbEdldHRlcihwYXJ0KSA6IHZhbHVlO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZWQucHVzaCh7XG4gICAgICAgICAgdGFnOiBwYXJ0LnZhbHVlLFxuICAgICAgICAgIGxJbmRleDogcGFydC5sSW5kZXgsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcm9taXNlcy5wdXNoKHJlc3VsdFtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgX3RvQ29uc3VtYWJsZUFycmF5KGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gcHJvbWlzZXM7XG4gIH0sIFtdKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgcmVzb2x2ZWQ6IHJlc29sdmVkXG4gICAgfTtcbiAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmU7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/resolve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/scope-manager.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/scope-manager.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"),\n  getScopeParserExecutionError = _require.getScopeParserExecutionError;\nvar _require2 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/docxtemplater/js/utils.js\"),\n  last = _require2.last;\nvar _require3 = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  concatArrays = _require3.concatArrays;\nfunction find(list, fn) {\n  var length = list.length >>> 0;\n  var value;\n  for (var i = 0; i < length; i++) {\n    value = list[i];\n    if (fn.call(this, value, i, list)) {\n      return value;\n    }\n  }\n  return undefined;\n}\nfunction _getValue(tag, meta, num) {\n  var _this = this;\n  var scope = this.scopeList[num];\n  if (this.root.finishedResolving) {\n    var w = this.resolved;\n    var _loop = function _loop() {\n      var lIndex = _this.scopeLindex[i];\n      w = find(w, function (r) {\n        return r.lIndex === lIndex;\n      });\n      w = w.value[_this.scopePathItem[i]];\n    };\n    for (var i = this.resolveOffset, len = this.scopePath.length; i < len; i++) {\n      _loop();\n    }\n    return find(w, function (r) {\n      return meta.part.lIndex === r.lIndex;\n    }).value;\n  }\n  // search in the scopes (in reverse order) and keep the first defined value\n  var result;\n  var parser;\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  }\n  try {\n    result = parser.get(scope, this.getContext(meta, num));\n  } catch (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }\n  if (result == null && num > 0) {\n    return _getValue.call(this, tag, meta, num - 1);\n  }\n  return result;\n}\nfunction _getValueAsync(tag, meta, num) {\n  var _this2 = this;\n  var scope = this.scopeList[num];\n  // search in the scopes (in reverse order) and keep the first defined value\n  var parser;\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  }\n  return Promise.resolve().then(function () {\n    return parser.get(scope, _this2.getContext(meta, num));\n  })[\"catch\"](function (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }).then(function (result) {\n    if (result == null && num > 0) {\n      return _getValueAsync.call(_this2, tag, meta, num - 1);\n    }\n    return result;\n  });\n}\nvar ScopeManager = /*#__PURE__*/function () {\n  function ScopeManager(options) {\n    _classCallCheck(this, ScopeManager);\n    this.root = options.root || this;\n    this.resolveOffset = options.resolveOffset || 0;\n    this.scopePath = options.scopePath;\n    this.scopePathItem = options.scopePathItem;\n    this.scopePathLength = options.scopePathLength;\n    this.scopeList = options.scopeList;\n    this.scopeType = \"\";\n    this.scopeTypes = options.scopeTypes;\n    this.scopeLindex = options.scopeLindex;\n    this.parser = options.parser;\n    this.resolved = options.resolved;\n    this.cachedParsers = options.cachedParsers;\n  }\n  return _createClass(ScopeManager, [{\n    key: \"loopOver\",\n    value: function loopOver(tag, functor, inverted, meta) {\n      return this.loopOverValue(this.getValue(tag, meta), functor, inverted);\n    }\n  }, {\n    key: \"functorIfInverted\",\n    value: function functorIfInverted(inverted, functor, value, i, length) {\n      if (inverted) {\n        functor(value, i, length);\n      }\n      return inverted;\n    }\n  }, {\n    key: \"isValueFalsy\",\n    value: function isValueFalsy(value, type) {\n      return value == null || !value || type === \"[object Array]\" && value.length === 0;\n    }\n  }, {\n    key: \"loopOverValue\",\n    value: function loopOverValue(value, functor, inverted) {\n      if (this.root.finishedResolving) {\n        inverted = false;\n      }\n      var type = Object.prototype.toString.call(value);\n      if (this.isValueFalsy(value, type)) {\n        this.scopeType = false;\n        return this.functorIfInverted(inverted, functor, last(this.scopeList), 0, 1);\n      }\n      if (type === \"[object Array]\") {\n        this.scopeType = \"array\";\n        for (var i = 0; i < value.length; i++) {\n          this.functorIfInverted(!inverted, functor, value[i], i, value.length);\n        }\n        return true;\n      }\n      if (type === \"[object Object]\") {\n        this.scopeType = \"object\";\n        return this.functorIfInverted(!inverted, functor, value, 0, 1);\n      }\n      return this.functorIfInverted(!inverted, functor, last(this.scopeList), 0, 1);\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(tag, meta) {\n      var result = _getValue.call(this, tag, meta, this.scopeList.length - 1);\n      if (typeof result === \"function\") {\n        return result(this.scopeList[this.scopeList.length - 1], this);\n      }\n      return result;\n    }\n  }, {\n    key: \"getValueAsync\",\n    value: function getValueAsync(tag, meta) {\n      var _this3 = this;\n      return _getValueAsync.call(this, tag, meta, this.scopeList.length - 1).then(function (result) {\n        if (typeof result === \"function\") {\n          return result(_this3.scopeList[_this3.scopeList.length - 1], _this3);\n        }\n        return result;\n      });\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(meta, num) {\n      return {\n        num: num,\n        meta: meta,\n        scopeList: this.scopeList,\n        resolved: this.resolved,\n        scopePath: this.scopePath,\n        scopeTypes: this.scopeTypes,\n        scopePathItem: this.scopePathItem,\n        scopePathLength: this.scopePathLength\n      };\n    }\n  }, {\n    key: \"createSubScopeManager\",\n    value: function createSubScopeManager(scope, tag, i, part, length) {\n      return new ScopeManager({\n        root: this.root,\n        resolveOffset: this.resolveOffset,\n        resolved: this.resolved,\n        parser: this.parser,\n        cachedParsers: this.cachedParsers,\n        scopeTypes: concatArrays([this.scopeTypes, [this.scopeType]]),\n        scopeList: concatArrays([this.scopeList, [scope]]),\n        scopePath: concatArrays([this.scopePath, [tag]]),\n        scopePathItem: concatArrays([this.scopePathItem, [i]]),\n        scopePathLength: concatArrays([this.scopePathLength, [length]]),\n        scopeLindex: concatArrays([this.scopeLindex, [part.lIndex]])\n      });\n    }\n  }]);\n}();\nmodule.exports = function (options) {\n  options.scopePath = [];\n  options.scopePathItem = [];\n  options.scopePathLength = [];\n  options.scopeTypes = [];\n  options.scopeLindex = [];\n  options.scopeList = [options.tags];\n  return new ScopeManager(options);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9zY29wZS1tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsb0VBQWE7QUFDcEM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBWTtBQUNwQztBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxrRUFBa0UsU0FBUztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9zY29wZS1tYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIiksXG4gIGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3IgPSBfcmVxdWlyZS5nZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpLFxuICBsYXN0ID0gX3JlcXVpcmUyLmxhc3Q7XG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBjb25jYXRBcnJheXMgPSBfcmVxdWlyZTMuY29uY2F0QXJyYXlzO1xuZnVuY3Rpb24gZmluZChsaXN0LCBmbikge1xuICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPj4+IDA7XG4gIHZhciB2YWx1ZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhbHVlID0gbGlzdFtpXTtcbiAgICBpZiAoZm4uY2FsbCh0aGlzLCB2YWx1ZSwgaSwgbGlzdCkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIF9nZXRWYWx1ZSh0YWcsIG1ldGEsIG51bSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlTGlzdFtudW1dO1xuICBpZiAodGhpcy5yb290LmZpbmlzaGVkUmVzb2x2aW5nKSB7XG4gICAgdmFyIHcgPSB0aGlzLnJlc29sdmVkO1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIGxJbmRleCA9IF90aGlzLnNjb3BlTGluZGV4W2ldO1xuICAgICAgdyA9IGZpbmQodywgZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgcmV0dXJuIHIubEluZGV4ID09PSBsSW5kZXg7XG4gICAgICB9KTtcbiAgICAgIHcgPSB3LnZhbHVlW190aGlzLnNjb3BlUGF0aEl0ZW1baV1dO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IHRoaXMucmVzb2x2ZU9mZnNldCwgbGVuID0gdGhpcy5zY29wZVBhdGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfVxuICAgIHJldHVybiBmaW5kKHcsIGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gbWV0YS5wYXJ0LmxJbmRleCA9PT0gci5sSW5kZXg7XG4gICAgfSkudmFsdWU7XG4gIH1cbiAgLy8gc2VhcmNoIGluIHRoZSBzY29wZXMgKGluIHJldmVyc2Ugb3JkZXIpIGFuZCBrZWVwIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlXG4gIHZhciByZXN1bHQ7XG4gIHZhciBwYXJzZXI7XG4gIGlmICghdGhpcy5jYWNoZWRQYXJzZXJzIHx8ICFtZXRhLnBhcnQpIHtcbiAgICBwYXJzZXIgPSB0aGlzLnBhcnNlcih0YWcsIHtcbiAgICAgIHRhZzogbWV0YS5wYXJ0LFxuICAgICAgc2NvcGVQYXRoOiB0aGlzLnNjb3BlUGF0aFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRoaXMuY2FjaGVkUGFyc2Vyc1ttZXRhLnBhcnQubEluZGV4XSkge1xuICAgIHBhcnNlciA9IHRoaXMuY2FjaGVkUGFyc2Vyc1ttZXRhLnBhcnQubEluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZXIgPSB0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF0gPSB0aGlzLnBhcnNlcih0YWcsIHtcbiAgICAgIHRhZzogbWV0YS5wYXJ0LFxuICAgICAgc2NvcGVQYXRoOiB0aGlzLnNjb3BlUGF0aFxuICAgIH0pO1xuICB9XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gcGFyc2VyLmdldChzY29wZSwgdGhpcy5nZXRDb250ZXh0KG1ldGEsIG51bSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3Ioe1xuICAgICAgdGFnOiB0YWcsXG4gICAgICBzY29wZTogc2NvcGUsXG4gICAgICBlcnJvcjogZXJyb3IsXG4gICAgICBvZmZzZXQ6IG1ldGEucGFydC5vZmZzZXRcbiAgICB9KTtcbiAgfVxuICBpZiAocmVzdWx0ID09IG51bGwgJiYgbnVtID4gMCkge1xuICAgIHJldHVybiBfZ2V0VmFsdWUuY2FsbCh0aGlzLCB0YWcsIG1ldGEsIG51bSAtIDEpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfZ2V0VmFsdWVBc3luYyh0YWcsIG1ldGEsIG51bSkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcbiAgdmFyIHNjb3BlID0gdGhpcy5zY29wZUxpc3RbbnVtXTtcbiAgLy8gc2VhcmNoIGluIHRoZSBzY29wZXMgKGluIHJldmVyc2Ugb3JkZXIpIGFuZCBrZWVwIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlXG4gIHZhciBwYXJzZXI7XG4gIGlmICghdGhpcy5jYWNoZWRQYXJzZXJzIHx8ICFtZXRhLnBhcnQpIHtcbiAgICBwYXJzZXIgPSB0aGlzLnBhcnNlcih0YWcsIHtcbiAgICAgIHRhZzogbWV0YS5wYXJ0LFxuICAgICAgc2NvcGVQYXRoOiB0aGlzLnNjb3BlUGF0aFxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRoaXMuY2FjaGVkUGFyc2Vyc1ttZXRhLnBhcnQubEluZGV4XSkge1xuICAgIHBhcnNlciA9IHRoaXMuY2FjaGVkUGFyc2Vyc1ttZXRhLnBhcnQubEluZGV4XTtcbiAgfSBlbHNlIHtcbiAgICBwYXJzZXIgPSB0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF0gPSB0aGlzLnBhcnNlcih0YWcsIHtcbiAgICAgIHRhZzogbWV0YS5wYXJ0LFxuICAgICAgc2NvcGVQYXRoOiB0aGlzLnNjb3BlUGF0aFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFyc2VyLmdldChzY29wZSwgX3RoaXMyLmdldENvbnRleHQobWV0YSwgbnVtKSk7XG4gIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdGhyb3cgZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcih7XG4gICAgICB0YWc6IHRhZyxcbiAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIG9mZnNldDogbWV0YS5wYXJ0Lm9mZnNldFxuICAgIH0pO1xuICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgbnVtID4gMCkge1xuICAgICAgcmV0dXJuIF9nZXRWYWx1ZUFzeW5jLmNhbGwoX3RoaXMyLCB0YWcsIG1ldGEsIG51bSAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn1cbnZhciBTY29wZU1hbmFnZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY29wZU1hbmFnZXIob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY29wZU1hbmFnZXIpO1xuICAgIHRoaXMucm9vdCA9IG9wdGlvbnMucm9vdCB8fCB0aGlzO1xuICAgIHRoaXMucmVzb2x2ZU9mZnNldCA9IG9wdGlvbnMucmVzb2x2ZU9mZnNldCB8fCAwO1xuICAgIHRoaXMuc2NvcGVQYXRoID0gb3B0aW9ucy5zY29wZVBhdGg7XG4gICAgdGhpcy5zY29wZVBhdGhJdGVtID0gb3B0aW9ucy5zY29wZVBhdGhJdGVtO1xuICAgIHRoaXMuc2NvcGVQYXRoTGVuZ3RoID0gb3B0aW9ucy5zY29wZVBhdGhMZW5ndGg7XG4gICAgdGhpcy5zY29wZUxpc3QgPSBvcHRpb25zLnNjb3BlTGlzdDtcbiAgICB0aGlzLnNjb3BlVHlwZSA9IFwiXCI7XG4gICAgdGhpcy5zY29wZVR5cGVzID0gb3B0aW9ucy5zY29wZVR5cGVzO1xuICAgIHRoaXMuc2NvcGVMaW5kZXggPSBvcHRpb25zLnNjb3BlTGluZGV4O1xuICAgIHRoaXMucGFyc2VyID0gb3B0aW9ucy5wYXJzZXI7XG4gICAgdGhpcy5yZXNvbHZlZCA9IG9wdGlvbnMucmVzb2x2ZWQ7XG4gICAgdGhpcy5jYWNoZWRQYXJzZXJzID0gb3B0aW9ucy5jYWNoZWRQYXJzZXJzO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoU2NvcGVNYW5hZ2VyLCBbe1xuICAgIGtleTogXCJsb29wT3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb29wT3Zlcih0YWcsIGZ1bmN0b3IsIGludmVydGVkLCBtZXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb29wT3ZlclZhbHVlKHRoaXMuZ2V0VmFsdWUodGFnLCBtZXRhKSwgZnVuY3RvciwgaW52ZXJ0ZWQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmdW5jdG9ySWZJbnZlcnRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmdW5jdG9ySWZJbnZlcnRlZChpbnZlcnRlZCwgZnVuY3RvciwgdmFsdWUsIGksIGxlbmd0aCkge1xuICAgICAgaWYgKGludmVydGVkKSB7XG4gICAgICAgIGZ1bmN0b3IodmFsdWUsIGksIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW52ZXJ0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmFsdWVGYWxzeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZhbHVlRmFsc3kodmFsdWUsIHR5cGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8ICF2YWx1ZSB8fCB0eXBlID09PSBcIltvYmplY3QgQXJyYXldXCIgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb29wT3ZlclZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvb3BPdmVyVmFsdWUodmFsdWUsIGZ1bmN0b3IsIGludmVydGVkKSB7XG4gICAgICBpZiAodGhpcy5yb290LmZpbmlzaGVkUmVzb2x2aW5nKSB7XG4gICAgICAgIGludmVydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBpZiAodGhpcy5pc1ZhbHVlRmFsc3kodmFsdWUsIHR5cGUpKSB7XG4gICAgICAgIHRoaXMuc2NvcGVUeXBlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0b3JJZkludmVydGVkKGludmVydGVkLCBmdW5jdG9yLCBsYXN0KHRoaXMuc2NvcGVMaXN0KSwgMCwgMSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICAgIHRoaXMuc2NvcGVUeXBlID0gXCJhcnJheVwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5mdW5jdG9ySWZJbnZlcnRlZCghaW52ZXJ0ZWQsIGZ1bmN0b3IsIHZhbHVlW2ldLCBpLCB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcbiAgICAgICAgdGhpcy5zY29wZVR5cGUgPSBcIm9iamVjdFwiO1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdG9ySWZJbnZlcnRlZCghaW52ZXJ0ZWQsIGZ1bmN0b3IsIHZhbHVlLCAwLCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZ1bmN0b3JJZkludmVydGVkKCFpbnZlcnRlZCwgZnVuY3RvciwgbGFzdCh0aGlzLnNjb3BlTGlzdCksIDAsIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSh0YWcsIG1ldGEpIHtcbiAgICAgIHZhciByZXN1bHQgPSBfZ2V0VmFsdWUuY2FsbCh0aGlzLCB0YWcsIG1ldGEsIHRoaXMuc2NvcGVMaXN0Lmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMuc2NvcGVMaXN0W3RoaXMuc2NvcGVMaXN0Lmxlbmd0aCAtIDFdLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlQXN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVBc3luYyh0YWcsIG1ldGEpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgcmV0dXJuIF9nZXRWYWx1ZUFzeW5jLmNhbGwodGhpcywgdGFnLCBtZXRhLCB0aGlzLnNjb3BlTGlzdC5sZW5ndGggLSAxKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQoX3RoaXMzLnNjb3BlTGlzdFtfdGhpczMuc2NvcGVMaXN0Lmxlbmd0aCAtIDFdLCBfdGhpczMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZXh0KG1ldGEsIG51bSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbnVtOiBudW0sXG4gICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgIHNjb3BlTGlzdDogdGhpcy5zY29wZUxpc3QsXG4gICAgICAgIHJlc29sdmVkOiB0aGlzLnJlc29sdmVkLFxuICAgICAgICBzY29wZVBhdGg6IHRoaXMuc2NvcGVQYXRoLFxuICAgICAgICBzY29wZVR5cGVzOiB0aGlzLnNjb3BlVHlwZXMsXG4gICAgICAgIHNjb3BlUGF0aEl0ZW06IHRoaXMuc2NvcGVQYXRoSXRlbSxcbiAgICAgICAgc2NvcGVQYXRoTGVuZ3RoOiB0aGlzLnNjb3BlUGF0aExlbmd0aFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlU3ViU2NvcGVNYW5hZ2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVN1YlNjb3BlTWFuYWdlcihzY29wZSwgdGFnLCBpLCBwYXJ0LCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgU2NvcGVNYW5hZ2VyKHtcbiAgICAgICAgcm9vdDogdGhpcy5yb290LFxuICAgICAgICByZXNvbHZlT2Zmc2V0OiB0aGlzLnJlc29sdmVPZmZzZXQsXG4gICAgICAgIHJlc29sdmVkOiB0aGlzLnJlc29sdmVkLFxuICAgICAgICBwYXJzZXI6IHRoaXMucGFyc2VyLFxuICAgICAgICBjYWNoZWRQYXJzZXJzOiB0aGlzLmNhY2hlZFBhcnNlcnMsXG4gICAgICAgIHNjb3BlVHlwZXM6IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZVR5cGVzLCBbdGhpcy5zY29wZVR5cGVdXSksXG4gICAgICAgIHNjb3BlTGlzdDogY29uY2F0QXJyYXlzKFt0aGlzLnNjb3BlTGlzdCwgW3Njb3BlXV0pLFxuICAgICAgICBzY29wZVBhdGg6IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZVBhdGgsIFt0YWddXSksXG4gICAgICAgIHNjb3BlUGF0aEl0ZW06IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZVBhdGhJdGVtLCBbaV1dKSxcbiAgICAgICAgc2NvcGVQYXRoTGVuZ3RoOiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVQYXRoTGVuZ3RoLCBbbGVuZ3RoXV0pLFxuICAgICAgICBzY29wZUxpbmRleDogY29uY2F0QXJyYXlzKFt0aGlzLnNjb3BlTGluZGV4LCBbcGFydC5sSW5kZXhdXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBvcHRpb25zLnNjb3BlUGF0aCA9IFtdO1xuICBvcHRpb25zLnNjb3BlUGF0aEl0ZW0gPSBbXTtcbiAgb3B0aW9ucy5zY29wZVBhdGhMZW5ndGggPSBbXTtcbiAgb3B0aW9ucy5zY29wZVR5cGVzID0gW107XG4gIG9wdGlvbnMuc2NvcGVMaW5kZXggPSBbXTtcbiAgb3B0aW9ucy5zY29wZUxpc3QgPSBbb3B0aW9ucy50YWdzXTtcbiAgcmV0dXJuIG5ldyBTY29wZU1hbmFnZXIob3B0aW9ucyk7XG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/scope-manager.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/traits.js":
/*!*************************************************!*\
  !*** ./node_modules/docxtemplater/js/traits.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  getRightOrNull = _require.getRightOrNull,\n  getRight = _require.getRight,\n  getLeft = _require.getLeft,\n  getLeftOrNull = _require.getLeftOrNull,\n  chunkBy = _require.chunkBy,\n  isTagStart = _require.isTagStart,\n  isTagEnd = _require.isTagEnd,\n  isContent = _require.isContent,\n  last = _require.last,\n  first = _require.first;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/docxtemplater/js/errors.js\"),\n  XTTemplateError = _require2.XTTemplateError,\n  throwExpandNotFound = _require2.throwExpandNotFound,\n  getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\nfunction lastTagIsOpenTag(tags, tag) {\n  if (tags.length === 0) {\n    return false;\n  }\n  var innerLastTag = last(tags).substr(1);\n  return innerLastTag.indexOf(tag) === 0;\n}\nfunction getListXmlElements(parts) {\n  /*\n   * Gets the list of closing and opening tags between two texts. It doesn't take\n   * into account tags that are opened then closed. Those that are closed then\n   * opened are kept\n   *\n   * Example input :\n   *\n   * [\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"table1\",\n   * \t\t...\n   * \t},\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"t1data1\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"position\": \"end\",\n   * \t\t\"text\": true,\n   * \t\t\"value\": \"</w:t>\",\n   * \t\t\"tag\": \"w:t\",\n   * \t\t\"lIndex\": 112\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:r>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:p>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:tc>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:tc>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"content\",\n   * \t\t\"value\": \"<w:tcPr><w:tcW w:w=\"2444\" w:type=\"dxa\"/><w:tcBorders><w:top w:val=\"nil\"/><w:left w:val=\"nil\"/><w:bottom w:val=\"nil\"/><w:right w:val=\"nil\"/></w:tcBorders><w:shd w:val=\"clear\" w:color=\"auto\" w:fill=\"FFFFFF\"/></w:tcPr>\",\n   * \t},\n   * \t...\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:r>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:t xml:space=\"preserve\">\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"t1data4\",\n   * \t}\n   * ]\n   *\n   * Returns\n   *\n   * \t[\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:t>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:r>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:p>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:tc>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:tc>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:p>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:r>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:t>\",\n   * \t\t},\n   * \t]\n   */\n\n  var result = [];\n  for (var _i2 = 0; _i2 < parts.length; _i2++) {\n    var _parts$_i = parts[_i2],\n      position = _parts$_i.position,\n      value = _parts$_i.value,\n      tag = _parts$_i.tag;\n    // Stryker disable all : because removing this condition would also work but we want to make the API future proof\n    if (!tag) {\n      continue;\n    }\n    // Stryker restore all\n    if (position === \"end\") {\n      if (lastTagIsOpenTag(result, tag)) {\n        result.pop();\n      } else {\n        result.push(value);\n      }\n    } else if (position === \"start\") {\n      result.push(value);\n    }\n    // ignore position === \"selfclosing\"\n  }\n  return result;\n}\nfunction has(name, xmlElements) {\n  for (var _i4 = 0; _i4 < xmlElements.length; _i4++) {\n    var xmlElement = xmlElements[_i4];\n    if (xmlElement.indexOf(\"<\".concat(name)) === 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getExpandToDefault(postparsed, pair, expandTags) {\n  var parts = postparsed.slice(pair[0].offset, pair[1].offset);\n  var xmlElements = getListXmlElements(parts);\n  var closingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] === \"/\";\n  }).length;\n  var startingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] !== \"/\" && tag[tag.length - 2] !== \"/\";\n  }).length;\n  if (closingTagCount !== startingTagCount) {\n    return {\n      error: getLoopPositionProducesInvalidXMLError({\n        tag: first(pair).part.value,\n        offset: [first(pair).part.offset, last(pair).part.offset]\n      })\n    };\n  }\n  var _loop = function _loop() {\n      var _expandTags$_i = expandTags[_i6],\n        contains = _expandTags$_i.contains,\n        expand = _expandTags$_i.expand,\n        onlyTextInTag = _expandTags$_i.onlyTextInTag;\n      if (has(contains, xmlElements)) {\n        if (onlyTextInTag) {\n          var left = getLeftOrNull(postparsed, contains, pair[0].offset);\n          var right = getRightOrNull(postparsed, contains, pair[1].offset);\n          if (left === null || right === null) {\n            return 0; // continue\n          }\n          var chunks = chunkBy(postparsed.slice(left, right), function (p) {\n            return isTagStart(contains, p) ? \"start\" : isTagEnd(contains, p) ? \"end\" : null;\n          });\n          var firstChunk = first(chunks);\n          var lastChunk = last(chunks);\n          var firstContent = firstChunk.filter(isContent);\n          var lastContent = lastChunk.filter(isContent);\n          if (firstContent.length !== 1 || lastContent.length !== 1) {\n            return 0; // continue\n          }\n        }\n        return {\n          v: {\n            value: expand\n          }\n        };\n      }\n    },\n    _ret;\n  for (var _i6 = 0; _i6 < expandTags.length; _i6++) {\n    _ret = _loop();\n    if (_ret === 0) continue;\n    if (_ret) return _ret.v;\n  }\n  return {};\n}\nfunction getExpandLimit(part, index, postparsed, options) {\n  var expandTo = part.expandTo || options.expandTo;\n  // Stryker disable all : because this condition can be removed in v4 (the only usage was the image module before version 3.12.3 of the image module\n  if (!expandTo) {\n    return;\n  }\n  // Stryker restore all\n  var right, left;\n  try {\n    left = getLeft(postparsed, expandTo, index);\n    right = getRight(postparsed, expandTo, index);\n  } catch (rootError) {\n    var errProps = _objectSpread({\n      part: part,\n      rootError: rootError,\n      postparsed: postparsed,\n      expandTo: expandTo,\n      index: index\n    }, options.error);\n    if (options.onError) {\n      var errorResult = options.onError(errProps);\n      if (errorResult === \"ignore\") {\n        return;\n      }\n    }\n    throwExpandNotFound(errProps);\n  }\n  return [left, right];\n}\nfunction expandOne(_ref, part, postparsed, options) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    left = _ref2[0],\n    right = _ref2[1];\n  var index = postparsed.indexOf(part);\n  var leftParts = postparsed.slice(left, index);\n  var rightParts = postparsed.slice(index + 1, right + 1);\n  var inner = options.getInner({\n    postparse: options.postparse,\n    index: index,\n    part: part,\n    leftParts: leftParts,\n    rightParts: rightParts,\n    left: left,\n    right: right,\n    postparsed: postparsed\n  });\n  if (!inner.length) {\n    inner.expanded = [leftParts, rightParts];\n    inner = [inner];\n  }\n  return {\n    left: left,\n    right: right,\n    inner: inner\n  };\n}\n\n/* eslint-disable-next-line complexity */\nfunction expandToOne(postparsed, options) {\n  var errors = [];\n  if (postparsed.errors) {\n    errors = postparsed.errors;\n    postparsed = postparsed.postparsed;\n  }\n  var limits = [];\n  for (var i = 0, len = postparsed.length; i < len; i++) {\n    var part = postparsed[i];\n    if (part.type === \"placeholder\" && part.module === options.moduleName &&\n    /*\n     * The part.subparsed check is used to fix this github issue :\n     * https://github.com/open-xml-templating/docxtemplater/issues/671\n     */\n    !part.subparsed && !part.expanded) {\n      try {\n        var limit = getExpandLimit(part, i, postparsed, options);\n        if (!limit) {\n          continue;\n        }\n        var _limit = _slicedToArray(limit, 2),\n          left = _limit[0],\n          right = _limit[1];\n        limits.push({\n          left: left,\n          right: right,\n          part: part,\n          i: i,\n          leftPart: postparsed[left],\n          rightPart: postparsed[right]\n        });\n      } catch (error) {\n        // The Error can only be a\n        errors.push(error);\n      }\n    }\n  }\n  limits.sort(function (l1, l2) {\n    if (l1.left === l2.left) {\n      return l2.part.lIndex < l1.part.lIndex ? 1 : -1;\n    }\n    return l2.left < l1.left ? 1 : -1;\n  });\n  var maxRight = -1;\n  var offset = 0;\n  for (var _i7 = 0, _len = limits.length; _i7 < _len; _i7++) {\n    var _postparsed;\n    var _limit2 = limits[_i7];\n    maxRight = Math.max(maxRight, _i7 > 0 ? limits[_i7 - 1].right : 0);\n    if (_limit2.left < maxRight) {\n      continue;\n    }\n    var result = void 0;\n    try {\n      result = expandOne([_limit2.left + offset, _limit2.right + offset], _limit2.part, postparsed, options);\n    } catch (error) {\n      if (options.onError) {\n        var errorResult = options.onError(_objectSpread({\n          part: _limit2.part,\n          rootError: error,\n          postparsed: postparsed,\n          expandOne: expandOne\n        }, options.errors));\n        if (errorResult === \"ignore\") {\n          continue;\n        }\n      }\n      if (error instanceof XTTemplateError) {\n        errors.push(error);\n      } else {\n        throw error;\n      }\n    }\n    if (!result) {\n      continue;\n    }\n    offset += result.inner.length - (result.right + 1 - result.left);\n    (_postparsed = postparsed).splice.apply(_postparsed, [result.left, result.right + 1 - result.left].concat(_toConsumableArray(result.inner)));\n  }\n  return {\n    postparsed: postparsed,\n    errors: errors\n  };\n}\nmodule.exports = {\n  expandToOne: expandToOne,\n  getExpandToDefault: getExpandToDefault\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy90cmFpdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHVDQUF1QyxrR0FBa0csaUJBQWlCLHdDQUF3QyxNQUFNLHlDQUF5Qyw2QkFBNkIsVUFBVSxZQUFZLGtFQUFrRSxXQUFXLFlBQVksaUJBQWlCLFVBQVUsTUFBTSxpRkFBaUYsVUFBVSxvQkFBb0I7QUFDN2dCLDhCQUE4QjtBQUM5Qix5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsZUFBZSxtQkFBTyxDQUFDLDBFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvdHJhaXRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHsgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIGdldFJpZ2h0T3JOdWxsID0gX3JlcXVpcmUuZ2V0UmlnaHRPck51bGwsXG4gIGdldFJpZ2h0ID0gX3JlcXVpcmUuZ2V0UmlnaHQsXG4gIGdldExlZnQgPSBfcmVxdWlyZS5nZXRMZWZ0LFxuICBnZXRMZWZ0T3JOdWxsID0gX3JlcXVpcmUuZ2V0TGVmdE9yTnVsbCxcbiAgY2h1bmtCeSA9IF9yZXF1aXJlLmNodW5rQnksXG4gIGlzVGFnU3RhcnQgPSBfcmVxdWlyZS5pc1RhZ1N0YXJ0LFxuICBpc1RhZ0VuZCA9IF9yZXF1aXJlLmlzVGFnRW5kLFxuICBpc0NvbnRlbnQgPSBfcmVxdWlyZS5pc0NvbnRlbnQsXG4gIGxhc3QgPSBfcmVxdWlyZS5sYXN0LFxuICBmaXJzdCA9IF9yZXF1aXJlLmZpcnN0O1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgWFRUZW1wbGF0ZUVycm9yID0gX3JlcXVpcmUyLlhUVGVtcGxhdGVFcnJvcixcbiAgdGhyb3dFeHBhbmROb3RGb3VuZCA9IF9yZXF1aXJlMi50aHJvd0V4cGFuZE5vdEZvdW5kLFxuICBnZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvciA9IF9yZXF1aXJlMi5nZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvcjtcbmZ1bmN0aW9uIGxhc3RUYWdJc09wZW5UYWcodGFncywgdGFnKSB7XG4gIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5uZXJMYXN0VGFnID0gbGFzdCh0YWdzKS5zdWJzdHIoMSk7XG4gIHJldHVybiBpbm5lckxhc3RUYWcuaW5kZXhPZih0YWcpID09PSAwO1xufVxuZnVuY3Rpb24gZ2V0TGlzdFhtbEVsZW1lbnRzKHBhcnRzKSB7XG4gIC8qXG4gICAqIEdldHMgdGhlIGxpc3Qgb2YgY2xvc2luZyBhbmQgb3BlbmluZyB0YWdzIGJldHdlZW4gdHdvIHRleHRzLiBJdCBkb2Vzbid0IHRha2VcbiAgICogaW50byBhY2NvdW50IHRhZ3MgdGhhdCBhcmUgb3BlbmVkIHRoZW4gY2xvc2VkLiBUaG9zZSB0aGF0IGFyZSBjbG9zZWQgdGhlblxuICAgKiBvcGVuZWQgYXJlIGtlcHRcbiAgICpcbiAgICogRXhhbXBsZSBpbnB1dCA6XG4gICAqXG4gICAqIFtcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJwbGFjZWhvbGRlclwiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcInRhYmxlMVwiLFxuICAgKiBcdFx0Li4uXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJwbGFjZWhvbGRlclwiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcInQxZGF0YTFcIixcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJwb3NpdGlvblwiOiBcImVuZFwiLFxuICAgKiBcdFx0XCJ0ZXh0XCI6IHRydWUsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPC93OnQ+XCIsXG4gICAqIFx0XHRcInRhZ1wiOiBcInc6dFwiLFxuICAgKiBcdFx0XCJsSW5kZXhcIjogMTEyXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCI8L3c6cj5cIixcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjwvdzpwPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPC93OnRjPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPHc6dGM+XCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJjb250ZW50XCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPHc6dGNQcj48dzp0Y1cgdzp3PVwiMjQ0NFwiIHc6dHlwZT1cImR4YVwiLz48dzp0Y0JvcmRlcnM+PHc6dG9wIHc6dmFsPVwibmlsXCIvPjx3OmxlZnQgdzp2YWw9XCJuaWxcIi8+PHc6Ym90dG9tIHc6dmFsPVwibmlsXCIvPjx3OnJpZ2h0IHc6dmFsPVwibmlsXCIvPjwvdzp0Y0JvcmRlcnM+PHc6c2hkIHc6dmFsPVwiY2xlYXJcIiB3OmNvbG9yPVwiYXV0b1wiIHc6ZmlsbD1cIkZGRkZGRlwiLz48L3c6dGNQcj5cIixcbiAgICogXHR9LFxuICAgKiBcdC4uLlxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjx3OnI+XCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCI8dzp0IHhtbDpzcGFjZT1cInByZXNlcnZlXCI+XCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJwbGFjZWhvbGRlclwiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcInQxZGF0YTRcIixcbiAgICogXHR9XG4gICAqIF1cbiAgICpcbiAgICogUmV0dXJuc1xuICAgKlxuICAgKiBcdFtcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8L3c6dD5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPC93OnI+XCIsXG4gICAqIFx0XHR9LFxuICAgKiBcdFx0e1xuICAgKiBcdFx0XHRcInRhZ1wiOiBcIjwvdzpwPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8L3c6dGM+XCIsXG4gICAqIFx0XHR9LFxuICAgKiBcdFx0e1xuICAgKiBcdFx0XHRcInRhZ1wiOiBcIjx3OnRjPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8dzpwPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8dzpyPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8dzp0PlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRdXG4gICAqL1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcGFydHMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfcGFydHMkX2kgPSBwYXJ0c1tfaTJdLFxuICAgICAgcG9zaXRpb24gPSBfcGFydHMkX2kucG9zaXRpb24sXG4gICAgICB2YWx1ZSA9IF9wYXJ0cyRfaS52YWx1ZSxcbiAgICAgIHRhZyA9IF9wYXJ0cyRfaS50YWc7XG4gICAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgcmVtb3ZpbmcgdGhpcyBjb25kaXRpb24gd291bGQgYWxzbyB3b3JrIGJ1dCB3ZSB3YW50IHRvIG1ha2UgdGhlIEFQSSBmdXR1cmUgcHJvb2ZcbiAgICBpZiAoIXRhZykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcbiAgICBpZiAocG9zaXRpb24gPT09IFwiZW5kXCIpIHtcbiAgICAgIGlmIChsYXN0VGFnSXNPcGVuVGFnKHJlc3VsdCwgdGFnKSkge1xuICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIGlnbm9yZSBwb3NpdGlvbiA9PT0gXCJzZWxmY2xvc2luZ1wiXG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGhhcyhuYW1lLCB4bWxFbGVtZW50cykge1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCB4bWxFbGVtZW50cy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIHhtbEVsZW1lbnQgPSB4bWxFbGVtZW50c1tfaTRdO1xuICAgIGlmICh4bWxFbGVtZW50LmluZGV4T2YoXCI8XCIuY29uY2F0KG5hbWUpKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEV4cGFuZFRvRGVmYXVsdChwb3N0cGFyc2VkLCBwYWlyLCBleHBhbmRUYWdzKSB7XG4gIHZhciBwYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UocGFpclswXS5vZmZzZXQsIHBhaXJbMV0ub2Zmc2V0KTtcbiAgdmFyIHhtbEVsZW1lbnRzID0gZ2V0TGlzdFhtbEVsZW1lbnRzKHBhcnRzKTtcbiAgdmFyIGNsb3NpbmdUYWdDb3VudCA9IHhtbEVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAodGFnKSB7XG4gICAgcmV0dXJuIHRhZ1sxXSA9PT0gXCIvXCI7XG4gIH0pLmxlbmd0aDtcbiAgdmFyIHN0YXJ0aW5nVGFnQ291bnQgPSB4bWxFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHRhZykge1xuICAgIHJldHVybiB0YWdbMV0gIT09IFwiL1wiICYmIHRhZ1t0YWcubGVuZ3RoIC0gMl0gIT09IFwiL1wiO1xuICB9KS5sZW5ndGg7XG4gIGlmIChjbG9zaW5nVGFnQ291bnQgIT09IHN0YXJ0aW5nVGFnQ291bnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yKHtcbiAgICAgICAgdGFnOiBmaXJzdChwYWlyKS5wYXJ0LnZhbHVlLFxuICAgICAgICBvZmZzZXQ6IFtmaXJzdChwYWlyKS5wYXJ0Lm9mZnNldCwgbGFzdChwYWlyKS5wYXJ0Lm9mZnNldF1cbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBfZXhwYW5kVGFncyRfaSA9IGV4cGFuZFRhZ3NbX2k2XSxcbiAgICAgICAgY29udGFpbnMgPSBfZXhwYW5kVGFncyRfaS5jb250YWlucyxcbiAgICAgICAgZXhwYW5kID0gX2V4cGFuZFRhZ3MkX2kuZXhwYW5kLFxuICAgICAgICBvbmx5VGV4dEluVGFnID0gX2V4cGFuZFRhZ3MkX2kub25seVRleHRJblRhZztcbiAgICAgIGlmIChoYXMoY29udGFpbnMsIHhtbEVsZW1lbnRzKSkge1xuICAgICAgICBpZiAob25seVRleHRJblRhZykge1xuICAgICAgICAgIHZhciBsZWZ0ID0gZ2V0TGVmdE9yTnVsbChwb3N0cGFyc2VkLCBjb250YWlucywgcGFpclswXS5vZmZzZXQpO1xuICAgICAgICAgIHZhciByaWdodCA9IGdldFJpZ2h0T3JOdWxsKHBvc3RwYXJzZWQsIGNvbnRhaW5zLCBwYWlyWzFdLm9mZnNldCk7XG4gICAgICAgICAgaWYgKGxlZnQgPT09IG51bGwgfHwgcmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2h1bmtzID0gY2h1bmtCeShwb3N0cGFyc2VkLnNsaWNlKGxlZnQsIHJpZ2h0KSwgZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHJldHVybiBpc1RhZ1N0YXJ0KGNvbnRhaW5zLCBwKSA/IFwic3RhcnRcIiA6IGlzVGFnRW5kKGNvbnRhaW5zLCBwKSA/IFwiZW5kXCIgOiBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBmaXJzdENodW5rID0gZmlyc3QoY2h1bmtzKTtcbiAgICAgICAgICB2YXIgbGFzdENodW5rID0gbGFzdChjaHVua3MpO1xuICAgICAgICAgIHZhciBmaXJzdENvbnRlbnQgPSBmaXJzdENodW5rLmZpbHRlcihpc0NvbnRlbnQpO1xuICAgICAgICAgIHZhciBsYXN0Q29udGVudCA9IGxhc3RDaHVuay5maWx0ZXIoaXNDb250ZW50KTtcbiAgICAgICAgICBpZiAoZmlyc3RDb250ZW50Lmxlbmd0aCAhPT0gMSB8fCBsYXN0Q29udGVudC5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6IHtcbiAgICAgICAgICAgIHZhbHVlOiBleHBhbmRcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBfcmV0O1xuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBleHBhbmRUYWdzLmxlbmd0aDsgX2k2KyspIHtcbiAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICBpZiAoX3JldCA9PT0gMCkgY29udGludWU7XG4gICAgaWYgKF9yZXQpIHJldHVybiBfcmV0LnY7XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kTGltaXQocGFydCwgaW5kZXgsIHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgdmFyIGV4cGFuZFRvID0gcGFydC5leHBhbmRUbyB8fCBvcHRpb25zLmV4cGFuZFRvO1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGNvbmRpdGlvbiBjYW4gYmUgcmVtb3ZlZCBpbiB2NCAodGhlIG9ubHkgdXNhZ2Ugd2FzIHRoZSBpbWFnZSBtb2R1bGUgYmVmb3JlIHZlcnNpb24gMy4xMi4zIG9mIHRoZSBpbWFnZSBtb2R1bGVcbiAgaWYgKCFleHBhbmRUbykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG4gIHZhciByaWdodCwgbGVmdDtcbiAgdHJ5IHtcbiAgICBsZWZ0ID0gZ2V0TGVmdChwb3N0cGFyc2VkLCBleHBhbmRUbywgaW5kZXgpO1xuICAgIHJpZ2h0ID0gZ2V0UmlnaHQocG9zdHBhcnNlZCwgZXhwYW5kVG8sIGluZGV4KTtcbiAgfSBjYXRjaCAocm9vdEVycm9yKSB7XG4gICAgdmFyIGVyclByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgcm9vdEVycm9yOiByb290RXJyb3IsXG4gICAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkLFxuICAgICAgZXhwYW5kVG86IGV4cGFuZFRvLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSwgb3B0aW9ucy5lcnJvcik7XG4gICAgaWYgKG9wdGlvbnMub25FcnJvcikge1xuICAgICAgdmFyIGVycm9yUmVzdWx0ID0gb3B0aW9ucy5vbkVycm9yKGVyclByb3BzKTtcbiAgICAgIGlmIChlcnJvclJlc3VsdCA9PT0gXCJpZ25vcmVcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93RXhwYW5kTm90Rm91bmQoZXJyUHJvcHMpO1xuICB9XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdO1xufVxuZnVuY3Rpb24gZXhwYW5kT25lKF9yZWYsIHBhcnQsIHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgbGVmdCA9IF9yZWYyWzBdLFxuICAgIHJpZ2h0ID0gX3JlZjJbMV07XG4gIHZhciBpbmRleCA9IHBvc3RwYXJzZWQuaW5kZXhPZihwYXJ0KTtcbiAgdmFyIGxlZnRQYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UobGVmdCwgaW5kZXgpO1xuICB2YXIgcmlnaHRQYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UoaW5kZXggKyAxLCByaWdodCArIDEpO1xuICB2YXIgaW5uZXIgPSBvcHRpb25zLmdldElubmVyKHtcbiAgICBwb3N0cGFyc2U6IG9wdGlvbnMucG9zdHBhcnNlLFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBwYXJ0OiBwYXJ0LFxuICAgIGxlZnRQYXJ0czogbGVmdFBhcnRzLFxuICAgIHJpZ2h0UGFydHM6IHJpZ2h0UGFydHMsXG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogcmlnaHQsXG4gICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZFxuICB9KTtcbiAgaWYgKCFpbm5lci5sZW5ndGgpIHtcbiAgICBpbm5lci5leHBhbmRlZCA9IFtsZWZ0UGFydHMsIHJpZ2h0UGFydHNdO1xuICAgIGlubmVyID0gW2lubmVyXTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIGlubmVyOiBpbm5lclxuICB9O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eSAqL1xuZnVuY3Rpb24gZXhwYW5kVG9PbmUocG9zdHBhcnNlZCwgb3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChwb3N0cGFyc2VkLmVycm9ycykge1xuICAgIGVycm9ycyA9IHBvc3RwYXJzZWQuZXJyb3JzO1xuICAgIHBvc3RwYXJzZWQgPSBwb3N0cGFyc2VkLnBvc3RwYXJzZWQ7XG4gIH1cbiAgdmFyIGxpbWl0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9zdHBhcnNlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwYXJ0ID0gcG9zdHBhcnNlZFtpXTtcbiAgICBpZiAocGFydC50eXBlID09PSBcInBsYWNlaG9sZGVyXCIgJiYgcGFydC5tb2R1bGUgPT09IG9wdGlvbnMubW9kdWxlTmFtZSAmJlxuICAgIC8qXG4gICAgICogVGhlIHBhcnQuc3VicGFyc2VkIGNoZWNrIGlzIHVzZWQgdG8gZml4IHRoaXMgZ2l0aHViIGlzc3VlIDpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vb3Blbi14bWwtdGVtcGxhdGluZy9kb2N4dGVtcGxhdGVyL2lzc3Vlcy82NzFcbiAgICAgKi9cbiAgICAhcGFydC5zdWJwYXJzZWQgJiYgIXBhcnQuZXhwYW5kZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBsaW1pdCA9IGdldEV4cGFuZExpbWl0KHBhcnQsIGksIHBvc3RwYXJzZWQsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIWxpbWl0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9saW1pdCA9IF9zbGljZWRUb0FycmF5KGxpbWl0LCAyKSxcbiAgICAgICAgICBsZWZ0ID0gX2xpbWl0WzBdLFxuICAgICAgICAgIHJpZ2h0ID0gX2xpbWl0WzFdO1xuICAgICAgICBsaW1pdHMucHVzaCh7XG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICBpOiBpLFxuICAgICAgICAgIGxlZnRQYXJ0OiBwb3N0cGFyc2VkW2xlZnRdLFxuICAgICAgICAgIHJpZ2h0UGFydDogcG9zdHBhcnNlZFtyaWdodF1cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUaGUgRXJyb3IgY2FuIG9ubHkgYmUgYVxuICAgICAgICBlcnJvcnMucHVzaChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxpbWl0cy5zb3J0KGZ1bmN0aW9uIChsMSwgbDIpIHtcbiAgICBpZiAobDEubGVmdCA9PT0gbDIubGVmdCkge1xuICAgICAgcmV0dXJuIGwyLnBhcnQubEluZGV4IDwgbDEucGFydC5sSW5kZXggPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiBsMi5sZWZ0IDwgbDEubGVmdCA/IDEgOiAtMTtcbiAgfSk7XG4gIHZhciBtYXhSaWdodCA9IC0xO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgZm9yICh2YXIgX2k3ID0gMCwgX2xlbiA9IGxpbWl0cy5sZW5ndGg7IF9pNyA8IF9sZW47IF9pNysrKSB7XG4gICAgdmFyIF9wb3N0cGFyc2VkO1xuICAgIHZhciBfbGltaXQyID0gbGltaXRzW19pN107XG4gICAgbWF4UmlnaHQgPSBNYXRoLm1heChtYXhSaWdodCwgX2k3ID4gMCA/IGxpbWl0c1tfaTcgLSAxXS5yaWdodCA6IDApO1xuICAgIGlmIChfbGltaXQyLmxlZnQgPCBtYXhSaWdodCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGV4cGFuZE9uZShbX2xpbWl0Mi5sZWZ0ICsgb2Zmc2V0LCBfbGltaXQyLnJpZ2h0ICsgb2Zmc2V0XSwgX2xpbWl0Mi5wYXJ0LCBwb3N0cGFyc2VkLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMub25FcnJvcikge1xuICAgICAgICB2YXIgZXJyb3JSZXN1bHQgPSBvcHRpb25zLm9uRXJyb3IoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgcGFydDogX2xpbWl0Mi5wYXJ0LFxuICAgICAgICAgIHJvb3RFcnJvcjogZXJyb3IsXG4gICAgICAgICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZCxcbiAgICAgICAgICBleHBhbmRPbmU6IGV4cGFuZE9uZVxuICAgICAgICB9LCBvcHRpb25zLmVycm9ycykpO1xuICAgICAgICBpZiAoZXJyb3JSZXN1bHQgPT09IFwiaWdub3JlXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgWFRUZW1wbGF0ZUVycm9yKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG9mZnNldCArPSByZXN1bHQuaW5uZXIubGVuZ3RoIC0gKHJlc3VsdC5yaWdodCArIDEgLSByZXN1bHQubGVmdCk7XG4gICAgKF9wb3N0cGFyc2VkID0gcG9zdHBhcnNlZCkuc3BsaWNlLmFwcGx5KF9wb3N0cGFyc2VkLCBbcmVzdWx0LmxlZnQsIHJlc3VsdC5yaWdodCArIDEgLSByZXN1bHQubGVmdF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXN1bHQuaW5uZXIpKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXhwYW5kVG9PbmU6IGV4cGFuZFRvT25lLFxuICBnZXRFeHBhbmRUb0RlZmF1bHQ6IGdldEV4cGFuZFRvRGVmYXVsdFxufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/traits.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/utils.js":
/*!************************************************!*\
  !*** ./node_modules/docxtemplater/js/utils.js ***!
  \************************************************/
/***/ ((module) => {

eval("\n\nfunction last(a) {\n  return a[a.length - 1];\n}\nfunction first(a) {\n  return a[0];\n}\nmodule.exports = {\n  last: last,\n  first: first\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gbGFzdChhKSB7XG4gIHJldHVybiBhW2EubGVuZ3RoIC0gMV07XG59XG5mdW5jdGlvbiBmaXJzdChhKSB7XG4gIHJldHVybiBhWzBdO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxhc3Q6IGxhc3QsXG4gIGZpcnN0OiBmaXJzdFxufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/xml-matcher.js":
/*!******************************************************!*\
  !*** ./node_modules/docxtemplater/js/xml-matcher.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  pregMatchAll = _require.pregMatchAll;\nmodule.exports = function xmlMatcher(content, tagsXmlArray) {\n  var res = {\n    content: content\n  };\n  var taj = tagsXmlArray.join(\"|\");\n  var regexp = new RegExp(\"(?:(<(?:\".concat(taj, \")[^>]*>)([^<>]*)</(?:\").concat(taj, \")>)|(<(?:\").concat(taj, \")[^>]*/>)\"), \"g\");\n  res.matches = pregMatchAll(regexp, res.content);\n  return res;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtbWF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3htbC1tYXRjaGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHByZWdNYXRjaEFsbCA9IF9yZXF1aXJlLnByZWdNYXRjaEFsbDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geG1sTWF0Y2hlcihjb250ZW50LCB0YWdzWG1sQXJyYXkpIHtcbiAgdmFyIHJlcyA9IHtcbiAgICBjb250ZW50OiBjb250ZW50XG4gIH07XG4gIHZhciB0YWogPSB0YWdzWG1sQXJyYXkuam9pbihcInxcIik7XG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKFwiKD86KDwoPzpcIi5jb25jYXQodGFqLCBcIilbXj5dKj4pKFtePD5dKik8Lyg/OlwiKS5jb25jYXQodGFqLCBcIik+KXwoPCg/OlwiKS5jb25jYXQodGFqLCBcIilbXj5dKi8+KVwiKSwgXCJnXCIpO1xuICByZXMubWF0Y2hlcyA9IHByZWdNYXRjaEFsbChyZWdleHAsIHJlcy5jb250ZW50KTtcbiAgcmV0dXJuIHJlcztcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/xml-matcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/docxtemplater/js/xml-templater.js":
/*!********************************************************!*\
  !*** ./node_modules/docxtemplater/js/xml-templater.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray,\n  wordToUtf8 = _require.wordToUtf8,\n  convertSpaces = _require.convertSpaces;\nvar xmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(ssr)/./node_modules/docxtemplater/js/xml-matcher.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(ssr)/./node_modules/docxtemplater/js/lexer.js\");\nvar Parser = __webpack_require__(/*! ./parser.js */ \"(ssr)/./node_modules/docxtemplater/js/parser.js\");\nvar _render = __webpack_require__(/*! ./render.js */ \"(ssr)/./node_modules/docxtemplater/js/render.js\");\nvar postrender = __webpack_require__(/*! ./postrender.js */ \"(ssr)/./node_modules/docxtemplater/js/postrender.js\");\nvar resolve = __webpack_require__(/*! ./resolve.js */ \"(ssr)/./node_modules/docxtemplater/js/resolve.js\");\nvar joinUncorrupt = __webpack_require__(/*! ./join-uncorrupt.js */ \"(ssr)/./node_modules/docxtemplater/js/join-uncorrupt.js\");\nfunction _getFullText(content, tagsXmlArray) {\n  var matcher = xmlMatcher(content, tagsXmlArray);\n  var result = matcher.matches.map(function (match) {\n    return match.array[2];\n  });\n  return wordToUtf8(convertSpaces(result.join(\"\")));\n}\nmodule.exports = /*#__PURE__*/function () {\n  function XmlTemplater(content, options) {\n    _classCallCheck(this, XmlTemplater);\n    this.cachedParsers = {};\n    this.content = content;\n    for (var key in options) {\n      this[key] = options[key];\n    }\n    this.setModules({\n      inspect: {\n        filePath: options.filePath\n      }\n    });\n  }\n  return _createClass(XmlTemplater, [{\n    key: \"resolveTags\",\n    value: function resolveTags(tags) {\n      var _this = this;\n      this.tags = tags;\n      var options = this.getOptions();\n      var filePath = this.filePath;\n      options.scopeManager = this.scopeManager;\n      options.resolve = resolve;\n      var errors = [];\n      return Promise.all(this.modules.map(function (module) {\n        return Promise.resolve(module.preResolve(options))[\"catch\"](function (e) {\n          errors.push(e);\n        });\n      })).then(function () {\n        if (errors.length !== 0) {\n          throw errors;\n        }\n        return resolve(options).then(function (_ref) {\n          var resolved = _ref.resolved,\n            errors = _ref.errors;\n          errors = errors.map(function (error) {\n            var _error;\n            // If a string is thrown, convert it to a real Error\n            if (!(error instanceof Error)) {\n              error = new Error(error);\n            }\n            /*\n             * error properties might not be defined if some foreign error\n             * (unhandled error not thrown by docxtemplater willingly) is\n             * thrown.\n             */\n            (_error = error).properties || (_error.properties = {});\n            error.properties.file = filePath;\n            return error;\n          });\n          if (errors.length !== 0) {\n            throw errors;\n          }\n          return Promise.all(resolved).then(function (resolved) {\n            options.scopeManager.root.finishedResolving = true;\n            options.scopeManager.resolved = resolved;\n            _this.setModules({\n              inspect: {\n                resolved: resolved,\n                filePath: filePath\n              }\n            });\n            return resolved;\n          });\n        })[\"catch\"](function (error) {\n          _this.errorChecker(error);\n          throw error;\n        });\n      });\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText() {\n      return _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      for (var _i2 = 0, _this$modules2 = this.modules; _i2 < _this$modules2.length; _i2++) {\n        var _module = _this$modules2[_i2];\n        _module.set(obj);\n      }\n    }\n  }, {\n    key: \"preparse\",\n    value: function preparse() {\n      this.allErrors = [];\n      this.xmllexed = Lexer.xmlparse(this.content, {\n        text: this.fileTypeConfig.tagsXmlTextArray,\n        other: this.fileTypeConfig.tagsXmlLexedArray\n      });\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          xmllexed: this.xmllexed\n        }\n      });\n      var _Lexer$parse = Lexer.parse(this.xmllexed, this.delimiters, this.syntax, this.fileType),\n        lexed = _Lexer$parse.lexed,\n        lexerErrors = _Lexer$parse.errors;\n      pushArray(this.allErrors, lexerErrors);\n      this.lexed = lexed;\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          lexed: this.lexed\n        }\n      });\n      var options = this.getOptions();\n      this.lexed = Parser.preparse(this.lexed, this.modules, options);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      this.setModules({\n        inspect: {\n          filePath: this.filePath\n        }\n      });\n      var options = this.getOptions();\n      this.parsed = Parser.parse(this.lexed, this.modules, options);\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          parsed: this.parsed\n        }\n      });\n      var _Parser$postparse = Parser.postparse(this.parsed, this.modules, options),\n        postparsed = _Parser$postparse.postparsed,\n        postparsedErrors = _Parser$postparse.errors;\n      this.postparsed = postparsed;\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          postparsed: this.postparsed\n        }\n      });\n      pushArray(this.allErrors, postparsedErrors);\n      this.errorChecker(this.allErrors);\n      return this;\n    }\n  }, {\n    key: \"errorChecker\",\n    value: function errorChecker(errors) {\n      for (var _i4 = 0, _errors2 = errors; _i4 < _errors2.length; _i4++) {\n        var error = _errors2[_i4];\n        /*\n         * error properties might not be defined if some foreign\n         * (unhandled error not thrown by docxtemplater willingly) is\n         * thrown.\n         */\n        error.properties || (error.properties = {});\n        error.properties.file = this.filePath;\n      }\n      for (var _i6 = 0, _this$modules4 = this.modules; _i6 < _this$modules4.length; _i6++) {\n        var _module2 = _this$modules4[_i6];\n        errors = _module2.errorsTransformer(errors);\n      }\n    }\n  }, {\n    key: \"baseNullGetter\",\n    value: function baseNullGetter(part, sm) {\n      var _this2 = this;\n      var value = this.modules.reduce(function (value, module) {\n        if (value != null) {\n          return value;\n        }\n        return module.nullGetter(part, sm, _this2);\n      }, null);\n      if (value != null) {\n        return value;\n      }\n      return this.nullGetter(part, sm);\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return {\n        compiled: this.postparsed,\n        cachedParsers: this.cachedParsers,\n        tags: this.tags,\n        modules: this.modules,\n        parser: this.parser,\n        contentType: this.contentType,\n        relsType: this.relsType,\n        baseNullGetter: this.baseNullGetter.bind(this),\n        filePath: this.filePath,\n        fileTypeConfig: this.fileTypeConfig,\n        fileType: this.fileType,\n        linebreaks: this.linebreaks,\n        stripInvalidXMLChars: this.stripInvalidXMLChars\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render(to) {\n      this.filePath = to;\n      var options = this.getOptions();\n      options.resolved = this.scopeManager.resolved;\n      options.scopeManager = this.scopeManager;\n      options.render = _render;\n      options.joinUncorrupt = joinUncorrupt;\n      var _render2 = _render(options),\n        errors = _render2.errors,\n        parts = _render2.parts;\n      if (errors.length > 0) {\n        this.allErrors = errors;\n        this.errorChecker(errors);\n        return this;\n      }\n      this.content = postrender(parts, options);\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          content: this.content\n        }\n      });\n      return this;\n    }\n  }]);\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtdGVtcGxhdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsMEVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFrQjtBQUMzQyxZQUFZLG1CQUFPLENBQUMsa0VBQVk7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG9FQUFhO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBYTtBQUNuQyxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDMUMsY0FBYyxtQkFBTyxDQUFDLHNFQUFjO0FBQ3BDLG9CQUFvQixtQkFBTyxDQUFDLG9GQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdURBQXVELDZCQUE2QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBLHVEQUF1RCw2QkFBNkI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMveG1sLXRlbXBsYXRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXksXG4gIHdvcmRUb1V0ZjggPSBfcmVxdWlyZS53b3JkVG9VdGY4LFxuICBjb252ZXJ0U3BhY2VzID0gX3JlcXVpcmUuY29udmVydFNwYWNlcztcbnZhciB4bWxNYXRjaGVyID0gcmVxdWlyZShcIi4veG1sLW1hdGNoZXIuanNcIik7XG52YXIgTGV4ZXIgPSByZXF1aXJlKFwiLi9sZXhlci5qc1wiKTtcbnZhciBQYXJzZXIgPSByZXF1aXJlKFwiLi9wYXJzZXIuanNcIik7XG52YXIgX3JlbmRlciA9IHJlcXVpcmUoXCIuL3JlbmRlci5qc1wiKTtcbnZhciBwb3N0cmVuZGVyID0gcmVxdWlyZShcIi4vcG9zdHJlbmRlci5qc1wiKTtcbnZhciByZXNvbHZlID0gcmVxdWlyZShcIi4vcmVzb2x2ZS5qc1wiKTtcbnZhciBqb2luVW5jb3JydXB0ID0gcmVxdWlyZShcIi4vam9pbi11bmNvcnJ1cHQuanNcIik7XG5mdW5jdGlvbiBfZ2V0RnVsbFRleHQoY29udGVudCwgdGFnc1htbEFycmF5KSB7XG4gIHZhciBtYXRjaGVyID0geG1sTWF0Y2hlcihjb250ZW50LCB0YWdzWG1sQXJyYXkpO1xuICB2YXIgcmVzdWx0ID0gbWF0Y2hlci5tYXRjaGVzLm1hcChmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gbWF0Y2guYXJyYXlbMl07XG4gIH0pO1xuICByZXR1cm4gd29yZFRvVXRmOChjb252ZXJ0U3BhY2VzKHJlc3VsdC5qb2luKFwiXCIpKSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhtbFRlbXBsYXRlcihjb250ZW50LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFhtbFRlbXBsYXRlcik7XG4gICAgdGhpcy5jYWNoZWRQYXJzZXJzID0ge307XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgdGhpc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgIH1cbiAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgaW5zcGVjdDoge1xuICAgICAgICBmaWxlUGF0aDogb3B0aW9ucy5maWxlUGF0aFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoWG1sVGVtcGxhdGVyLCBbe1xuICAgIGtleTogXCJyZXNvbHZlVGFnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlVGFncyh0YWdzKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICB2YXIgZmlsZVBhdGggPSB0aGlzLmZpbGVQYXRoO1xuICAgICAgb3B0aW9ucy5zY29wZU1hbmFnZXIgPSB0aGlzLnNjb3BlTWFuYWdlcjtcbiAgICAgIG9wdGlvbnMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5tb2R1bGVzLm1hcChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobW9kdWxlLnByZVJlc29sdmUob3B0aW9ucykpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSBfcmVmLnJlc29sdmVkLFxuICAgICAgICAgICAgZXJyb3JzID0gX3JlZi5lcnJvcnM7XG4gICAgICAgICAgZXJyb3JzID0gZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBfZXJyb3I7XG4gICAgICAgICAgICAvLyBJZiBhIHN0cmluZyBpcyB0aHJvd24sIGNvbnZlcnQgaXQgdG8gYSByZWFsIEVycm9yXG4gICAgICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogZXJyb3IgcHJvcGVydGllcyBtaWdodCBub3QgYmUgZGVmaW5lZCBpZiBzb21lIGZvcmVpZ24gZXJyb3JcbiAgICAgICAgICAgICAqICh1bmhhbmRsZWQgZXJyb3Igbm90IHRocm93biBieSBkb2N4dGVtcGxhdGVyIHdpbGxpbmdseSkgaXNcbiAgICAgICAgICAgICAqIHRocm93bi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgKF9lcnJvciA9IGVycm9yKS5wcm9wZXJ0aWVzIHx8IChfZXJyb3IucHJvcGVydGllcyA9IHt9KTtcbiAgICAgICAgICAgIGVycm9yLnByb3BlcnRpZXMuZmlsZSA9IGZpbGVQYXRoO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXNvbHZlZCkudGhlbihmdW5jdGlvbiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2NvcGVNYW5hZ2VyLnJvb3QuZmluaXNoZWRSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgb3B0aW9ucy5zY29wZU1hbmFnZXIucmVzb2x2ZWQgPSByZXNvbHZlZDtcbiAgICAgICAgICAgIF90aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQ6IHJlc29sdmVkLFxuICAgICAgICAgICAgICAgIGZpbGVQYXRoOiBmaWxlUGF0aFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICBfdGhpcy5lcnJvckNoZWNrZXIoZXJyb3IpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGdWxsVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGdWxsVGV4dCgpIHtcbiAgICAgIHJldHVybiBfZ2V0RnVsbFRleHQodGhpcy5jb250ZW50LCB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ3NYbWxUZXh0QXJyYXkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRNb2R1bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1vZHVsZXMob2JqKSB7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwLCBfdGhpcyRtb2R1bGVzMiA9IHRoaXMubW9kdWxlczsgX2kyIDwgX3RoaXMkbW9kdWxlczIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgX21vZHVsZSA9IF90aGlzJG1vZHVsZXMyW19pMl07XG4gICAgICAgIF9tb2R1bGUuc2V0KG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByZXBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcnNlKCkge1xuICAgICAgdGhpcy5hbGxFcnJvcnMgPSBbXTtcbiAgICAgIHRoaXMueG1sbGV4ZWQgPSBMZXhlci54bWxwYXJzZSh0aGlzLmNvbnRlbnQsIHtcbiAgICAgICAgdGV4dDogdGhpcy5maWxlVHlwZUNvbmZpZy50YWdzWG1sVGV4dEFycmF5LFxuICAgICAgICBvdGhlcjogdGhpcy5maWxlVHlwZUNvbmZpZy50YWdzWG1sTGV4ZWRBcnJheVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgICAgeG1sbGV4ZWQ6IHRoaXMueG1sbGV4ZWRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgX0xleGVyJHBhcnNlID0gTGV4ZXIucGFyc2UodGhpcy54bWxsZXhlZCwgdGhpcy5kZWxpbWl0ZXJzLCB0aGlzLnN5bnRheCwgdGhpcy5maWxlVHlwZSksXG4gICAgICAgIGxleGVkID0gX0xleGVyJHBhcnNlLmxleGVkLFxuICAgICAgICBsZXhlckVycm9ycyA9IF9MZXhlciRwYXJzZS5lcnJvcnM7XG4gICAgICBwdXNoQXJyYXkodGhpcy5hbGxFcnJvcnMsIGxleGVyRXJyb3JzKTtcbiAgICAgIHRoaXMubGV4ZWQgPSBsZXhlZDtcbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICBsZXhlZDogdGhpcy5sZXhlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICB0aGlzLmxleGVkID0gUGFyc2VyLnByZXBhcnNlKHRoaXMubGV4ZWQsIHRoaXMubW9kdWxlcywgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKCkge1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIHRoaXMucGFyc2VkID0gUGFyc2VyLnBhcnNlKHRoaXMubGV4ZWQsIHRoaXMubW9kdWxlcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgICAgcGFyc2VkOiB0aGlzLnBhcnNlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBfUGFyc2VyJHBvc3RwYXJzZSA9IFBhcnNlci5wb3N0cGFyc2UodGhpcy5wYXJzZWQsIHRoaXMubW9kdWxlcywgb3B0aW9ucyksXG4gICAgICAgIHBvc3RwYXJzZWQgPSBfUGFyc2VyJHBvc3RwYXJzZS5wb3N0cGFyc2VkLFxuICAgICAgICBwb3N0cGFyc2VkRXJyb3JzID0gX1BhcnNlciRwb3N0cGFyc2UuZXJyb3JzO1xuICAgICAgdGhpcy5wb3N0cGFyc2VkID0gcG9zdHBhcnNlZDtcbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICBwb3N0cGFyc2VkOiB0aGlzLnBvc3RwYXJzZWRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBwdXNoQXJyYXkodGhpcy5hbGxFcnJvcnMsIHBvc3RwYXJzZWRFcnJvcnMpO1xuICAgICAgdGhpcy5lcnJvckNoZWNrZXIodGhpcy5hbGxFcnJvcnMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVycm9yQ2hlY2tlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnJvckNoZWNrZXIoZXJyb3JzKSB7XG4gICAgICBmb3IgKHZhciBfaTQgPSAwLCBfZXJyb3JzMiA9IGVycm9yczsgX2k0IDwgX2Vycm9yczIubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSBfZXJyb3JzMltfaTRdO1xuICAgICAgICAvKlxuICAgICAgICAgKiBlcnJvciBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCBiZSBkZWZpbmVkIGlmIHNvbWUgZm9yZWlnblxuICAgICAgICAgKiAodW5oYW5kbGVkIGVycm9yIG5vdCB0aHJvd24gYnkgZG9jeHRlbXBsYXRlciB3aWxsaW5nbHkpIGlzXG4gICAgICAgICAqIHRocm93bi5cbiAgICAgICAgICovXG4gICAgICAgIGVycm9yLnByb3BlcnRpZXMgfHwgKGVycm9yLnByb3BlcnRpZXMgPSB7fSk7XG4gICAgICAgIGVycm9yLnByb3BlcnRpZXMuZmlsZSA9IHRoaXMuZmlsZVBhdGg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTYgPSAwLCBfdGhpcyRtb2R1bGVzNCA9IHRoaXMubW9kdWxlczsgX2k2IDwgX3RoaXMkbW9kdWxlczQubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICB2YXIgX21vZHVsZTIgPSBfdGhpcyRtb2R1bGVzNFtfaTZdO1xuICAgICAgICBlcnJvcnMgPSBfbW9kdWxlMi5lcnJvcnNUcmFuc2Zvcm1lcihlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiYXNlTnVsbEdldHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYXNlTnVsbEdldHRlcihwYXJ0LCBzbSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uICh2YWx1ZSwgbW9kdWxlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGUubnVsbEdldHRlcihwYXJ0LCBzbSwgX3RoaXMyKTtcbiAgICAgIH0sIG51bGwpO1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubnVsbEdldHRlcihwYXJ0LCBzbSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBpbGVkOiB0aGlzLnBvc3RwYXJzZWQsXG4gICAgICAgIGNhY2hlZFBhcnNlcnM6IHRoaXMuY2FjaGVkUGFyc2VycyxcbiAgICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAgICBtb2R1bGVzOiB0aGlzLm1vZHVsZXMsXG4gICAgICAgIHBhcnNlcjogdGhpcy5wYXJzZXIsXG4gICAgICAgIGNvbnRlbnRUeXBlOiB0aGlzLmNvbnRlbnRUeXBlLFxuICAgICAgICByZWxzVHlwZTogdGhpcy5yZWxzVHlwZSxcbiAgICAgICAgYmFzZU51bGxHZXR0ZXI6IHRoaXMuYmFzZU51bGxHZXR0ZXIuYmluZCh0aGlzKSxcbiAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgIGZpbGVUeXBlQ29uZmlnOiB0aGlzLmZpbGVUeXBlQ29uZmlnLFxuICAgICAgICBmaWxlVHlwZTogdGhpcy5maWxlVHlwZSxcbiAgICAgICAgbGluZWJyZWFrczogdGhpcy5saW5lYnJlYWtzLFxuICAgICAgICBzdHJpcEludmFsaWRYTUxDaGFyczogdGhpcy5zdHJpcEludmFsaWRYTUxDaGFyc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcih0bykge1xuICAgICAgdGhpcy5maWxlUGF0aCA9IHRvO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIG9wdGlvbnMucmVzb2x2ZWQgPSB0aGlzLnNjb3BlTWFuYWdlci5yZXNvbHZlZDtcbiAgICAgIG9wdGlvbnMuc2NvcGVNYW5hZ2VyID0gdGhpcy5zY29wZU1hbmFnZXI7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IF9yZW5kZXI7XG4gICAgICBvcHRpb25zLmpvaW5VbmNvcnJ1cHQgPSBqb2luVW5jb3JydXB0O1xuICAgICAgdmFyIF9yZW5kZXIyID0gX3JlbmRlcihvcHRpb25zKSxcbiAgICAgICAgZXJyb3JzID0gX3JlbmRlcjIuZXJyb3JzLFxuICAgICAgICBwYXJ0cyA9IF9yZW5kZXIyLnBhcnRzO1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuYWxsRXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLmVycm9yQ2hlY2tlcihlcnJvcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGVudCA9IHBvc3RyZW5kZXIocGFydHMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoLFxuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xufSgpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/docxtemplater/js/xml-templater.js\n");

/***/ })

};
;