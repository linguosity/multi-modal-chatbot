"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/docxtemplater@3.60.2";
exports.ids = ["vendor-chunks/docxtemplater@3.60.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/collect-content-types.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/collect-content-types.js ***!
  \********************************************************************************************************/
/***/ ((module) => {

eval("\n\nvar ctXML = \"[Content_Types].xml\";\nfunction collectContentTypes(overrides, defaults, zip) {\n  var partNames = {};\n  for (var _i2 = 0; _i2 < overrides.length; _i2++) {\n    var override = overrides[_i2];\n    var contentType = override.getAttribute(\"ContentType\");\n    var partName = override.getAttribute(\"PartName\").substr(1);\n    partNames[partName] = contentType;\n  }\n  var _loop = function _loop() {\n    var def = defaults[_i4];\n    var contentType = def.getAttribute(\"ContentType\");\n    var extension = def.getAttribute(\"Extension\");\n    zip.file(/./).map(function (_ref) {\n      var name = _ref.name;\n      if (name.slice(name.length - extension.length) === extension && !partNames[name] && name !== ctXML) {\n        partNames[name] = contentType;\n      }\n    });\n  };\n  for (var _i4 = 0; _i4 < defaults.length; _i4++) {\n    _loop();\n  }\n  return partNames;\n}\nmodule.exports = collectContentTypes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvY29sbGVjdC1jb250ZW50LXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvY29sbGVjdC1jb250ZW50LXR5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY3RYTUwgPSBcIltDb250ZW50X1R5cGVzXS54bWxcIjtcbmZ1bmN0aW9uIGNvbGxlY3RDb250ZW50VHlwZXMob3ZlcnJpZGVzLCBkZWZhdWx0cywgemlwKSB7XG4gIHZhciBwYXJ0TmFtZXMgPSB7fTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgb3ZlcnJpZGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgb3ZlcnJpZGUgPSBvdmVycmlkZXNbX2kyXTtcbiAgICB2YXIgY29udGVudFR5cGUgPSBvdmVycmlkZS5nZXRBdHRyaWJ1dGUoXCJDb250ZW50VHlwZVwiKTtcbiAgICB2YXIgcGFydE5hbWUgPSBvdmVycmlkZS5nZXRBdHRyaWJ1dGUoXCJQYXJ0TmFtZVwiKS5zdWJzdHIoMSk7XG4gICAgcGFydE5hbWVzW3BhcnROYW1lXSA9IGNvbnRlbnRUeXBlO1xuICB9XG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgIHZhciBkZWYgPSBkZWZhdWx0c1tfaTRdO1xuICAgIHZhciBjb250ZW50VHlwZSA9IGRlZi5nZXRBdHRyaWJ1dGUoXCJDb250ZW50VHlwZVwiKTtcbiAgICB2YXIgZXh0ZW5zaW9uID0gZGVmLmdldEF0dHJpYnV0ZShcIkV4dGVuc2lvblwiKTtcbiAgICB6aXAuZmlsZSgvLi8pLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICBpZiAobmFtZS5zbGljZShuYW1lLmxlbmd0aCAtIGV4dGVuc2lvbi5sZW5ndGgpID09PSBleHRlbnNpb24gJiYgIXBhcnROYW1lc1tuYW1lXSAmJiBuYW1lICE9PSBjdFhNTCkge1xuICAgICAgICBwYXJ0TmFtZXNbbmFtZV0gPSBjb250ZW50VHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgZGVmYXVsdHMubGVuZ3RoOyBfaTQrKykge1xuICAgIF9sb29wKCk7XG4gIH1cbiAgcmV0dXJuIHBhcnROYW1lcztcbn1cbm1vZHVsZS5leHBvcnRzID0gY29sbGVjdENvbnRlbnRUeXBlczsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/collect-content-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/content-types.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/content-types.js ***!
  \************************************************************************************************/
/***/ ((module) => {

eval("\n\nvar coreContentType = \"application/vnd.openxmlformats-package.core-properties+xml\";\nvar appContentType = \"application/vnd.openxmlformats-officedocument.extended-properties+xml\";\nvar customContentType = \"application/vnd.openxmlformats-officedocument.custom-properties+xml\";\nvar settingsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\";\nvar diagramDataContentType = \"application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml\";\nvar diagramDrawingContentType = \"application/vnd.ms-office.drawingml.diagramDrawing+xml\";\nmodule.exports = {\n  settingsContentType: settingsContentType,\n  coreContentType: coreContentType,\n  appContentType: appContentType,\n  customContentType: customContentType,\n  diagramDataContentType: diagramDataContentType,\n  diagramDrawingContentType: diagramDrawingContentType\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvY29udGVudC10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy8ucG5wbS9kb2N4dGVtcGxhdGVyQDMuNjAuMi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9jb250ZW50LXR5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgY29yZUNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtcGFja2FnZS5jb3JlLXByb3BlcnRpZXMreG1sXCI7XG52YXIgYXBwQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5leHRlbmRlZC1wcm9wZXJ0aWVzK3htbFwiO1xudmFyIGN1c3RvbUNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuY3VzdG9tLXByb3BlcnRpZXMreG1sXCI7XG52YXIgc2V0dGluZ3NDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuc2V0dGluZ3MreG1sXCI7XG52YXIgZGlhZ3JhbURhdGFDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmRyYXdpbmdtbC5kaWFncmFtRGF0YSt4bWxcIjtcbnZhciBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQubXMtb2ZmaWNlLmRyYXdpbmdtbC5kaWFncmFtRHJhd2luZyt4bWxcIjtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXR0aW5nc0NvbnRlbnRUeXBlOiBzZXR0aW5nc0NvbnRlbnRUeXBlLFxuICBjb3JlQ29udGVudFR5cGU6IGNvcmVDb250ZW50VHlwZSxcbiAgYXBwQ29udGVudFR5cGU6IGFwcENvbnRlbnRUeXBlLFxuICBjdXN0b21Db250ZW50VHlwZTogY3VzdG9tQ29udGVudFR5cGUsXG4gIGRpYWdyYW1EYXRhQ29udGVudFR5cGU6IGRpYWdyYW1EYXRhQ29udGVudFR5cGUsXG4gIGRpYWdyYW1EcmF3aW5nQ29udGVudFR5cGU6IGRpYWdyYW1EcmF3aW5nQ29udGVudFR5cGVcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/content-types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nvar _require = __webpack_require__(/*! @xmldom/xmldom */ \"(ssr)/./node_modules/.pnpm/@xmldom+xmldom@0.9.8/node_modules/@xmldom/xmldom/lib/index.js\"),\n  DOMParser = _require.DOMParser,\n  XMLSerializer = _require.XMLSerializer;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\"),\n  throwXmlTagNotFound = _require2.throwXmlTagNotFound;\nvar _require3 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/utils.js\"),\n  last = _require3.last,\n  first = _require3.first;\nfunction isWhiteSpace(value) {\n  return /^[ \\n\\r\\t]+$/.test(value);\n}\nfunction parser(tag) {\n  return {\n    get: function get(scope) {\n      if (tag === \".\") {\n        return scope;\n      }\n      if (scope) {\n        return scope[tag];\n      }\n      return scope;\n    }\n  };\n}\nvar attrToRegex = {};\nfunction setSingleAttribute(partValue, attr, attrValue) {\n  var regex;\n  // Stryker disable next-line all : because this is an optimisation\n  if (attrToRegex[attr]) {\n    regex = attrToRegex[attr];\n  } else {\n    regex = new RegExp(\"(<.* \".concat(attr, \"=\\\")([^\\\"]*)(\\\".*)$\"));\n    attrToRegex[attr] = regex;\n  }\n  if (regex.test(partValue)) {\n    return partValue.replace(regex, \"$1\".concat(attrValue, \"$3\"));\n  }\n  var end = partValue.lastIndexOf(\"/>\");\n  if (end === -1) {\n    end = partValue.lastIndexOf(\">\");\n  }\n  return partValue.substr(0, end) + \" \".concat(attr, \"=\\\"\").concat(attrValue, \"\\\"\") + partValue.substr(end);\n}\nfunction getSingleAttribute(value, attributeName) {\n  var index = value.indexOf(\" \".concat(attributeName, \"=\\\"\"));\n  if (index === -1) {\n    return null;\n  }\n  var startIndex = value.substr(index).search(/[\"']/) + index;\n  var endIndex = value.substr(startIndex + 1).search(/[\"']/) + startIndex;\n  return value.substr(startIndex + 1, endIndex - startIndex);\n}\nfunction endsWith(str, suffix) {\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\nfunction startsWith(str, prefix) {\n  return str.substring(0, prefix.length) === prefix;\n}\nfunction getDuplicates(arr) {\n  var duplicates = [];\n  var hash = {},\n    result = [];\n  for (var i = 0, l = arr.length; i < l; ++i) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      result.push(arr[i]);\n    } else {\n      duplicates.push(arr[i]);\n    }\n  }\n  return duplicates;\n}\nfunction uniq(arr) {\n  var hash = {},\n    result = [];\n  for (var i = 0, l = arr.length; i < l; ++i) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\nfunction chunkBy(parsed, f) {\n  var chunks = [[]];\n  for (var _i2 = 0; _i2 < parsed.length; _i2++) {\n    var p = parsed[_i2];\n    var currentChunk = chunks[chunks.length - 1];\n    var res = f(p);\n    if (res === \"start\") {\n      chunks.push([p]);\n    } else if (res === \"end\") {\n      currentChunk.push(p);\n      chunks.push([]);\n    } else {\n      currentChunk.push(p);\n    }\n  } // Remove empty chunks\n  var result = [];\n  for (var _i4 = 0; _i4 < chunks.length; _i4++) {\n    var chunk = chunks[_i4];\n    if (chunk.length > 0) {\n      result.push(chunk);\n    }\n  }\n  return result;\n}\nfunction getDefaults() {\n  return {\n    errorLogging: \"json\",\n    stripInvalidXMLChars: false,\n    paragraphLoop: false,\n    nullGetter: function nullGetter(part) {\n      return part.module ? \"\" : \"undefined\";\n    },\n    xmlFileNames: [\"[Content_Types].xml\"],\n    parser: parser,\n    linebreaks: false,\n    fileTypeConfig: null,\n    delimiters: {\n      start: \"{\",\n      end: \"}\"\n    },\n    syntax: {\n      changeDelimiterPrefix: \"=\"\n    }\n  };\n}\nfunction xml2str(xmlNode) {\n  return new XMLSerializer().serializeToString(xmlNode).replace(/xmlns(:[a-z0-9]+)?=\"\" ?/g, \"\");\n}\nfunction str2xml(str) {\n  if (str.charCodeAt(0) === 65279) {\n    // BOM sequence\n    str = str.substr(1);\n  }\n  return new DOMParser().parseFromString(str, \"text/xml\");\n}\nvar charMap = [[\"&\", \"&amp;\"], [\"<\", \"&lt;\"], [\">\", \"&gt;\"], ['\"', \"&quot;\"], [\"'\", \"&apos;\"]];\nvar charMapRegexes = charMap.map(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    endChar = _ref2[0],\n    startChar = _ref2[1];\n  return {\n    rstart: new RegExp(startChar, \"g\"),\n    rend: new RegExp(endChar, \"g\"),\n    start: startChar,\n    end: endChar\n  };\n});\nfunction wordToUtf8(string) {\n  for (var i = charMapRegexes.length - 1; i >= 0; i--) {\n    var r = charMapRegexes[i];\n    string = string.replace(r.rstart, r.end);\n  }\n  return string;\n}\nfunction utf8ToWord(string) {\n  // To make sure that the object given is a string (this is a noop for strings).\n  string = string.toString();\n  var r;\n  for (var i = 0, l = charMapRegexes.length; i < l; i++) {\n    r = charMapRegexes[i];\n    string = string.replace(r.rend, r.start);\n  }\n  return string;\n}\n\n// This function is written with for loops for performance\nfunction concatArrays(arrays) {\n  var result = [];\n  for (var _i6 = 0; _i6 < arrays.length; _i6++) {\n    var array = arrays[_i6];\n    for (var _i8 = 0; _i8 < array.length; _i8++) {\n      var el = array[_i8];\n      result.push(el);\n    }\n  }\n  return result;\n}\nfunction pushArray(array1, array2) {\n  if (!array2) {\n    return array1;\n  }\n  for (var i = 0, len = array2.length; i < len; i++) {\n    array1.push(array2[i]);\n  }\n  return array1;\n}\nvar spaceRegexp = new RegExp(String.fromCharCode(160), \"g\");\nfunction convertSpaces(s) {\n  return s.replace(spaceRegexp, \" \");\n}\nfunction pregMatchAll(regex, content) {\n  /*\n   * Regex is a string, content is the content. It returns an array of all\n   * matches with their offset, for example:\n   *\n   * regex=la\n   * content=lolalolilala\n   *\n   * Returns:\n   *\n   * [\n   *    {array: {0: 'la'}, offset: 2},\n   *    {array: {0: 'la'}, offset: 8},\n   *    {array: {0: 'la'}, offset: 10}\n   * ]\n   */\n  var matchArray = [];\n  var match;\n  while ((match = regex.exec(content)) != null) {\n    matchArray.push({\n      array: match,\n      offset: match.index\n    });\n  }\n  return matchArray;\n}\nfunction isEnding(value, element) {\n  return value === \"</\" + element + \">\";\n}\nfunction isStarting(value, element) {\n  return value.indexOf(\"<\" + element) === 0 && [\">\", \" \", \"/\"].indexOf(value[element.length + 1]) !== -1;\n}\nfunction getRight(parsed, element, index) {\n  var val = getRightOrNull(parsed, element, index);\n  if (val !== null) {\n    return val;\n  }\n  throwXmlTagNotFound({\n    position: \"right\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\nfunction getRightOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n  var level = 1;\n  for (var i = index, l = parsed.length; i < l; i++) {\n    var part = parsed[i];\n    for (var _i10 = 0, _elements2 = elements; _i10 < _elements2.length; _i10++) {\n      var element = _elements2[_i10];\n      if (isEnding(part.value, element)) {\n        level--;\n      }\n      if (isStarting(part.value, element)) {\n        level++;\n      }\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\nfunction getLeft(parsed, element, index) {\n  var val = getLeftOrNull(parsed, element, index);\n  if (val !== null) {\n    return val;\n  }\n  throwXmlTagNotFound({\n    position: \"left\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\nfunction getLeftOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n  var level = 1;\n  for (var i = index; i >= 0; i--) {\n    var part = parsed[i];\n    for (var _i12 = 0, _elements4 = elements; _i12 < _elements4.length; _i12++) {\n      var element = _elements4[_i12];\n      if (isStarting(part.value, element)) {\n        level--;\n      }\n      if (isEnding(part.value, element)) {\n        level++;\n      }\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\n\n/*\n * Stryker disable all : because those are functions that depend on the parsed\n * structure based and we don't want minimal code here, but rather code that\n * makes things clear.\n */\nfunction isTagStart(tagType, _ref3) {\n  var type = _ref3.type,\n    tag = _ref3.tag,\n    position = _ref3.position;\n  return type === \"tag\" && tag === tagType && (position === \"start\" || position === \"selfclosing\");\n}\nfunction isTagEnd(tagType, _ref4) {\n  var type = _ref4.type,\n    tag = _ref4.tag,\n    position = _ref4.position;\n  return type === \"tag\" && tag === tagType && position === \"end\";\n}\nfunction isParagraphStart(_ref5) {\n  var type = _ref5.type,\n    tag = _ref5.tag,\n    position = _ref5.position;\n  return [\"w:p\", \"a:p\"].indexOf(tag) !== -1 && type === \"tag\" && position === \"start\";\n}\nfunction isParagraphEnd(_ref6) {\n  var type = _ref6.type,\n    tag = _ref6.tag,\n    position = _ref6.position;\n  return [\"w:p\", \"a:p\"].indexOf(tag) !== -1 && type === \"tag\" && position === \"end\";\n}\nfunction isTextStart(_ref7) {\n  var type = _ref7.type,\n    position = _ref7.position,\n    text = _ref7.text;\n  return text && type === \"tag\" && position === \"start\";\n}\nfunction isTextEnd(_ref8) {\n  var type = _ref8.type,\n    position = _ref8.position,\n    text = _ref8.text;\n  return text && type === \"tag\" && position === \"end\";\n}\nfunction isContent(_ref9) {\n  var type = _ref9.type,\n    position = _ref9.position;\n  return type === \"placeholder\" || type === \"content\" && position === \"insidetag\";\n}\nfunction isModule(_ref10, modules) {\n  var module = _ref10.module,\n    type = _ref10.type;\n  if (!(modules instanceof Array)) {\n    modules = [modules];\n  }\n  return type === \"placeholder\" && modules.indexOf(module) !== -1;\n}\n// Stryker restore all\n\nvar corruptCharacters = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/;\n/*\n * 00    NUL '\\0' (null character)\n * 01    SOH (start of heading)\n * 02    STX (start of text)\n * 03    ETX (end of text)\n * 04    EOT (end of transmission)\n * 05    ENQ (enquiry)\n * 06    ACK (acknowledge)\n * 07    BEL '\\a' (bell)\n * 08    BS  '\\b' (backspace)\n * 0B    VT  '\\v' (vertical tab)\n * 0C    FF  '\\f' (form feed)\n * 0E    SO  (shift out)\n * 0F    SI  (shift in)\n * 10    DLE (data link escape)\n * 11    DC1 (device control 1)\n * 12    DC2 (device control 2)\n * 13    DC3 (device control 3)\n * 14    DC4 (device control 4)\n * 15    NAK (negative ack.)\n * 16    SYN (synchronous idle)\n * 17    ETB (end of trans. blk)\n * 18    CAN (cancel)\n * 19    EM  (end of medium)\n * 1A    SUB (substitute)\n * 1B    ESC (escape)\n * 1C    FS  (file separator)\n * 1D    GS  (group separator)\n * 1E    RS  (record separator)\n * 1F    US  (unit separator)\n */\nfunction hasCorruptCharacters(string) {\n  return corruptCharacters.test(string);\n}\nfunction removeCorruptCharacters(string) {\n  if (typeof string !== \"string\") {\n    string = String(string);\n  }\n  return string.replace(corruptCharacters, \"\");\n}\nfunction invertMap(map) {\n  var invertedMap = {};\n  for (var key in map) {\n    var value = map[key];\n    invertedMap[value] || (invertedMap[value] = []);\n    invertedMap[value].push(key);\n  }\n  return invertedMap;\n}\n/*\n * This ensures that the sort is stable. The default Array.sort of the browser\n * is not stable in firefox, as the JS spec does not enforce the sort to be\n * stable.\n */\nfunction stableSort(arr, compare) {\n  // Stryker disable all : in previous versions of Chrome, sort was not stable by itself, so we had to add this. This is to support older versions of JS runners.\n  return arr.map(function (item, index) {\n    return {\n      item: item,\n      index: index\n    };\n  }).sort(function (a, b) {\n    return compare(a.item, b.item) || a.index - b.index;\n  }).map(function (_ref11) {\n    var item = _ref11.item;\n    return item;\n  });\n  // Stryker restore all\n}\nmodule.exports = {\n  endsWith: endsWith,\n  startsWith: startsWith,\n  isContent: isContent,\n  isParagraphStart: isParagraphStart,\n  isParagraphEnd: isParagraphEnd,\n  isTagStart: isTagStart,\n  isTagEnd: isTagEnd,\n  isTextStart: isTextStart,\n  isTextEnd: isTextEnd,\n  isStarting: isStarting,\n  isEnding: isEnding,\n  isModule: isModule,\n  uniq: uniq,\n  getDuplicates: getDuplicates,\n  chunkBy: chunkBy,\n  last: last,\n  first: first,\n  xml2str: xml2str,\n  str2xml: str2xml,\n  getRightOrNull: getRightOrNull,\n  getRight: getRight,\n  getLeftOrNull: getLeftOrNull,\n  getLeft: getLeft,\n  pregMatchAll: pregMatchAll,\n  convertSpaces: convertSpaces,\n  charMapRegexes: charMapRegexes,\n  hasCorruptCharacters: hasCorruptCharacters,\n  removeCorruptCharacters: removeCorruptCharacters,\n  getDefaults: getDefaults,\n  wordToUtf8: wordToUtf8,\n  utf8ToWord: utf8ToWord,\n  concatArrays: concatArrays,\n  pushArray: pushArray,\n  invertMap: invertMap,\n  charMap: charMap,\n  getSingleAttribute: getSingleAttribute,\n  setSingleAttribute: setSingleAttribute,\n  isWhiteSpace: isWhiteSpace,\n  stableSort: stableSort\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZG9jLXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHVDQUF1QyxrR0FBa0csaUJBQWlCLHdDQUF3QyxNQUFNLHlDQUF5Qyw2QkFBNkIsVUFBVSxZQUFZLGtFQUFrRSxXQUFXLFlBQVksaUJBQWlCLFVBQVUsTUFBTSxpRkFBaUYsVUFBVSxvQkFBb0I7QUFDN2dCLDhCQUE4QjtBQUM5QixlQUFlLG1CQUFPLENBQUMsZ0hBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0R0FBYTtBQUNyQztBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDBHQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlLGVBQWUsaUJBQWlCLGlCQUFpQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsUUFBUSxRQUFRLFlBQVk7QUFDckMsU0FBUyxRQUFRLFFBQVEsWUFBWTtBQUNyQyxTQUFTLFFBQVEsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0EsOENBQThDLDBCQUEwQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy8ucG5wbS9kb2N4dGVtcGxhdGVyQDMuNjAuMi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2MtdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCJAeG1sZG9tL3htbGRvbVwiKSxcbiAgRE9NUGFyc2VyID0gX3JlcXVpcmUuRE9NUGFyc2VyLFxuICBYTUxTZXJpYWxpemVyID0gX3JlcXVpcmUuWE1MU2VyaWFsaXplcjtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIiksXG4gIHRocm93WG1sVGFnTm90Rm91bmQgPSBfcmVxdWlyZTIudGhyb3dYbWxUYWdOb3RGb3VuZDtcbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKSxcbiAgbGFzdCA9IF9yZXF1aXJlMy5sYXN0LFxuICBmaXJzdCA9IF9yZXF1aXJlMy5maXJzdDtcbmZ1bmN0aW9uIGlzV2hpdGVTcGFjZSh2YWx1ZSkge1xuICByZXR1cm4gL15bIFxcblxcclxcdF0rJC8udGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwYXJzZXIodGFnKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoc2NvcGUpIHtcbiAgICAgIGlmICh0YWcgPT09IFwiLlwiKSB7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgIH1cbiAgICAgIGlmIChzY29wZSkge1xuICAgICAgICByZXR1cm4gc2NvcGVbdGFnXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG4gIH07XG59XG52YXIgYXR0clRvUmVnZXggPSB7fTtcbmZ1bmN0aW9uIHNldFNpbmdsZUF0dHJpYnV0ZShwYXJ0VmFsdWUsIGF0dHIsIGF0dHJWYWx1ZSkge1xuICB2YXIgcmVnZXg7XG4gIC8vIFN0cnlrZXIgZGlzYWJsZSBuZXh0LWxpbmUgYWxsIDogYmVjYXVzZSB0aGlzIGlzIGFuIG9wdGltaXNhdGlvblxuICBpZiAoYXR0clRvUmVnZXhbYXR0cl0pIHtcbiAgICByZWdleCA9IGF0dHJUb1JlZ2V4W2F0dHJdO1xuICB9IGVsc2Uge1xuICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIig8LiogXCIuY29uY2F0KGF0dHIsIFwiPVxcXCIpKFteXFxcIl0qKShcXFwiLiopJFwiKSk7XG4gICAgYXR0clRvUmVnZXhbYXR0cl0gPSByZWdleDtcbiAgfVxuICBpZiAocmVnZXgudGVzdChwYXJ0VmFsdWUpKSB7XG4gICAgcmV0dXJuIHBhcnRWYWx1ZS5yZXBsYWNlKHJlZ2V4LCBcIiQxXCIuY29uY2F0KGF0dHJWYWx1ZSwgXCIkM1wiKSk7XG4gIH1cbiAgdmFyIGVuZCA9IHBhcnRWYWx1ZS5sYXN0SW5kZXhPZihcIi8+XCIpO1xuICBpZiAoZW5kID09PSAtMSkge1xuICAgIGVuZCA9IHBhcnRWYWx1ZS5sYXN0SW5kZXhPZihcIj5cIik7XG4gIH1cbiAgcmV0dXJuIHBhcnRWYWx1ZS5zdWJzdHIoMCwgZW5kKSArIFwiIFwiLmNvbmNhdChhdHRyLCBcIj1cXFwiXCIpLmNvbmNhdChhdHRyVmFsdWUsIFwiXFxcIlwiKSArIHBhcnRWYWx1ZS5zdWJzdHIoZW5kKTtcbn1cbmZ1bmN0aW9uIGdldFNpbmdsZUF0dHJpYnV0ZSh2YWx1ZSwgYXR0cmlidXRlTmFtZSkge1xuICB2YXIgaW5kZXggPSB2YWx1ZS5pbmRleE9mKFwiIFwiLmNvbmNhdChhdHRyaWJ1dGVOYW1lLCBcIj1cXFwiXCIpKTtcbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBzdGFydEluZGV4ID0gdmFsdWUuc3Vic3RyKGluZGV4KS5zZWFyY2goL1tcIiddLykgKyBpbmRleDtcbiAgdmFyIGVuZEluZGV4ID0gdmFsdWUuc3Vic3RyKHN0YXJ0SW5kZXggKyAxKS5zZWFyY2goL1tcIiddLykgKyBzdGFydEluZGV4O1xuICByZXR1cm4gdmFsdWUuc3Vic3RyKHN0YXJ0SW5kZXggKyAxLCBlbmRJbmRleCAtIHN0YXJ0SW5kZXgpO1xufVxuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzdWZmaXgpIHtcbiAgcmV0dXJuIHN0ci5pbmRleE9mKHN1ZmZpeCwgc3RyLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyLCBwcmVmaXgpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgcHJlZml4Lmxlbmd0aCkgPT09IHByZWZpeDtcbn1cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZXMoYXJyKSB7XG4gIHZhciBkdXBsaWNhdGVzID0gW107XG4gIHZhciBoYXNoID0ge30sXG4gICAgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmICghaGFzaFthcnJbaV1dKSB7XG4gICAgICBoYXNoW2FycltpXV0gPSB0cnVlO1xuICAgICAgcmVzdWx0LnB1c2goYXJyW2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHVwbGljYXRlcy5wdXNoKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkdXBsaWNhdGVzO1xufVxuZnVuY3Rpb24gdW5pcShhcnIpIHtcbiAgdmFyIGhhc2ggPSB7fSxcbiAgICByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKCFoYXNoW2FycltpXV0pIHtcbiAgICAgIGhhc2hbYXJyW2ldXSA9IHRydWU7XG4gICAgICByZXN1bHQucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2h1bmtCeShwYXJzZWQsIGYpIHtcbiAgdmFyIGNodW5rcyA9IFtbXV07XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBhcnNlZC5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIHAgPSBwYXJzZWRbX2kyXTtcbiAgICB2YXIgY3VycmVudENodW5rID0gY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgcmVzID0gZihwKTtcbiAgICBpZiAocmVzID09PSBcInN0YXJ0XCIpIHtcbiAgICAgIGNodW5rcy5wdXNoKFtwXSk7XG4gICAgfSBlbHNlIGlmIChyZXMgPT09IFwiZW5kXCIpIHtcbiAgICAgIGN1cnJlbnRDaHVuay5wdXNoKHApO1xuICAgICAgY2h1bmtzLnB1c2goW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q2h1bmsucHVzaChwKTtcbiAgICB9XG4gIH0gLy8gUmVtb3ZlIGVtcHR5IGNodW5rc1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGNodW5rcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIGNodW5rID0gY2h1bmtzW19pNF07XG4gICAgaWYgKGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNodW5rKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRzKCkge1xuICByZXR1cm4ge1xuICAgIGVycm9yTG9nZ2luZzogXCJqc29uXCIsXG4gICAgc3RyaXBJbnZhbGlkWE1MQ2hhcnM6IGZhbHNlLFxuICAgIHBhcmFncmFwaExvb3A6IGZhbHNlLFxuICAgIG51bGxHZXR0ZXI6IGZ1bmN0aW9uIG51bGxHZXR0ZXIocGFydCkge1xuICAgICAgcmV0dXJuIHBhcnQubW9kdWxlID8gXCJcIiA6IFwidW5kZWZpbmVkXCI7XG4gICAgfSxcbiAgICB4bWxGaWxlTmFtZXM6IFtcIltDb250ZW50X1R5cGVzXS54bWxcIl0sXG4gICAgcGFyc2VyOiBwYXJzZXIsXG4gICAgbGluZWJyZWFrczogZmFsc2UsXG4gICAgZmlsZVR5cGVDb25maWc6IG51bGwsXG4gICAgZGVsaW1pdGVyczoge1xuICAgICAgc3RhcnQ6IFwie1wiLFxuICAgICAgZW5kOiBcIn1cIlxuICAgIH0sXG4gICAgc3ludGF4OiB7XG4gICAgICBjaGFuZ2VEZWxpbWl0ZXJQcmVmaXg6IFwiPVwiXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24geG1sMnN0cih4bWxOb2RlKSB7XG4gIHJldHVybiBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHhtbE5vZGUpLnJlcGxhY2UoL3htbG5zKDpbYS16MC05XSspPz1cIlwiID8vZywgXCJcIik7XG59XG5mdW5jdGlvbiBzdHIyeG1sKHN0cikge1xuICBpZiAoc3RyLmNoYXJDb2RlQXQoMCkgPT09IDY1Mjc5KSB7XG4gICAgLy8gQk9NIHNlcXVlbmNlXG4gICAgc3RyID0gc3RyLnN1YnN0cigxKTtcbiAgfVxuICByZXR1cm4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHIsIFwidGV4dC94bWxcIik7XG59XG52YXIgY2hhck1hcCA9IFtbXCImXCIsIFwiJmFtcDtcIl0sIFtcIjxcIiwgXCImbHQ7XCJdLCBbXCI+XCIsIFwiJmd0O1wiXSwgWydcIicsIFwiJnF1b3Q7XCJdLCBbXCInXCIsIFwiJmFwb3M7XCJdXTtcbnZhciBjaGFyTWFwUmVnZXhlcyA9IGNoYXJNYXAubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgIGVuZENoYXIgPSBfcmVmMlswXSxcbiAgICBzdGFydENoYXIgPSBfcmVmMlsxXTtcbiAgcmV0dXJuIHtcbiAgICByc3RhcnQ6IG5ldyBSZWdFeHAoc3RhcnRDaGFyLCBcImdcIiksXG4gICAgcmVuZDogbmV3IFJlZ0V4cChlbmRDaGFyLCBcImdcIiksXG4gICAgc3RhcnQ6IHN0YXJ0Q2hhcixcbiAgICBlbmQ6IGVuZENoYXJcbiAgfTtcbn0pO1xuZnVuY3Rpb24gd29yZFRvVXRmOChzdHJpbmcpIHtcbiAgZm9yICh2YXIgaSA9IGNoYXJNYXBSZWdleGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHIgPSBjaGFyTWFwUmVnZXhlc1tpXTtcbiAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyLnJzdGFydCwgci5lbmQpO1xuICB9XG4gIHJldHVybiBzdHJpbmc7XG59XG5mdW5jdGlvbiB1dGY4VG9Xb3JkKHN0cmluZykge1xuICAvLyBUbyBtYWtlIHN1cmUgdGhhdCB0aGUgb2JqZWN0IGdpdmVuIGlzIGEgc3RyaW5nICh0aGlzIGlzIGEgbm9vcCBmb3Igc3RyaW5ncykuXG4gIHN0cmluZyA9IHN0cmluZy50b1N0cmluZygpO1xuICB2YXIgcjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGFyTWFwUmVnZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICByID0gY2hhck1hcFJlZ2V4ZXNbaV07XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2Uoci5yZW5kLCByLnN0YXJ0KTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gd2l0aCBmb3IgbG9vcHMgZm9yIHBlcmZvcm1hbmNlXG5mdW5jdGlvbiBjb25jYXRBcnJheXMoYXJyYXlzKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgYXJyYXlzLmxlbmd0aDsgX2k2KyspIHtcbiAgICB2YXIgYXJyYXkgPSBhcnJheXNbX2k2XTtcbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBhcnJheS5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICB2YXIgZWwgPSBhcnJheVtfaThdO1xuICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcHVzaEFycmF5KGFycmF5MSwgYXJyYXkyKSB7XG4gIGlmICghYXJyYXkyKSB7XG4gICAgcmV0dXJuIGFycmF5MTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyYXkxLnB1c2goYXJyYXkyW2ldKTtcbiAgfVxuICByZXR1cm4gYXJyYXkxO1xufVxudmFyIHNwYWNlUmVnZXhwID0gbmV3IFJlZ0V4cChTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCksIFwiZ1wiKTtcbmZ1bmN0aW9uIGNvbnZlcnRTcGFjZXMocykge1xuICByZXR1cm4gcy5yZXBsYWNlKHNwYWNlUmVnZXhwLCBcIiBcIik7XG59XG5mdW5jdGlvbiBwcmVnTWF0Y2hBbGwocmVnZXgsIGNvbnRlbnQpIHtcbiAgLypcbiAgICogUmVnZXggaXMgYSBzdHJpbmcsIGNvbnRlbnQgaXMgdGhlIGNvbnRlbnQuIEl0IHJldHVybnMgYW4gYXJyYXkgb2YgYWxsXG4gICAqIG1hdGNoZXMgd2l0aCB0aGVpciBvZmZzZXQsIGZvciBleGFtcGxlOlxuICAgKlxuICAgKiByZWdleD1sYVxuICAgKiBjb250ZW50PWxvbGFsb2xpbGFsYVxuICAgKlxuICAgKiBSZXR1cm5zOlxuICAgKlxuICAgKiBbXG4gICAqICAgIHthcnJheTogezA6ICdsYSd9LCBvZmZzZXQ6IDJ9LFxuICAgKiAgICB7YXJyYXk6IHswOiAnbGEnfSwgb2Zmc2V0OiA4fSxcbiAgICogICAge2FycmF5OiB7MDogJ2xhJ30sIG9mZnNldDogMTB9XG4gICAqIF1cbiAgICovXG4gIHZhciBtYXRjaEFycmF5ID0gW107XG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMoY29udGVudCkpICE9IG51bGwpIHtcbiAgICBtYXRjaEFycmF5LnB1c2goe1xuICAgICAgYXJyYXk6IG1hdGNoLFxuICAgICAgb2Zmc2V0OiBtYXRjaC5pbmRleFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXRjaEFycmF5O1xufVxuZnVuY3Rpb24gaXNFbmRpbmcodmFsdWUsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIjwvXCIgKyBlbGVtZW50ICsgXCI+XCI7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aW5nKHZhbHVlLCBlbGVtZW50KSB7XG4gIHJldHVybiB2YWx1ZS5pbmRleE9mKFwiPFwiICsgZWxlbWVudCkgPT09IDAgJiYgW1wiPlwiLCBcIiBcIiwgXCIvXCJdLmluZGV4T2YodmFsdWVbZWxlbWVudC5sZW5ndGggKyAxXSkgIT09IC0xO1xufVxuZnVuY3Rpb24gZ2V0UmlnaHQocGFyc2VkLCBlbGVtZW50LCBpbmRleCkge1xuICB2YXIgdmFsID0gZ2V0UmlnaHRPck51bGwocGFyc2VkLCBlbGVtZW50LCBpbmRleCk7XG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHRocm93WG1sVGFnTm90Rm91bmQoe1xuICAgIHBvc2l0aW9uOiBcInJpZ2h0XCIsXG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBwYXJzZWQ6IHBhcnNlZCxcbiAgICBpbmRleDogaW5kZXhcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRSaWdodE9yTnVsbChwYXJzZWQsIGVsZW1lbnRzLCBpbmRleCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuICB9XG4gIHZhciBsZXZlbCA9IDE7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgbCA9IHBhcnNlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBmb3IgKHZhciBfaTEwID0gMCwgX2VsZW1lbnRzMiA9IGVsZW1lbnRzOyBfaTEwIDwgX2VsZW1lbnRzMi5sZW5ndGg7IF9pMTArKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSBfZWxlbWVudHMyW19pMTBdO1xuICAgICAgaWYgKGlzRW5kaW5nKHBhcnQudmFsdWUsIGVsZW1lbnQpKSB7XG4gICAgICAgIGxldmVsLS07XG4gICAgICB9XG4gICAgICBpZiAoaXNTdGFydGluZyhwYXJ0LnZhbHVlLCBlbGVtZW50KSkge1xuICAgICAgICBsZXZlbCsrO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldExlZnQocGFyc2VkLCBlbGVtZW50LCBpbmRleCkge1xuICB2YXIgdmFsID0gZ2V0TGVmdE9yTnVsbChwYXJzZWQsIGVsZW1lbnQsIGluZGV4KTtcbiAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgdGhyb3dYbWxUYWdOb3RGb3VuZCh7XG4gICAgcG9zaXRpb246IFwibGVmdFwiLFxuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgcGFyc2VkOiBwYXJzZWQsXG4gICAgaW5kZXg6IGluZGV4XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0TGVmdE9yTnVsbChwYXJzZWQsIGVsZW1lbnRzLCBpbmRleCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuICB9XG4gIHZhciBsZXZlbCA9IDE7XG4gIGZvciAodmFyIGkgPSBpbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBmb3IgKHZhciBfaTEyID0gMCwgX2VsZW1lbnRzNCA9IGVsZW1lbnRzOyBfaTEyIDwgX2VsZW1lbnRzNC5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSBfZWxlbWVudHM0W19pMTJdO1xuICAgICAgaWYgKGlzU3RhcnRpbmcocGFydC52YWx1ZSwgZWxlbWVudCkpIHtcbiAgICAgICAgbGV2ZWwtLTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VuZGluZyhwYXJ0LnZhbHVlLCBlbGVtZW50KSkge1xuICAgICAgICBsZXZlbCsrO1xuICAgICAgfVxuICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLypcbiAqIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRob3NlIGFyZSBmdW5jdGlvbnMgdGhhdCBkZXBlbmQgb24gdGhlIHBhcnNlZFxuICogc3RydWN0dXJlIGJhc2VkIGFuZCB3ZSBkb24ndCB3YW50IG1pbmltYWwgY29kZSBoZXJlLCBidXQgcmF0aGVyIGNvZGUgdGhhdFxuICogbWFrZXMgdGhpbmdzIGNsZWFyLlxuICovXG5mdW5jdGlvbiBpc1RhZ1N0YXJ0KHRhZ1R5cGUsIF9yZWYzKSB7XG4gIHZhciB0eXBlID0gX3JlZjMudHlwZSxcbiAgICB0YWcgPSBfcmVmMy50YWcsXG4gICAgcG9zaXRpb24gPSBfcmVmMy5wb3NpdGlvbjtcbiAgcmV0dXJuIHR5cGUgPT09IFwidGFnXCIgJiYgdGFnID09PSB0YWdUeXBlICYmIChwb3NpdGlvbiA9PT0gXCJzdGFydFwiIHx8IHBvc2l0aW9uID09PSBcInNlbGZjbG9zaW5nXCIpO1xufVxuZnVuY3Rpb24gaXNUYWdFbmQodGFnVHlwZSwgX3JlZjQpIHtcbiAgdmFyIHR5cGUgPSBfcmVmNC50eXBlLFxuICAgIHRhZyA9IF9yZWY0LnRhZyxcbiAgICBwb3NpdGlvbiA9IF9yZWY0LnBvc2l0aW9uO1xuICByZXR1cm4gdHlwZSA9PT0gXCJ0YWdcIiAmJiB0YWcgPT09IHRhZ1R5cGUgJiYgcG9zaXRpb24gPT09IFwiZW5kXCI7XG59XG5mdW5jdGlvbiBpc1BhcmFncmFwaFN0YXJ0KF9yZWY1KSB7XG4gIHZhciB0eXBlID0gX3JlZjUudHlwZSxcbiAgICB0YWcgPSBfcmVmNS50YWcsXG4gICAgcG9zaXRpb24gPSBfcmVmNS5wb3NpdGlvbjtcbiAgcmV0dXJuIFtcInc6cFwiLCBcImE6cFwiXS5pbmRleE9mKHRhZykgIT09IC0xICYmIHR5cGUgPT09IFwidGFnXCIgJiYgcG9zaXRpb24gPT09IFwic3RhcnRcIjtcbn1cbmZ1bmN0aW9uIGlzUGFyYWdyYXBoRW5kKF9yZWY2KSB7XG4gIHZhciB0eXBlID0gX3JlZjYudHlwZSxcbiAgICB0YWcgPSBfcmVmNi50YWcsXG4gICAgcG9zaXRpb24gPSBfcmVmNi5wb3NpdGlvbjtcbiAgcmV0dXJuIFtcInc6cFwiLCBcImE6cFwiXS5pbmRleE9mKHRhZykgIT09IC0xICYmIHR5cGUgPT09IFwidGFnXCIgJiYgcG9zaXRpb24gPT09IFwiZW5kXCI7XG59XG5mdW5jdGlvbiBpc1RleHRTdGFydChfcmVmNykge1xuICB2YXIgdHlwZSA9IF9yZWY3LnR5cGUsXG4gICAgcG9zaXRpb24gPSBfcmVmNy5wb3NpdGlvbixcbiAgICB0ZXh0ID0gX3JlZjcudGV4dDtcbiAgcmV0dXJuIHRleHQgJiYgdHlwZSA9PT0gXCJ0YWdcIiAmJiBwb3NpdGlvbiA9PT0gXCJzdGFydFwiO1xufVxuZnVuY3Rpb24gaXNUZXh0RW5kKF9yZWY4KSB7XG4gIHZhciB0eXBlID0gX3JlZjgudHlwZSxcbiAgICBwb3NpdGlvbiA9IF9yZWY4LnBvc2l0aW9uLFxuICAgIHRleHQgPSBfcmVmOC50ZXh0O1xuICByZXR1cm4gdGV4dCAmJiB0eXBlID09PSBcInRhZ1wiICYmIHBvc2l0aW9uID09PSBcImVuZFwiO1xufVxuZnVuY3Rpb24gaXNDb250ZW50KF9yZWY5KSB7XG4gIHZhciB0eXBlID0gX3JlZjkudHlwZSxcbiAgICBwb3NpdGlvbiA9IF9yZWY5LnBvc2l0aW9uO1xuICByZXR1cm4gdHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiIHx8IHR5cGUgPT09IFwiY29udGVudFwiICYmIHBvc2l0aW9uID09PSBcImluc2lkZXRhZ1wiO1xufVxuZnVuY3Rpb24gaXNNb2R1bGUoX3JlZjEwLCBtb2R1bGVzKSB7XG4gIHZhciBtb2R1bGUgPSBfcmVmMTAubW9kdWxlLFxuICAgIHR5cGUgPSBfcmVmMTAudHlwZTtcbiAgaWYgKCEobW9kdWxlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIG1vZHVsZXMgPSBbbW9kdWxlc107XG4gIH1cbiAgcmV0dXJuIHR5cGUgPT09IFwicGxhY2Vob2xkZXJcIiAmJiBtb2R1bGVzLmluZGV4T2YobW9kdWxlKSAhPT0gLTE7XG59XG4vLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG5cbnZhciBjb3JydXB0Q2hhcmFjdGVycyA9IC9bXFx4MDAtXFx4MDhcXHgwQlxceDBDXFx4MEUtXFx4MUZdLztcbi8qXG4gKiAwMCAgICBOVUwgJ1xcMCcgKG51bGwgY2hhcmFjdGVyKVxuICogMDEgICAgU09IIChzdGFydCBvZiBoZWFkaW5nKVxuICogMDIgICAgU1RYIChzdGFydCBvZiB0ZXh0KVxuICogMDMgICAgRVRYIChlbmQgb2YgdGV4dClcbiAqIDA0ICAgIEVPVCAoZW5kIG9mIHRyYW5zbWlzc2lvbilcbiAqIDA1ICAgIEVOUSAoZW5xdWlyeSlcbiAqIDA2ICAgIEFDSyAoYWNrbm93bGVkZ2UpXG4gKiAwNyAgICBCRUwgJ1xcYScgKGJlbGwpXG4gKiAwOCAgICBCUyAgJ1xcYicgKGJhY2tzcGFjZSlcbiAqIDBCICAgIFZUICAnXFx2JyAodmVydGljYWwgdGFiKVxuICogMEMgICAgRkYgICdcXGYnIChmb3JtIGZlZWQpXG4gKiAwRSAgICBTTyAgKHNoaWZ0IG91dClcbiAqIDBGICAgIFNJICAoc2hpZnQgaW4pXG4gKiAxMCAgICBETEUgKGRhdGEgbGluayBlc2NhcGUpXG4gKiAxMSAgICBEQzEgKGRldmljZSBjb250cm9sIDEpXG4gKiAxMiAgICBEQzIgKGRldmljZSBjb250cm9sIDIpXG4gKiAxMyAgICBEQzMgKGRldmljZSBjb250cm9sIDMpXG4gKiAxNCAgICBEQzQgKGRldmljZSBjb250cm9sIDQpXG4gKiAxNSAgICBOQUsgKG5lZ2F0aXZlIGFjay4pXG4gKiAxNiAgICBTWU4gKHN5bmNocm9ub3VzIGlkbGUpXG4gKiAxNyAgICBFVEIgKGVuZCBvZiB0cmFucy4gYmxrKVxuICogMTggICAgQ0FOIChjYW5jZWwpXG4gKiAxOSAgICBFTSAgKGVuZCBvZiBtZWRpdW0pXG4gKiAxQSAgICBTVUIgKHN1YnN0aXR1dGUpXG4gKiAxQiAgICBFU0MgKGVzY2FwZSlcbiAqIDFDICAgIEZTICAoZmlsZSBzZXBhcmF0b3IpXG4gKiAxRCAgICBHUyAgKGdyb3VwIHNlcGFyYXRvcilcbiAqIDFFICAgIFJTICAocmVjb3JkIHNlcGFyYXRvcilcbiAqIDFGICAgIFVTICAodW5pdCBzZXBhcmF0b3IpXG4gKi9cbmZ1bmN0aW9uIGhhc0NvcnJ1cHRDaGFyYWN0ZXJzKHN0cmluZykge1xuICByZXR1cm4gY29ycnVwdENoYXJhY3RlcnMudGVzdChzdHJpbmcpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ29ycnVwdENoYXJhY3RlcnMoc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgc3RyaW5nID0gU3RyaW5nKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGNvcnJ1cHRDaGFyYWN0ZXJzLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGludmVydE1hcChtYXApIHtcbiAgdmFyIGludmVydGVkTWFwID0ge307XG4gIGZvciAodmFyIGtleSBpbiBtYXApIHtcbiAgICB2YXIgdmFsdWUgPSBtYXBba2V5XTtcbiAgICBpbnZlcnRlZE1hcFt2YWx1ZV0gfHwgKGludmVydGVkTWFwW3ZhbHVlXSA9IFtdKTtcbiAgICBpbnZlcnRlZE1hcFt2YWx1ZV0ucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBpbnZlcnRlZE1hcDtcbn1cbi8qXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgc29ydCBpcyBzdGFibGUuIFRoZSBkZWZhdWx0IEFycmF5LnNvcnQgb2YgdGhlIGJyb3dzZXJcbiAqIGlzIG5vdCBzdGFibGUgaW4gZmlyZWZveCwgYXMgdGhlIEpTIHNwZWMgZG9lcyBub3QgZW5mb3JjZSB0aGUgc29ydCB0byBiZVxuICogc3RhYmxlLlxuICovXG5mdW5jdGlvbiBzdGFibGVTb3J0KGFyciwgY29tcGFyZSkge1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogaW4gcHJldmlvdXMgdmVyc2lvbnMgb2YgQ2hyb21lLCBzb3J0IHdhcyBub3Qgc3RhYmxlIGJ5IGl0c2VsZiwgc28gd2UgaGFkIHRvIGFkZCB0aGlzLiBUaGlzIGlzIHRvIHN1cHBvcnQgb2xkZXIgdmVyc2lvbnMgb2YgSlMgcnVubmVycy5cbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9O1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYS5pdGVtLCBiLml0ZW0pIHx8IGEuaW5kZXggLSBiLmluZGV4O1xuICB9KS5tYXAoZnVuY3Rpb24gKF9yZWYxMSkge1xuICAgIHZhciBpdGVtID0gX3JlZjExLml0ZW07XG4gICAgcmV0dXJuIGl0ZW07XG4gIH0pO1xuICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5kc1dpdGg6IGVuZHNXaXRoLFxuICBzdGFydHNXaXRoOiBzdGFydHNXaXRoLFxuICBpc0NvbnRlbnQ6IGlzQ29udGVudCxcbiAgaXNQYXJhZ3JhcGhTdGFydDogaXNQYXJhZ3JhcGhTdGFydCxcbiAgaXNQYXJhZ3JhcGhFbmQ6IGlzUGFyYWdyYXBoRW5kLFxuICBpc1RhZ1N0YXJ0OiBpc1RhZ1N0YXJ0LFxuICBpc1RhZ0VuZDogaXNUYWdFbmQsXG4gIGlzVGV4dFN0YXJ0OiBpc1RleHRTdGFydCxcbiAgaXNUZXh0RW5kOiBpc1RleHRFbmQsXG4gIGlzU3RhcnRpbmc6IGlzU3RhcnRpbmcsXG4gIGlzRW5kaW5nOiBpc0VuZGluZyxcbiAgaXNNb2R1bGU6IGlzTW9kdWxlLFxuICB1bmlxOiB1bmlxLFxuICBnZXREdXBsaWNhdGVzOiBnZXREdXBsaWNhdGVzLFxuICBjaHVua0J5OiBjaHVua0J5LFxuICBsYXN0OiBsYXN0LFxuICBmaXJzdDogZmlyc3QsXG4gIHhtbDJzdHI6IHhtbDJzdHIsXG4gIHN0cjJ4bWw6IHN0cjJ4bWwsXG4gIGdldFJpZ2h0T3JOdWxsOiBnZXRSaWdodE9yTnVsbCxcbiAgZ2V0UmlnaHQ6IGdldFJpZ2h0LFxuICBnZXRMZWZ0T3JOdWxsOiBnZXRMZWZ0T3JOdWxsLFxuICBnZXRMZWZ0OiBnZXRMZWZ0LFxuICBwcmVnTWF0Y2hBbGw6IHByZWdNYXRjaEFsbCxcbiAgY29udmVydFNwYWNlczogY29udmVydFNwYWNlcyxcbiAgY2hhck1hcFJlZ2V4ZXM6IGNoYXJNYXBSZWdleGVzLFxuICBoYXNDb3JydXB0Q2hhcmFjdGVyczogaGFzQ29ycnVwdENoYXJhY3RlcnMsXG4gIHJlbW92ZUNvcnJ1cHRDaGFyYWN0ZXJzOiByZW1vdmVDb3JydXB0Q2hhcmFjdGVycyxcbiAgZ2V0RGVmYXVsdHM6IGdldERlZmF1bHRzLFxuICB3b3JkVG9VdGY4OiB3b3JkVG9VdGY4LFxuICB1dGY4VG9Xb3JkOiB1dGY4VG9Xb3JkLFxuICBjb25jYXRBcnJheXM6IGNvbmNhdEFycmF5cyxcbiAgcHVzaEFycmF5OiBwdXNoQXJyYXksXG4gIGludmVydE1hcDogaW52ZXJ0TWFwLFxuICBjaGFyTWFwOiBjaGFyTWFwLFxuICBnZXRTaW5nbGVBdHRyaWJ1dGU6IGdldFNpbmdsZUF0dHJpYnV0ZSxcbiAgc2V0U2luZ2xlQXR0cmlidXRlOiBzZXRTaW5nbGVBdHRyaWJ1dGUsXG4gIGlzV2hpdGVTcGFjZTogaXNXaGl0ZVNwYWNlLFxuICBzdGFibGVTb3J0OiBzdGFibGVTb3J0XG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/docxtemplater.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/docxtemplater.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _excluded = [\"modules\"];\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar DocUtils = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\");\nDocUtils.traits = __webpack_require__(/*! ./traits.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/traits.js\");\nDocUtils.moduleWrapper = __webpack_require__(/*! ./module-wrapper.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/module-wrapper.js\");\nvar createScope = __webpack_require__(/*! ./scope-manager.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/scope-manager.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/lexer.js\");\nvar commonModule = __webpack_require__(/*! ./modules/common.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/common.js\");\nfunction deprecatedMessage(obj, message) {\n  if (obj.hideDeprecations === true) {\n    return;\n  }\n  // eslint-disable-next-line no-console\n  console.warn(message);\n}\nfunction deprecatedMethod(obj, method) {\n  if (obj.hideDeprecations === true) {\n    return;\n  }\n  return deprecatedMessage(obj, \"Deprecated method \\\".\".concat(method, \"\\\", view upgrade guide : https://docxtemplater.com/docs/api/#upgrade-guide, stack : \").concat(new Error().stack));\n}\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\"),\n  throwMultiError = _require.throwMultiError,\n  throwResolveBeforeCompile = _require.throwResolveBeforeCompile,\n  throwRenderInvalidTemplate = _require.throwRenderInvalidTemplate,\n  throwRenderTwice = _require.throwRenderTwice,\n  XTInternalError = _require.XTInternalError,\n  XTTemplateError = _require.XTTemplateError,\n  throwFileTypeNotIdentified = _require.throwFileTypeNotIdentified,\n  throwFileTypeNotHandled = _require.throwFileTypeNotHandled,\n  throwApiVersionError = _require.throwApiVersionError;\nvar logErrors = __webpack_require__(/*! ./error-logger.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/error-logger.js\");\nvar collectContentTypes = __webpack_require__(/*! ./collect-content-types.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/collect-content-types.js\");\nvar getDefaults = DocUtils.getDefaults,\n  str2xml = DocUtils.str2xml,\n  xml2str = DocUtils.xml2str,\n  moduleWrapper = DocUtils.moduleWrapper,\n  concatArrays = DocUtils.concatArrays,\n  uniq = DocUtils.uniq,\n  getDuplicates = DocUtils.getDuplicates,\n  stableSort = DocUtils.stableSort,\n  pushArray = DocUtils.pushArray;\nvar ctXML = \"[Content_Types].xml\";\nvar relsFile = \"_rels/.rels\";\nvar currentModuleApiVersion = [3, 44, 0];\nfunction dropUnsupportedFileTypesModules(doc) {\n  doc.modules = doc.modules.filter(function (module) {\n    if (!module.supportedFileTypes) {\n      return true;\n    }\n    if (!Array.isArray(module.supportedFileTypes)) {\n      throw new Error(\"The supportedFileTypes field of the module must be an array\");\n    }\n    var isSupportedModule = module.supportedFileTypes.includes(doc.fileType);\n    if (!isSupportedModule) {\n      module.on(\"detached\");\n    }\n    return isSupportedModule;\n  });\n}\nfunction verifyErrors(doc) {\n  var compiled = doc.compiled;\n  doc.errors = concatArrays(Object.keys(compiled).map(function (name) {\n    return compiled[name].allErrors;\n  }));\n  if (doc.errors.length !== 0) {\n    if (doc.options.errorLogging) {\n      logErrors(doc.errors, doc.options.errorLogging);\n    }\n    throwMultiError(doc.errors);\n  }\n}\nvar Docxtemplater = /*#__PURE__*/function () {\n  function Docxtemplater(zip) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$modules = _ref.modules,\n      modules = _ref$modules === void 0 ? [] : _ref$modules,\n      options = _objectWithoutProperties(_ref, _excluded);\n    _classCallCheck(this, Docxtemplater);\n    this.targets = [];\n    this.rendered = false;\n    this.scopeManagers = {};\n    this.compiled = {};\n    this.modules = [commonModule()];\n    this.xmlDocuments = {};\n    if (arguments.length === 0) {\n      deprecatedMessage(this, \"Deprecated docxtemplater constructor with no arguments, view upgrade guide : https://docxtemplater.com/docs/api/#upgrade-guide, stack : \".concat(new Error().stack));\n      this.hideDeprecations = true;\n      this.setOptions(options);\n    } else {\n      this.hideDeprecations = true;\n      this.setOptions(options);\n      if (!zip || !zip.files || typeof zip.file !== \"function\") {\n        throw new Error(\"The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)\");\n      }\n      if (!Array.isArray(modules)) {\n        throw new Error(\"The modules argument of docxtemplater's constructor must be an array\");\n      }\n      for (var _i2 = 0; _i2 < modules.length; _i2++) {\n        var _module = modules[_i2];\n        this.attachModule(_module);\n      }\n      this.loadZip(zip);\n      this.compile();\n      this.v4Constructor = true;\n    }\n    this.hideDeprecations = false;\n  }\n  return _createClass(Docxtemplater, [{\n    key: \"verifyApiVersion\",\n    value: function verifyApiVersion(neededVersion) {\n      neededVersion = neededVersion.split(\".\").map(function (i) {\n        return parseInt(i, 10);\n      });\n      if (neededVersion.length !== 3) {\n        throwApiVersionError(\"neededVersion is not a valid version\", {\n          neededVersion: neededVersion,\n          explanation: \"the neededVersion must be an array of length 3\"\n        });\n      }\n      if (neededVersion[0] !== currentModuleApiVersion[0]) {\n        throwApiVersionError(\"The major api version do not match, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      if (neededVersion[1] > currentModuleApiVersion[1]) {\n        throwApiVersionError(\"The minor api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      if (neededVersion[1] === currentModuleApiVersion[1] && neededVersion[2] > currentModuleApiVersion[2]) {\n        throwApiVersionError(\"The patch api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      return true;\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      for (var _i4 = 0, _this$modules2 = this.modules; _i4 < _this$modules2.length; _i4++) {\n        var _module2 = _this$modules2[_i4];\n        _module2.set(obj);\n      }\n    }\n  }, {\n    key: \"sendEvent\",\n    value: function sendEvent(eventName) {\n      for (var _i6 = 0, _this$modules4 = this.modules; _i6 < _this$modules4.length; _i6++) {\n        var _module3 = _this$modules4[_i6];\n        _module3.on(eventName);\n      }\n    }\n  }, {\n    key: \"attachModule\",\n    value: function attachModule(module) {\n      if (this.v4Constructor) {\n        throw new XTInternalError(\"attachModule() should not be called manually when using the v4 constructor\");\n      }\n      deprecatedMethod(this, \"attachModule\");\n      var moduleType = _typeof(module);\n      if (moduleType === \"function\") {\n        throw new XTInternalError(\"Cannot attach a class/function as a module. Most probably you forgot to instantiate the module by using `new` on the module.\");\n      }\n      if (!module || moduleType !== \"object\") {\n        throw new XTInternalError(\"Cannot attachModule with a falsy value\");\n      }\n      if (module.requiredAPIVersion) {\n        this.verifyApiVersion(module.requiredAPIVersion);\n      }\n      if (module.attached === true) {\n        if (typeof module.clone === \"function\") {\n          module = module.clone();\n        } else {\n          throw new Error(\"Cannot attach a module that was already attached : \\\"\".concat(module.name, \"\\\". The most likely cause is that you are instantiating the module at the root level, and using it for multiple instances of Docxtemplater\"));\n        }\n      }\n      module.attached = true;\n      var wrappedModule = moduleWrapper(module);\n      this.modules.push(wrappedModule);\n      wrappedModule.on(\"attached\");\n      if (this.fileType) {\n        dropUnsupportedFileTypesModules(this);\n      }\n      return this;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var _this$delimiters, _this$delimiters2;\n      if (this.v4Constructor) {\n        throw new Error(\"setOptions() should not be called manually when using the v4 constructor\");\n      }\n      deprecatedMethod(this, \"setOptions\");\n      if (!options) {\n        throw new Error(\"setOptions should be called with an object as first parameter\");\n      }\n      this.options = {};\n      var defaults = getDefaults();\n      for (var key in defaults) {\n        var defaultValue = defaults[key];\n        this.options[key] = options[key] != null ? options[key] : this[key] || defaultValue;\n        this[key] = this.options[key];\n      }\n      (_this$delimiters = this.delimiters).start && (_this$delimiters.start = DocUtils.utf8ToWord(this.delimiters.start));\n      (_this$delimiters2 = this.delimiters).end && (_this$delimiters2.end = DocUtils.utf8ToWord(this.delimiters.end));\n      return this;\n    }\n  }, {\n    key: \"loadZip\",\n    value: function loadZip(zip) {\n      if (this.v4Constructor) {\n        throw new Error(\"loadZip() should not be called manually when using the v4 constructor\");\n      }\n      deprecatedMethod(this, \"loadZip\");\n      if (zip.loadAsync) {\n        throw new XTInternalError(\"Docxtemplater doesn't handle JSZip version >=3, please use pizzip\");\n      }\n      this.zip = zip;\n      this.updateFileTypeConfig();\n      this.modules = concatArrays([this.fileTypeConfig.baseModules.map(function (moduleFunction) {\n        return moduleFunction();\n      }), this.modules]);\n      for (var _i8 = 0, _this$modules6 = this.modules; _i8 < _this$modules6.length; _i8++) {\n        var _module4 = _this$modules6[_i8];\n        _module4.zip = this.zip;\n        _module4.docxtemplater = this;\n      }\n      dropUnsupportedFileTypesModules(this);\n      return this;\n    }\n  }, {\n    key: \"precompileFile\",\n    value: function precompileFile(fileName) {\n      var currentFile = this.createTemplateClass(fileName);\n      currentFile.preparse();\n      this.compiled[fileName] = currentFile;\n    }\n  }, {\n    key: \"compileFile\",\n    value: function compileFile(fileName) {\n      this.compiled[fileName].parse();\n    }\n  }, {\n    key: \"getScopeManager\",\n    value: function getScopeManager(to, currentFile, tags) {\n      var _this$scopeManagers;\n      (_this$scopeManagers = this.scopeManagers)[to] || (_this$scopeManagers[to] = createScope({\n        tags: tags,\n        parser: this.parser,\n        cachedParsers: currentFile.cachedParsers\n      }));\n      return this.scopeManagers[to];\n    }\n  }, {\n    key: \"resolveData\",\n    value: function resolveData(data) {\n      var _this = this;\n      deprecatedMethod(this, \"resolveData\");\n      var errors = [];\n      if (!Object.keys(this.compiled).length) {\n        throwResolveBeforeCompile();\n      }\n      return Promise.resolve(data).then(function (data) {\n        _this.data = data;\n        _this.setModules({\n          data: _this.data,\n          Lexer: Lexer\n        });\n        _this.mapper = _this.modules.reduce(function (value, module) {\n          return module.getRenderedMap(value);\n        }, {});\n        return Promise.all(Object.keys(_this.mapper).map(function (to) {\n          var _this$mapper$to = _this.mapper[to],\n            from = _this$mapper$to.from,\n            data = _this$mapper$to.data;\n          return Promise.resolve(data).then(function (data) {\n            var currentFile = _this.compiled[from];\n            currentFile.filePath = to;\n            currentFile.scopeManager = _this.getScopeManager(to, currentFile, data);\n            return currentFile.resolveTags(data).then(function (result) {\n              currentFile.scopeManager.finishedResolving = true;\n              return result;\n            }, function (errs) {\n              Array.prototype.push.apply(errors, errs);\n            });\n          });\n        })).then(function (resolved) {\n          if (errors.length !== 0) {\n            if (_this.options.errorLogging) {\n              logErrors(errors, _this.options.errorLogging);\n            }\n            throwMultiError(errors);\n          }\n          return concatArrays(resolved);\n        });\n      });\n    }\n  }, {\n    key: \"reorderModules\",\n    value: function reorderModules() {\n      /**\n       * Modules will be sorted according to priority.\n       *\n       * Input example:\n       * [\n       *   { priority: 1, name: \"FooMod\" },\n       *   { priority: -1, name: \"XMod\" },\n       *   { priority: 4, name: \"OtherMod\" }\n       * ]\n       *\n       * Output example (sorted by priority in descending order):\n       * [\n       *   { priority: 4, name: \"OtherMod\" },\n       *   { priority: 1, name: \"FooMod\" },\n       *   { priority: -1, name: \"XMod\" }\n       * ]\n       */\n      this.modules = stableSort(this.modules, function (m1, m2) {\n        return (m2.priority || 0) - (m1.priority || 0);\n      });\n    }\n  }, {\n    key: \"throwIfDuplicateModules\",\n    value: function throwIfDuplicateModules() {\n      var duplicates = getDuplicates(this.modules.map(function (_ref2) {\n        var name = _ref2.name;\n        return name;\n      }));\n      if (duplicates.length > 0) {\n        throw new XTInternalError(\"Detected duplicate module \\\"\".concat(duplicates[0], \"\\\"\"));\n      }\n    }\n  }, {\n    key: \"compile\",\n    value: function compile() {\n      var _this2 = this;\n      deprecatedMethod(this, \"compile\");\n      this.updateFileTypeConfig();\n      this.throwIfDuplicateModules();\n      this.reorderModules();\n      if (Object.keys(this.compiled).length) {\n        return this;\n      }\n      this.options = this.modules.reduce(function (options, module) {\n        return module.optionsTransformer(options, _this2);\n      }, this.options);\n      this.options.xmlFileNames = uniq(this.options.xmlFileNames);\n      for (var _i10 = 0, _this$options$xmlFile2 = this.options.xmlFileNames; _i10 < _this$options$xmlFile2.length; _i10++) {\n        var fileName = _this$options$xmlFile2[_i10];\n        var content = this.zip.files[fileName].asText();\n        this.xmlDocuments[fileName] = str2xml(content);\n      }\n      this.setModules({\n        zip: this.zip,\n        xmlDocuments: this.xmlDocuments\n      });\n      this.getTemplatedFiles();\n      /*\n       * Loop inside all templatedFiles (ie xml files with content).\n       * Sometimes they don't exist (footer.xml for example)\n       */\n      for (var _i12 = 0, _this$templatedFiles2 = this.templatedFiles; _i12 < _this$templatedFiles2.length; _i12++) {\n        var _fileName = _this$templatedFiles2[_i12];\n        if (this.zip.files[_fileName] != null) {\n          this.precompileFile(_fileName);\n        }\n      }\n      for (var _i14 = 0, _this$templatedFiles4 = this.templatedFiles; _i14 < _this$templatedFiles4.length; _i14++) {\n        var _fileName2 = _this$templatedFiles4[_i14];\n        if (this.zip.files[_fileName2] != null) {\n          this.compileFile(_fileName2);\n        }\n      }\n      this.setModules({\n        compiled: this.compiled\n      });\n      verifyErrors(this);\n      return this;\n    }\n  }, {\n    key: \"getRelsTypes\",\n    value: function getRelsTypes() {\n      var rootRels = this.zip.files[relsFile];\n      var rootRelsXml = rootRels ? str2xml(rootRels.asText()) : null;\n      var rootRelationships = rootRelsXml ? rootRelsXml.getElementsByTagName(\"Relationship\") : [];\n      var relsTypes = {};\n      for (var _i16 = 0; _i16 < rootRelationships.length; _i16++) {\n        var relation = rootRelationships[_i16];\n        relsTypes[relation.getAttribute(\"Target\")] = relation.getAttribute(\"Type\");\n      }\n      return relsTypes;\n    }\n  }, {\n    key: \"getContentTypes\",\n    value: function getContentTypes() {\n      var contentTypes = this.zip.files[ctXML];\n      var contentTypeXml = contentTypes ? str2xml(contentTypes.asText()) : null;\n      var overrides = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Override\") : null;\n      var defaults = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Default\") : null;\n      return {\n        overrides: overrides,\n        defaults: defaults,\n        contentTypes: contentTypes,\n        contentTypeXml: contentTypeXml\n      };\n    }\n  }, {\n    key: \"updateFileTypeConfig\",\n    value: function updateFileTypeConfig() {\n      var fileType;\n      if (this.zip.files.mimetype) {\n        fileType = \"odt\";\n      }\n      this.relsTypes = this.getRelsTypes();\n      var _this$getContentTypes = this.getContentTypes(),\n        overrides = _this$getContentTypes.overrides,\n        defaults = _this$getContentTypes.defaults,\n        contentTypes = _this$getContentTypes.contentTypes,\n        contentTypeXml = _this$getContentTypes.contentTypeXml;\n      if (contentTypeXml) {\n        this.filesContentTypes = collectContentTypes(overrides, defaults, this.zip);\n        this.invertedContentTypes = DocUtils.invertMap(this.filesContentTypes);\n        this.setModules({\n          contentTypes: this.contentTypes,\n          invertedContentTypes: this.invertedContentTypes\n        });\n      }\n      for (var _i18 = 0, _this$modules8 = this.modules; _i18 < _this$modules8.length; _i18++) {\n        var _module5 = _this$modules8[_i18];\n        fileType = _module5.getFileType({\n          zip: this.zip,\n          contentTypes: contentTypes,\n          contentTypeXml: contentTypeXml,\n          overrides: overrides,\n          defaults: defaults,\n          doc: this\n        }) || fileType;\n      }\n      if (fileType === \"odt\") {\n        throwFileTypeNotHandled(fileType);\n      }\n      if (!fileType) {\n        throwFileTypeNotIdentified(this.zip);\n      }\n      for (var _i20 = 0, _this$modules10 = this.modules; _i20 < _this$modules10.length; _i20++) {\n        var _module6 = _this$modules10[_i20];\n        for (var _i22 = 0, _ref4 = _module6.xmlContentTypes || []; _i22 < _ref4.length; _i22++) {\n          var contentType = _ref4[_i22];\n          pushArray(this.options.xmlFileNames, this.invertedContentTypes[contentType] || []);\n        }\n      }\n      this.fileType = fileType;\n      dropUnsupportedFileTypesModules(this);\n      this.fileTypeConfig = this.options.fileTypeConfig || this.fileTypeConfig;\n      if (!this.fileTypeConfig) {\n        if (Docxtemplater.FileTypeConfig[this.fileType]) {\n          this.fileTypeConfig = Docxtemplater.FileTypeConfig[this.fileType]();\n        } else {\n          /*\n           * Error case handled since v3.60.2\n           * Throw specific error when trying to template xlsx file without xlsxmodule\n           */\n          var message = \"Filetype \\\"\".concat(this.fileType, \"\\\" is not supported\");\n          var id = \"filetype_not_supported\";\n          if (this.fileType === \"xlsx\") {\n            message = \"Filetype \\\"\".concat(this.fileType, \"\\\" is supported only with the paid XlsxModule\");\n            id = \"xlsx_filetype_needs_xlsx_module\";\n          }\n          var err = new XTTemplateError(message);\n          err.properties = {\n            id: id,\n            explanation: message\n          };\n          throw err;\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"renderAsync\",\n    value: function renderAsync(data) {\n      var _this3 = this;\n      this.hideDeprecations = true;\n      var promise = this.resolveData(data);\n      this.hideDeprecations = false;\n      return promise.then(function () {\n        return _this3.render();\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(data) {\n      if (this.rendered) {\n        throwRenderTwice();\n      }\n      this.rendered = true;\n      if (Object.keys(this.compiled).length === 0) {\n        this.compile();\n      }\n      if (this.errors.length > 0) {\n        throwRenderInvalidTemplate();\n      }\n      if (arguments.length > 0) {\n        this.data = data;\n      }\n      this.setModules({\n        data: this.data,\n        Lexer: Lexer\n      });\n      this.mapper || (this.mapper = this.modules.reduce(function (value, module) {\n        return module.getRenderedMap(value);\n      }, {}));\n      var output = [];\n      for (var to in this.mapper) {\n        var _this$mapper$to2 = this.mapper[to],\n          from = _this$mapper$to2.from,\n          _data = _this$mapper$to2.data;\n        var currentFile = this.compiled[from];\n        currentFile.scopeManager = this.getScopeManager(to, currentFile, _data);\n        currentFile.render(to);\n        output.push([to, currentFile.content, currentFile]);\n        delete currentFile.content;\n      }\n      for (var _i24 = 0; _i24 < output.length; _i24++) {\n        var outputPart = output[_i24];\n        var _outputPart = _slicedToArray(outputPart, 3),\n          content = _outputPart[1],\n          _currentFile = _outputPart[2];\n        for (var _i26 = 0, _this$modules12 = this.modules; _i26 < _this$modules12.length; _i26++) {\n          var _module7 = _this$modules12[_i26];\n          if (_module7.preZip) {\n            var result = _module7.preZip(content, _currentFile);\n            if (typeof result === \"string\") {\n              outputPart[1] = result;\n            }\n          }\n        }\n      }\n      for (var _i28 = 0; _i28 < output.length; _i28++) {\n        var _output$_i = _slicedToArray(output[_i28], 2),\n          _to = _output$_i[0],\n          _content = _output$_i[1];\n        this.zip.file(_to, _content, {\n          createFolders: true\n        });\n      }\n      verifyErrors(this);\n      this.sendEvent(\"syncing-zip\");\n      this.syncZip();\n      // The synced-zip event is used in the subtemplate module for example\n      this.sendEvent(\"synced-zip\");\n      return this;\n    }\n  }, {\n    key: \"syncZip\",\n    value: function syncZip() {\n      for (var fileName in this.xmlDocuments) {\n        this.zip.remove(fileName);\n        var content = xml2str(this.xmlDocuments[fileName]);\n        this.zip.file(fileName, content, {\n          createFolders: true\n        });\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      deprecatedMethod(this, \"setData\");\n      this.data = data;\n      return this;\n    }\n  }, {\n    key: \"getZip\",\n    value: function getZip() {\n      return this.zip;\n    }\n  }, {\n    key: \"createTemplateClass\",\n    value: function createTemplateClass(path) {\n      var content = this.zip.files[path].asText();\n      return this.createTemplateClassFromContent(content, path);\n    }\n  }, {\n    key: \"createTemplateClassFromContent\",\n    value: function createTemplateClassFromContent(content, filePath) {\n      var xmltOptions = {\n        filePath: filePath,\n        contentType: this.filesContentTypes[filePath],\n        relsType: this.relsTypes[filePath]\n      };\n      var defaults = getDefaults();\n      var defaultKeys = pushArray(Object.keys(defaults), [\"filesContentTypes\", \"fileTypeConfig\", \"fileType\", \"modules\"]);\n      for (var _i30 = 0; _i30 < defaultKeys.length; _i30++) {\n        var key = defaultKeys[_i30];\n        xmltOptions[key] = this[key];\n      }\n      return new Docxtemplater.XmlTemplater(content, xmltOptions);\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText(path) {\n      return this.createTemplateClass(path || this.fileTypeConfig.textPath(this)).getFullText();\n    }\n  }, {\n    key: \"getTemplatedFiles\",\n    value: function getTemplatedFiles() {\n      this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);\n      pushArray(this.templatedFiles, this.targets);\n      this.templatedFiles = uniq(this.templatedFiles);\n      return this.templatedFiles;\n    }\n  }]);\n}();\nDocxtemplater.DocUtils = DocUtils;\nDocxtemplater.Errors = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\");\nDocxtemplater.XmlTemplater = __webpack_require__(/*! ./xml-templater.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/xml-templater.js\");\nDocxtemplater.FileTypeConfig = __webpack_require__(/*! ./file-type-config.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/file-type-config.js\");\nDocxtemplater.XmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/xml-matcher.js\");\nmodule.exports = Docxtemplater;\nmodule.exports[\"default\"] = Docxtemplater;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZG9jeHRlbXBsYXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHVDQUF1QyxrR0FBa0csaUJBQWlCLHdDQUF3QyxNQUFNLHlDQUF5Qyw2QkFBNkIsVUFBVSxZQUFZLGtFQUFrRSxXQUFXLFlBQVksaUJBQWlCLFVBQVUsTUFBTSxpRkFBaUYsVUFBVSxvQkFBb0I7QUFDN2dCLDhCQUE4QjtBQUM5QixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUywwQ0FBMEMsMEJBQTBCLG1EQUFtRCxvQ0FBb0MseUNBQXlDLFlBQVksY0FBYyx3Q0FBd0MscURBQXFEO0FBQzNULCtDQUErQywwQkFBMEIsWUFBWSx1QkFBdUIsOEJBQThCLG1DQUFtQyxlQUFlO0FBQzVMLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsa0hBQWdCO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLDRHQUFhO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLDRIQUFxQjtBQUN0RCxrQkFBa0IsbUJBQU8sQ0FBQywwSEFBb0I7QUFDOUMsWUFBWSxtQkFBTyxDQUFDLDBHQUFZO0FBQ2hDLG1CQUFtQixtQkFBTyxDQUFDLDRIQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw0R0FBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3SEFBbUI7QUFDM0MsMEJBQTBCLG1CQUFPLENBQUMsMElBQTRCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVEQUF1RCw2QkFBNkI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVEQUF1RCw2QkFBNkI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx1REFBdUQsNkJBQTZCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYSw0QkFBNEI7QUFDekMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBK0I7QUFDNUMsYUFBYSw2QkFBNkI7QUFDMUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsNkVBQTZFLHNDQUFzQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHFDQUFxQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHFDQUFxQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlDQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwrQkFBK0I7QUFDeEY7QUFDQSxtRUFBbUUscUJBQXFCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELCtCQUErQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyw0R0FBYTtBQUM1Qyw2QkFBNkIsbUJBQU8sQ0FBQywwSEFBb0I7QUFDekQsK0JBQStCLG1CQUFPLENBQUMsZ0lBQXVCO0FBQzlELDJCQUEyQixtQkFBTyxDQUFDLHNIQUFrQjtBQUNyRDtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZG9jeHRlbXBsYXRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9leGNsdWRlZCA9IFtcIm1vZHVsZXNcIl07XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZSwgdCkgeyBpZiAobnVsbCA9PSBlKSByZXR1cm4ge307IHZhciBvLCByLCBpID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgZm9yIChyID0gMDsgciA8IG4ubGVuZ3RoOyByKyspIG8gPSBuW3JdLCAtMSA9PT0gdC5pbmRleE9mKG8pICYmIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgbykgJiYgKGlbb10gPSBlW29dKTsgfSByZXR1cm4gaTsgfVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkgeyBpZiAobnVsbCA9PSByKSByZXR1cm4ge307IHZhciB0ID0ge307IGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHsgaWYgKC0xICE9PSBlLmluZGV4T2YobikpIGNvbnRpbnVlOyB0W25dID0gcltuXTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIERvY1V0aWxzID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpO1xuRG9jVXRpbHMudHJhaXRzID0gcmVxdWlyZShcIi4vdHJhaXRzLmpzXCIpO1xuRG9jVXRpbHMubW9kdWxlV3JhcHBlciA9IHJlcXVpcmUoXCIuL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIGNyZWF0ZVNjb3BlID0gcmVxdWlyZShcIi4vc2NvcGUtbWFuYWdlci5qc1wiKTtcbnZhciBMZXhlciA9IHJlcXVpcmUoXCIuL2xleGVyLmpzXCIpO1xudmFyIGNvbW1vbk1vZHVsZSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvY29tbW9uLmpzXCIpO1xuZnVuY3Rpb24gZGVwcmVjYXRlZE1lc3NhZ2Uob2JqLCBtZXNzYWdlKSB7XG4gIGlmIChvYmouaGlkZURlcHJlY2F0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkTWV0aG9kKG9iaiwgbWV0aG9kKSB7XG4gIGlmIChvYmouaGlkZURlcHJlY2F0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gZGVwcmVjYXRlZE1lc3NhZ2Uob2JqLCBcIkRlcHJlY2F0ZWQgbWV0aG9kIFxcXCIuXCIuY29uY2F0KG1ldGhvZCwgXCJcXFwiLCB2aWV3IHVwZ3JhZGUgZ3VpZGUgOiBodHRwczovL2RvY3h0ZW1wbGF0ZXIuY29tL2RvY3MvYXBpLyN1cGdyYWRlLWd1aWRlLCBzdGFjayA6IFwiKS5jb25jYXQobmV3IEVycm9yKCkuc3RhY2spKTtcbn1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgdGhyb3dNdWx0aUVycm9yID0gX3JlcXVpcmUudGhyb3dNdWx0aUVycm9yLFxuICB0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlID0gX3JlcXVpcmUudGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZSxcbiAgdGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGUgPSBfcmVxdWlyZS50aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSxcbiAgdGhyb3dSZW5kZXJUd2ljZSA9IF9yZXF1aXJlLnRocm93UmVuZGVyVHdpY2UsXG4gIFhUSW50ZXJuYWxFcnJvciA9IF9yZXF1aXJlLlhUSW50ZXJuYWxFcnJvcixcbiAgWFRUZW1wbGF0ZUVycm9yID0gX3JlcXVpcmUuWFRUZW1wbGF0ZUVycm9yLFxuICB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCA9IF9yZXF1aXJlLnRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkLFxuICB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZCA9IF9yZXF1aXJlLnRocm93RmlsZVR5cGVOb3RIYW5kbGVkLFxuICB0aHJvd0FwaVZlcnNpb25FcnJvciA9IF9yZXF1aXJlLnRocm93QXBpVmVyc2lvbkVycm9yO1xudmFyIGxvZ0Vycm9ycyA9IHJlcXVpcmUoXCIuL2Vycm9yLWxvZ2dlci5qc1wiKTtcbnZhciBjb2xsZWN0Q29udGVudFR5cGVzID0gcmVxdWlyZShcIi4vY29sbGVjdC1jb250ZW50LXR5cGVzLmpzXCIpO1xudmFyIGdldERlZmF1bHRzID0gRG9jVXRpbHMuZ2V0RGVmYXVsdHMsXG4gIHN0cjJ4bWwgPSBEb2NVdGlscy5zdHIyeG1sLFxuICB4bWwyc3RyID0gRG9jVXRpbHMueG1sMnN0cixcbiAgbW9kdWxlV3JhcHBlciA9IERvY1V0aWxzLm1vZHVsZVdyYXBwZXIsXG4gIGNvbmNhdEFycmF5cyA9IERvY1V0aWxzLmNvbmNhdEFycmF5cyxcbiAgdW5pcSA9IERvY1V0aWxzLnVuaXEsXG4gIGdldER1cGxpY2F0ZXMgPSBEb2NVdGlscy5nZXREdXBsaWNhdGVzLFxuICBzdGFibGVTb3J0ID0gRG9jVXRpbHMuc3RhYmxlU29ydCxcbiAgcHVzaEFycmF5ID0gRG9jVXRpbHMucHVzaEFycmF5O1xudmFyIGN0WE1MID0gXCJbQ29udGVudF9UeXBlc10ueG1sXCI7XG52YXIgcmVsc0ZpbGUgPSBcIl9yZWxzLy5yZWxzXCI7XG52YXIgY3VycmVudE1vZHVsZUFwaVZlcnNpb24gPSBbMywgNDQsIDBdO1xuZnVuY3Rpb24gZHJvcFVuc3VwcG9ydGVkRmlsZVR5cGVzTW9kdWxlcyhkb2MpIHtcbiAgZG9jLm1vZHVsZXMgPSBkb2MubW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIGlmICghbW9kdWxlLnN1cHBvcnRlZEZpbGVUeXBlcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGUuc3VwcG9ydGVkRmlsZVR5cGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN1cHBvcnRlZEZpbGVUeXBlcyBmaWVsZCBvZiB0aGUgbW9kdWxlIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gICAgfVxuICAgIHZhciBpc1N1cHBvcnRlZE1vZHVsZSA9IG1vZHVsZS5zdXBwb3J0ZWRGaWxlVHlwZXMuaW5jbHVkZXMoZG9jLmZpbGVUeXBlKTtcbiAgICBpZiAoIWlzU3VwcG9ydGVkTW9kdWxlKSB7XG4gICAgICBtb2R1bGUub24oXCJkZXRhY2hlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkTW9kdWxlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUVycm9ycyhkb2MpIHtcbiAgdmFyIGNvbXBpbGVkID0gZG9jLmNvbXBpbGVkO1xuICBkb2MuZXJyb3JzID0gY29uY2F0QXJyYXlzKE9iamVjdC5rZXlzKGNvbXBpbGVkKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gY29tcGlsZWRbbmFtZV0uYWxsRXJyb3JzO1xuICB9KSk7XG4gIGlmIChkb2MuZXJyb3JzLmxlbmd0aCAhPT0gMCkge1xuICAgIGlmIChkb2Mub3B0aW9ucy5lcnJvckxvZ2dpbmcpIHtcbiAgICAgIGxvZ0Vycm9ycyhkb2MuZXJyb3JzLCBkb2Mub3B0aW9ucy5lcnJvckxvZ2dpbmcpO1xuICAgIH1cbiAgICB0aHJvd011bHRpRXJyb3IoZG9jLmVycm9ycyk7XG4gIH1cbn1cbnZhciBEb2N4dGVtcGxhdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRG9jeHRlbXBsYXRlcih6aXApIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICBfcmVmJG1vZHVsZXMgPSBfcmVmLm1vZHVsZXMsXG4gICAgICBtb2R1bGVzID0gX3JlZiRtb2R1bGVzID09PSB2b2lkIDAgPyBbXSA6IF9yZWYkbW9kdWxlcyxcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9jeHRlbXBsYXRlcik7XG4gICAgdGhpcy50YXJnZXRzID0gW107XG4gICAgdGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2NvcGVNYW5hZ2VycyA9IHt9O1xuICAgIHRoaXMuY29tcGlsZWQgPSB7fTtcbiAgICB0aGlzLm1vZHVsZXMgPSBbY29tbW9uTW9kdWxlKCldO1xuICAgIHRoaXMueG1sRG9jdW1lbnRzID0ge307XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlcHJlY2F0ZWRNZXNzYWdlKHRoaXMsIFwiRGVwcmVjYXRlZCBkb2N4dGVtcGxhdGVyIGNvbnN0cnVjdG9yIHdpdGggbm8gYXJndW1lbnRzLCB2aWV3IHVwZ3JhZGUgZ3VpZGUgOiBodHRwczovL2RvY3h0ZW1wbGF0ZXIuY29tL2RvY3MvYXBpLyN1cGdyYWRlLWd1aWRlLCBzdGFjayA6IFwiLmNvbmNhdChuZXcgRXJyb3IoKS5zdGFjaykpO1xuICAgICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIGlmICghemlwIHx8ICF6aXAuZmlsZXMgfHwgdHlwZW9mIHppcC5maWxlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG9mIGRvY3h0ZW1wbGF0ZXIncyBjb25zdHJ1Y3RvciBtdXN0IGJlIGEgdmFsaWQgemlwIGZpbGUgKGpzemlwIHYyIG9yIHBpenppcCB2MylcIik7XG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kdWxlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG1vZHVsZXMgYXJndW1lbnQgb2YgZG9jeHRlbXBsYXRlcidzIGNvbnN0cnVjdG9yIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBtb2R1bGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGUgPSBtb2R1bGVzW19pMl07XG4gICAgICAgIHRoaXMuYXR0YWNoTW9kdWxlKF9tb2R1bGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2FkWmlwKHppcCk7XG4gICAgICB0aGlzLmNvbXBpbGUoKTtcbiAgICAgIHRoaXMudjRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaGlkZURlcHJlY2F0aW9ucyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRG9jeHRlbXBsYXRlciwgW3tcbiAgICBrZXk6IFwidmVyaWZ5QXBpVmVyc2lvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnlBcGlWZXJzaW9uKG5lZWRlZFZlcnNpb24pIHtcbiAgICAgIG5lZWRlZFZlcnNpb24gPSBuZWVkZWRWZXJzaW9uLnNwbGl0KFwiLlwiKS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGksIDEwKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG5lZWRlZFZlcnNpb24ubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93QXBpVmVyc2lvbkVycm9yKFwibmVlZGVkVmVyc2lvbiBpcyBub3QgYSB2YWxpZCB2ZXJzaW9uXCIsIHtcbiAgICAgICAgICBuZWVkZWRWZXJzaW9uOiBuZWVkZWRWZXJzaW9uLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBcInRoZSBuZWVkZWRWZXJzaW9uIG11c3QgYmUgYW4gYXJyYXkgb2YgbGVuZ3RoIDNcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkZWRWZXJzaW9uWzBdICE9PSBjdXJyZW50TW9kdWxlQXBpVmVyc2lvblswXSkge1xuICAgICAgICB0aHJvd0FwaVZlcnNpb25FcnJvcihcIlRoZSBtYWpvciBhcGkgdmVyc2lvbiBkbyBub3QgbWF0Y2gsIHlvdSBwcm9iYWJseSBoYXZlIHRvIHVwZGF0ZSBkb2N4dGVtcGxhdGVyIHdpdGggbnBtIGluc3RhbGwgLS1zYXZlIGRvY3h0ZW1wbGF0ZXJcIiwge1xuICAgICAgICAgIG5lZWRlZFZlcnNpb246IG5lZWRlZFZlcnNpb24sXG4gICAgICAgICAgY3VycmVudE1vZHVsZUFwaVZlcnNpb246IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBcIm1vZHVsZUFQSVZlcnNpb25NaXNtYXRjaCA6IG5lZWRlZD1cIi5jb25jYXQobmVlZGVkVmVyc2lvbi5qb2luKFwiLlwiKSwgXCIsIGN1cnJlbnQ9XCIpLmNvbmNhdChjdXJyZW50TW9kdWxlQXBpVmVyc2lvbi5qb2luKFwiLlwiKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobmVlZGVkVmVyc2lvblsxXSA+IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uWzFdKSB7XG4gICAgICAgIHRocm93QXBpVmVyc2lvbkVycm9yKFwiVGhlIG1pbm9yIGFwaSB2ZXJzaW9uIGlzIG5vdCB1cHRvZGF0ZSwgeW91IHByb2JhYmx5IGhhdmUgdG8gdXBkYXRlIGRvY3h0ZW1wbGF0ZXIgd2l0aCBucG0gaW5zdGFsbCAtLXNhdmUgZG9jeHRlbXBsYXRlclwiLCB7XG4gICAgICAgICAgbmVlZGVkVmVyc2lvbjogbmVlZGVkVmVyc2lvbixcbiAgICAgICAgICBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbjogY3VycmVudE1vZHVsZUFwaVZlcnNpb24sXG4gICAgICAgICAgZXhwbGFuYXRpb246IFwibW9kdWxlQVBJVmVyc2lvbk1pc21hdGNoIDogbmVlZGVkPVwiLmNvbmNhdChuZWVkZWRWZXJzaW9uLmpvaW4oXCIuXCIpLCBcIiwgY3VycmVudD1cIikuY29uY2F0KGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLmpvaW4oXCIuXCIpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkZWRWZXJzaW9uWzFdID09PSBjdXJyZW50TW9kdWxlQXBpVmVyc2lvblsxXSAmJiBuZWVkZWRWZXJzaW9uWzJdID4gY3VycmVudE1vZHVsZUFwaVZlcnNpb25bMl0pIHtcbiAgICAgICAgdGhyb3dBcGlWZXJzaW9uRXJyb3IoXCJUaGUgcGF0Y2ggYXBpIHZlcnNpb24gaXMgbm90IHVwdG9kYXRlLCB5b3UgcHJvYmFibHkgaGF2ZSB0byB1cGRhdGUgZG9jeHRlbXBsYXRlciB3aXRoIG5wbSBpbnN0YWxsIC0tc2F2ZSBkb2N4dGVtcGxhdGVyXCIsIHtcbiAgICAgICAgICBuZWVkZWRWZXJzaW9uOiBuZWVkZWRWZXJzaW9uLFxuICAgICAgICAgIGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uOiBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbixcbiAgICAgICAgICBleHBsYW5hdGlvbjogXCJtb2R1bGVBUElWZXJzaW9uTWlzbWF0Y2ggOiBuZWVkZWQ9XCIuY29uY2F0KG5lZWRlZFZlcnNpb24uam9pbihcIi5cIiksIFwiLCBjdXJyZW50PVwiKS5jb25jYXQoY3VycmVudE1vZHVsZUFwaVZlcnNpb24uam9pbihcIi5cIikpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1vZHVsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TW9kdWxlcyhvYmopIHtcbiAgICAgIGZvciAodmFyIF9pNCA9IDAsIF90aGlzJG1vZHVsZXMyID0gdGhpcy5tb2R1bGVzOyBfaTQgPCBfdGhpcyRtb2R1bGVzMi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlMiA9IF90aGlzJG1vZHVsZXMyW19pNF07XG4gICAgICAgIF9tb2R1bGUyLnNldChvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZEV2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgZm9yICh2YXIgX2k2ID0gMCwgX3RoaXMkbW9kdWxlczQgPSB0aGlzLm1vZHVsZXM7IF9pNiA8IF90aGlzJG1vZHVsZXM0Lmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGUzID0gX3RoaXMkbW9kdWxlczRbX2k2XTtcbiAgICAgICAgX21vZHVsZTMub24oZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXR0YWNoTW9kdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGF0dGFjaE1vZHVsZShtb2R1bGUpIHtcbiAgICAgIGlmICh0aGlzLnY0Q29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFhUSW50ZXJuYWxFcnJvcihcImF0dGFjaE1vZHVsZSgpIHNob3VsZCBub3QgYmUgY2FsbGVkIG1hbnVhbGx5IHdoZW4gdXNpbmcgdGhlIHY0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgfVxuICAgICAgZGVwcmVjYXRlZE1ldGhvZCh0aGlzLCBcImF0dGFjaE1vZHVsZVwiKTtcbiAgICAgIHZhciBtb2R1bGVUeXBlID0gX3R5cGVvZihtb2R1bGUpO1xuICAgICAgaWYgKG1vZHVsZVR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgWFRJbnRlcm5hbEVycm9yKFwiQ2Fubm90IGF0dGFjaCBhIGNsYXNzL2Z1bmN0aW9uIGFzIGEgbW9kdWxlLiBNb3N0IHByb2JhYmx5IHlvdSBmb3Jnb3QgdG8gaW5zdGFudGlhdGUgdGhlIG1vZHVsZSBieSB1c2luZyBgbmV3YCBvbiB0aGUgbW9kdWxlLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghbW9kdWxlIHx8IG1vZHVsZVR5cGUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFhUSW50ZXJuYWxFcnJvcihcIkNhbm5vdCBhdHRhY2hNb2R1bGUgd2l0aCBhIGZhbHN5IHZhbHVlXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG1vZHVsZS5yZXF1aXJlZEFQSVZlcnNpb24pIHtcbiAgICAgICAgdGhpcy52ZXJpZnlBcGlWZXJzaW9uKG1vZHVsZS5yZXF1aXJlZEFQSVZlcnNpb24pO1xuICAgICAgfVxuICAgICAgaWYgKG1vZHVsZS5hdHRhY2hlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZS5jbG9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgbW9kdWxlID0gbW9kdWxlLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGF0dGFjaCBhIG1vZHVsZSB0aGF0IHdhcyBhbHJlYWR5IGF0dGFjaGVkIDogXFxcIlwiLmNvbmNhdChtb2R1bGUubmFtZSwgXCJcXFwiLiBUaGUgbW9zdCBsaWtlbHkgY2F1c2UgaXMgdGhhdCB5b3UgYXJlIGluc3RhbnRpYXRpbmcgdGhlIG1vZHVsZSBhdCB0aGUgcm9vdCBsZXZlbCwgYW5kIHVzaW5nIGl0IGZvciBtdWx0aXBsZSBpbnN0YW5jZXMgb2YgRG9jeHRlbXBsYXRlclwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vZHVsZS5hdHRhY2hlZCA9IHRydWU7XG4gICAgICB2YXIgd3JhcHBlZE1vZHVsZSA9IG1vZHVsZVdyYXBwZXIobW9kdWxlKTtcbiAgICAgIHRoaXMubW9kdWxlcy5wdXNoKHdyYXBwZWRNb2R1bGUpO1xuICAgICAgd3JhcHBlZE1vZHVsZS5vbihcImF0dGFjaGVkXCIpO1xuICAgICAgaWYgKHRoaXMuZmlsZVR5cGUpIHtcbiAgICAgICAgZHJvcFVuc3VwcG9ydGVkRmlsZVR5cGVzTW9kdWxlcyh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzJGRlbGltaXRlcnMsIF90aGlzJGRlbGltaXRlcnMyO1xuICAgICAgaWYgKHRoaXMudjRDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRPcHRpb25zKCkgc2hvdWxkIG5vdCBiZSBjYWxsZWQgbWFudWFsbHkgd2hlbiB1c2luZyB0aGUgdjQgY29uc3RydWN0b3JcIik7XG4gICAgICB9XG4gICAgICBkZXByZWNhdGVkTWV0aG9kKHRoaXMsIFwic2V0T3B0aW9uc1wiKTtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRPcHRpb25zIHNob3VsZCBiZSBjYWxsZWQgd2l0aCBhbiBvYmplY3QgYXMgZmlyc3QgcGFyYW1ldGVyXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB2YXIgZGVmYXVsdHMgPSBnZXREZWZhdWx0cygpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBkZWZhdWx0c1trZXldO1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XSAhPSBudWxsID8gb3B0aW9uc1trZXldIDogdGhpc1trZXldIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpc1trZXldID0gdGhpcy5vcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgICAoX3RoaXMkZGVsaW1pdGVycyA9IHRoaXMuZGVsaW1pdGVycykuc3RhcnQgJiYgKF90aGlzJGRlbGltaXRlcnMuc3RhcnQgPSBEb2NVdGlscy51dGY4VG9Xb3JkKHRoaXMuZGVsaW1pdGVycy5zdGFydCkpO1xuICAgICAgKF90aGlzJGRlbGltaXRlcnMyID0gdGhpcy5kZWxpbWl0ZXJzKS5lbmQgJiYgKF90aGlzJGRlbGltaXRlcnMyLmVuZCA9IERvY1V0aWxzLnV0ZjhUb1dvcmQodGhpcy5kZWxpbWl0ZXJzLmVuZCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRaaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFppcCh6aXApIHtcbiAgICAgIGlmICh0aGlzLnY0Q29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFppcCgpIHNob3VsZCBub3QgYmUgY2FsbGVkIG1hbnVhbGx5IHdoZW4gdXNpbmcgdGhlIHY0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgfVxuICAgICAgZGVwcmVjYXRlZE1ldGhvZCh0aGlzLCBcImxvYWRaaXBcIik7XG4gICAgICBpZiAoemlwLmxvYWRBc3luYykge1xuICAgICAgICB0aHJvdyBuZXcgWFRJbnRlcm5hbEVycm9yKFwiRG9jeHRlbXBsYXRlciBkb2Vzbid0IGhhbmRsZSBKU1ppcCB2ZXJzaW9uID49MywgcGxlYXNlIHVzZSBwaXp6aXBcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnppcCA9IHppcDtcbiAgICAgIHRoaXMudXBkYXRlRmlsZVR5cGVDb25maWcoKTtcbiAgICAgIHRoaXMubW9kdWxlcyA9IGNvbmNhdEFycmF5cyhbdGhpcy5maWxlVHlwZUNvbmZpZy5iYXNlTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG1vZHVsZUZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGVGdW5jdGlvbigpO1xuICAgICAgfSksIHRoaXMubW9kdWxlc10pO1xuICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX3RoaXMkbW9kdWxlczYgPSB0aGlzLm1vZHVsZXM7IF9pOCA8IF90aGlzJG1vZHVsZXM2Lmxlbmd0aDsgX2k4KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU0ID0gX3RoaXMkbW9kdWxlczZbX2k4XTtcbiAgICAgICAgX21vZHVsZTQuemlwID0gdGhpcy56aXA7XG4gICAgICAgIF9tb2R1bGU0LmRvY3h0ZW1wbGF0ZXIgPSB0aGlzO1xuICAgICAgfVxuICAgICAgZHJvcFVuc3VwcG9ydGVkRmlsZVR5cGVzTW9kdWxlcyh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVjb21waWxlRmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVjb21waWxlRmlsZShmaWxlTmFtZSkge1xuICAgICAgdmFyIGN1cnJlbnRGaWxlID0gdGhpcy5jcmVhdGVUZW1wbGF0ZUNsYXNzKGZpbGVOYW1lKTtcbiAgICAgIGN1cnJlbnRGaWxlLnByZXBhcnNlKCk7XG4gICAgICB0aGlzLmNvbXBpbGVkW2ZpbGVOYW1lXSA9IGN1cnJlbnRGaWxlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21waWxlRmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21waWxlRmlsZShmaWxlTmFtZSkge1xuICAgICAgdGhpcy5jb21waWxlZFtmaWxlTmFtZV0ucGFyc2UoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2NvcGVNYW5hZ2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjb3BlTWFuYWdlcih0bywgY3VycmVudEZpbGUsIHRhZ3MpIHtcbiAgICAgIHZhciBfdGhpcyRzY29wZU1hbmFnZXJzO1xuICAgICAgKF90aGlzJHNjb3BlTWFuYWdlcnMgPSB0aGlzLnNjb3BlTWFuYWdlcnMpW3RvXSB8fCAoX3RoaXMkc2NvcGVNYW5hZ2Vyc1t0b10gPSBjcmVhdGVTY29wZSh7XG4gICAgICAgIHRhZ3M6IHRhZ3MsXG4gICAgICAgIHBhcnNlcjogdGhpcy5wYXJzZXIsXG4gICAgICAgIGNhY2hlZFBhcnNlcnM6IGN1cnJlbnRGaWxlLmNhY2hlZFBhcnNlcnNcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB0aGlzLnNjb3BlTWFuYWdlcnNbdG9dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNvbHZlRGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlRGF0YShkYXRhKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgZGVwcmVjYXRlZE1ldGhvZCh0aGlzLCBcInJlc29sdmVEYXRhXCIpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLmNvbXBpbGVkKS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICBfdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgICBkYXRhOiBfdGhpcy5kYXRhLFxuICAgICAgICAgIExleGVyOiBMZXhlclxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMubWFwcGVyID0gX3RoaXMubW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlLCBtb2R1bGUpIHtcbiAgICAgICAgICByZXR1cm4gbW9kdWxlLmdldFJlbmRlcmVkTWFwKHZhbHVlKTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0LmtleXMoX3RoaXMubWFwcGVyKS5tYXAoZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgICAgdmFyIF90aGlzJG1hcHBlciR0byA9IF90aGlzLm1hcHBlclt0b10sXG4gICAgICAgICAgICBmcm9tID0gX3RoaXMkbWFwcGVyJHRvLmZyb20sXG4gICAgICAgICAgICBkYXRhID0gX3RoaXMkbWFwcGVyJHRvLmRhdGE7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkYXRhKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEZpbGUgPSBfdGhpcy5jb21waWxlZFtmcm9tXTtcbiAgICAgICAgICAgIGN1cnJlbnRGaWxlLmZpbGVQYXRoID0gdG87XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5zY29wZU1hbmFnZXIgPSBfdGhpcy5nZXRTY29wZU1hbmFnZXIodG8sIGN1cnJlbnRGaWxlLCBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RmlsZS5yZXNvbHZlVGFncyhkYXRhKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgY3VycmVudEZpbGUuc2NvcGVNYW5hZ2VyLmZpbmlzaGVkUmVzb2x2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJzKSB7XG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVycm9ycywgZXJycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpLnRoZW4oZnVuY3Rpb24gKHJlc29sdmVkKSB7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmVycm9yTG9nZ2luZykge1xuICAgICAgICAgICAgICBsb2dFcnJvcnMoZXJyb3JzLCBfdGhpcy5vcHRpb25zLmVycm9yTG9nZ2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvd011bHRpRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbmNhdEFycmF5cyhyZXNvbHZlZCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlb3JkZXJNb2R1bGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlb3JkZXJNb2R1bGVzKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBNb2R1bGVzIHdpbGwgYmUgc29ydGVkIGFjY29yZGluZyB0byBwcmlvcml0eS5cbiAgICAgICAqXG4gICAgICAgKiBJbnB1dCBleGFtcGxlOlxuICAgICAgICogW1xuICAgICAgICogICB7IHByaW9yaXR5OiAxLCBuYW1lOiBcIkZvb01vZFwiIH0sXG4gICAgICAgKiAgIHsgcHJpb3JpdHk6IC0xLCBuYW1lOiBcIlhNb2RcIiB9LFxuICAgICAgICogICB7IHByaW9yaXR5OiA0LCBuYW1lOiBcIk90aGVyTW9kXCIgfVxuICAgICAgICogXVxuICAgICAgICpcbiAgICAgICAqIE91dHB1dCBleGFtcGxlIChzb3J0ZWQgYnkgcHJpb3JpdHkgaW4gZGVzY2VuZGluZyBvcmRlcik6XG4gICAgICAgKiBbXG4gICAgICAgKiAgIHsgcHJpb3JpdHk6IDQsIG5hbWU6IFwiT3RoZXJNb2RcIiB9LFxuICAgICAgICogICB7IHByaW9yaXR5OiAxLCBuYW1lOiBcIkZvb01vZFwiIH0sXG4gICAgICAgKiAgIHsgcHJpb3JpdHk6IC0xLCBuYW1lOiBcIlhNb2RcIiB9XG4gICAgICAgKiBdXG4gICAgICAgKi9cbiAgICAgIHRoaXMubW9kdWxlcyA9IHN0YWJsZVNvcnQodGhpcy5tb2R1bGVzLCBmdW5jdGlvbiAobTEsIG0yKSB7XG4gICAgICAgIHJldHVybiAobTIucHJpb3JpdHkgfHwgMCkgLSAobTEucHJpb3JpdHkgfHwgMCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGhyb3dJZkR1cGxpY2F0ZU1vZHVsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGhyb3dJZkR1cGxpY2F0ZU1vZHVsZXMoKSB7XG4gICAgICB2YXIgZHVwbGljYXRlcyA9IGdldER1cGxpY2F0ZXModGhpcy5tb2R1bGVzLm1hcChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lO1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH0pKTtcbiAgICAgIGlmIChkdXBsaWNhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFhUSW50ZXJuYWxFcnJvcihcIkRldGVjdGVkIGR1cGxpY2F0ZSBtb2R1bGUgXFxcIlwiLmNvbmNhdChkdXBsaWNhdGVzWzBdLCBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21waWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGRlcHJlY2F0ZWRNZXRob2QodGhpcywgXCJjb21waWxlXCIpO1xuICAgICAgdGhpcy51cGRhdGVGaWxlVHlwZUNvbmZpZygpO1xuICAgICAgdGhpcy50aHJvd0lmRHVwbGljYXRlTW9kdWxlcygpO1xuICAgICAgdGhpcy5yZW9yZGVyTW9kdWxlcygpO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuY29tcGlsZWQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMubW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKG9wdGlvbnMsIG1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLm9wdGlvbnNUcmFuc2Zvcm1lcihvcHRpb25zLCBfdGhpczIpO1xuICAgICAgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMub3B0aW9ucy54bWxGaWxlTmFtZXMgPSB1bmlxKHRoaXMub3B0aW9ucy54bWxGaWxlTmFtZXMpO1xuICAgICAgZm9yICh2YXIgX2kxMCA9IDAsIF90aGlzJG9wdGlvbnMkeG1sRmlsZTIgPSB0aGlzLm9wdGlvbnMueG1sRmlsZU5hbWVzOyBfaTEwIDwgX3RoaXMkb3B0aW9ucyR4bWxGaWxlMi5sZW5ndGg7IF9pMTArKykge1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBfdGhpcyRvcHRpb25zJHhtbEZpbGUyW19pMTBdO1xuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuemlwLmZpbGVzW2ZpbGVOYW1lXS5hc1RleHQoKTtcbiAgICAgICAgdGhpcy54bWxEb2N1bWVudHNbZmlsZU5hbWVdID0gc3RyMnhtbChjb250ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIHppcDogdGhpcy56aXAsXG4gICAgICAgIHhtbERvY3VtZW50czogdGhpcy54bWxEb2N1bWVudHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5nZXRUZW1wbGF0ZWRGaWxlcygpO1xuICAgICAgLypcbiAgICAgICAqIExvb3AgaW5zaWRlIGFsbCB0ZW1wbGF0ZWRGaWxlcyAoaWUgeG1sIGZpbGVzIHdpdGggY29udGVudCkuXG4gICAgICAgKiBTb21ldGltZXMgdGhleSBkb24ndCBleGlzdCAoZm9vdGVyLnhtbCBmb3IgZXhhbXBsZSlcbiAgICAgICAqL1xuICAgICAgZm9yICh2YXIgX2kxMiA9IDAsIF90aGlzJHRlbXBsYXRlZEZpbGVzMiA9IHRoaXMudGVtcGxhdGVkRmlsZXM7IF9pMTIgPCBfdGhpcyR0ZW1wbGF0ZWRGaWxlczIubGVuZ3RoOyBfaTEyKyspIHtcbiAgICAgICAgdmFyIF9maWxlTmFtZSA9IF90aGlzJHRlbXBsYXRlZEZpbGVzMltfaTEyXTtcbiAgICAgICAgaWYgKHRoaXMuemlwLmZpbGVzW19maWxlTmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMucHJlY29tcGlsZUZpbGUoX2ZpbGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kxNCA9IDAsIF90aGlzJHRlbXBsYXRlZEZpbGVzNCA9IHRoaXMudGVtcGxhdGVkRmlsZXM7IF9pMTQgPCBfdGhpcyR0ZW1wbGF0ZWRGaWxlczQubGVuZ3RoOyBfaTE0KyspIHtcbiAgICAgICAgdmFyIF9maWxlTmFtZTIgPSBfdGhpcyR0ZW1wbGF0ZWRGaWxlczRbX2kxNF07XG4gICAgICAgIGlmICh0aGlzLnppcC5maWxlc1tfZmlsZU5hbWUyXSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jb21waWxlRmlsZShfZmlsZU5hbWUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgY29tcGlsZWQ6IHRoaXMuY29tcGlsZWRcbiAgICAgIH0pO1xuICAgICAgdmVyaWZ5RXJyb3JzKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJlbHNUeXBlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWxzVHlwZXMoKSB7XG4gICAgICB2YXIgcm9vdFJlbHMgPSB0aGlzLnppcC5maWxlc1tyZWxzRmlsZV07XG4gICAgICB2YXIgcm9vdFJlbHNYbWwgPSByb290UmVscyA/IHN0cjJ4bWwocm9vdFJlbHMuYXNUZXh0KCkpIDogbnVsbDtcbiAgICAgIHZhciByb290UmVsYXRpb25zaGlwcyA9IHJvb3RSZWxzWG1sID8gcm9vdFJlbHNYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJSZWxhdGlvbnNoaXBcIikgOiBbXTtcbiAgICAgIHZhciByZWxzVHlwZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIF9pMTYgPSAwOyBfaTE2IDwgcm9vdFJlbGF0aW9uc2hpcHMubGVuZ3RoOyBfaTE2KyspIHtcbiAgICAgICAgdmFyIHJlbGF0aW9uID0gcm9vdFJlbGF0aW9uc2hpcHNbX2kxNl07XG4gICAgICAgIHJlbHNUeXBlc1tyZWxhdGlvbi5nZXRBdHRyaWJ1dGUoXCJUYXJnZXRcIildID0gcmVsYXRpb24uZ2V0QXR0cmlidXRlKFwiVHlwZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWxzVHlwZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbnRlbnRUeXBlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250ZW50VHlwZXMoKSB7XG4gICAgICB2YXIgY29udGVudFR5cGVzID0gdGhpcy56aXAuZmlsZXNbY3RYTUxdO1xuICAgICAgdmFyIGNvbnRlbnRUeXBlWG1sID0gY29udGVudFR5cGVzID8gc3RyMnhtbChjb250ZW50VHlwZXMuYXNUZXh0KCkpIDogbnVsbDtcbiAgICAgIHZhciBvdmVycmlkZXMgPSBjb250ZW50VHlwZVhtbCA/IGNvbnRlbnRUeXBlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiT3ZlcnJpZGVcIikgOiBudWxsO1xuICAgICAgdmFyIGRlZmF1bHRzID0gY29udGVudFR5cGVYbWwgPyBjb250ZW50VHlwZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkRlZmF1bHRcIikgOiBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3ZlcnJpZGVzOiBvdmVycmlkZXMsXG4gICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgY29udGVudFR5cGVzOiBjb250ZW50VHlwZXMsXG4gICAgICAgIGNvbnRlbnRUeXBlWG1sOiBjb250ZW50VHlwZVhtbFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRmlsZVR5cGVDb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRmlsZVR5cGVDb25maWcoKSB7XG4gICAgICB2YXIgZmlsZVR5cGU7XG4gICAgICBpZiAodGhpcy56aXAuZmlsZXMubWltZXR5cGUpIHtcbiAgICAgICAgZmlsZVR5cGUgPSBcIm9kdFwiO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWxzVHlwZXMgPSB0aGlzLmdldFJlbHNUeXBlcygpO1xuICAgICAgdmFyIF90aGlzJGdldENvbnRlbnRUeXBlcyA9IHRoaXMuZ2V0Q29udGVudFR5cGVzKCksXG4gICAgICAgIG92ZXJyaWRlcyA9IF90aGlzJGdldENvbnRlbnRUeXBlcy5vdmVycmlkZXMsXG4gICAgICAgIGRlZmF1bHRzID0gX3RoaXMkZ2V0Q29udGVudFR5cGVzLmRlZmF1bHRzLFxuICAgICAgICBjb250ZW50VHlwZXMgPSBfdGhpcyRnZXRDb250ZW50VHlwZXMuY29udGVudFR5cGVzLFxuICAgICAgICBjb250ZW50VHlwZVhtbCA9IF90aGlzJGdldENvbnRlbnRUeXBlcy5jb250ZW50VHlwZVhtbDtcbiAgICAgIGlmIChjb250ZW50VHlwZVhtbCkge1xuICAgICAgICB0aGlzLmZpbGVzQ29udGVudFR5cGVzID0gY29sbGVjdENvbnRlbnRUeXBlcyhvdmVycmlkZXMsIGRlZmF1bHRzLCB0aGlzLnppcCk7XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWRDb250ZW50VHlwZXMgPSBEb2NVdGlscy5pbnZlcnRNYXAodGhpcy5maWxlc0NvbnRlbnRUeXBlcyk7XG4gICAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgICAgY29udGVudFR5cGVzOiB0aGlzLmNvbnRlbnRUeXBlcyxcbiAgICAgICAgICBpbnZlcnRlZENvbnRlbnRUeXBlczogdGhpcy5pbnZlcnRlZENvbnRlbnRUeXBlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMTggPSAwLCBfdGhpcyRtb2R1bGVzOCA9IHRoaXMubW9kdWxlczsgX2kxOCA8IF90aGlzJG1vZHVsZXM4Lmxlbmd0aDsgX2kxOCsrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlNSA9IF90aGlzJG1vZHVsZXM4W19pMThdO1xuICAgICAgICBmaWxlVHlwZSA9IF9tb2R1bGU1LmdldEZpbGVUeXBlKHtcbiAgICAgICAgICB6aXA6IHRoaXMuemlwLFxuICAgICAgICAgIGNvbnRlbnRUeXBlczogY29udGVudFR5cGVzLFxuICAgICAgICAgIGNvbnRlbnRUeXBlWG1sOiBjb250ZW50VHlwZVhtbCxcbiAgICAgICAgICBvdmVycmlkZXM6IG92ZXJyaWRlcyxcbiAgICAgICAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgICAgICAgZG9jOiB0aGlzXG4gICAgICAgIH0pIHx8IGZpbGVUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGVUeXBlID09PSBcIm9kdFwiKSB7XG4gICAgICAgIHRocm93RmlsZVR5cGVOb3RIYW5kbGVkKGZpbGVUeXBlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZmlsZVR5cGUpIHtcbiAgICAgICAgdGhyb3dGaWxlVHlwZU5vdElkZW50aWZpZWQodGhpcy56aXApO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kyMCA9IDAsIF90aGlzJG1vZHVsZXMxMCA9IHRoaXMubW9kdWxlczsgX2kyMCA8IF90aGlzJG1vZHVsZXMxMC5sZW5ndGg7IF9pMjArKykge1xuICAgICAgICB2YXIgX21vZHVsZTYgPSBfdGhpcyRtb2R1bGVzMTBbX2kyMF07XG4gICAgICAgIGZvciAodmFyIF9pMjIgPSAwLCBfcmVmNCA9IF9tb2R1bGU2LnhtbENvbnRlbnRUeXBlcyB8fCBbXTsgX2kyMiA8IF9yZWY0Lmxlbmd0aDsgX2kyMisrKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gX3JlZjRbX2kyMl07XG4gICAgICAgICAgcHVzaEFycmF5KHRoaXMub3B0aW9ucy54bWxGaWxlTmFtZXMsIHRoaXMuaW52ZXJ0ZWRDb250ZW50VHlwZXNbY29udGVudFR5cGVdIHx8IFtdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5maWxlVHlwZSA9IGZpbGVUeXBlO1xuICAgICAgZHJvcFVuc3VwcG9ydGVkRmlsZVR5cGVzTW9kdWxlcyh0aGlzKTtcbiAgICAgIHRoaXMuZmlsZVR5cGVDb25maWcgPSB0aGlzLm9wdGlvbnMuZmlsZVR5cGVDb25maWcgfHwgdGhpcy5maWxlVHlwZUNvbmZpZztcbiAgICAgIGlmICghdGhpcy5maWxlVHlwZUNvbmZpZykge1xuICAgICAgICBpZiAoRG9jeHRlbXBsYXRlci5GaWxlVHlwZUNvbmZpZ1t0aGlzLmZpbGVUeXBlXSkge1xuICAgICAgICAgIHRoaXMuZmlsZVR5cGVDb25maWcgPSBEb2N4dGVtcGxhdGVyLkZpbGVUeXBlQ29uZmlnW3RoaXMuZmlsZVR5cGVdKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBFcnJvciBjYXNlIGhhbmRsZWQgc2luY2UgdjMuNjAuMlxuICAgICAgICAgICAqIFRocm93IHNwZWNpZmljIGVycm9yIHdoZW4gdHJ5aW5nIHRvIHRlbXBsYXRlIHhsc3ggZmlsZSB3aXRob3V0IHhsc3htb2R1bGVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiRmlsZXR5cGUgXFxcIlwiLmNvbmNhdCh0aGlzLmZpbGVUeXBlLCBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICB2YXIgaWQgPSBcImZpbGV0eXBlX25vdF9zdXBwb3J0ZWRcIjtcbiAgICAgICAgICBpZiAodGhpcy5maWxlVHlwZSA9PT0gXCJ4bHN4XCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkZpbGV0eXBlIFxcXCJcIi5jb25jYXQodGhpcy5maWxlVHlwZSwgXCJcXFwiIGlzIHN1cHBvcnRlZCBvbmx5IHdpdGggdGhlIHBhaWQgWGxzeE1vZHVsZVwiKTtcbiAgICAgICAgICAgIGlkID0gXCJ4bHN4X2ZpbGV0eXBlX25lZWRzX3hsc3hfbW9kdWxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgZXhwbGFuYXRpb246IG1lc3NhZ2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckFzeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckFzeW5jKGRhdGEpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gdHJ1ZTtcbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5yZXNvbHZlRGF0YShkYXRhKTtcbiAgICAgIHRoaXMuaGlkZURlcHJlY2F0aW9ucyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczMucmVuZGVyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihkYXRhKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJlZCkge1xuICAgICAgICB0aHJvd1JlbmRlclR3aWNlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmNvbXBpbGVkKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5jb21waWxlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICB9XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgIExleGVyOiBMZXhlclxuICAgICAgfSk7XG4gICAgICB0aGlzLm1hcHBlciB8fCAodGhpcy5tYXBwZXIgPSB0aGlzLm1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uICh2YWx1ZSwgbW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUuZ2V0UmVuZGVyZWRNYXAodmFsdWUpO1xuICAgICAgfSwge30pKTtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIHRvIGluIHRoaXMubWFwcGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyRtYXBwZXIkdG8yID0gdGhpcy5tYXBwZXJbdG9dLFxuICAgICAgICAgIGZyb20gPSBfdGhpcyRtYXBwZXIkdG8yLmZyb20sXG4gICAgICAgICAgX2RhdGEgPSBfdGhpcyRtYXBwZXIkdG8yLmRhdGE7XG4gICAgICAgIHZhciBjdXJyZW50RmlsZSA9IHRoaXMuY29tcGlsZWRbZnJvbV07XG4gICAgICAgIGN1cnJlbnRGaWxlLnNjb3BlTWFuYWdlciA9IHRoaXMuZ2V0U2NvcGVNYW5hZ2VyKHRvLCBjdXJyZW50RmlsZSwgX2RhdGEpO1xuICAgICAgICBjdXJyZW50RmlsZS5yZW5kZXIodG8pO1xuICAgICAgICBvdXRwdXQucHVzaChbdG8sIGN1cnJlbnRGaWxlLmNvbnRlbnQsIGN1cnJlbnRGaWxlXSk7XG4gICAgICAgIGRlbGV0ZSBjdXJyZW50RmlsZS5jb250ZW50O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kyNCA9IDA7IF9pMjQgPCBvdXRwdXQubGVuZ3RoOyBfaTI0KyspIHtcbiAgICAgICAgdmFyIG91dHB1dFBhcnQgPSBvdXRwdXRbX2kyNF07XG4gICAgICAgIHZhciBfb3V0cHV0UGFydCA9IF9zbGljZWRUb0FycmF5KG91dHB1dFBhcnQsIDMpLFxuICAgICAgICAgIGNvbnRlbnQgPSBfb3V0cHV0UGFydFsxXSxcbiAgICAgICAgICBfY3VycmVudEZpbGUgPSBfb3V0cHV0UGFydFsyXTtcbiAgICAgICAgZm9yICh2YXIgX2kyNiA9IDAsIF90aGlzJG1vZHVsZXMxMiA9IHRoaXMubW9kdWxlczsgX2kyNiA8IF90aGlzJG1vZHVsZXMxMi5sZW5ndGg7IF9pMjYrKykge1xuICAgICAgICAgIHZhciBfbW9kdWxlNyA9IF90aGlzJG1vZHVsZXMxMltfaTI2XTtcbiAgICAgICAgICBpZiAoX21vZHVsZTcucHJlWmlwKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gX21vZHVsZTcucHJlWmlwKGNvbnRlbnQsIF9jdXJyZW50RmlsZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICBvdXRwdXRQYXJ0WzFdID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kyOCA9IDA7IF9pMjggPCBvdXRwdXQubGVuZ3RoOyBfaTI4KyspIHtcbiAgICAgICAgdmFyIF9vdXRwdXQkX2kgPSBfc2xpY2VkVG9BcnJheShvdXRwdXRbX2kyOF0sIDIpLFxuICAgICAgICAgIF90byA9IF9vdXRwdXQkX2lbMF0sXG4gICAgICAgICAgX2NvbnRlbnQgPSBfb3V0cHV0JF9pWzFdO1xuICAgICAgICB0aGlzLnppcC5maWxlKF90bywgX2NvbnRlbnQsIHtcbiAgICAgICAgICBjcmVhdGVGb2xkZXJzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmVyaWZ5RXJyb3JzKHRoaXMpO1xuICAgICAgdGhpcy5zZW5kRXZlbnQoXCJzeW5jaW5nLXppcFwiKTtcbiAgICAgIHRoaXMuc3luY1ppcCgpO1xuICAgICAgLy8gVGhlIHN5bmNlZC16aXAgZXZlbnQgaXMgdXNlZCBpbiB0aGUgc3VidGVtcGxhdGUgbW9kdWxlIGZvciBleGFtcGxlXG4gICAgICB0aGlzLnNlbmRFdmVudChcInN5bmNlZC16aXBcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3luY1ppcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jWmlwKCkge1xuICAgICAgZm9yICh2YXIgZmlsZU5hbWUgaW4gdGhpcy54bWxEb2N1bWVudHMpIHtcbiAgICAgICAgdGhpcy56aXAucmVtb3ZlKGZpbGVOYW1lKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB4bWwyc3RyKHRoaXMueG1sRG9jdW1lbnRzW2ZpbGVOYW1lXSk7XG4gICAgICAgIHRoaXMuemlwLmZpbGUoZmlsZU5hbWUsIGNvbnRlbnQsIHtcbiAgICAgICAgICBjcmVhdGVGb2xkZXJzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERhdGEoZGF0YSkge1xuICAgICAgZGVwcmVjYXRlZE1ldGhvZCh0aGlzLCBcInNldERhdGFcIik7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFppcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRaaXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy56aXA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVRlbXBsYXRlQ2xhc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVDbGFzcyhwYXRoKSB7XG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuemlwLmZpbGVzW3BhdGhdLmFzVGV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGVtcGxhdGVDbGFzc0Zyb21Db250ZW50KGNvbnRlbnQsIHBhdGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVUZW1wbGF0ZUNsYXNzRnJvbUNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVDbGFzc0Zyb21Db250ZW50KGNvbnRlbnQsIGZpbGVQYXRoKSB7XG4gICAgICB2YXIgeG1sdE9wdGlvbnMgPSB7XG4gICAgICAgIGZpbGVQYXRoOiBmaWxlUGF0aCxcbiAgICAgICAgY29udGVudFR5cGU6IHRoaXMuZmlsZXNDb250ZW50VHlwZXNbZmlsZVBhdGhdLFxuICAgICAgICByZWxzVHlwZTogdGhpcy5yZWxzVHlwZXNbZmlsZVBhdGhdXG4gICAgICB9O1xuICAgICAgdmFyIGRlZmF1bHRzID0gZ2V0RGVmYXVsdHMoKTtcbiAgICAgIHZhciBkZWZhdWx0S2V5cyA9IHB1c2hBcnJheShPYmplY3Qua2V5cyhkZWZhdWx0cyksIFtcImZpbGVzQ29udGVudFR5cGVzXCIsIFwiZmlsZVR5cGVDb25maWdcIiwgXCJmaWxlVHlwZVwiLCBcIm1vZHVsZXNcIl0pO1xuICAgICAgZm9yICh2YXIgX2kzMCA9IDA7IF9pMzAgPCBkZWZhdWx0S2V5cy5sZW5ndGg7IF9pMzArKykge1xuICAgICAgICB2YXIga2V5ID0gZGVmYXVsdEtleXNbX2kzMF07XG4gICAgICAgIHhtbHRPcHRpb25zW2tleV0gPSB0aGlzW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERvY3h0ZW1wbGF0ZXIuWG1sVGVtcGxhdGVyKGNvbnRlbnQsIHhtbHRPcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnVsbFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnVsbFRleHQocGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGVtcGxhdGVDbGFzcyhwYXRoIHx8IHRoaXMuZmlsZVR5cGVDb25maWcudGV4dFBhdGgodGhpcykpLmdldEZ1bGxUZXh0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRlbXBsYXRlZEZpbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRlbXBsYXRlZEZpbGVzKCkge1xuICAgICAgdGhpcy50ZW1wbGF0ZWRGaWxlcyA9IHRoaXMuZmlsZVR5cGVDb25maWcuZ2V0VGVtcGxhdGVkRmlsZXModGhpcy56aXApO1xuICAgICAgcHVzaEFycmF5KHRoaXMudGVtcGxhdGVkRmlsZXMsIHRoaXMudGFyZ2V0cyk7XG4gICAgICB0aGlzLnRlbXBsYXRlZEZpbGVzID0gdW5pcSh0aGlzLnRlbXBsYXRlZEZpbGVzKTtcbiAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlZEZpbGVzO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuRG9jeHRlbXBsYXRlci5Eb2NVdGlscyA9IERvY1V0aWxzO1xuRG9jeHRlbXBsYXRlci5FcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5Eb2N4dGVtcGxhdGVyLlhtbFRlbXBsYXRlciA9IHJlcXVpcmUoXCIuL3htbC10ZW1wbGF0ZXIuanNcIik7XG5Eb2N4dGVtcGxhdGVyLkZpbGVUeXBlQ29uZmlnID0gcmVxdWlyZShcIi4vZmlsZS10eXBlLWNvbmZpZy5qc1wiKTtcbkRvY3h0ZW1wbGF0ZXIuWG1sTWF0Y2hlciA9IHJlcXVpcmUoXCIuL3htbC1tYXRjaGVyLmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBEb2N4dGVtcGxhdGVyO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRG9jeHRlbXBsYXRlcjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/docxtemplater.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/error-logger.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/error-logger.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray;\n// The error thrown here contains additional information when logged with JSON.stringify (it contains a properties object containing all suberrors).\nfunction replaceErrors(key, value) {\n  if (value instanceof Error) {\n    return pushArray(Object.getOwnPropertyNames(value), [\"stack\"]).reduce(function (error, key) {\n      error[key] = value[key];\n      if (key === \"stack\") {\n        // This is used because in Firefox, stack is not an own property\n        error[key] = value[key].toString();\n      }\n      return error;\n    }, {});\n  }\n  return value;\n}\nfunction logger(error, logging) {\n  // eslint-disable-next-line no-console\n  console.log(JSON.stringify({\n    error: error\n  }, replaceErrors, logging === \"json\" ? 2 : null));\n  if (error.properties && error.properties.errors instanceof Array) {\n    var errorMessages = error.properties.errors.map(function (error) {\n      return error.properties.explanation;\n    }).join(\"\\n\");\n    // eslint-disable-next-line no-console\n    console.log(\"errorMessages\", errorMessages);\n    /*\n     * errorMessages is a humanly readable message looking like this :\n     * 'The tag beginning with \"foobar\" is unopened'\n     */\n  }\n}\nmodule.exports = logger;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZXJyb3ItbG9nZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxrSEFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzLy5wbnBtL2RvY3h0ZW1wbGF0ZXJAMy42MC4yL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2Vycm9yLWxvZ2dlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG4vLyBUaGUgZXJyb3IgdGhyb3duIGhlcmUgY29udGFpbnMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB3aGVuIGxvZ2dlZCB3aXRoIEpTT04uc3RyaW5naWZ5IChpdCBjb250YWlucyBhIHByb3BlcnRpZXMgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHN1YmVycm9ycykuXG5mdW5jdGlvbiByZXBsYWNlRXJyb3JzKGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gcHVzaEFycmF5KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSwgW1wic3RhY2tcIl0pLnJlZHVjZShmdW5jdGlvbiAoZXJyb3IsIGtleSkge1xuICAgICAgZXJyb3Jba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICBpZiAoa2V5ID09PSBcInN0YWNrXCIpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIGJlY2F1c2UgaW4gRmlyZWZveCwgc3RhY2sgaXMgbm90IGFuIG93biBwcm9wZXJ0eVxuICAgICAgICBlcnJvcltrZXldID0gdmFsdWVba2V5XS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0sIHt9KTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBsb2dnZXIoZXJyb3IsIGxvZ2dpbmcpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoe1xuICAgIGVycm9yOiBlcnJvclxuICB9LCByZXBsYWNlRXJyb3JzLCBsb2dnaW5nID09PSBcImpzb25cIiA/IDIgOiBudWxsKSk7XG4gIGlmIChlcnJvci5wcm9wZXJ0aWVzICYmIGVycm9yLnByb3BlcnRpZXMuZXJyb3JzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgZXJyb3JNZXNzYWdlcyA9IGVycm9yLnByb3BlcnRpZXMuZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBlcnJvci5wcm9wZXJ0aWVzLmV4cGxhbmF0aW9uO1xuICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmxvZyhcImVycm9yTWVzc2FnZXNcIiwgZXJyb3JNZXNzYWdlcyk7XG4gICAgLypcbiAgICAgKiBlcnJvck1lc3NhZ2VzIGlzIGEgaHVtYW5seSByZWFkYWJsZSBtZXNzYWdlIGxvb2tpbmcgbGlrZSB0aGlzIDpcbiAgICAgKiAnVGhlIHRhZyBiZWdpbm5pbmcgd2l0aCBcImZvb2JhclwiIGlzIHVub3BlbmVkJ1xuICAgICAqL1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGxvZ2dlcjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/error-logger.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/utils.js\"),\n  last = _require.last,\n  first = _require.first;\nfunction XTError(message) {\n  this.name = \"GenericError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTError.prototype = Error.prototype;\nfunction XTTemplateError(message) {\n  this.name = \"TemplateError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTTemplateError.prototype = new XTError();\nfunction XTRenderingError(message) {\n  this.name = \"RenderingError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTRenderingError.prototype = new XTError();\nfunction XTScopeParserError(message) {\n  this.name = \"ScopeParserError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTScopeParserError.prototype = new XTError();\nfunction XTInternalError(message) {\n  this.name = \"InternalError\";\n  this.properties = {\n    explanation: \"InternalError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTInternalError.prototype = new XTError();\nfunction XTAPIVersionError(message) {\n  this.name = \"APIVersionError\";\n  this.properties = {\n    explanation: \"APIVersionError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTAPIVersionError.prototype = new XTError();\nfunction throwApiVersionError(msg, properties) {\n  var err = new XTAPIVersionError(msg);\n  err.properties = _objectSpread({\n    id: \"api_version_error\"\n  }, properties);\n  throw err;\n}\nfunction throwMultiError(errors) {\n  var err = new XTTemplateError(\"Multi error\");\n  err.properties = {\n    errors: errors,\n    id: \"multi_error\",\n    explanation: \"The template has multiple errors\"\n  };\n  throw err;\n}\nfunction getUnopenedTagException(options) {\n  var err = new XTTemplateError(\"Unopened tag\");\n  err.properties = {\n    xtag: last(options.xtag.split(\" \")),\n    id: \"unopened_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unopened\")\n  };\n  return err;\n}\nfunction getDuplicateOpenTagException(options) {\n  var err = new XTTemplateError(\"Duplicate open tag, expected one open tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_open_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate open tags\")\n  };\n  return err;\n}\nfunction getDuplicateCloseTagException(options) {\n  var err = new XTTemplateError(\"Duplicate close tag, expected one close tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_close_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag ending with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate close tags\")\n  };\n  return err;\n}\nfunction getUnclosedTagException(options) {\n  var err = new XTTemplateError(\"Unclosed tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")).substr(1),\n    id: \"unclosed_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unclosed\")\n  };\n  return err;\n}\nfunction throwXmlTagNotFound(options) {\n  var err = new XTTemplateError(\"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position));\n  var part = options.parsed[options.index];\n  err.properties = {\n    id: \"no_xml_tag_found_at_\".concat(options.position),\n    explanation: \"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position),\n    offset: part.offset,\n    part: part,\n    parsed: options.parsed,\n    index: options.index,\n    element: options.element\n  };\n  throw err;\n}\nfunction getCorruptCharactersException(_ref) {\n  var tag = _ref.tag,\n    value = _ref.value,\n    offset = _ref.offset;\n  var err = new XTRenderingError(\"There are some XML corrupt characters\");\n  err.properties = {\n    id: \"invalid_xml_characters\",\n    xtag: tag,\n    value: value,\n    offset: offset,\n    explanation: \"There are some corrupt characters for the field \".concat(tag)\n  };\n  return err;\n}\nfunction getInvalidRawXMLValueException(_ref2) {\n  var tag = _ref2.tag,\n    value = _ref2.value,\n    offset = _ref2.offset;\n  var err = new XTRenderingError(\"Non string values are not allowed for rawXML tags\");\n  err.properties = {\n    id: \"invalid_raw_xml_value\",\n    xtag: tag,\n    value: value,\n    offset: offset,\n    explanation: \"The value of the raw tag : '\".concat(tag, \"' is not a string\")\n  };\n  return err;\n}\nfunction throwExpandNotFound(options) {\n  var _options$part = options.part,\n    value = _options$part.value,\n    offset = _options$part.offset,\n    _options$id = options.id,\n    id = _options$id === void 0 ? \"raw_tag_outerxml_invalid\" : _options$id,\n    _options$message = options.message,\n    message = _options$message === void 0 ? \"Raw tag not in paragraph\" : _options$message;\n  var part = options.part;\n  var _options$explanation = options.explanation,\n    explanation = _options$explanation === void 0 ? \"The tag \\\"\".concat(value, \"\\\" is not inside a paragraph\") : _options$explanation;\n  if (typeof explanation === \"function\") {\n    explanation = explanation(part);\n  }\n  var err = new XTTemplateError(message);\n  err.properties = {\n    id: id,\n    explanation: explanation,\n    rootError: options.rootError,\n    xtag: value,\n    offset: offset,\n    postparsed: options.postparsed,\n    expandTo: options.expandTo,\n    index: options.index\n  };\n  throw err;\n}\nfunction throwRawTagShouldBeOnlyTextInParagraph(options) {\n  var err = new XTTemplateError(\"Raw tag should be the only text in paragraph\");\n  var tag = options.part.value;\n  err.properties = {\n    id: \"raw_xml_tag_should_be_only_text_in_paragraph\",\n    explanation: \"The raw tag \\\"\".concat(tag, \"\\\" should be the only text in this paragraph. This means that this tag should not be surrounded by any text or spaces.\"),\n    xtag: tag,\n    offset: options.part.offset,\n    paragraphParts: options.paragraphParts\n  };\n  throw err;\n}\nfunction getUnmatchedLoopException(part) {\n  var location = part.location,\n    offset = part.offset,\n    square = part.square;\n  var t = location === \"start\" ? \"unclosed\" : \"unopened\";\n  var T = location === \"start\" ? \"Unclosed\" : \"Unopened\";\n  var err = new XTTemplateError(\"\".concat(T, \" loop\"));\n  var tag = part.value;\n  err.properties = {\n    id: \"\".concat(t, \"_loop\"),\n    explanation: \"The loop with tag \\\"\".concat(tag, \"\\\" is \").concat(t),\n    xtag: tag,\n    offset: offset\n  };\n  if (square) {\n    err.properties.square = square;\n  }\n  return err;\n}\nfunction getUnbalancedLoopException(pair, lastPair) {\n  var err = new XTTemplateError(\"Unbalanced loop tag\");\n  var lastL = lastPair[0].part.value;\n  var lastR = lastPair[1].part.value;\n  var l = pair[0].part.value;\n  var r = pair[1].part.value;\n  err.properties = {\n    id: \"unbalanced_loop_tags\",\n    explanation: \"Unbalanced loop tags {#\".concat(lastL, \"}{/\").concat(lastR, \"}{#\").concat(l, \"}{/\").concat(r, \"}\"),\n    offset: [lastPair[0].part.offset, pair[1].part.offset],\n    lastPair: {\n      left: lastPair[0].part.value,\n      right: lastPair[1].part.value\n    },\n    pair: {\n      left: pair[0].part.value,\n      right: pair[1].part.value\n    }\n  };\n  return err;\n}\nfunction getClosingTagNotMatchOpeningTag(_ref3) {\n  var tags = _ref3.tags;\n  var err = new XTTemplateError(\"Closing tag does not match opening tag\");\n  err.properties = {\n    id: \"closing_tag_does_not_match_opening_tag\",\n    explanation: \"The tag \\\"\".concat(tags[0].value, \"\\\" is closed by the tag \\\"\").concat(tags[1].value, \"\\\"\"),\n    openingtag: first(tags).value,\n    offset: [first(tags).offset, last(tags).offset],\n    closingtag: last(tags).value\n  };\n  return err;\n}\nfunction getScopeCompilationError(_ref4) {\n  var tag = _ref4.tag,\n    rootError = _ref4.rootError,\n    offset = _ref4.offset;\n  var err = new XTScopeParserError(\"Scope parser compilation failed\");\n  err.properties = {\n    id: \"scopeparser_compilation_failed\",\n    offset: offset,\n    xtag: tag,\n    explanation: \"The scope parser for the tag \\\"\".concat(tag, \"\\\" failed to compile\"),\n    rootError: rootError\n  };\n  return err;\n}\nfunction getScopeParserExecutionError(_ref5) {\n  var tag = _ref5.tag,\n    scope = _ref5.scope,\n    error = _ref5.error,\n    offset = _ref5.offset;\n  var err = new XTScopeParserError(\"Scope parser execution failed\");\n  err.properties = {\n    id: \"scopeparser_execution_failed\",\n    explanation: \"The scope parser for the tag \".concat(tag, \" failed to execute\"),\n    scope: scope,\n    offset: offset,\n    xtag: tag,\n    rootError: error\n  };\n  return err;\n}\nfunction getLoopPositionProducesInvalidXMLError(_ref6) {\n  var tag = _ref6.tag,\n    offset = _ref6.offset;\n  var err = new XTTemplateError(\"The position of the loop tags \\\"\".concat(tag, \"\\\" would produce invalid XML\"));\n  err.properties = {\n    xtag: tag,\n    id: \"loop_position_invalid\",\n    explanation: \"The tags \\\"\".concat(tag, \"\\\" are misplaced in the document, for example one of them is in a table and the other one outside the table\"),\n    offset: offset\n  };\n  return err;\n}\nfunction throwUnimplementedTagType(part, index) {\n  var errorMsg = \"Unimplemented tag type \\\"\".concat(part.type, \"\\\"\");\n  if (part.module) {\n    errorMsg += \" \\\"\".concat(part.module, \"\\\"\");\n  }\n  var err = new XTTemplateError(errorMsg);\n  err.properties = {\n    part: part,\n    index: index,\n    id: \"unimplemented_tag_type\"\n  };\n  throw err;\n}\nfunction throwMalformedXml() {\n  var err = new XTInternalError(\"Malformed xml\");\n  err.properties = {\n    explanation: \"The template contains malformed xml\",\n    id: \"malformed_xml\"\n  };\n  throw err;\n}\nfunction throwResolveBeforeCompile() {\n  var err = new XTInternalError(\"You must run `.compile()` before running `.resolveData()`\");\n  err.properties = {\n    id: \"resolve_before_compile\",\n    explanation: \"You must run `.compile()` before running `.resolveData()`\"\n  };\n  throw err;\n}\nfunction throwRenderInvalidTemplate() {\n  var err = new XTInternalError(\"You should not call .render on a document that had compilation errors\");\n  err.properties = {\n    id: \"render_on_invalid_template\",\n    explanation: \"You should not call .render on a document that had compilation errors\"\n  };\n  throw err;\n}\nfunction throwRenderTwice() {\n  var err = new XTInternalError(\"You should not call .render twice on the same docxtemplater instance\");\n  err.properties = {\n    id: \"render_twice\",\n    explanation: \"You should not call .render twice on the same docxtemplater instance\"\n  };\n  throw err;\n}\nfunction throwFileTypeNotIdentified(zip) {\n  var files = Object.keys(zip.files).slice(0, 10);\n  var msg = \"\";\n  if (files.length === 0) {\n    msg = \"Empty zip file\";\n  } else {\n    msg = \"Zip file contains : \".concat(files.join(\",\"));\n  }\n  var err = new XTInternalError(\"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg));\n  err.properties = {\n    id: \"filetype_not_identified\",\n    explanation: \"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg)\n  };\n  throw err;\n}\nfunction throwXmlInvalid(content, offset) {\n  var err = new XTTemplateError(\"An XML file has invalid xml\");\n  err.properties = {\n    id: \"file_has_invalid_xml\",\n    content: content,\n    offset: offset,\n    explanation: \"The docx contains invalid XML, it is most likely corrupt\"\n  };\n  throw err;\n}\nfunction throwFileTypeNotHandled(fileType) {\n  var err = new XTInternalError(\"The filetype \\\"\".concat(fileType, \"\\\" is not handled by docxtemplater\"));\n  err.properties = {\n    id: \"filetype_not_handled\",\n    explanation: \"The file you are trying to generate is of type \\\"\".concat(fileType, \"\\\", but only docx and pptx formats are handled\"),\n    fileType: fileType\n  };\n  throw err;\n}\nmodule.exports = {\n  XTError: XTError,\n  XTTemplateError: XTTemplateError,\n  XTInternalError: XTInternalError,\n  XTScopeParserError: XTScopeParserError,\n  XTAPIVersionError: XTAPIVersionError,\n  // Remove this alias in v4\n  RenderingError: XTRenderingError,\n  XTRenderingError: XTRenderingError,\n  getClosingTagNotMatchOpeningTag: getClosingTagNotMatchOpeningTag,\n  getLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError,\n  getScopeCompilationError: getScopeCompilationError,\n  getScopeParserExecutionError: getScopeParserExecutionError,\n  getUnclosedTagException: getUnclosedTagException,\n  getUnopenedTagException: getUnopenedTagException,\n  getUnmatchedLoopException: getUnmatchedLoopException,\n  getDuplicateCloseTagException: getDuplicateCloseTagException,\n  getDuplicateOpenTagException: getDuplicateOpenTagException,\n  getCorruptCharactersException: getCorruptCharactersException,\n  getInvalidRawXMLValueException: getInvalidRawXMLValueException,\n  getUnbalancedLoopException: getUnbalancedLoopException,\n  throwApiVersionError: throwApiVersionError,\n  throwFileTypeNotHandled: throwFileTypeNotHandled,\n  throwFileTypeNotIdentified: throwFileTypeNotIdentified,\n  throwMalformedXml: throwMalformedXml,\n  throwMultiError: throwMultiError,\n  throwExpandNotFound: throwExpandNotFound,\n  throwRawTagShouldBeOnlyTextInParagraph: throwRawTagShouldBeOnlyTextInParagraph,\n  throwUnimplementedTagType: throwUnimplementedTagType,\n  throwXmlTagNotFound: throwXmlTagNotFound,\n  throwXmlInvalid: throwXmlInvalid,\n  throwResolveBeforeCompile: throwResolveBeforeCompile,\n  throwRenderInvalidTemplate: throwRenderInvalidTemplate,\n  throwRenderTwice: throwRenderTwice\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsMEdBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0JBQW9CLHFCQUFxQixpQkFBaUIsZ0JBQWdCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzLy5wbnBtL2RvY3h0ZW1wbGF0ZXJAMy42MC4yL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKSxcbiAgbGFzdCA9IF9yZXF1aXJlLmxhc3QsXG4gIGZpcnN0ID0gX3JlcXVpcmUuZmlyc3Q7XG5mdW5jdGlvbiBYVEVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJHZW5lcmljRXJyb3JcIjtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbn1cblhURXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuZnVuY3Rpb24gWFRUZW1wbGF0ZUVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJUZW1wbGF0ZUVycm9yXCI7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVFRlbXBsYXRlRXJyb3IucHJvdG90eXBlID0gbmV3IFhURXJyb3IoKTtcbmZ1bmN0aW9uIFhUUmVuZGVyaW5nRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIlJlbmRlcmluZ0Vycm9yXCI7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7XG59XG5YVFJlbmRlcmluZ0Vycm9yLnByb3RvdHlwZSA9IG5ldyBYVEVycm9yKCk7XG5mdW5jdGlvbiBYVFNjb3BlUGFyc2VyRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIlNjb3BlUGFyc2VyRXJyb3JcIjtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbn1cblhUU2NvcGVQYXJzZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgWFRFcnJvcigpO1xuZnVuY3Rpb24gWFRJbnRlcm5hbEVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gXCJJbnRlcm5hbEVycm9yXCI7XG4gIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICBleHBsYW5hdGlvbjogXCJJbnRlcm5hbEVycm9yXCJcbiAgfTtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbn1cblhUSW50ZXJuYWxFcnJvci5wcm90b3R5cGUgPSBuZXcgWFRFcnJvcigpO1xuZnVuY3Rpb24gWFRBUElWZXJzaW9uRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIkFQSVZlcnNpb25FcnJvclwiO1xuICB0aGlzLnByb3BlcnRpZXMgPSB7XG4gICAgZXhwbGFuYXRpb246IFwiQVBJVmVyc2lvbkVycm9yXCJcbiAgfTtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbn1cblhUQVBJVmVyc2lvbkVycm9yLnByb3RvdHlwZSA9IG5ldyBYVEVycm9yKCk7XG5mdW5jdGlvbiB0aHJvd0FwaVZlcnNpb25FcnJvcihtc2csIHByb3BlcnRpZXMpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEFQSVZlcnNpb25FcnJvcihtc2cpO1xuICBlcnIucHJvcGVydGllcyA9IF9vYmplY3RTcHJlYWQoe1xuICAgIGlkOiBcImFwaV92ZXJzaW9uX2Vycm9yXCJcbiAgfSwgcHJvcGVydGllcyk7XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93TXVsdGlFcnJvcihlcnJvcnMpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJNdWx0aSBlcnJvclwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgaWQ6IFwibXVsdGlfZXJyb3JcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGVtcGxhdGUgaGFzIG11bHRpcGxlIGVycm9yc1wiXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIGdldFVub3BlbmVkVGFnRXhjZXB0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJVbm9wZW5lZCB0YWdcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIHh0YWc6IGxhc3Qob3B0aW9ucy54dGFnLnNwbGl0KFwiIFwiKSksXG4gICAgaWQ6IFwidW5vcGVuZWRfdGFnXCIsXG4gICAgY29udGV4dDogb3B0aW9ucy54dGFnLFxuICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQsXG4gICAgbEluZGV4OiBvcHRpb25zLmxJbmRleCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFnIGJlZ2lubmluZyB3aXRoIFxcXCJcIi5jb25jYXQob3B0aW9ucy54dGFnLnN1YnN0cigwLCAxMCksIFwiXFxcIiBpcyB1bm9wZW5lZFwiKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbihvcHRpb25zKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiRHVwbGljYXRlIG9wZW4gdGFnLCBleHBlY3RlZCBvbmUgb3BlbiB0YWdcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIHh0YWc6IGZpcnN0KG9wdGlvbnMueHRhZy5zcGxpdChcIiBcIikpLFxuICAgIGlkOiBcImR1cGxpY2F0ZV9vcGVuX3RhZ1wiLFxuICAgIGNvbnRleHQ6IG9wdGlvbnMueHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgIGxJbmRleDogb3B0aW9ucy5sSW5kZXgsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZyBiZWdpbm5pbmcgd2l0aCBcXFwiXCIuY29uY2F0KG9wdGlvbnMueHRhZy5zdWJzdHIoMCwgMTApLCBcIlxcXCIgaGFzIGR1cGxpY2F0ZSBvcGVuIHRhZ3NcIilcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldER1cGxpY2F0ZUNsb3NlVGFnRXhjZXB0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJEdXBsaWNhdGUgY2xvc2UgdGFnLCBleHBlY3RlZCBvbmUgY2xvc2UgdGFnXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICB4dGFnOiBmaXJzdChvcHRpb25zLnh0YWcuc3BsaXQoXCIgXCIpKSxcbiAgICBpZDogXCJkdXBsaWNhdGVfY2xvc2VfdGFnXCIsXG4gICAgY29udGV4dDogb3B0aW9ucy54dGFnLFxuICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQsXG4gICAgbEluZGV4OiBvcHRpb25zLmxJbmRleCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFnIGVuZGluZyB3aXRoIFxcXCJcIi5jb25jYXQob3B0aW9ucy54dGFnLnN1YnN0cigwLCAxMCksIFwiXFxcIiBoYXMgZHVwbGljYXRlIGNsb3NlIHRhZ3NcIilcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldFVuY2xvc2VkVGFnRXhjZXB0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJVbmNsb3NlZCB0YWdcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIHh0YWc6IGZpcnN0KG9wdGlvbnMueHRhZy5zcGxpdChcIiBcIikpLnN1YnN0cigxKSxcbiAgICBpZDogXCJ1bmNsb3NlZF90YWdcIixcbiAgICBjb250ZXh0OiBvcHRpb25zLnh0YWcsXG4gICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldCxcbiAgICBsSW5kZXg6IG9wdGlvbnMubEluZGV4LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0YWcgYmVnaW5uaW5nIHdpdGggXFxcIlwiLmNvbmNhdChvcHRpb25zLnh0YWcuc3Vic3RyKDAsIDEwKSwgXCJcXFwiIGlzIHVuY2xvc2VkXCIpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1htbFRhZ05vdEZvdW5kKG9wdGlvbnMpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJObyB0YWcgXFxcIlwiLmNvbmNhdChvcHRpb25zLmVsZW1lbnQsIFwiXFxcIiB3YXMgZm91bmQgYXQgdGhlIFwiKS5jb25jYXQob3B0aW9ucy5wb3NpdGlvbikpO1xuICB2YXIgcGFydCA9IG9wdGlvbnMucGFyc2VkW29wdGlvbnMuaW5kZXhdO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJub194bWxfdGFnX2ZvdW5kX2F0X1wiLmNvbmNhdChvcHRpb25zLnBvc2l0aW9uKSxcbiAgICBleHBsYW5hdGlvbjogXCJObyB0YWcgXFxcIlwiLmNvbmNhdChvcHRpb25zLmVsZW1lbnQsIFwiXFxcIiB3YXMgZm91bmQgYXQgdGhlIFwiKS5jb25jYXQob3B0aW9ucy5wb3NpdGlvbiksXG4gICAgb2Zmc2V0OiBwYXJ0Lm9mZnNldCxcbiAgICBwYXJ0OiBwYXJ0LFxuICAgIHBhcnNlZDogb3B0aW9ucy5wYXJzZWQsXG4gICAgaW5kZXg6IG9wdGlvbnMuaW5kZXgsXG4gICAgZWxlbWVudDogb3B0aW9ucy5lbGVtZW50XG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIGdldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uKF9yZWYpIHtcbiAgdmFyIHRhZyA9IF9yZWYudGFnLFxuICAgIHZhbHVlID0gX3JlZi52YWx1ZSxcbiAgICBvZmZzZXQgPSBfcmVmLm9mZnNldDtcbiAgdmFyIGVyciA9IG5ldyBYVFJlbmRlcmluZ0Vycm9yKFwiVGhlcmUgYXJlIHNvbWUgWE1MIGNvcnJ1cHQgY2hhcmFjdGVyc1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiaW52YWxpZF94bWxfY2hhcmFjdGVyc1wiLFxuICAgIHh0YWc6IHRhZyxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlcmUgYXJlIHNvbWUgY29ycnVwdCBjaGFyYWN0ZXJzIGZvciB0aGUgZmllbGQgXCIuY29uY2F0KHRhZylcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbihfcmVmMikge1xuICB2YXIgdGFnID0gX3JlZjIudGFnLFxuICAgIHZhbHVlID0gX3JlZjIudmFsdWUsXG4gICAgb2Zmc2V0ID0gX3JlZjIub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUUmVuZGVyaW5nRXJyb3IoXCJOb24gc3RyaW5nIHZhbHVlcyBhcmUgbm90IGFsbG93ZWQgZm9yIHJhd1hNTCB0YWdzXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJpbnZhbGlkX3Jhd194bWxfdmFsdWVcIixcbiAgICB4dGFnOiB0YWcsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB2YWx1ZSBvZiB0aGUgcmF3IHRhZyA6ICdcIi5jb25jYXQodGFnLCBcIicgaXMgbm90IGEgc3RyaW5nXCIpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd0V4cGFuZE5vdEZvdW5kKG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJHBhcnQgPSBvcHRpb25zLnBhcnQsXG4gICAgdmFsdWUgPSBfb3B0aW9ucyRwYXJ0LnZhbHVlLFxuICAgIG9mZnNldCA9IF9vcHRpb25zJHBhcnQub2Zmc2V0LFxuICAgIF9vcHRpb25zJGlkID0gb3B0aW9ucy5pZCxcbiAgICBpZCA9IF9vcHRpb25zJGlkID09PSB2b2lkIDAgPyBcInJhd190YWdfb3V0ZXJ4bWxfaW52YWxpZFwiIDogX29wdGlvbnMkaWQsXG4gICAgX29wdGlvbnMkbWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZSxcbiAgICBtZXNzYWdlID0gX29wdGlvbnMkbWVzc2FnZSA9PT0gdm9pZCAwID8gXCJSYXcgdGFnIG5vdCBpbiBwYXJhZ3JhcGhcIiA6IF9vcHRpb25zJG1lc3NhZ2U7XG4gIHZhciBwYXJ0ID0gb3B0aW9ucy5wYXJ0O1xuICB2YXIgX29wdGlvbnMkZXhwbGFuYXRpb24gPSBvcHRpb25zLmV4cGxhbmF0aW9uLFxuICAgIGV4cGxhbmF0aW9uID0gX29wdGlvbnMkZXhwbGFuYXRpb24gPT09IHZvaWQgMCA/IFwiVGhlIHRhZyBcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCIgaXMgbm90IGluc2lkZSBhIHBhcmFncmFwaFwiKSA6IF9vcHRpb25zJGV4cGxhbmF0aW9uO1xuICBpZiAodHlwZW9mIGV4cGxhbmF0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBleHBsYW5hdGlvbiA9IGV4cGxhbmF0aW9uKHBhcnQpO1xuICB9XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKG1lc3NhZ2UpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogaWQsXG4gICAgZXhwbGFuYXRpb246IGV4cGxhbmF0aW9uLFxuICAgIHJvb3RFcnJvcjogb3B0aW9ucy5yb290RXJyb3IsXG4gICAgeHRhZzogdmFsdWUsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgcG9zdHBhcnNlZDogb3B0aW9ucy5wb3N0cGFyc2VkLFxuICAgIGV4cGFuZFRvOiBvcHRpb25zLmV4cGFuZFRvLFxuICAgIGluZGV4OiBvcHRpb25zLmluZGV4XG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoKG9wdGlvbnMpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJSYXcgdGFnIHNob3VsZCBiZSB0aGUgb25seSB0ZXh0IGluIHBhcmFncmFwaFwiKTtcbiAgdmFyIHRhZyA9IG9wdGlvbnMucGFydC52YWx1ZTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwicmF3X3htbF90YWdfc2hvdWxkX2JlX29ubHlfdGV4dF9pbl9wYXJhZ3JhcGhcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgcmF3IHRhZyBcXFwiXCIuY29uY2F0KHRhZywgXCJcXFwiIHNob3VsZCBiZSB0aGUgb25seSB0ZXh0IGluIHRoaXMgcGFyYWdyYXBoLiBUaGlzIG1lYW5zIHRoYXQgdGhpcyB0YWcgc2hvdWxkIG5vdCBiZSBzdXJyb3VuZGVkIGJ5IGFueSB0ZXh0IG9yIHNwYWNlcy5cIiksXG4gICAgeHRhZzogdGFnLFxuICAgIG9mZnNldDogb3B0aW9ucy5wYXJ0Lm9mZnNldCxcbiAgICBwYXJhZ3JhcGhQYXJ0czogb3B0aW9ucy5wYXJhZ3JhcGhQYXJ0c1xuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiBnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uKHBhcnQpIHtcbiAgdmFyIGxvY2F0aW9uID0gcGFydC5sb2NhdGlvbixcbiAgICBvZmZzZXQgPSBwYXJ0Lm9mZnNldCxcbiAgICBzcXVhcmUgPSBwYXJ0LnNxdWFyZTtcbiAgdmFyIHQgPSBsb2NhdGlvbiA9PT0gXCJzdGFydFwiID8gXCJ1bmNsb3NlZFwiIDogXCJ1bm9wZW5lZFwiO1xuICB2YXIgVCA9IGxvY2F0aW9uID09PSBcInN0YXJ0XCIgPyBcIlVuY2xvc2VkXCIgOiBcIlVub3BlbmVkXCI7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiXCIuY29uY2F0KFQsIFwiIGxvb3BcIikpO1xuICB2YXIgdGFnID0gcGFydC52YWx1ZTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiXCIuY29uY2F0KHQsIFwiX2xvb3BcIiksXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIGxvb3Agd2l0aCB0YWcgXFxcIlwiLmNvbmNhdCh0YWcsIFwiXFxcIiBpcyBcIikuY29uY2F0KHQpLFxuICAgIHh0YWc6IHRhZyxcbiAgICBvZmZzZXQ6IG9mZnNldFxuICB9O1xuICBpZiAoc3F1YXJlKSB7XG4gICAgZXJyLnByb3BlcnRpZXMuc3F1YXJlID0gc3F1YXJlO1xuICB9XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbihwYWlyLCBsYXN0UGFpcikge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlVuYmFsYW5jZWQgbG9vcCB0YWdcIik7XG4gIHZhciBsYXN0TCA9IGxhc3RQYWlyWzBdLnBhcnQudmFsdWU7XG4gIHZhciBsYXN0UiA9IGxhc3RQYWlyWzFdLnBhcnQudmFsdWU7XG4gIHZhciBsID0gcGFpclswXS5wYXJ0LnZhbHVlO1xuICB2YXIgciA9IHBhaXJbMV0ucGFydC52YWx1ZTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwidW5iYWxhbmNlZF9sb29wX3RhZ3NcIixcbiAgICBleHBsYW5hdGlvbjogXCJVbmJhbGFuY2VkIGxvb3AgdGFncyB7I1wiLmNvbmNhdChsYXN0TCwgXCJ9ey9cIikuY29uY2F0KGxhc3RSLCBcIn17I1wiKS5jb25jYXQobCwgXCJ9ey9cIikuY29uY2F0KHIsIFwifVwiKSxcbiAgICBvZmZzZXQ6IFtsYXN0UGFpclswXS5wYXJ0Lm9mZnNldCwgcGFpclsxXS5wYXJ0Lm9mZnNldF0sXG4gICAgbGFzdFBhaXI6IHtcbiAgICAgIGxlZnQ6IGxhc3RQYWlyWzBdLnBhcnQudmFsdWUsXG4gICAgICByaWdodDogbGFzdFBhaXJbMV0ucGFydC52YWx1ZVxuICAgIH0sXG4gICAgcGFpcjoge1xuICAgICAgbGVmdDogcGFpclswXS5wYXJ0LnZhbHVlLFxuICAgICAgcmlnaHQ6IHBhaXJbMV0ucGFydC52YWx1ZVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWcoX3JlZjMpIHtcbiAgdmFyIHRhZ3MgPSBfcmVmMy50YWdzO1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIkNsb3NpbmcgdGFnIGRvZXMgbm90IG1hdGNoIG9wZW5pbmcgdGFnXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJjbG9zaW5nX3RhZ19kb2VzX25vdF9tYXRjaF9vcGVuaW5nX3RhZ1wiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0YWcgXFxcIlwiLmNvbmNhdCh0YWdzWzBdLnZhbHVlLCBcIlxcXCIgaXMgY2xvc2VkIGJ5IHRoZSB0YWcgXFxcIlwiKS5jb25jYXQodGFnc1sxXS52YWx1ZSwgXCJcXFwiXCIpLFxuICAgIG9wZW5pbmd0YWc6IGZpcnN0KHRhZ3MpLnZhbHVlLFxuICAgIG9mZnNldDogW2ZpcnN0KHRhZ3MpLm9mZnNldCwgbGFzdCh0YWdzKS5vZmZzZXRdLFxuICAgIGNsb3Npbmd0YWc6IGxhc3QodGFncykudmFsdWVcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldFNjb3BlQ29tcGlsYXRpb25FcnJvcihfcmVmNCkge1xuICB2YXIgdGFnID0gX3JlZjQudGFnLFxuICAgIHJvb3RFcnJvciA9IF9yZWY0LnJvb3RFcnJvcixcbiAgICBvZmZzZXQgPSBfcmVmNC5vZmZzZXQ7XG4gIHZhciBlcnIgPSBuZXcgWFRTY29wZVBhcnNlckVycm9yKFwiU2NvcGUgcGFyc2VyIGNvbXBpbGF0aW9uIGZhaWxlZFwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwic2NvcGVwYXJzZXJfY29tcGlsYXRpb25fZmFpbGVkXCIsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgeHRhZzogdGFnLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSBzY29wZSBwYXJzZXIgZm9yIHRoZSB0YWcgXFxcIlwiLmNvbmNhdCh0YWcsIFwiXFxcIiBmYWlsZWQgdG8gY29tcGlsZVwiKSxcbiAgICByb290RXJyb3I6IHJvb3RFcnJvclxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcihfcmVmNSkge1xuICB2YXIgdGFnID0gX3JlZjUudGFnLFxuICAgIHNjb3BlID0gX3JlZjUuc2NvcGUsXG4gICAgZXJyb3IgPSBfcmVmNS5lcnJvcixcbiAgICBvZmZzZXQgPSBfcmVmNS5vZmZzZXQ7XG4gIHZhciBlcnIgPSBuZXcgWFRTY29wZVBhcnNlckVycm9yKFwiU2NvcGUgcGFyc2VyIGV4ZWN1dGlvbiBmYWlsZWRcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInNjb3BlcGFyc2VyX2V4ZWN1dGlvbl9mYWlsZWRcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgc2NvcGUgcGFyc2VyIGZvciB0aGUgdGFnIFwiLmNvbmNhdCh0YWcsIFwiIGZhaWxlZCB0byBleGVjdXRlXCIpLFxuICAgIHNjb3BlOiBzY29wZSxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICB4dGFnOiB0YWcsXG4gICAgcm9vdEVycm9yOiBlcnJvclxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3IoX3JlZjYpIHtcbiAgdmFyIHRhZyA9IF9yZWY2LnRhZyxcbiAgICBvZmZzZXQgPSBfcmVmNi5vZmZzZXQ7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiVGhlIHBvc2l0aW9uIG9mIHRoZSBsb29wIHRhZ3MgXFxcIlwiLmNvbmNhdCh0YWcsIFwiXFxcIiB3b3VsZCBwcm9kdWNlIGludmFsaWQgWE1MXCIpKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgeHRhZzogdGFnLFxuICAgIGlkOiBcImxvb3BfcG9zaXRpb25faW52YWxpZFwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0YWdzIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgYXJlIG1pc3BsYWNlZCBpbiB0aGUgZG9jdW1lbnQsIGZvciBleGFtcGxlIG9uZSBvZiB0aGVtIGlzIGluIGEgdGFibGUgYW5kIHRoZSBvdGhlciBvbmUgb3V0c2lkZSB0aGUgdGFibGVcIiksXG4gICAgb2Zmc2V0OiBvZmZzZXRcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIHRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGUocGFydCwgaW5kZXgpIHtcbiAgdmFyIGVycm9yTXNnID0gXCJVbmltcGxlbWVudGVkIHRhZyB0eXBlIFxcXCJcIi5jb25jYXQocGFydC50eXBlLCBcIlxcXCJcIik7XG4gIGlmIChwYXJ0Lm1vZHVsZSkge1xuICAgIGVycm9yTXNnICs9IFwiIFxcXCJcIi5jb25jYXQocGFydC5tb2R1bGUsIFwiXFxcIlwiKTtcbiAgfVxuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihlcnJvck1zZyk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIHBhcnQ6IHBhcnQsXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGlkOiBcInVuaW1wbGVtZW50ZWRfdGFnX3R5cGVcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd01hbGZvcm1lZFhtbCgpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJNYWxmb3JtZWQgeG1sXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGVtcGxhdGUgY29udGFpbnMgbWFsZm9ybWVkIHhtbFwiLFxuICAgIGlkOiBcIm1hbGZvcm1lZF94bWxcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlKCkge1xuICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIllvdSBtdXN0IHJ1biBgLmNvbXBpbGUoKWAgYmVmb3JlIHJ1bm5pbmcgYC5yZXNvbHZlRGF0YSgpYFwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwicmVzb2x2ZV9iZWZvcmVfY29tcGlsZVwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIllvdSBtdXN0IHJ1biBgLmNvbXBpbGUoKWAgYmVmb3JlIHJ1bm5pbmcgYC5yZXNvbHZlRGF0YSgpYFwiXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlKCkge1xuICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIllvdSBzaG91bGQgbm90IGNhbGwgLnJlbmRlciBvbiBhIGRvY3VtZW50IHRoYXQgaGFkIGNvbXBpbGF0aW9uIGVycm9yc1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwicmVuZGVyX29uX2ludmFsaWRfdGVtcGxhdGVcIixcbiAgICBleHBsYW5hdGlvbjogXCJZb3Ugc2hvdWxkIG5vdCBjYWxsIC5yZW5kZXIgb24gYSBkb2N1bWVudCB0aGF0IGhhZCBjb21waWxhdGlvbiBlcnJvcnNcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1JlbmRlclR3aWNlKCkge1xuICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIllvdSBzaG91bGQgbm90IGNhbGwgLnJlbmRlciB0d2ljZSBvbiB0aGUgc2FtZSBkb2N4dGVtcGxhdGVyIGluc3RhbmNlXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJyZW5kZXJfdHdpY2VcIixcbiAgICBleHBsYW5hdGlvbjogXCJZb3Ugc2hvdWxkIG5vdCBjYWxsIC5yZW5kZXIgdHdpY2Ugb24gdGhlIHNhbWUgZG9jeHRlbXBsYXRlciBpbnN0YW5jZVwiXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkKHppcCkge1xuICB2YXIgZmlsZXMgPSBPYmplY3Qua2V5cyh6aXAuZmlsZXMpLnNsaWNlKDAsIDEwKTtcbiAgdmFyIG1zZyA9IFwiXCI7XG4gIGlmIChmaWxlcy5sZW5ndGggPT09IDApIHtcbiAgICBtc2cgPSBcIkVtcHR5IHppcCBmaWxlXCI7XG4gIH0gZWxzZSB7XG4gICAgbXNnID0gXCJaaXAgZmlsZSBjb250YWlucyA6IFwiLmNvbmNhdChmaWxlcy5qb2luKFwiLFwiKSk7XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJUaGUgZmlsZXR5cGUgZm9yIHRoaXMgZmlsZSBjb3VsZCBub3QgYmUgaWRlbnRpZmllZCwgaXMgdGhpcyBmaWxlIGNvcnJ1cHRlZCA/IFwiLmNvbmNhdChtc2cpKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiZmlsZXR5cGVfbm90X2lkZW50aWZpZWRcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgZmlsZXR5cGUgZm9yIHRoaXMgZmlsZSBjb3VsZCBub3QgYmUgaWRlbnRpZmllZCwgaXMgdGhpcyBmaWxlIGNvcnJ1cHRlZCA/IFwiLmNvbmNhdChtc2cpXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93WG1sSW52YWxpZChjb250ZW50LCBvZmZzZXQpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJBbiBYTUwgZmlsZSBoYXMgaW52YWxpZCB4bWxcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImZpbGVfaGFzX2ludmFsaWRfeG1sXCIsXG4gICAgY29udGVudDogY29udGVudCxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgZG9jeCBjb250YWlucyBpbnZhbGlkIFhNTCwgaXQgaXMgbW9zdCBsaWtlbHkgY29ycnVwdFwiXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIHRocm93RmlsZVR5cGVOb3RIYW5kbGVkKGZpbGVUeXBlKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiVGhlIGZpbGV0eXBlIFxcXCJcIi5jb25jYXQoZmlsZVR5cGUsIFwiXFxcIiBpcyBub3QgaGFuZGxlZCBieSBkb2N4dGVtcGxhdGVyXCIpKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwiZmlsZXR5cGVfbm90X2hhbmRsZWRcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgZmlsZSB5b3UgYXJlIHRyeWluZyB0byBnZW5lcmF0ZSBpcyBvZiB0eXBlIFxcXCJcIi5jb25jYXQoZmlsZVR5cGUsIFwiXFxcIiwgYnV0IG9ubHkgZG9jeCBhbmQgcHB0eCBmb3JtYXRzIGFyZSBoYW5kbGVkXCIpLFxuICAgIGZpbGVUeXBlOiBmaWxlVHlwZVxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgWFRFcnJvcjogWFRFcnJvcixcbiAgWFRUZW1wbGF0ZUVycm9yOiBYVFRlbXBsYXRlRXJyb3IsXG4gIFhUSW50ZXJuYWxFcnJvcjogWFRJbnRlcm5hbEVycm9yLFxuICBYVFNjb3BlUGFyc2VyRXJyb3I6IFhUU2NvcGVQYXJzZXJFcnJvcixcbiAgWFRBUElWZXJzaW9uRXJyb3I6IFhUQVBJVmVyc2lvbkVycm9yLFxuICAvLyBSZW1vdmUgdGhpcyBhbGlhcyBpbiB2NFxuICBSZW5kZXJpbmdFcnJvcjogWFRSZW5kZXJpbmdFcnJvcixcbiAgWFRSZW5kZXJpbmdFcnJvcjogWFRSZW5kZXJpbmdFcnJvcixcbiAgZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZzogZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyxcbiAgZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3I6IGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yLFxuICBnZXRTY29wZUNvbXBpbGF0aW9uRXJyb3I6IGdldFNjb3BlQ29tcGlsYXRpb25FcnJvcixcbiAgZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcjogZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcixcbiAgZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb246IGdldFVuY2xvc2VkVGFnRXhjZXB0aW9uLFxuICBnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbjogZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb24sXG4gIGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb246IGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24sXG4gIGdldER1cGxpY2F0ZUNsb3NlVGFnRXhjZXB0aW9uOiBnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbixcbiAgZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbjogZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbixcbiAgZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb246IGdldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uLFxuICBnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb246IGdldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbixcbiAgZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb246IGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uLFxuICB0aHJvd0FwaVZlcnNpb25FcnJvcjogdGhyb3dBcGlWZXJzaW9uRXJyb3IsXG4gIHRocm93RmlsZVR5cGVOb3RIYW5kbGVkOiB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZCxcbiAgdGhyb3dGaWxlVHlwZU5vdElkZW50aWZpZWQ6IHRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkLFxuICB0aHJvd01hbGZvcm1lZFhtbDogdGhyb3dNYWxmb3JtZWRYbWwsXG4gIHRocm93TXVsdGlFcnJvcjogdGhyb3dNdWx0aUVycm9yLFxuICB0aHJvd0V4cGFuZE5vdEZvdW5kOiB0aHJvd0V4cGFuZE5vdEZvdW5kLFxuICB0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaDogdGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGgsXG4gIHRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGU6IHRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGUsXG4gIHRocm93WG1sVGFnTm90Rm91bmQ6IHRocm93WG1sVGFnTm90Rm91bmQsXG4gIHRocm93WG1sSW52YWxpZDogdGhyb3dYbWxJbnZhbGlkLFxuICB0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlOiB0aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlLFxuICB0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZTogdGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGUsXG4gIHRocm93UmVuZGVyVHdpY2U6IHRocm93UmVuZGVyVHdpY2Vcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/file-type-config.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/file-type-config.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar loopModule = __webpack_require__(/*! ./modules/loop.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/loop.js\");\nvar spacePreserveModule = __webpack_require__(/*! ./modules/space-preserve.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/space-preserve.js\");\nvar rawXmlModule = __webpack_require__(/*! ./modules/rawxml.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/rawxml.js\");\nvar expandPairTrait = __webpack_require__(/*! ./modules/expand-pair-trait.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/expand-pair-trait.js\");\nvar render = __webpack_require__(/*! ./modules/render.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/render.js\");\nfunction DocXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles() {\n      return [];\n    },\n    textPath: function textPath(doc) {\n      return doc.textTarget;\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"cp:contentStatus\", \"w:t\", \"a:t\", \"m:t\", \"vt:lpstr\", \"vt:lpwstr\"],\n    tagsXmlLexedArray: [\"w:proofState\", \"w:tc\", \"w:tr\", \"w:tbl\", \"w:body\", \"w:document\", \"w:p\", \"w:r\", \"w:br\", \"w:rPr\", \"w:pPr\", \"w:spacing\", \"w:sdtContent\", \"w:sdt\", \"w:drawing\", \"w:sectPr\", \"w:type\", \"w:headerReference\", \"w:footerReference\", \"w:bookmarkStart\", \"w:bookmarkEnd\", \"w:commentRangeStart\", \"w:commentRangeEnd\", \"w:commentReference\"],\n    droppedTagsInsidePlaceholder: [\"w:p\", \"w:br\", \"w:bookmarkStart\", \"w:bookmarkEnd\"],\n    expandTags: [{\n      contains: \"w:tc\",\n      expand: \"w:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"w:p\",\n      expand: \"w:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"w:p\",\n    baseModules: [loopModule, spacePreserveModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"w:sdtContent\",\n      shouldContain: [\"w:p\", \"w:r\", \"w:commentRangeStart\", \"w:sdt\"],\n      value: \"<w:p></w:p>\"\n    }, {\n      tag: \"w:tc\",\n      shouldContain: [\"w:p\"],\n      value: \"<w:p></w:p>\"\n    }, {\n      tag: \"w:tr\",\n      shouldContain: [\"w:tc\"],\n      drop: true\n    }, {\n      tag: \"w:tbl\",\n      shouldContain: [\"w:tr\"],\n      drop: true\n    }]\n  };\n}\nfunction PptXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles() {\n      return [];\n    },\n    textPath: function textPath(doc) {\n      return doc.textTarget;\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"a:t\", \"m:t\", \"vt:lpstr\", \"vt:lpwstr\"],\n    tagsXmlLexedArray: [\"p:sp\", \"a:tc\", \"a:tr\", \"a:tbl\", \"a:graphicData\", \"a:p\", \"a:r\", \"a:rPr\", \"p:txBody\", \"a:txBody\", \"a:off\", \"a:ext\", \"p:graphicFrame\", \"p:xfrm\", \"a16:rowId\", \"a:endParaRPr\"],\n    droppedTagsInsidePlaceholder: [\"a:p\", \"a:endParaRPr\"],\n    expandTags: [{\n      contains: \"a:tc\",\n      expand: \"a:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"a:p\",\n      expand: \"a:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"p:sp\",\n    baseModules: [loopModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"a:tbl\",\n      shouldContain: [\"a:tr\"],\n      dropParent: \"p:graphicFrame\"\n    }, {\n      tag: \"p:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }, {\n      tag: \"a:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }]\n  };\n}\nmodule.exports = {\n  docx: DocXFileTypeConfig,\n  pptx: PptXFileTypeConfig\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZmlsZS10eXBlLWNvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyx3SEFBbUI7QUFDNUMsMEJBQTBCLG1CQUFPLENBQUMsNElBQTZCO0FBQy9ELG1CQUFtQixtQkFBTyxDQUFDLDRIQUFxQjtBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyxrSkFBZ0M7QUFDOUQsYUFBYSxtQkFBTyxDQUFDLDRIQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZmlsZS10eXBlLWNvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIGxvb3BNb2R1bGUgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2xvb3AuanNcIik7XG52YXIgc3BhY2VQcmVzZXJ2ZU1vZHVsZSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvc3BhY2UtcHJlc2VydmUuanNcIik7XG52YXIgcmF3WG1sTW9kdWxlID0gcmVxdWlyZShcIi4vbW9kdWxlcy9yYXd4bWwuanNcIik7XG52YXIgZXhwYW5kUGFpclRyYWl0ID0gcmVxdWlyZShcIi4vbW9kdWxlcy9leHBhbmQtcGFpci10cmFpdC5qc1wiKTtcbnZhciByZW5kZXIgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3JlbmRlci5qc1wiKTtcbmZ1bmN0aW9uIERvY1hGaWxlVHlwZUNvbmZpZygpIHtcbiAgcmV0dXJuIHtcbiAgICBnZXRUZW1wbGF0ZWRGaWxlczogZnVuY3Rpb24gZ2V0VGVtcGxhdGVkRmlsZXMoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICB0ZXh0UGF0aDogZnVuY3Rpb24gdGV4dFBhdGgoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLnRleHRUYXJnZXQ7XG4gICAgfSxcbiAgICB0YWdzWG1sVGV4dEFycmF5OiBbXCJDb21wYW55XCIsIFwiSHlwZXJsaW5rQmFzZVwiLCBcIk1hbmFnZXJcIiwgXCJjcDpjYXRlZ29yeVwiLCBcImNwOmtleXdvcmRzXCIsIFwiZGM6Y3JlYXRvclwiLCBcImRjOmRlc2NyaXB0aW9uXCIsIFwiZGM6c3ViamVjdFwiLCBcImRjOnRpdGxlXCIsIFwiY3A6Y29udGVudFN0YXR1c1wiLCBcInc6dFwiLCBcImE6dFwiLCBcIm06dFwiLCBcInZ0Omxwc3RyXCIsIFwidnQ6bHB3c3RyXCJdLFxuICAgIHRhZ3NYbWxMZXhlZEFycmF5OiBbXCJ3OnByb29mU3RhdGVcIiwgXCJ3OnRjXCIsIFwidzp0clwiLCBcInc6dGJsXCIsIFwidzpib2R5XCIsIFwidzpkb2N1bWVudFwiLCBcInc6cFwiLCBcInc6clwiLCBcInc6YnJcIiwgXCJ3OnJQclwiLCBcInc6cFByXCIsIFwidzpzcGFjaW5nXCIsIFwidzpzZHRDb250ZW50XCIsIFwidzpzZHRcIiwgXCJ3OmRyYXdpbmdcIiwgXCJ3OnNlY3RQclwiLCBcInc6dHlwZVwiLCBcInc6aGVhZGVyUmVmZXJlbmNlXCIsIFwidzpmb290ZXJSZWZlcmVuY2VcIiwgXCJ3OmJvb2ttYXJrU3RhcnRcIiwgXCJ3OmJvb2ttYXJrRW5kXCIsIFwidzpjb21tZW50UmFuZ2VTdGFydFwiLCBcInc6Y29tbWVudFJhbmdlRW5kXCIsIFwidzpjb21tZW50UmVmZXJlbmNlXCJdLFxuICAgIGRyb3BwZWRUYWdzSW5zaWRlUGxhY2Vob2xkZXI6IFtcInc6cFwiLCBcInc6YnJcIiwgXCJ3OmJvb2ttYXJrU3RhcnRcIiwgXCJ3OmJvb2ttYXJrRW5kXCJdLFxuICAgIGV4cGFuZFRhZ3M6IFt7XG4gICAgICBjb250YWluczogXCJ3OnRjXCIsXG4gICAgICBleHBhbmQ6IFwidzp0clwiXG4gICAgfV0sXG4gICAgb25QYXJhZ3JhcGhMb29wOiBbe1xuICAgICAgY29udGFpbnM6IFwidzpwXCIsXG4gICAgICBleHBhbmQ6IFwidzpwXCIsXG4gICAgICBvbmx5VGV4dEluVGFnOiB0cnVlXG4gICAgfV0sXG4gICAgdGFnUmF3WG1sOiBcInc6cFwiLFxuICAgIGJhc2VNb2R1bGVzOiBbbG9vcE1vZHVsZSwgc3BhY2VQcmVzZXJ2ZU1vZHVsZSwgZXhwYW5kUGFpclRyYWl0LCByYXdYbWxNb2R1bGUsIHJlbmRlcl0sXG4gICAgdGFnU2hvdWxkQ29udGFpbjogW3tcbiAgICAgIHRhZzogXCJ3OnNkdENvbnRlbnRcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcInc6cFwiLCBcInc6clwiLCBcInc6Y29tbWVudFJhbmdlU3RhcnRcIiwgXCJ3OnNkdFwiXSxcbiAgICAgIHZhbHVlOiBcIjx3OnA+PC93OnA+XCJcbiAgICB9LCB7XG4gICAgICB0YWc6IFwidzp0Y1wiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1widzpwXCJdLFxuICAgICAgdmFsdWU6IFwiPHc6cD48L3c6cD5cIlxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJ3OnRyXCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJ3OnRjXCJdLFxuICAgICAgZHJvcDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJ3OnRibFwiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1widzp0clwiXSxcbiAgICAgIGRyb3A6IHRydWVcbiAgICB9XVxuICB9O1xufVxuZnVuY3Rpb24gUHB0WEZpbGVUeXBlQ29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIGdldFRlbXBsYXRlZEZpbGVzOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZWRGaWxlcygpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHRleHRQYXRoOiBmdW5jdGlvbiB0ZXh0UGF0aChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MudGV4dFRhcmdldDtcbiAgICB9LFxuICAgIHRhZ3NYbWxUZXh0QXJyYXk6IFtcIkNvbXBhbnlcIiwgXCJIeXBlcmxpbmtCYXNlXCIsIFwiTWFuYWdlclwiLCBcImNwOmNhdGVnb3J5XCIsIFwiY3A6a2V5d29yZHNcIiwgXCJkYzpjcmVhdG9yXCIsIFwiZGM6ZGVzY3JpcHRpb25cIiwgXCJkYzpzdWJqZWN0XCIsIFwiZGM6dGl0bGVcIiwgXCJhOnRcIiwgXCJtOnRcIiwgXCJ2dDpscHN0clwiLCBcInZ0Omxwd3N0clwiXSxcbiAgICB0YWdzWG1sTGV4ZWRBcnJheTogW1wicDpzcFwiLCBcImE6dGNcIiwgXCJhOnRyXCIsIFwiYTp0YmxcIiwgXCJhOmdyYXBoaWNEYXRhXCIsIFwiYTpwXCIsIFwiYTpyXCIsIFwiYTpyUHJcIiwgXCJwOnR4Qm9keVwiLCBcImE6dHhCb2R5XCIsIFwiYTpvZmZcIiwgXCJhOmV4dFwiLCBcInA6Z3JhcGhpY0ZyYW1lXCIsIFwicDp4ZnJtXCIsIFwiYTE2OnJvd0lkXCIsIFwiYTplbmRQYXJhUlByXCJdLFxuICAgIGRyb3BwZWRUYWdzSW5zaWRlUGxhY2Vob2xkZXI6IFtcImE6cFwiLCBcImE6ZW5kUGFyYVJQclwiXSxcbiAgICBleHBhbmRUYWdzOiBbe1xuICAgICAgY29udGFpbnM6IFwiYTp0Y1wiLFxuICAgICAgZXhwYW5kOiBcImE6dHJcIlxuICAgIH1dLFxuICAgIG9uUGFyYWdyYXBoTG9vcDogW3tcbiAgICAgIGNvbnRhaW5zOiBcImE6cFwiLFxuICAgICAgZXhwYW5kOiBcImE6cFwiLFxuICAgICAgb25seVRleHRJblRhZzogdHJ1ZVxuICAgIH1dLFxuICAgIHRhZ1Jhd1htbDogXCJwOnNwXCIsXG4gICAgYmFzZU1vZHVsZXM6IFtsb29wTW9kdWxlLCBleHBhbmRQYWlyVHJhaXQsIHJhd1htbE1vZHVsZSwgcmVuZGVyXSxcbiAgICB0YWdTaG91bGRDb250YWluOiBbe1xuICAgICAgdGFnOiBcImE6dGJsXCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJhOnRyXCJdLFxuICAgICAgZHJvcFBhcmVudDogXCJwOmdyYXBoaWNGcmFtZVwiXG4gICAgfSwge1xuICAgICAgdGFnOiBcInA6dHhCb2R5XCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJhOnBcIl0sXG4gICAgICB2YWx1ZTogXCI8YTpwPjwvYTpwPlwiXG4gICAgfSwge1xuICAgICAgdGFnOiBcImE6dHhCb2R5XCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJhOnBcIl0sXG4gICAgICB2YWx1ZTogXCI8YTpwPjwvYTpwPlwiXG4gICAgfV1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkb2N4OiBEb2NYRmlsZVR5cGVDb25maWcsXG4gIHBwdHg6IFBwdFhGaWxlVHlwZUNvbmZpZ1xufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/file-type-config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/filetypes.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/filetypes.js ***!
  \********************************************************************************************/
/***/ ((module) => {

eval("\n\nvar docxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\";\nvar docxmContentType = \"application/vnd.ms-word.document.macroEnabled.main+xml\";\nvar dotxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\";\nvar dotmContentType = \"application/vnd.ms-word.template.macroEnabledTemplate.main+xml\";\nvar headerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\";\nvar footnotesContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\";\nvar commentsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml\";\nvar footerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\";\nvar pptxContentType = \"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\";\nvar pptxSlideMaster = \"application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml\";\nvar pptxSlideLayout = \"application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml\";\nvar pptxPresentationContentType = \"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\";\nvar xlsxContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\";\nvar xlsmContentType = \"application/vnd.ms-excel.sheet.macroEnabled.main+xml\";\nvar xlsxWorksheetContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\";\n/*\n * This is used for the main part of the document, ie usually that would be the\n * type of word/document.xml\n */\nvar main = [docxContentType, docxmContentType, dotxContentType, dotmContentType];\nvar filetypes = {\n  main: main,\n  docx: [headerContentType].concat(main, [footerContentType, footnotesContentType, commentsContentType]),\n  pptx: [pptxContentType, pptxSlideMaster, pptxSlideLayout, pptxPresentationContentType],\n  xlsx: [xlsxContentType, xlsmContentType, xlsxWorksheetContentType]\n};\nmodule.exports = filetypes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZmlsZXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZmlsZXR5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZG9jeENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudC5tYWluK3htbFwiO1xudmFyIGRvY3htQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLmRvY3VtZW50Lm1hY3JvRW5hYmxlZC5tYWluK3htbFwiO1xudmFyIGRvdHhDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwudGVtcGxhdGUubWFpbit4bWxcIjtcbnZhciBkb3RtQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5tcy13b3JkLnRlbXBsYXRlLm1hY3JvRW5hYmxlZFRlbXBsYXRlLm1haW4reG1sXCI7XG52YXIgaGVhZGVyQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmhlYWRlcit4bWxcIjtcbnZhciBmb290bm90ZXNDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZm9vdG5vdGVzK3htbFwiO1xudmFyIGNvbW1lbnRzQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmNvbW1lbnRzK3htbFwiO1xudmFyIGZvb3RlckNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5mb290ZXIreG1sXCI7XG52YXIgcHB0eENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGUreG1sXCI7XG52YXIgcHB0eFNsaWRlTWFzdGVyID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGVNYXN0ZXIreG1sXCI7XG52YXIgcHB0eFNsaWRlTGF5b3V0ID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGVMYXlvdXQreG1sXCI7XG52YXIgcHB0eFByZXNlbnRhdGlvbkNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uLm1haW4reG1sXCI7XG52YXIgeGxzeENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldC5tYWluK3htbFwiO1xudmFyIHhsc21Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnNoZWV0Lm1hY3JvRW5hYmxlZC5tYWluK3htbFwiO1xudmFyIHhsc3hXb3Jrc2hlZXRDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwud29ya3NoZWV0K3htbFwiO1xuLypcbiAqIFRoaXMgaXMgdXNlZCBmb3IgdGhlIG1haW4gcGFydCBvZiB0aGUgZG9jdW1lbnQsIGllIHVzdWFsbHkgdGhhdCB3b3VsZCBiZSB0aGVcbiAqIHR5cGUgb2Ygd29yZC9kb2N1bWVudC54bWxcbiAqL1xudmFyIG1haW4gPSBbZG9jeENvbnRlbnRUeXBlLCBkb2N4bUNvbnRlbnRUeXBlLCBkb3R4Q29udGVudFR5cGUsIGRvdG1Db250ZW50VHlwZV07XG52YXIgZmlsZXR5cGVzID0ge1xuICBtYWluOiBtYWluLFxuICBkb2N4OiBbaGVhZGVyQ29udGVudFR5cGVdLmNvbmNhdChtYWluLCBbZm9vdGVyQ29udGVudFR5cGUsIGZvb3Rub3Rlc0NvbnRlbnRUeXBlLCBjb21tZW50c0NvbnRlbnRUeXBlXSksXG4gIHBwdHg6IFtwcHR4Q29udGVudFR5cGUsIHBwdHhTbGlkZU1hc3RlciwgcHB0eFNsaWRlTGF5b3V0LCBwcHR4UHJlc2VudGF0aW9uQ29udGVudFR5cGVdLFxuICB4bHN4OiBbeGxzeENvbnRlbnRUeXBlLCB4bHNtQ29udGVudFR5cGUsIHhsc3hXb3Jrc2hlZXRDb250ZW50VHlwZV1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZpbGV0eXBlczsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/filetypes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/get-resolved-id.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/get-resolved-id.js ***!
  \**************************************************************************************************/
/***/ ((module) => {

eval("\n\nfunction getResolvedId(part, options) {\n  if (part.lIndex == null) {\n    return null;\n  }\n  var path = options.scopeManager.scopePathItem;\n  if (part.parentPart) {\n    path = path.slice(0, path.length - 1);\n  }\n  var res = options.filePath + \"@\" + part.lIndex.toString() + \"-\" + path.join(\"-\");\n  return res;\n}\nmodule.exports = getResolvedId;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZ2V0LXJlc29sdmVkLWlkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZ2V0LXJlc29sdmVkLWlkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBnZXRSZXNvbHZlZElkKHBhcnQsIG9wdGlvbnMpIHtcbiAgaWYgKHBhcnQubEluZGV4ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcGF0aCA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyLnNjb3BlUGF0aEl0ZW07XG4gIGlmIChwYXJ0LnBhcmVudFBhcnQpIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICB9XG4gIHZhciByZXMgPSBvcHRpb25zLmZpbGVQYXRoICsgXCJAXCIgKyBwYXJ0LmxJbmRleC50b1N0cmluZygpICsgXCItXCIgKyBwYXRoLmpvaW4oXCItXCIpO1xuICByZXR1cm4gcmVzO1xufVxubW9kdWxlLmV4cG9ydHMgPSBnZXRSZXNvbHZlZElkOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/get-resolved-id.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/join-uncorrupt.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/join-uncorrupt.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  startsWith = _require.startsWith,\n  endsWith = _require.endsWith,\n  isStarting = _require.isStarting,\n  isEnding = _require.isEnding,\n  isWhiteSpace = _require.isWhiteSpace;\nvar filetypes = __webpack_require__(/*! ./filetypes.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/filetypes.js\");\nfunction addEmptyParagraphAfterTable(parts) {\n  var lastNonEmpty = \"\";\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var p = parts[i];\n    if (isWhiteSpace(p) || startsWith(p, \"<w:bookmarkEnd\")) {\n      continue;\n    }\n    if (endsWith(lastNonEmpty, \"</w:tbl>\")) {\n      if (!startsWith(p, \"<w:p\") && !startsWith(p, \"<w:tbl\") && !startsWith(p, \"<w:sectPr\")) {\n        p = \"<w:p/>\".concat(p);\n      }\n    }\n    lastNonEmpty = p;\n    parts[i] = p;\n  }\n  return parts;\n}\n\n// eslint-disable-next-line complexity\nfunction joinUncorrupt(parts, options) {\n  var contains = options.fileTypeConfig.tagShouldContain || [];\n  /*\n   * Before doing this \"uncorruption\" method here, this was done with the\n   * `part.emptyValue` trick, however, there were some corruptions that were\n   * not handled, for example with a template like this :\n   *\n   * ------------------------------------------------\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * ------------------------------------------------\n   */\n  var collecting = \"\";\n  var currentlyCollecting = -1;\n  if (filetypes.docx.indexOf(options.contentType) !== -1) {\n    parts = addEmptyParagraphAfterTable(parts);\n  }\n  var startIndex = -1;\n  for (var j = 0, len2 = contains.length; j < len2; j++) {\n    var _contains$j = contains[j],\n      tag = _contains$j.tag,\n      shouldContain = _contains$j.shouldContain,\n      value = _contains$j.value,\n      drop = _contains$j.drop,\n      dropParent = _contains$j.dropParent;\n    for (var i = 0, len = parts.length; i < len; i++) {\n      var part = parts[i];\n      if (currentlyCollecting === j) {\n        if (isEnding(part, tag)) {\n          currentlyCollecting = -1;\n          if (dropParent) {\n            var start = -1;\n            for (var k = startIndex; k > 0; k--) {\n              if (isStarting(parts[k], dropParent)) {\n                start = k;\n                break;\n              }\n            }\n            for (var _k = start; _k <= parts.length; _k++) {\n              if (isEnding(parts[_k], dropParent)) {\n                parts[_k] = \"\";\n                break;\n              }\n              parts[_k] = \"\";\n            }\n          } else {\n            for (var _k2 = startIndex; _k2 <= i; _k2++) {\n              parts[_k2] = \"\";\n            }\n            if (!drop) {\n              parts[i] = collecting + value + part;\n            }\n          }\n        }\n        collecting += part;\n        for (var _k3 = 0, len3 = shouldContain.length; _k3 < len3; _k3++) {\n          var sc = shouldContain[_k3];\n          if (isStarting(part, sc)) {\n            currentlyCollecting = -1;\n            break;\n          }\n        }\n      }\n      if (currentlyCollecting === -1 && isStarting(part, tag) &&\n      /*\n       * To verify that the part doesn't have multiple tags,\n       * such as <w:tc><w:p>\n       */\n      part.substr(1).indexOf(\"<\") === -1) {\n        // self-closing tag such as <w:t/>\n        if (part[part.length - 2] === \"/\") {\n          parts[i] = \"\";\n        } else {\n          startIndex = i;\n          currentlyCollecting = j;\n          collecting = part;\n        }\n      }\n    }\n  }\n  return parts;\n}\nmodule.exports = joinUncorrupt;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvam9pbi11bmNvcnJ1cHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLGtIQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsa0hBQWdCO0FBQ3hDO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVyxRQUFRLFVBQVU7QUFDckMsUUFBUSxXQUFXLFFBQVEsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQkFBb0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvam9pbi11bmNvcnJ1cHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgc3RhcnRzV2l0aCA9IF9yZXF1aXJlLnN0YXJ0c1dpdGgsXG4gIGVuZHNXaXRoID0gX3JlcXVpcmUuZW5kc1dpdGgsXG4gIGlzU3RhcnRpbmcgPSBfcmVxdWlyZS5pc1N0YXJ0aW5nLFxuICBpc0VuZGluZyA9IF9yZXF1aXJlLmlzRW5kaW5nLFxuICBpc1doaXRlU3BhY2UgPSBfcmVxdWlyZS5pc1doaXRlU3BhY2U7XG52YXIgZmlsZXR5cGVzID0gcmVxdWlyZShcIi4vZmlsZXR5cGVzLmpzXCIpO1xuZnVuY3Rpb24gYWRkRW1wdHlQYXJhZ3JhcGhBZnRlclRhYmxlKHBhcnRzKSB7XG4gIHZhciBsYXN0Tm9uRW1wdHkgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcCA9IHBhcnRzW2ldO1xuICAgIGlmIChpc1doaXRlU3BhY2UocCkgfHwgc3RhcnRzV2l0aChwLCBcIjx3OmJvb2ttYXJrRW5kXCIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGVuZHNXaXRoKGxhc3ROb25FbXB0eSwgXCI8L3c6dGJsPlwiKSkge1xuICAgICAgaWYgKCFzdGFydHNXaXRoKHAsIFwiPHc6cFwiKSAmJiAhc3RhcnRzV2l0aChwLCBcIjx3OnRibFwiKSAmJiAhc3RhcnRzV2l0aChwLCBcIjx3OnNlY3RQclwiKSkge1xuICAgICAgICBwID0gXCI8dzpwLz5cIi5jb25jYXQocCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3ROb25FbXB0eSA9IHA7XG4gICAgcGFydHNbaV0gPSBwO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIGpvaW5VbmNvcnJ1cHQocGFydHMsIG9wdGlvbnMpIHtcbiAgdmFyIGNvbnRhaW5zID0gb3B0aW9ucy5maWxlVHlwZUNvbmZpZy50YWdTaG91bGRDb250YWluIHx8IFtdO1xuICAvKlxuICAgKiBCZWZvcmUgZG9pbmcgdGhpcyBcInVuY29ycnVwdGlvblwiIG1ldGhvZCBoZXJlLCB0aGlzIHdhcyBkb25lIHdpdGggdGhlXG4gICAqIGBwYXJ0LmVtcHR5VmFsdWVgIHRyaWNrLCBob3dldmVyLCB0aGVyZSB3ZXJlIHNvbWUgY29ycnVwdGlvbnMgdGhhdCB3ZXJlXG4gICAqIG5vdCBoYW5kbGVkLCBmb3IgZXhhbXBsZSB3aXRoIGEgdGVtcGxhdGUgbGlrZSB0aGlzIDpcbiAgICpcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIHwgey13OnAgZmFsc3l9TXkgcGFyYXsvZmFsc3l9ICAgfCAgICAgICAgICAgICAgfFxuICAgKiB8IHstdzpwIGZhbHN5fU15IHBhcmF7L2ZhbHN5fSAgIHwgICAgICAgICAgICAgIHxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICB2YXIgY29sbGVjdGluZyA9IFwiXCI7XG4gIHZhciBjdXJyZW50bHlDb2xsZWN0aW5nID0gLTE7XG4gIGlmIChmaWxldHlwZXMuZG9jeC5pbmRleE9mKG9wdGlvbnMuY29udGVudFR5cGUpICE9PSAtMSkge1xuICAgIHBhcnRzID0gYWRkRW1wdHlQYXJhZ3JhcGhBZnRlclRhYmxlKHBhcnRzKTtcbiAgfVxuICB2YXIgc3RhcnRJbmRleCA9IC0xO1xuICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IGNvbnRhaW5zLmxlbmd0aDsgaiA8IGxlbjI7IGorKykge1xuICAgIHZhciBfY29udGFpbnMkaiA9IGNvbnRhaW5zW2pdLFxuICAgICAgdGFnID0gX2NvbnRhaW5zJGoudGFnLFxuICAgICAgc2hvdWxkQ29udGFpbiA9IF9jb250YWlucyRqLnNob3VsZENvbnRhaW4sXG4gICAgICB2YWx1ZSA9IF9jb250YWlucyRqLnZhbHVlLFxuICAgICAgZHJvcCA9IF9jb250YWlucyRqLmRyb3AsXG4gICAgICBkcm9wUGFyZW50ID0gX2NvbnRhaW5zJGouZHJvcFBhcmVudDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAoY3VycmVudGx5Q29sbGVjdGluZyA9PT0gaikge1xuICAgICAgICBpZiAoaXNFbmRpbmcocGFydCwgdGFnKSkge1xuICAgICAgICAgIGN1cnJlbnRseUNvbGxlY3RpbmcgPSAtMTtcbiAgICAgICAgICBpZiAoZHJvcFBhcmVudCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gc3RhcnRJbmRleDsgayA+IDA7IGstLSkge1xuICAgICAgICAgICAgICBpZiAoaXNTdGFydGluZyhwYXJ0c1trXSwgZHJvcFBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGs7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIF9rID0gc3RhcnQ7IF9rIDw9IHBhcnRzLmxlbmd0aDsgX2srKykge1xuICAgICAgICAgICAgICBpZiAoaXNFbmRpbmcocGFydHNbX2tdLCBkcm9wUGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzW19rXSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFydHNbX2tdID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgX2syID0gc3RhcnRJbmRleDsgX2syIDw9IGk7IF9rMisrKSB7XG4gICAgICAgICAgICAgIHBhcnRzW19rMl0gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkcm9wKSB7XG4gICAgICAgICAgICAgIHBhcnRzW2ldID0gY29sbGVjdGluZyArIHZhbHVlICsgcGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29sbGVjdGluZyArPSBwYXJ0O1xuICAgICAgICBmb3IgKHZhciBfazMgPSAwLCBsZW4zID0gc2hvdWxkQ29udGFpbi5sZW5ndGg7IF9rMyA8IGxlbjM7IF9rMysrKSB7XG4gICAgICAgICAgdmFyIHNjID0gc2hvdWxkQ29udGFpbltfazNdO1xuICAgICAgICAgIGlmIChpc1N0YXJ0aW5nKHBhcnQsIHNjKSkge1xuICAgICAgICAgICAgY3VycmVudGx5Q29sbGVjdGluZyA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudGx5Q29sbGVjdGluZyA9PT0gLTEgJiYgaXNTdGFydGluZyhwYXJ0LCB0YWcpICYmXG4gICAgICAvKlxuICAgICAgICogVG8gdmVyaWZ5IHRoYXQgdGhlIHBhcnQgZG9lc24ndCBoYXZlIG11bHRpcGxlIHRhZ3MsXG4gICAgICAgKiBzdWNoIGFzIDx3OnRjPjx3OnA+XG4gICAgICAgKi9cbiAgICAgIHBhcnQuc3Vic3RyKDEpLmluZGV4T2YoXCI8XCIpID09PSAtMSkge1xuICAgICAgICAvLyBzZWxmLWNsb3NpbmcgdGFnIHN1Y2ggYXMgPHc6dC8+XG4gICAgICAgIGlmIChwYXJ0W3BhcnQubGVuZ3RoIC0gMl0gPT09IFwiL1wiKSB7XG4gICAgICAgICAgcGFydHNbaV0gPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0SW5kZXggPSBpO1xuICAgICAgICAgIGN1cnJlbnRseUNvbGxlY3RpbmcgPSBqO1xuICAgICAgICAgIGNvbGxlY3RpbmcgPSBwYXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbm1vZHVsZS5leHBvcnRzID0gam9pblVuY29ycnVwdDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/join-uncorrupt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/lexer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/lexer.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\"),\n  getUnclosedTagException = _require.getUnclosedTagException,\n  getUnopenedTagException = _require.getUnopenedTagException,\n  getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n  getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n  throwMalformedXml = _require.throwMalformedXml,\n  throwXmlInvalid = _require.throwXmlInvalid,\n  XTTemplateError = _require.XTTemplateError;\nvar _require2 = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  isTextStart = _require2.isTextStart,\n  isTextEnd = _require2.isTextEnd,\n  wordToUtf8 = _require2.wordToUtf8;\nvar DELIMITER_NONE = 0,\n  DELIMITER_EQUAL = 1,\n  DELIMITER_START = 2,\n  DELIMITER_END = 3;\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml();\n    }\n    return true;\n  }\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml();\n    }\n    return false;\n  }\n  return inTextTag;\n}\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = {};\n  for (var _i2 = 0; _i2 < textMatchArray.length; _i2++) {\n    var m = textMatchArray[_i2];\n    allMatches[m] = true;\n  }\n  for (var _i4 = 0; _i4 < othersMatchArray.length; _i4++) {\n    var _m = othersMatchArray[_i4];\n    allMatches[_m] = false;\n  }\n  var totalMatches = [];\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n    if (cursor === -1) {\n      break;\n    }\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n    var tagText = content.slice(offset, cursor + 1);\n    var _getTag = getTag(tagText),\n      tag = _getTag.tag,\n      position = _getTag.position;\n    var text = allMatches[tag];\n    if (text == null) {\n      continue;\n    }\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n  return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText, syntaxOptions) {\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  var delimiterWithErrors = delimiterMatches.reduce(function (delimiterAcc, currDelimiterMatch) {\n    var position = currDelimiterMatch.position;\n    var delimiterOffset = currDelimiterMatch.offset;\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    var lastDelimiterLength = lastDelimiterMatch.length;\n    xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset);\n    if (inDelimiter && position === \"start\") {\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        if (!syntaxOptions.allowUnclosedTag) {\n          errors.push(getDuplicateOpenTagException({\n            xtag: xtag,\n            offset: lastDelimiterOffset\n          }));\n          lastDelimiterMatch = currDelimiterMatch;\n          delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n            error: true\n          }));\n          return delimiterAcc;\n        }\n      }\n      if (!syntaxOptions.allowUnclosedTag) {\n        errors.push(getUnclosedTagException({\n          xtag: wordToUtf8(xtag),\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      delimiterAcc.pop();\n    }\n    if (!inDelimiter && position === \"end\") {\n      if (syntaxOptions.allowUnopenedTag) {\n        return delimiterAcc;\n      }\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset - 4, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        errors.push(getDuplicateCloseTagException({\n          xtag: xtag,\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      errors.push(getUnopenedTagException({\n        xtag: xtag,\n        offset: delimiterOffset\n      }));\n      lastDelimiterMatch = currDelimiterMatch;\n      delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n        error: true\n      }));\n      return delimiterAcc;\n    }\n    inDelimiter = position === \"start\";\n    lastDelimiterMatch = currDelimiterMatch;\n    delimiterAcc.push(currDelimiterMatch);\n    return delimiterAcc;\n  }, []);\n  if (inDelimiter) {\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    xtag = fullText.substr(lastDelimiterOffset, fullText.length - lastDelimiterOffset);\n    if (!syntaxOptions.allowUnclosedTag) {\n      errors.push(getUnclosedTagException({\n        xtag: wordToUtf8(xtag),\n        offset: lastDelimiterOffset\n      }));\n    } else {\n      delimiterWithErrors.pop();\n    }\n  }\n  return {\n    delimiterWithErrors: delimiterWithErrors,\n    errors: errors\n  };\n}\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return DELIMITER_NONE;\n  }\n  if (startOffset === endOffset) {\n    return DELIMITER_EQUAL;\n  }\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n  }\n  return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n  if (newDelimiters.length !== 2) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n    start = _newDelimiters[0],\n    end = _newDelimiters[1];\n  if (start.length === 0 || end.length === 0) {\n    var _err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    _err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw _err;\n  }\n  return [start, end];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters, syntaxOptions) {\n  var indexes = [];\n  var start = delimiters.start,\n    end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n  if (start == null && end == null) {\n    // Special case of delimiter set to null/null, no templating is done\n    return [];\n  }\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n    if (compareResult === DELIMITER_EQUAL) {\n      compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n    }\n    switch (compareResult) {\n      case DELIMITER_NONE:\n        return indexes;\n      case DELIMITER_END:\n        insideTag = false;\n        offset = endOffset;\n        position = \"end\";\n        len = end.length;\n        break;\n      case DELIMITER_START:\n        insideTag = true;\n        offset = startOffset;\n        position = \"start\";\n        len = start.length;\n        break;\n    }\n    /*\n     * If tag starts with =, such as {=[ ]=}\n     * then the delimiters will change right after that tag.\n     *\n     * For example, with the following template :\n     *\n     * Hello {foo}, {=[ ]=}what's up with [name] ?\n     *\n     * The \"foo\" tag is a normal tag, the \"=[ ]=\" is a tag to change the\n     * delimiters to \"[\" and \"]\", and the last \"name\" is a tag with the new\n     * delimiters\n     */\n    if (syntaxOptions.changeDelimiterPrefix && compareResult === DELIMITER_START && fullText[offset + start.length] === syntaxOptions.changeDelimiterPrefix) {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(syntaxOptions.changeDelimiterPrefix, offset + start.length + 1);\n      var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n      indexes.push({\n        offset: nextEndOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n      var _splitDelimiters = splitDelimiters(_insideTag);\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = nextEndOffset;\n      continue;\n    }\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\nfunction parseDelimiters(innerContentParts, delimiters, syntaxOptions) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllDelimiterIndexes(full, delimiters, syntaxOptions);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var _getDelimiterErrors = getDelimiterErrors(delimiterMatches, full, syntaxOptions),\n    delimiterWithErrors = _getDelimiterErrors.delimiterWithErrors,\n    errors = _getDelimiterErrors.errors;\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n    while (delimiterIndex < delimiterWithErrors.length && inRange(range, delimiterWithErrors[delimiterIndex])) {\n      delimitersInOffset.push(delimiterWithErrors[delimiterIndex]);\n      delimiterIndex++;\n    }\n    var parts = [];\n    var cursor = 0;\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n    for (var _i6 = 0; _i6 < delimitersInOffset.length; _i6++) {\n      var delimiterInOffset = delimitersInOffset[_i6];\n      var _value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n      if (delimiterInOffset.changedelimiter) {\n        if (delimiterInOffset.position === \"start\") {\n          if (_value.length > 0) {\n            parts.push({\n              type: \"content\",\n              value: _value\n            });\n          }\n        } else {\n          cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        continue;\n      }\n      if (_value.length > 0) {\n        parts.push({\n          type: \"content\",\n          value: _value\n        });\n        cursor += _value.length;\n      }\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    }\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\nfunction isInsideContent(part) {\n  // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n  return part.type === \"content\" && part.position === \"insidetag\";\n  // Stryker restore all\n}\nfunction getContentParts(xmlparsed) {\n  return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed, fileType) {\n  var inTextTag = false;\n  for (var _i8 = 0; _i8 < xmlparsed.length; _i8++) {\n    var part = xmlparsed[_i8];\n    inTextTag = updateInTextTag(part, inTextTag);\n    if (part.type === \"content\") {\n      part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n    }\n    if (fileType !== \"text\" && isInsideContent(part)) {\n      part.value = part.value.replace(/>/g, \"&gt;\");\n    }\n  }\n}\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmllexed, delimiters, syntax, fileType) {\n    decodeContentParts(xmllexed, fileType);\n    var _parseDelimiters = parseDelimiters(getContentParts(xmllexed), delimiters, syntax),\n      delimiterParsed = _parseDelimiters.parsed,\n      errors = _parseDelimiters.errors;\n    var lexed = [];\n    var index = 0;\n    var lIndex = 0;\n    for (var _i10 = 0; _i10 < xmllexed.length; _i10++) {\n      var part = xmllexed[_i10];\n      if (isInsideContent(part)) {\n        for (var _i12 = 0, _delimiterParsed$inde2 = delimiterParsed[index]; _i12 < _delimiterParsed$inde2.length; _i12++) {\n          var p = _delimiterParsed$inde2[_i12];\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n          p.lIndex = lIndex++;\n        }\n        Array.prototype.push.apply(lexed, delimiterParsed[index]);\n        index++;\n      } else {\n        part.lIndex = lIndex++;\n        lexed.push(part);\n      }\n    }\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = matches.reduce(function (parsed, match) {\n      if (content.length > cursor && match.offset - cursor > 0) {\n        parsed.push({\n          type: \"content\",\n          value: content.substr(cursor, match.offset - cursor)\n        });\n      }\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n      parsed.push(match);\n      return parsed;\n    }, []);\n    if (content.length > cursor) {\n      parsed.push({\n        type: \"content\",\n        value: content.substr(cursor)\n      });\n    }\n    return parsed;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbGV4ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qiw2Q0FBNkMsU0FBUywwREFBMEQsVUFBVSxnQ0FBZ0M7QUFDMUosbUNBQW1DLCtDQUErQyw4QkFBOEIsT0FBTyxrQkFBa0I7QUFDekksdUNBQXVDLGtHQUFrRyxpQkFBaUIsd0NBQXdDLE1BQU0seUNBQXlDLDZCQUE2QixVQUFVLFlBQVksa0VBQWtFLFdBQVcsWUFBWSxpQkFBaUIsVUFBVSxNQUFNLGlGQUFpRixVQUFVLG9CQUFvQjtBQUM3Z0IsOEJBQThCO0FBQzlCLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsNEdBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxrSEFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsMERBQTBELHlCQUF5QjtBQUNuRjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdEQUF3RCx5QkFBeUI7QUFDakY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3REFBd0QseUJBQXlCO0FBQ2pGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzREFBc0QseUJBQXlCO0FBQy9FO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksR0FBRyxNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBLDRFQUE0RSxzQ0FBc0M7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbGV4ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICBnZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldFVuY2xvc2VkVGFnRXhjZXB0aW9uLFxuICBnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldFVub3BlbmVkVGFnRXhjZXB0aW9uLFxuICBnZXREdXBsaWNhdGVPcGVuVGFnRXhjZXB0aW9uID0gX3JlcXVpcmUuZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbixcbiAgZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24gPSBfcmVxdWlyZS5nZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbixcbiAgdGhyb3dNYWxmb3JtZWRYbWwgPSBfcmVxdWlyZS50aHJvd01hbGZvcm1lZFhtbCxcbiAgdGhyb3dYbWxJbnZhbGlkID0gX3JlcXVpcmUudGhyb3dYbWxJbnZhbGlkLFxuICBYVFRlbXBsYXRlRXJyb3IgPSBfcmVxdWlyZS5YVFRlbXBsYXRlRXJyb3I7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBpc1RleHRTdGFydCA9IF9yZXF1aXJlMi5pc1RleHRTdGFydCxcbiAgaXNUZXh0RW5kID0gX3JlcXVpcmUyLmlzVGV4dEVuZCxcbiAgd29yZFRvVXRmOCA9IF9yZXF1aXJlMi53b3JkVG9VdGY4O1xudmFyIERFTElNSVRFUl9OT05FID0gMCxcbiAgREVMSU1JVEVSX0VRVUFMID0gMSxcbiAgREVMSU1JVEVSX1NUQVJUID0gMixcbiAgREVMSU1JVEVSX0VORCA9IDM7XG5mdW5jdGlvbiBpblJhbmdlKHJhbmdlLCBtYXRjaCkge1xuICByZXR1cm4gcmFuZ2VbMF0gPD0gbWF0Y2gub2Zmc2V0ICYmIG1hdGNoLm9mZnNldCA8IHJhbmdlWzFdO1xufVxuZnVuY3Rpb24gdXBkYXRlSW5UZXh0VGFnKHBhcnQsIGluVGV4dFRhZykge1xuICBpZiAoaXNUZXh0U3RhcnQocGFydCkpIHtcbiAgICBpZiAoaW5UZXh0VGFnKSB7XG4gICAgICB0aHJvd01hbGZvcm1lZFhtbCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNUZXh0RW5kKHBhcnQpKSB7XG4gICAgaWYgKCFpblRleHRUYWcpIHtcbiAgICAgIHRocm93TWFsZm9ybWVkWG1sKCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaW5UZXh0VGFnO1xufVxuZnVuY3Rpb24gZ2V0VGFnKHRhZykge1xuICB2YXIgcG9zaXRpb24gPSBcIlwiO1xuICB2YXIgc3RhcnQgPSAxO1xuICB2YXIgZW5kID0gdGFnLmluZGV4T2YoXCIgXCIpO1xuICBpZiAodGFnW3RhZy5sZW5ndGggLSAyXSA9PT0gXCIvXCIpIHtcbiAgICBwb3NpdGlvbiA9IFwic2VsZmNsb3NpbmdcIjtcbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgZW5kID0gdGFnLmxlbmd0aCAtIDI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRhZ1sxXSA9PT0gXCIvXCIpIHtcbiAgICBzdGFydCA9IDI7XG4gICAgcG9zaXRpb24gPSBcImVuZFwiO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICBlbmQgPSB0YWcubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcG9zaXRpb24gPSBcInN0YXJ0XCI7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIGVuZCA9IHRhZy5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRhZzogdGFnLnNsaWNlKHN0YXJ0LCBlbmQpLFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9O1xufVxuZnVuY3Rpb24gdGFnTWF0Y2hlcihjb250ZW50LCB0ZXh0TWF0Y2hBcnJheSwgb3RoZXJzTWF0Y2hBcnJheSkge1xuICB2YXIgY3Vyc29yID0gMDtcbiAgdmFyIGNvbnRlbnRMZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgdmFyIGFsbE1hdGNoZXMgPSB7fTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdGV4dE1hdGNoQXJyYXkubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBtID0gdGV4dE1hdGNoQXJyYXlbX2kyXTtcbiAgICBhbGxNYXRjaGVzW21dID0gdHJ1ZTtcbiAgfVxuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBvdGhlcnNNYXRjaEFycmF5Lmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgX20gPSBvdGhlcnNNYXRjaEFycmF5W19pNF07XG4gICAgYWxsTWF0Y2hlc1tfbV0gPSBmYWxzZTtcbiAgfVxuICB2YXIgdG90YWxNYXRjaGVzID0gW107XG4gIHdoaWxlIChjdXJzb3IgPCBjb250ZW50TGVuZ3RoKSB7XG4gICAgY3Vyc29yID0gY29udGVudC5pbmRleE9mKFwiPFwiLCBjdXJzb3IpO1xuICAgIGlmIChjdXJzb3IgPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IGN1cnNvcjtcbiAgICB2YXIgbmV4dE9wZW5pbmcgPSBjb250ZW50LmluZGV4T2YoXCI8XCIsIGN1cnNvciArIDEpO1xuICAgIGN1cnNvciA9IGNvbnRlbnQuaW5kZXhPZihcIj5cIiwgY3Vyc29yKTtcbiAgICBpZiAoY3Vyc29yID09PSAtMSB8fCBuZXh0T3BlbmluZyAhPT0gLTEgJiYgY3Vyc29yID4gbmV4dE9wZW5pbmcpIHtcbiAgICAgIHRocm93WG1sSW52YWxpZChjb250ZW50LCBvZmZzZXQpO1xuICAgIH1cbiAgICB2YXIgdGFnVGV4dCA9IGNvbnRlbnQuc2xpY2Uob2Zmc2V0LCBjdXJzb3IgKyAxKTtcbiAgICB2YXIgX2dldFRhZyA9IGdldFRhZyh0YWdUZXh0KSxcbiAgICAgIHRhZyA9IF9nZXRUYWcudGFnLFxuICAgICAgcG9zaXRpb24gPSBfZ2V0VGFnLnBvc2l0aW9uO1xuICAgIHZhciB0ZXh0ID0gYWxsTWF0Y2hlc1t0YWddO1xuICAgIGlmICh0ZXh0ID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0b3RhbE1hdGNoZXMucHVzaCh7XG4gICAgICB0eXBlOiBcInRhZ1wiLFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgdGV4dDogdGV4dCxcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgdmFsdWU6IHRhZ1RleHQsXG4gICAgICB0YWc6IHRhZ1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0b3RhbE1hdGNoZXM7XG59XG5mdW5jdGlvbiBnZXREZWxpbWl0ZXJFcnJvcnMoZGVsaW1pdGVyTWF0Y2hlcywgZnVsbFRleHQsIHN5bnRheE9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgaW5EZWxpbWl0ZXIgPSBmYWxzZTtcbiAgdmFyIGxhc3REZWxpbWl0ZXJNYXRjaCA9IHtcbiAgICBvZmZzZXQ6IDBcbiAgfTtcbiAgdmFyIHh0YWc7XG4gIHZhciBkZWxpbWl0ZXJXaXRoRXJyb3JzID0gZGVsaW1pdGVyTWF0Y2hlcy5yZWR1Y2UoZnVuY3Rpb24gKGRlbGltaXRlckFjYywgY3VyckRlbGltaXRlck1hdGNoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gY3VyckRlbGltaXRlck1hdGNoLnBvc2l0aW9uO1xuICAgIHZhciBkZWxpbWl0ZXJPZmZzZXQgPSBjdXJyRGVsaW1pdGVyTWF0Y2gub2Zmc2V0O1xuICAgIHZhciBsYXN0RGVsaW1pdGVyT2Zmc2V0ID0gbGFzdERlbGltaXRlck1hdGNoLm9mZnNldDtcbiAgICB2YXIgbGFzdERlbGltaXRlckxlbmd0aCA9IGxhc3REZWxpbWl0ZXJNYXRjaC5sZW5ndGg7XG4gICAgeHRhZyA9IGZ1bGxUZXh0LnN1YnN0cihsYXN0RGVsaW1pdGVyT2Zmc2V0LCBkZWxpbWl0ZXJPZmZzZXQgLSBsYXN0RGVsaW1pdGVyT2Zmc2V0KTtcbiAgICBpZiAoaW5EZWxpbWl0ZXIgJiYgcG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuICAgICAgaWYgKGxhc3REZWxpbWl0ZXJPZmZzZXQgKyBsYXN0RGVsaW1pdGVyTGVuZ3RoID09PSBkZWxpbWl0ZXJPZmZzZXQpIHtcbiAgICAgICAgeHRhZyA9IGZ1bGxUZXh0LnN1YnN0cihsYXN0RGVsaW1pdGVyT2Zmc2V0LCBkZWxpbWl0ZXJPZmZzZXQgLSBsYXN0RGVsaW1pdGVyT2Zmc2V0ICsgbGFzdERlbGltaXRlckxlbmd0aCArIDQpO1xuICAgICAgICBpZiAoIXN5bnRheE9wdGlvbnMuYWxsb3dVbmNsb3NlZFRhZykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24oe1xuICAgICAgICAgICAgeHRhZzogeHRhZyxcbiAgICAgICAgICAgIG9mZnNldDogbGFzdERlbGltaXRlck9mZnNldFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBsYXN0RGVsaW1pdGVyTWF0Y2ggPSBjdXJyRGVsaW1pdGVyTWF0Y2g7XG4gICAgICAgICAgZGVsaW1pdGVyQWNjLnB1c2goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjdXJyRGVsaW1pdGVyTWF0Y2gpLCB7fSwge1xuICAgICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzeW50YXhPcHRpb25zLmFsbG93VW5jbG9zZWRUYWcpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24oe1xuICAgICAgICAgIHh0YWc6IHdvcmRUb1V0ZjgoeHRhZyksXG4gICAgICAgICAgb2Zmc2V0OiBsYXN0RGVsaW1pdGVyT2Zmc2V0XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgICAgICBkZWxpbWl0ZXJBY2MucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGN1cnJEZWxpbWl0ZXJNYXRjaCksIHt9LCB7XG4gICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZGVsaW1pdGVyQWNjO1xuICAgICAgfVxuICAgICAgZGVsaW1pdGVyQWNjLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoIWluRGVsaW1pdGVyICYmIHBvc2l0aW9uID09PSBcImVuZFwiKSB7XG4gICAgICBpZiAoc3ludGF4T3B0aW9ucy5hbGxvd1Vub3BlbmVkVGFnKSB7XG4gICAgICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gICAgICB9XG4gICAgICBpZiAobGFzdERlbGltaXRlck9mZnNldCArIGxhc3REZWxpbWl0ZXJMZW5ndGggPT09IGRlbGltaXRlck9mZnNldCkge1xuICAgICAgICB4dGFnID0gZnVsbFRleHQuc3Vic3RyKGxhc3REZWxpbWl0ZXJPZmZzZXQgLSA0LCBkZWxpbWl0ZXJPZmZzZXQgLSBsYXN0RGVsaW1pdGVyT2Zmc2V0ICsgbGFzdERlbGltaXRlckxlbmd0aCArIDQpO1xuICAgICAgICBlcnJvcnMucHVzaChnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbih7XG4gICAgICAgICAgeHRhZzogeHRhZyxcbiAgICAgICAgICBvZmZzZXQ6IGxhc3REZWxpbWl0ZXJPZmZzZXRcbiAgICAgICAgfSkpO1xuICAgICAgICBsYXN0RGVsaW1pdGVyTWF0Y2ggPSBjdXJyRGVsaW1pdGVyTWF0Y2g7XG4gICAgICAgIGRlbGltaXRlckFjYy5wdXNoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3VyckRlbGltaXRlck1hdGNoKSwge30sIHtcbiAgICAgICAgICBlcnJvcjogdHJ1ZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gICAgICB9XG4gICAgICBlcnJvcnMucHVzaChnZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbih7XG4gICAgICAgIHh0YWc6IHh0YWcsXG4gICAgICAgIG9mZnNldDogZGVsaW1pdGVyT2Zmc2V0XG4gICAgICB9KSk7XG4gICAgICBsYXN0RGVsaW1pdGVyTWF0Y2ggPSBjdXJyRGVsaW1pdGVyTWF0Y2g7XG4gICAgICBkZWxpbWl0ZXJBY2MucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGN1cnJEZWxpbWl0ZXJNYXRjaCksIHt9LCB7XG4gICAgICAgIGVycm9yOiB0cnVlXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gZGVsaW1pdGVyQWNjO1xuICAgIH1cbiAgICBpbkRlbGltaXRlciA9IHBvc2l0aW9uID09PSBcInN0YXJ0XCI7XG4gICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgIGRlbGltaXRlckFjYy5wdXNoKGN1cnJEZWxpbWl0ZXJNYXRjaCk7XG4gICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgfSwgW10pO1xuICBpZiAoaW5EZWxpbWl0ZXIpIHtcbiAgICB2YXIgbGFzdERlbGltaXRlck9mZnNldCA9IGxhc3REZWxpbWl0ZXJNYXRjaC5vZmZzZXQ7XG4gICAgeHRhZyA9IGZ1bGxUZXh0LnN1YnN0cihsYXN0RGVsaW1pdGVyT2Zmc2V0LCBmdWxsVGV4dC5sZW5ndGggLSBsYXN0RGVsaW1pdGVyT2Zmc2V0KTtcbiAgICBpZiAoIXN5bnRheE9wdGlvbnMuYWxsb3dVbmNsb3NlZFRhZykge1xuICAgICAgZXJyb3JzLnB1c2goZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24oe1xuICAgICAgICB4dGFnOiB3b3JkVG9VdGY4KHh0YWcpLFxuICAgICAgICBvZmZzZXQ6IGxhc3REZWxpbWl0ZXJPZmZzZXRcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsaW1pdGVyV2l0aEVycm9ycy5wb3AoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZWxpbWl0ZXJXaXRoRXJyb3JzOiBkZWxpbWl0ZXJXaXRoRXJyb3JzLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG5mdW5jdGlvbiBjb21wYXJlT2Zmc2V0cyhzdGFydE9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gIGlmIChzdGFydE9mZnNldCA9PT0gLTEgJiYgZW5kT2Zmc2V0ID09PSAtMSkge1xuICAgIHJldHVybiBERUxJTUlURVJfTk9ORTtcbiAgfVxuICBpZiAoc3RhcnRPZmZzZXQgPT09IGVuZE9mZnNldCkge1xuICAgIHJldHVybiBERUxJTUlURVJfRVFVQUw7XG4gIH1cbiAgaWYgKHN0YXJ0T2Zmc2V0ID09PSAtMSB8fCBlbmRPZmZzZXQgPT09IC0xKSB7XG4gICAgcmV0dXJuIGVuZE9mZnNldCA8IHN0YXJ0T2Zmc2V0ID8gREVMSU1JVEVSX1NUQVJUIDogREVMSU1JVEVSX0VORDtcbiAgfVxuICByZXR1cm4gc3RhcnRPZmZzZXQgPCBlbmRPZmZzZXQgPyBERUxJTUlURVJfU1RBUlQgOiBERUxJTUlURVJfRU5EO1xufVxuZnVuY3Rpb24gc3BsaXREZWxpbWl0ZXJzKGluc2lkZSkge1xuICB2YXIgbmV3RGVsaW1pdGVycyA9IGluc2lkZS5zcGxpdChcIiBcIik7XG4gIGlmIChuZXdEZWxpbWl0ZXJzLmxlbmd0aCAhPT0gMikge1xuICAgIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTmV3IERlbGltaXRlcnMgY2Fubm90IGJlIHBhcnNlZFwiKTtcbiAgICBlcnIucHJvcGVydGllcyA9IHtcbiAgICAgIGlkOiBcImNoYW5nZV9kZWxpbWl0ZXJzX2ludmFsaWRcIixcbiAgICAgIGV4cGxhbmF0aW9uOiBcIkNhbm5vdCBwYXJzZXIgZGVsaW1pdGVyc1wiXG4gICAgfTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgdmFyIF9uZXdEZWxpbWl0ZXJzID0gX3NsaWNlZFRvQXJyYXkobmV3RGVsaW1pdGVycywgMiksXG4gICAgc3RhcnQgPSBfbmV3RGVsaW1pdGVyc1swXSxcbiAgICBlbmQgPSBfbmV3RGVsaW1pdGVyc1sxXTtcbiAgaWYgKHN0YXJ0Lmxlbmd0aCA9PT0gMCB8fCBlbmQubGVuZ3RoID09PSAwKSB7XG4gICAgdmFyIF9lcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiTmV3IERlbGltaXRlcnMgY2Fubm90IGJlIHBhcnNlZFwiKTtcbiAgICBfZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgICBpZDogXCJjaGFuZ2VfZGVsaW1pdGVyc19pbnZhbGlkXCIsXG4gICAgICBleHBsYW5hdGlvbjogXCJDYW5ub3QgcGFyc2VyIGRlbGltaXRlcnNcIlxuICAgIH07XG4gICAgdGhyb3cgX2VycjtcbiAgfVxuICByZXR1cm4gW3N0YXJ0LCBlbmRdO1xufVxuZnVuY3Rpb24gZ2V0QWxsRGVsaW1pdGVySW5kZXhlcyhmdWxsVGV4dCwgZGVsaW1pdGVycywgc3ludGF4T3B0aW9ucykge1xuICB2YXIgaW5kZXhlcyA9IFtdO1xuICB2YXIgc3RhcnQgPSBkZWxpbWl0ZXJzLnN0YXJ0LFxuICAgIGVuZCA9IGRlbGltaXRlcnMuZW5kO1xuICB2YXIgb2Zmc2V0ID0gLTE7XG4gIHZhciBpbnNpZGVUYWcgPSBmYWxzZTtcbiAgaWYgKHN0YXJ0ID09IG51bGwgJiYgZW5kID09IG51bGwpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2Ugb2YgZGVsaW1pdGVyIHNldCB0byBudWxsL251bGwsIG5vIHRlbXBsYXRpbmcgaXMgZG9uZVxuICAgIHJldHVybiBbXTtcbiAgfVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBzdGFydE9mZnNldCA9IGZ1bGxUZXh0LmluZGV4T2Yoc3RhcnQsIG9mZnNldCArIDEpO1xuICAgIHZhciBlbmRPZmZzZXQgPSBmdWxsVGV4dC5pbmRleE9mKGVuZCwgb2Zmc2V0ICsgMSk7XG4gICAgdmFyIHBvc2l0aW9uID0gbnVsbDtcbiAgICB2YXIgbGVuID0gdm9pZCAwO1xuICAgIHZhciBjb21wYXJlUmVzdWx0ID0gY29tcGFyZU9mZnNldHMoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgaWYgKGNvbXBhcmVSZXN1bHQgPT09IERFTElNSVRFUl9FUVVBTCkge1xuICAgICAgY29tcGFyZVJlc3VsdCA9IGluc2lkZVRhZyA/IERFTElNSVRFUl9FTkQgOiBERUxJTUlURVJfU1RBUlQ7XG4gICAgfVxuICAgIHN3aXRjaCAoY29tcGFyZVJlc3VsdCkge1xuICAgICAgY2FzZSBERUxJTUlURVJfTk9ORTpcbiAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgICBjYXNlIERFTElNSVRFUl9FTkQ6XG4gICAgICAgIGluc2lkZVRhZyA9IGZhbHNlO1xuICAgICAgICBvZmZzZXQgPSBlbmRPZmZzZXQ7XG4gICAgICAgIHBvc2l0aW9uID0gXCJlbmRcIjtcbiAgICAgICAgbGVuID0gZW5kLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERFTElNSVRFUl9TVEFSVDpcbiAgICAgICAgaW5zaWRlVGFnID0gdHJ1ZTtcbiAgICAgICAgb2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgIHBvc2l0aW9uID0gXCJzdGFydFwiO1xuICAgICAgICBsZW4gPSBzdGFydC5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvKlxuICAgICAqIElmIHRhZyBzdGFydHMgd2l0aCA9LCBzdWNoIGFzIHs9WyBdPX1cbiAgICAgKiB0aGVuIHRoZSBkZWxpbWl0ZXJzIHdpbGwgY2hhbmdlIHJpZ2h0IGFmdGVyIHRoYXQgdGFnLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIHdpdGggdGhlIGZvbGxvd2luZyB0ZW1wbGF0ZSA6XG4gICAgICpcbiAgICAgKiBIZWxsbyB7Zm9vfSwgez1bIF09fXdoYXQncyB1cCB3aXRoIFtuYW1lXSA/XG4gICAgICpcbiAgICAgKiBUaGUgXCJmb29cIiB0YWcgaXMgYSBub3JtYWwgdGFnLCB0aGUgXCI9WyBdPVwiIGlzIGEgdGFnIHRvIGNoYW5nZSB0aGVcbiAgICAgKiBkZWxpbWl0ZXJzIHRvIFwiW1wiIGFuZCBcIl1cIiwgYW5kIHRoZSBsYXN0IFwibmFtZVwiIGlzIGEgdGFnIHdpdGggdGhlIG5ld1xuICAgICAqIGRlbGltaXRlcnNcbiAgICAgKi9cbiAgICBpZiAoc3ludGF4T3B0aW9ucy5jaGFuZ2VEZWxpbWl0ZXJQcmVmaXggJiYgY29tcGFyZVJlc3VsdCA9PT0gREVMSU1JVEVSX1NUQVJUICYmIGZ1bGxUZXh0W29mZnNldCArIHN0YXJ0Lmxlbmd0aF0gPT09IHN5bnRheE9wdGlvbnMuY2hhbmdlRGVsaW1pdGVyUHJlZml4KSB7XG4gICAgICBpbmRleGVzLnB1c2goe1xuICAgICAgICBvZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICBwb3NpdGlvbjogXCJzdGFydFwiLFxuICAgICAgICBsZW5ndGg6IHN0YXJ0Lmxlbmd0aCxcbiAgICAgICAgY2hhbmdlZGVsaW1pdGVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhciBuZXh0RXF1YWwgPSBmdWxsVGV4dC5pbmRleE9mKHN5bnRheE9wdGlvbnMuY2hhbmdlRGVsaW1pdGVyUHJlZml4LCBvZmZzZXQgKyBzdGFydC5sZW5ndGggKyAxKTtcbiAgICAgIHZhciBuZXh0RW5kT2Zmc2V0ID0gZnVsbFRleHQuaW5kZXhPZihlbmQsIG5leHRFcXVhbCArIDEpO1xuICAgICAgaW5kZXhlcy5wdXNoKHtcbiAgICAgICAgb2Zmc2V0OiBuZXh0RW5kT2Zmc2V0LFxuICAgICAgICBwb3NpdGlvbjogXCJlbmRcIixcbiAgICAgICAgbGVuZ3RoOiBlbmQubGVuZ3RoLFxuICAgICAgICBjaGFuZ2VkZWxpbWl0ZXI6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdmFyIF9pbnNpZGVUYWcgPSBmdWxsVGV4dC5zdWJzdHIob2Zmc2V0ICsgc3RhcnQubGVuZ3RoICsgMSwgbmV4dEVxdWFsIC0gb2Zmc2V0IC0gc3RhcnQubGVuZ3RoIC0gMSk7XG4gICAgICB2YXIgX3NwbGl0RGVsaW1pdGVycyA9IHNwbGl0RGVsaW1pdGVycyhfaW5zaWRlVGFnKTtcbiAgICAgIHZhciBfc3BsaXREZWxpbWl0ZXJzMiA9IF9zbGljZWRUb0FycmF5KF9zcGxpdERlbGltaXRlcnMsIDIpO1xuICAgICAgc3RhcnQgPSBfc3BsaXREZWxpbWl0ZXJzMlswXTtcbiAgICAgIGVuZCA9IF9zcGxpdERlbGltaXRlcnMyWzFdO1xuICAgICAgb2Zmc2V0ID0gbmV4dEVuZE9mZnNldDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbmRleGVzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICBsZW5ndGg6IGxlblxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZURlbGltaXRlcnMoaW5uZXJDb250ZW50UGFydHMsIGRlbGltaXRlcnMsIHN5bnRheE9wdGlvbnMpIHtcbiAgdmFyIGZ1bGwgPSBpbm5lckNvbnRlbnRQYXJ0cy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC52YWx1ZTtcbiAgfSkuam9pbihcIlwiKTtcbiAgdmFyIGRlbGltaXRlck1hdGNoZXMgPSBnZXRBbGxEZWxpbWl0ZXJJbmRleGVzKGZ1bGwsIGRlbGltaXRlcnMsIHN5bnRheE9wdGlvbnMpO1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgdmFyIHJhbmdlcyA9IGlubmVyQ29udGVudFBhcnRzLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgIG9mZnNldCArPSBwYXJ0LnZhbHVlLmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBwYXJ0LnZhbHVlLmxlbmd0aCxcbiAgICAgIGxJbmRleDogcGFydC5sSW5kZXhcbiAgICB9O1xuICB9KTtcbiAgdmFyIF9nZXREZWxpbWl0ZXJFcnJvcnMgPSBnZXREZWxpbWl0ZXJFcnJvcnMoZGVsaW1pdGVyTWF0Y2hlcywgZnVsbCwgc3ludGF4T3B0aW9ucyksXG4gICAgZGVsaW1pdGVyV2l0aEVycm9ycyA9IF9nZXREZWxpbWl0ZXJFcnJvcnMuZGVsaW1pdGVyV2l0aEVycm9ycyxcbiAgICBlcnJvcnMgPSBfZ2V0RGVsaW1pdGVyRXJyb3JzLmVycm9ycztcbiAgdmFyIGN1dE5leHQgPSAwO1xuICB2YXIgZGVsaW1pdGVySW5kZXggPSAwO1xuICB2YXIgcGFyc2VkID0gcmFuZ2VzLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgIHZhciBvZmZzZXQgPSBwLm9mZnNldDtcbiAgICB2YXIgcmFuZ2UgPSBbb2Zmc2V0LCBvZmZzZXQgKyBpbm5lckNvbnRlbnRQYXJ0c1tpXS52YWx1ZS5sZW5ndGhdO1xuICAgIHZhciBwYXJ0Q29udGVudCA9IGlubmVyQ29udGVudFBhcnRzW2ldLnZhbHVlO1xuICAgIHZhciBkZWxpbWl0ZXJzSW5PZmZzZXQgPSBbXTtcbiAgICB3aGlsZSAoZGVsaW1pdGVySW5kZXggPCBkZWxpbWl0ZXJXaXRoRXJyb3JzLmxlbmd0aCAmJiBpblJhbmdlKHJhbmdlLCBkZWxpbWl0ZXJXaXRoRXJyb3JzW2RlbGltaXRlckluZGV4XSkpIHtcbiAgICAgIGRlbGltaXRlcnNJbk9mZnNldC5wdXNoKGRlbGltaXRlcldpdGhFcnJvcnNbZGVsaW1pdGVySW5kZXhdKTtcbiAgICAgIGRlbGltaXRlckluZGV4Kys7XG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IFtdO1xuICAgIHZhciBjdXJzb3IgPSAwO1xuICAgIGlmIChjdXROZXh0ID4gMCkge1xuICAgICAgY3Vyc29yID0gY3V0TmV4dDtcbiAgICAgIGN1dE5leHQgPSAwO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBkZWxpbWl0ZXJzSW5PZmZzZXQubGVuZ3RoOyBfaTYrKykge1xuICAgICAgdmFyIGRlbGltaXRlckluT2Zmc2V0ID0gZGVsaW1pdGVyc0luT2Zmc2V0W19pNl07XG4gICAgICB2YXIgX3ZhbHVlID0gcGFydENvbnRlbnQuc3Vic3RyKGN1cnNvciwgZGVsaW1pdGVySW5PZmZzZXQub2Zmc2V0IC0gb2Zmc2V0IC0gY3Vyc29yKTtcbiAgICAgIGlmIChkZWxpbWl0ZXJJbk9mZnNldC5jaGFuZ2VkZWxpbWl0ZXIpIHtcbiAgICAgICAgaWYgKGRlbGltaXRlckluT2Zmc2V0LnBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICBpZiAoX3ZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnNvciA9IGRlbGltaXRlckluT2Zmc2V0Lm9mZnNldCAtIG9mZnNldCArIGRlbGltaXRlckluT2Zmc2V0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChfdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICAgICAgICB2YWx1ZTogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJzb3IgKz0gX3ZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciBkZWxpbWl0ZXJQYXJ0ID0ge1xuICAgICAgICB0eXBlOiBcImRlbGltaXRlclwiLFxuICAgICAgICBwb3NpdGlvbjogZGVsaW1pdGVySW5PZmZzZXQucG9zaXRpb24sXG4gICAgICAgIG9mZnNldDogY3Vyc29yICsgb2Zmc2V0XG4gICAgICB9O1xuICAgICAgcGFydHMucHVzaChkZWxpbWl0ZXJQYXJ0KTtcbiAgICAgIGN1cnNvciA9IGRlbGltaXRlckluT2Zmc2V0Lm9mZnNldCAtIG9mZnNldCArIGRlbGltaXRlckluT2Zmc2V0Lmxlbmd0aDtcbiAgICB9XG4gICAgY3V0TmV4dCA9IGN1cnNvciAtIHBhcnRDb250ZW50Lmxlbmd0aDtcbiAgICB2YXIgdmFsdWUgPSBwYXJ0Q29udGVudC5zdWJzdHIoY3Vyc29yKTtcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiY29udGVudFwiLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG4gIH0sIHRoaXMpO1xuICByZXR1cm4ge1xuICAgIHBhcnNlZDogcGFyc2VkLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG5mdW5jdGlvbiBpc0luc2lkZUNvbnRlbnQocGFydCkge1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGUgcGFydC5wb3NpdGlvbiA9PT0gXCJpbnNpZGV0YWdcIiB3b3VsZCBiZSBlbm91Z2ggYnV0IHdlIHdhbnQgdG8gbWFrZSB0aGUgQVBJIGZ1dHVyZSBwcm9vZlxuICByZXR1cm4gcGFydC50eXBlID09PSBcImNvbnRlbnRcIiAmJiBwYXJ0LnBvc2l0aW9uID09PSBcImluc2lkZXRhZ1wiO1xuICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG59XG5mdW5jdGlvbiBnZXRDb250ZW50UGFydHMoeG1scGFyc2VkKSB7XG4gIHJldHVybiB4bWxwYXJzZWQuZmlsdGVyKGlzSW5zaWRlQ29udGVudCk7XG59XG5mdW5jdGlvbiBkZWNvZGVDb250ZW50UGFydHMoeG1scGFyc2VkLCBmaWxlVHlwZSkge1xuICB2YXIgaW5UZXh0VGFnID0gZmFsc2U7XG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IHhtbHBhcnNlZC5sZW5ndGg7IF9pOCsrKSB7XG4gICAgdmFyIHBhcnQgPSB4bWxwYXJzZWRbX2k4XTtcbiAgICBpblRleHRUYWcgPSB1cGRhdGVJblRleHRUYWcocGFydCwgaW5UZXh0VGFnKTtcbiAgICBpZiAocGFydC50eXBlID09PSBcImNvbnRlbnRcIikge1xuICAgICAgcGFydC5wb3NpdGlvbiA9IGluVGV4dFRhZyA/IFwiaW5zaWRldGFnXCIgOiBcIm91dHNpZGV0YWdcIjtcbiAgICB9XG4gICAgaWYgKGZpbGVUeXBlICE9PSBcInRleHRcIiAmJiBpc0luc2lkZUNvbnRlbnQocGFydCkpIHtcbiAgICAgIHBhcnQudmFsdWUgPSBwYXJ0LnZhbHVlLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xuICAgIH1cbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlRGVsaW1pdGVyczogcGFyc2VEZWxpbWl0ZXJzLFxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoeG1sbGV4ZWQsIGRlbGltaXRlcnMsIHN5bnRheCwgZmlsZVR5cGUpIHtcbiAgICBkZWNvZGVDb250ZW50UGFydHMoeG1sbGV4ZWQsIGZpbGVUeXBlKTtcbiAgICB2YXIgX3BhcnNlRGVsaW1pdGVycyA9IHBhcnNlRGVsaW1pdGVycyhnZXRDb250ZW50UGFydHMoeG1sbGV4ZWQpLCBkZWxpbWl0ZXJzLCBzeW50YXgpLFxuICAgICAgZGVsaW1pdGVyUGFyc2VkID0gX3BhcnNlRGVsaW1pdGVycy5wYXJzZWQsXG4gICAgICBlcnJvcnMgPSBfcGFyc2VEZWxpbWl0ZXJzLmVycm9ycztcbiAgICB2YXIgbGV4ZWQgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBsSW5kZXggPSAwO1xuICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgeG1sbGV4ZWQubGVuZ3RoOyBfaTEwKyspIHtcbiAgICAgIHZhciBwYXJ0ID0geG1sbGV4ZWRbX2kxMF07XG4gICAgICBpZiAoaXNJbnNpZGVDb250ZW50KHBhcnQpKSB7XG4gICAgICAgIGZvciAodmFyIF9pMTIgPSAwLCBfZGVsaW1pdGVyUGFyc2VkJGluZGUyID0gZGVsaW1pdGVyUGFyc2VkW2luZGV4XTsgX2kxMiA8IF9kZWxpbWl0ZXJQYXJzZWQkaW5kZTIubGVuZ3RoOyBfaTEyKyspIHtcbiAgICAgICAgICB2YXIgcCA9IF9kZWxpbWl0ZXJQYXJzZWQkaW5kZTJbX2kxMl07XG4gICAgICAgICAgaWYgKHAudHlwZSA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgICAgICAgIHAucG9zaXRpb24gPSBcImluc2lkZXRhZ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwLmxJbmRleCA9IGxJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxleGVkLCBkZWxpbWl0ZXJQYXJzZWRbaW5kZXhdKTtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnQubEluZGV4ID0gbEluZGV4Kys7XG4gICAgICAgIGxleGVkLnB1c2gocGFydCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgIGxleGVkOiBsZXhlZFxuICAgIH07XG4gIH0sXG4gIHhtbHBhcnNlOiBmdW5jdGlvbiB4bWxwYXJzZShjb250ZW50LCB4bWx0YWdzKSB7XG4gICAgdmFyIG1hdGNoZXMgPSB0YWdNYXRjaGVyKGNvbnRlbnQsIHhtbHRhZ3MudGV4dCwgeG1sdGFncy5vdGhlcik7XG4gICAgdmFyIGN1cnNvciA9IDA7XG4gICAgdmFyIHBhcnNlZCA9IG1hdGNoZXMucmVkdWNlKGZ1bmN0aW9uIChwYXJzZWQsIG1hdGNoKSB7XG4gICAgICBpZiAoY29udGVudC5sZW5ndGggPiBjdXJzb3IgJiYgbWF0Y2gub2Zmc2V0IC0gY3Vyc29yID4gMCkge1xuICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJjb250ZW50XCIsXG4gICAgICAgICAgdmFsdWU6IGNvbnRlbnQuc3Vic3RyKGN1cnNvciwgbWF0Y2gub2Zmc2V0IC0gY3Vyc29yKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGN1cnNvciA9IG1hdGNoLm9mZnNldCArIG1hdGNoLnZhbHVlLmxlbmd0aDtcbiAgICAgIGRlbGV0ZSBtYXRjaC5vZmZzZXQ7XG4gICAgICBwYXJzZWQucHVzaChtYXRjaCk7XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH0sIFtdKTtcbiAgICBpZiAoY29udGVudC5sZW5ndGggPiBjdXJzb3IpIHtcbiAgICAgIHBhcnNlZC5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJjb250ZW50XCIsXG4gICAgICAgIHZhbHVlOiBjb250ZW50LnN1YnN0cihjdXJzb3IpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/lexer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/merge-sort.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/merge-sort.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

eval("\n\nfunction getMinFromArrays(arrays, state) {\n  var minIndex = -1;\n  for (var i = 0, l = arrays.length; i < l; i++) {\n    if (state[i] >= arrays[i].length) {\n      continue;\n    }\n    if (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n}\nmodule.exports = function (arrays) {\n  var totalLength = arrays.reduce(function (sum, array) {\n    return sum + array.length;\n  }, 0);\n  arrays = arrays.filter(function (array) {\n    return array.length > 0;\n  });\n  var resultArray = new Array(totalLength);\n  var state = arrays.map(function () {\n    return 0;\n  });\n  for (var i = 0; i < totalLength; i++) {\n    var arrayIndex = getMinFromArrays(arrays, state);\n    resultArray[i] = arrays[arrayIndex][state[arrayIndex]];\n    state[arrayIndex]++;\n  }\n  return resultArray;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbWVyZ2Utc29ydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy8ucG5wbS9kb2N4dGVtcGxhdGVyQDMuNjAuMi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tZXJnZS1zb3J0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBnZXRNaW5Gcm9tQXJyYXlzKGFycmF5cywgc3RhdGUpIHtcbiAgdmFyIG1pbkluZGV4ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdGF0ZVtpXSA+PSBhcnJheXNbaV0ubGVuZ3RoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG1pbkluZGV4ID09PSAtMSB8fCBhcnJheXNbaV1bc3RhdGVbaV1dLm9mZnNldCA8IGFycmF5c1ttaW5JbmRleF1bc3RhdGVbbWluSW5kZXhdXS5vZmZzZXQpIHtcbiAgICAgIG1pbkluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pbkluZGV4O1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyYXlzKSB7XG4gIHZhciB0b3RhbExlbmd0aCA9IGFycmF5cy5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgYXJyYXkpIHtcbiAgICByZXR1cm4gc3VtICsgYXJyYXkubGVuZ3RoO1xuICB9LCAwKTtcbiAgYXJyYXlzID0gYXJyYXlzLmZpbHRlcihmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICByZXR1cm4gYXJyYXkubGVuZ3RoID4gMDtcbiAgfSk7XG4gIHZhciByZXN1bHRBcnJheSA9IG5ldyBBcnJheSh0b3RhbExlbmd0aCk7XG4gIHZhciBzdGF0ZSA9IGFycmF5cy5tYXAoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAwO1xuICB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbExlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGFycmF5SW5kZXggPSBnZXRNaW5Gcm9tQXJyYXlzKGFycmF5cywgc3RhdGUpO1xuICAgIHJlc3VsdEFycmF5W2ldID0gYXJyYXlzW2FycmF5SW5kZXhdW3N0YXRlW2FycmF5SW5kZXhdXTtcbiAgICBzdGF0ZVthcnJheUluZGV4XSsrO1xuICB9XG4gIHJldHVybiByZXN1bHRBcnJheTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/merge-sort.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/module-wrapper.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/module-wrapper.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\"),\n  XTInternalError = _require.XTInternalError;\nfunction emptyFun() {}\nfunction identity(i) {\n  return i;\n}\nmodule.exports = function (module) {\n  var defaults = {\n    set: emptyFun,\n    matchers: function matchers() {\n      return [];\n    },\n    parse: emptyFun,\n    render: emptyFun,\n    getTraits: emptyFun,\n    getFileType: emptyFun,\n    nullGetter: emptyFun,\n    optionsTransformer: identity,\n    postrender: identity,\n    errorsTransformer: identity,\n    getRenderedMap: identity,\n    preparse: identity,\n    postparse: identity,\n    on: emptyFun,\n    resolve: emptyFun,\n    preResolve: emptyFun\n  };\n  if (Object.keys(defaults).every(function (key) {\n    return !module[key];\n  })) {\n    var err = new XTInternalError(\"This module cannot be wrapped, because it doesn't define any of the necessary functions\");\n    err.properties = {\n      id: \"module_cannot_be_wrapped\",\n      explanation: \"This module cannot be wrapped, because it doesn't define any of the necessary functions\"\n    };\n    throw err;\n  }\n  for (var key in defaults) {\n    module[key] || (module[key] = defaults[key]);\n  }\n  return module;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlLXdyYXBwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDRHQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy8ucG5wbS9kb2N4dGVtcGxhdGVyQDMuNjAuMi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGUtd3JhcHBlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICBYVEludGVybmFsRXJyb3IgPSBfcmVxdWlyZS5YVEludGVybmFsRXJyb3I7XG5mdW5jdGlvbiBlbXB0eUZ1bigpIHt9XG5mdW5jdGlvbiBpZGVudGl0eShpKSB7XG4gIHJldHVybiBpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobW9kdWxlKSB7XG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBzZXQ6IGVtcHR5RnVuLFxuICAgIG1hdGNoZXJzOiBmdW5jdGlvbiBtYXRjaGVycygpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHBhcnNlOiBlbXB0eUZ1bixcbiAgICByZW5kZXI6IGVtcHR5RnVuLFxuICAgIGdldFRyYWl0czogZW1wdHlGdW4sXG4gICAgZ2V0RmlsZVR5cGU6IGVtcHR5RnVuLFxuICAgIG51bGxHZXR0ZXI6IGVtcHR5RnVuLFxuICAgIG9wdGlvbnNUcmFuc2Zvcm1lcjogaWRlbnRpdHksXG4gICAgcG9zdHJlbmRlcjogaWRlbnRpdHksXG4gICAgZXJyb3JzVHJhbnNmb3JtZXI6IGlkZW50aXR5LFxuICAgIGdldFJlbmRlcmVkTWFwOiBpZGVudGl0eSxcbiAgICBwcmVwYXJzZTogaWRlbnRpdHksXG4gICAgcG9zdHBhcnNlOiBpZGVudGl0eSxcbiAgICBvbjogZW1wdHlGdW4sXG4gICAgcmVzb2x2ZTogZW1wdHlGdW4sXG4gICAgcHJlUmVzb2x2ZTogZW1wdHlGdW5cbiAgfTtcbiAgaWYgKE9iamVjdC5rZXlzKGRlZmF1bHRzKS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICFtb2R1bGVba2V5XTtcbiAgfSkpIHtcbiAgICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIlRoaXMgbW9kdWxlIGNhbm5vdCBiZSB3cmFwcGVkLCBiZWNhdXNlIGl0IGRvZXNuJ3QgZGVmaW5lIGFueSBvZiB0aGUgbmVjZXNzYXJ5IGZ1bmN0aW9uc1wiKTtcbiAgICBlcnIucHJvcGVydGllcyA9IHtcbiAgICAgIGlkOiBcIm1vZHVsZV9jYW5ub3RfYmVfd3JhcHBlZFwiLFxuICAgICAgZXhwbGFuYXRpb246IFwiVGhpcyBtb2R1bGUgY2Fubm90IGJlIHdyYXBwZWQsIGJlY2F1c2UgaXQgZG9lc24ndCBkZWZpbmUgYW55IG9mIHRoZSBuZWNlc3NhcnkgZnVuY3Rpb25zXCJcbiAgICB9O1xuICAgIHRocm93IGVycjtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBtb2R1bGVba2V5XSB8fCAobW9kdWxlW2tleV0gPSBkZWZhdWx0c1trZXldKTtcbiAgfVxuICByZXR1cm4gbW9kdWxlO1xufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/module-wrapper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/common.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/common.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/module-wrapper.js\");\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/filetypes.js\");\nvar _require = __webpack_require__(/*! ../content-types.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/content-types.js\"),\n  settingsContentType = _require.settingsContentType,\n  coreContentType = _require.coreContentType,\n  appContentType = _require.appContentType,\n  customContentType = _require.customContentType,\n  diagramDataContentType = _require.diagramDataContentType,\n  diagramDrawingContentType = _require.diagramDrawingContentType;\nvar commonContentTypes = [settingsContentType, coreContentType, appContentType, customContentType, diagramDataContentType, diagramDrawingContentType];\nvar Common = /*#__PURE__*/function () {\n  function Common() {\n    _classCallCheck(this, Common);\n    this.name = \"Common\";\n  }\n  return _createClass(Common, [{\n    key: \"getFileType\",\n    value: function getFileType(_ref) {\n      var doc = _ref.doc;\n      var invertedContentTypes = doc.invertedContentTypes;\n      if (!invertedContentTypes) {\n        return;\n      }\n      for (var _i2 = 0; _i2 < commonContentTypes.length; _i2++) {\n        var ct = commonContentTypes[_i2];\n        if (invertedContentTypes[ct]) {\n          Array.prototype.push.apply(doc.targets, invertedContentTypes[ct]);\n        }\n      }\n      var keys = [\"docx\", \"pptx\", \"xlsx\"];\n      var ftCandidate;\n      for (var _i4 = 0; _i4 < keys.length; _i4++) {\n        var key = keys[_i4];\n        var contentTypes = filetypes[key];\n        for (var _i6 = 0; _i6 < contentTypes.length; _i6++) {\n          var _ct = contentTypes[_i6];\n          if (invertedContentTypes[_ct]) {\n            for (var _i8 = 0, _invertedContentTypes2 = invertedContentTypes[_ct]; _i8 < _invertedContentTypes2.length; _i8++) {\n              var target = _invertedContentTypes2[_i8];\n              if (doc.relsTypes[target] && [\"http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument\", \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\"].indexOf(doc.relsTypes[target]) === -1) {\n                continue;\n              }\n              ftCandidate = key;\n              if (filetypes.main.indexOf(_ct) !== -1 || _ct === filetypes.pptx[0]) {\n                doc.textTarget || (doc.textTarget = target);\n              }\n              if (ftCandidate === \"xlsx\") {\n                continue;\n              }\n              doc.targets.push(target);\n            }\n          }\n        }\n        if (ftCandidate) {\n          return ftCandidate;\n        }\n      }\n      return ftCandidate;\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new Common());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGNBQWMsbUJBQU8sQ0FBQyw2SEFBc0I7QUFDNUMsZ0JBQWdCLG1CQUFPLENBQUMsbUhBQWlCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQywySEFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQSxrRkFBa0YscUNBQXFDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy8ucG5wbS9kb2N4dGVtcGxhdGVyQDMuNjAuMi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2NvbW1vbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgZmlsZXR5cGVzID0gcmVxdWlyZShcIi4uL2ZpbGV0eXBlcy5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9jb250ZW50LXR5cGVzLmpzXCIpLFxuICBzZXR0aW5nc0NvbnRlbnRUeXBlID0gX3JlcXVpcmUuc2V0dGluZ3NDb250ZW50VHlwZSxcbiAgY29yZUNvbnRlbnRUeXBlID0gX3JlcXVpcmUuY29yZUNvbnRlbnRUeXBlLFxuICBhcHBDb250ZW50VHlwZSA9IF9yZXF1aXJlLmFwcENvbnRlbnRUeXBlLFxuICBjdXN0b21Db250ZW50VHlwZSA9IF9yZXF1aXJlLmN1c3RvbUNvbnRlbnRUeXBlLFxuICBkaWFncmFtRGF0YUNvbnRlbnRUeXBlID0gX3JlcXVpcmUuZGlhZ3JhbURhdGFDb250ZW50VHlwZSxcbiAgZGlhZ3JhbURyYXdpbmdDb250ZW50VHlwZSA9IF9yZXF1aXJlLmRpYWdyYW1EcmF3aW5nQ29udGVudFR5cGU7XG52YXIgY29tbW9uQ29udGVudFR5cGVzID0gW3NldHRpbmdzQ29udGVudFR5cGUsIGNvcmVDb250ZW50VHlwZSwgYXBwQ29udGVudFR5cGUsIGN1c3RvbUNvbnRlbnRUeXBlLCBkaWFncmFtRGF0YUNvbnRlbnRUeXBlLCBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlXTtcbnZhciBDb21tb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21tb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbW1vbik7XG4gICAgdGhpcy5uYW1lID0gXCJDb21tb25cIjtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENvbW1vbiwgW3tcbiAgICBrZXk6IFwiZ2V0RmlsZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsZVR5cGUoX3JlZikge1xuICAgICAgdmFyIGRvYyA9IF9yZWYuZG9jO1xuICAgICAgdmFyIGludmVydGVkQ29udGVudFR5cGVzID0gZG9jLmludmVydGVkQ29udGVudFR5cGVzO1xuICAgICAgaWYgKCFpbnZlcnRlZENvbnRlbnRUeXBlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBjb21tb25Db250ZW50VHlwZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgY3QgPSBjb21tb25Db250ZW50VHlwZXNbX2kyXTtcbiAgICAgICAgaWYgKGludmVydGVkQ29udGVudFR5cGVzW2N0XSkge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy50YXJnZXRzLCBpbnZlcnRlZENvbnRlbnRUeXBlc1tjdF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIga2V5cyA9IFtcImRvY3hcIiwgXCJwcHR4XCIsIFwieGxzeFwiXTtcbiAgICAgIHZhciBmdENhbmRpZGF0ZTtcbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGtleXMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tfaTRdO1xuICAgICAgICB2YXIgY29udGVudFR5cGVzID0gZmlsZXR5cGVzW2tleV07XG4gICAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGNvbnRlbnRUeXBlcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgICAgICAgdmFyIF9jdCA9IGNvbnRlbnRUeXBlc1tfaTZdO1xuICAgICAgICAgIGlmIChpbnZlcnRlZENvbnRlbnRUeXBlc1tfY3RdKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaTggPSAwLCBfaW52ZXJ0ZWRDb250ZW50VHlwZXMyID0gaW52ZXJ0ZWRDb250ZW50VHlwZXNbX2N0XTsgX2k4IDwgX2ludmVydGVkQ29udGVudFR5cGVzMi5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBfaW52ZXJ0ZWRDb250ZW50VHlwZXMyW19pOF07XG4gICAgICAgICAgICAgIGlmIChkb2MucmVsc1R5cGVzW3RhcmdldF0gJiYgW1wiaHR0cDovL3B1cmwub2NsYy5vcmcvb294bWwvb2ZmaWNlRG9jdW1lbnQvcmVsYXRpb25zaGlwcy9vZmZpY2VEb2N1bWVudFwiLCBcImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9vZmZpY2VEb2N1bWVudC8yMDA2L3JlbGF0aW9uc2hpcHMvb2ZmaWNlRG9jdW1lbnRcIl0uaW5kZXhPZihkb2MucmVsc1R5cGVzW3RhcmdldF0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ0Q2FuZGlkYXRlID0ga2V5O1xuICAgICAgICAgICAgICBpZiAoZmlsZXR5cGVzLm1haW4uaW5kZXhPZihfY3QpICE9PSAtMSB8fCBfY3QgPT09IGZpbGV0eXBlcy5wcHR4WzBdKSB7XG4gICAgICAgICAgICAgICAgZG9jLnRleHRUYXJnZXQgfHwgKGRvYy50ZXh0VGFyZ2V0ID0gdGFyZ2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZnRDYW5kaWRhdGUgPT09IFwieGxzeFwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZG9jLnRhcmdldHMucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZnRDYW5kaWRhdGUpIHtcbiAgICAgICAgICByZXR1cm4gZnRDYW5kaWRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmdENhbmRpZGF0ZTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd3JhcHBlcihuZXcgQ29tbW9uKCkpO1xufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/expand-pair-trait.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/expand-pair-trait.js ***!
  \************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar traitName = \"expandPair\";\nvar mergeSort = __webpack_require__(/*! ../merge-sort.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/merge-sort.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  getLeft = _require.getLeft,\n  getRight = _require.getRight,\n  pushArray = _require.pushArray;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require2 = __webpack_require__(/*! ../traits.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/traits.js\"),\n  getExpandToDefault = _require2.getExpandToDefault;\nvar _require3 = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\"),\n  getUnmatchedLoopException = _require3.getUnmatchedLoopException,\n  getClosingTagNotMatchOpeningTag = _require3.getClosingTagNotMatchOpeningTag,\n  getUnbalancedLoopException = _require3.getUnbalancedLoopException;\nfunction getOpenCountChange(part) {\n  switch (part.location) {\n    case \"start\":\n      return 1;\n    case \"end\":\n      return -1;\n  }\n}\nfunction match(start, end) {\n  return start != null && end != null && (start.part.location === \"start\" && end.part.location === \"end\" && start.part.value === end.part.value || end.part.value === \"\");\n}\nfunction transformer(traits) {\n  var i = 0;\n  var errors = [];\n  while (i < traits.length) {\n    var part = traits[i].part;\n    if (part.location === \"end\") {\n      if (i === 0) {\n        traits.splice(0, 1);\n        errors.push(getUnmatchedLoopException(part));\n        return {\n          traits: traits,\n          errors: errors\n        };\n      }\n      var endIndex = i;\n      var startIndex = i - 1;\n      var offseter = 1;\n      if (match(traits[startIndex], traits[endIndex])) {\n        traits.splice(endIndex, 1);\n        traits.splice(startIndex, 1);\n        return {\n          errors: errors,\n          traits: traits\n        };\n      }\n      while (offseter < 50) {\n        var startCandidate = traits[startIndex - offseter];\n        var endCandidate = traits[endIndex + offseter];\n        if (match(startCandidate, traits[endIndex])) {\n          traits.splice(endIndex, 1);\n          traits.splice(startIndex - offseter, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n        if (match(traits[startIndex], endCandidate)) {\n          traits.splice(endIndex + offseter, 1);\n          traits.splice(startIndex, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n        offseter++;\n      }\n      errors.push(getClosingTagNotMatchOpeningTag({\n        tags: [traits[startIndex].part, traits[endIndex].part]\n      }));\n      traits.splice(endIndex, 1);\n      traits.splice(startIndex, 1);\n      return {\n        traits: traits,\n        errors: errors\n      };\n    }\n    i++;\n  }\n  for (var _i2 = 0; _i2 < traits.length; _i2++) {\n    var _part = traits[_i2].part;\n    errors.push(getUnmatchedLoopException(_part));\n  }\n  return {\n    traits: [],\n    errors: errors\n  };\n}\nfunction getPairs(traits) {\n  var levelTraits = {};\n  var errors = [];\n  var pairs = [];\n  var transformedTraits = [];\n  pushArray(transformedTraits, traits);\n  while (transformedTraits.length > 0) {\n    var result = transformer(transformedTraits);\n    pushArray(errors, result.errors);\n    transformedTraits = result.traits;\n  }\n\n  // Stryker disable all : because this check makes the function return quicker\n  if (errors.length > 0) {\n    return {\n      pairs: pairs,\n      errors: errors\n    };\n  }\n  // Stryker restore all\n  var countOpen = 0;\n  for (var _i4 = 0; _i4 < traits.length; _i4++) {\n    var currentTrait = traits[_i4];\n    var part = currentTrait.part;\n    var change = getOpenCountChange(part);\n    countOpen += change;\n    if (change === 1) {\n      levelTraits[countOpen] = currentTrait;\n    } else {\n      var startTrait = levelTraits[countOpen + 1];\n      if (countOpen === 0) {\n        pairs.push([startTrait, currentTrait]);\n      }\n    }\n    countOpen = countOpen >= 0 ? countOpen : 0;\n  }\n  return {\n    pairs: pairs,\n    errors: errors\n  };\n}\nvar ExpandPairTrait = /*#__PURE__*/function () {\n  function ExpandPairTrait() {\n    _classCallCheck(this, ExpandPairTrait);\n    this.name = \"ExpandPairTrait\";\n  }\n  return _createClass(ExpandPairTrait, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      if (docxtemplater.options.paragraphLoop) {\n        pushArray(docxtemplater.fileTypeConfig.expandTags, docxtemplater.fileTypeConfig.onParagraphLoop);\n      }\n      this.expandTags = docxtemplater.fileTypeConfig.expandTags;\n      return options;\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, _ref) {\n      var _this = this;\n      var getTraits = _ref.getTraits,\n        _postparse = _ref.postparse,\n        fileType = _ref.fileType;\n      var traits = getTraits(traitName, postparsed);\n      traits = traits.map(function (trait) {\n        return trait || [];\n      });\n      traits = mergeSort(traits);\n      var _getPairs = getPairs(traits),\n        pairs = _getPairs.pairs,\n        errors = _getPairs.errors;\n      var lastRight = 0;\n      var lastPair = null;\n      var expandedPairs = pairs.map(function (pair) {\n        var expandTo = pair[0].part.expandTo;\n        if (expandTo === \"auto\" && fileType !== \"text\") {\n          var result = getExpandToDefault(postparsed, pair, _this.expandTags);\n          if (result.error) {\n            errors.push(result.error);\n          }\n          expandTo = result.value;\n        }\n        if (!expandTo || fileType === \"text\") {\n          var _left = pair[0].offset;\n          var _right = pair[1].offset;\n          if (_left < lastRight && !_this.docxtemplater.options.syntax.allowUnbalancedLoops) {\n            errors.push(getUnbalancedLoopException(pair, lastPair));\n          }\n          lastPair = pair;\n          lastRight = _right;\n          return [_left, _right];\n        }\n        var left, right;\n        try {\n          left = getLeft(postparsed, expandTo, pair[0].offset);\n        } catch (e) {\n          errors.push(e);\n        }\n        try {\n          right = getRight(postparsed, expandTo, pair[1].offset);\n        } catch (e) {\n          errors.push(e);\n        }\n        if (left < lastRight && !_this.docxtemplater.options.syntax.allowUnbalancedLoops) {\n          errors.push(getUnbalancedLoopException(pair, lastPair));\n        }\n        lastRight = right;\n        lastPair = pair;\n        return [left, right];\n      });\n\n      // Stryker disable all : because this check makes the function return quicker\n      if (errors.length > 0) {\n        return {\n          postparsed: postparsed,\n          errors: errors\n        };\n      }\n      // Stryker restore all\n      var currentPairIndex = 0;\n      var innerParts;\n      var newParsed = postparsed.reduce(function (newParsed, part, i) {\n        var inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i && i <= expandedPairs[currentPairIndex][1];\n        var pair = pairs[currentPairIndex];\n        var expandedPair = expandedPairs[currentPairIndex];\n        if (!inPair) {\n          newParsed.push(part);\n          return newParsed;\n        }\n        // We're inside the pair\n        if (expandedPair[0] === i) {\n          // Start pair\n          innerParts = [];\n        }\n        if (pair[0].offset !== i && pair[1].offset !== i) {\n          // Exclude inner pair indexes\n          innerParts.push(part);\n        }\n        if (expandedPair[1] === i) {\n          // End pair\n          var basePart = postparsed[pair[0].offset];\n          basePart.subparsed = _postparse(innerParts, {\n            basePart: basePart\n          });\n          basePart.endLindex = pair[1].part.lIndex;\n          delete basePart.location;\n          delete basePart.expandTo;\n          newParsed.push(basePart);\n          currentPairIndex++;\n          var _expandedPair = expandedPairs[currentPairIndex];\n          while (_expandedPair && _expandedPair[0] < i) {\n            /*\n             * If we have :\n             * expandedPairs =[[5,72],[51,67],[90,106]]\n             * Then after treating [5,72], we need to treat [90,106]\n             * Fixed since v3.58.4\n             */\n            currentPairIndex++;\n            _expandedPair = expandedPairs[currentPairIndex];\n          }\n        }\n        return newParsed;\n      }, []);\n      return {\n        postparsed: newParsed,\n        errors: errors\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new ExpandPairTrait());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9leHBhbmQtcGFpci10cmFpdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxSEFBa0I7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLG1IQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsNkhBQXNCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLDZHQUFjO0FBQ3RDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsNkdBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9leHBhbmQtcGFpci10cmFpdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIHRyYWl0TmFtZSA9IFwiZXhwYW5kUGFpclwiO1xudmFyIG1lcmdlU29ydCA9IHJlcXVpcmUoXCIuLi9tZXJnZS1zb3J0LmpzXCIpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2RvYy11dGlscy5qc1wiKSxcbiAgZ2V0TGVmdCA9IF9yZXF1aXJlLmdldExlZnQsXG4gIGdldFJpZ2h0ID0gX3JlcXVpcmUuZ2V0UmlnaHQsXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlLnB1c2hBcnJheTtcbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuLi90cmFpdHMuanNcIiksXG4gIGdldEV4cGFuZFRvRGVmYXVsdCA9IF9yZXF1aXJlMi5nZXRFeHBhbmRUb0RlZmF1bHQ7XG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZShcIi4uL2Vycm9ycy5qc1wiKSxcbiAgZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbiA9IF9yZXF1aXJlMy5nZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uLFxuICBnZXRDbG9zaW5nVGFnTm90TWF0Y2hPcGVuaW5nVGFnID0gX3JlcXVpcmUzLmdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWcsXG4gIGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uID0gX3JlcXVpcmUzLmdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uO1xuZnVuY3Rpb24gZ2V0T3BlbkNvdW50Q2hhbmdlKHBhcnQpIHtcbiAgc3dpdGNoIChwYXJ0LmxvY2F0aW9uKSB7XG4gICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlIFwiZW5kXCI6XG4gICAgICByZXR1cm4gLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hdGNoKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHN0YXJ0ICE9IG51bGwgJiYgZW5kICE9IG51bGwgJiYgKHN0YXJ0LnBhcnQubG9jYXRpb24gPT09IFwic3RhcnRcIiAmJiBlbmQucGFydC5sb2NhdGlvbiA9PT0gXCJlbmRcIiAmJiBzdGFydC5wYXJ0LnZhbHVlID09PSBlbmQucGFydC52YWx1ZSB8fCBlbmQucGFydC52YWx1ZSA9PT0gXCJcIik7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1lcih0cmFpdHMpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgZXJyb3JzID0gW107XG4gIHdoaWxlIChpIDwgdHJhaXRzLmxlbmd0aCkge1xuICAgIHZhciBwYXJ0ID0gdHJhaXRzW2ldLnBhcnQ7XG4gICAgaWYgKHBhcnQubG9jYXRpb24gPT09IFwiZW5kXCIpIHtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHRyYWl0cy5zcGxpY2UoMCwgMSk7XG4gICAgICAgIGVycm9ycy5wdXNoKGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24ocGFydCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYWl0czogdHJhaXRzLFxuICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgZW5kSW5kZXggPSBpO1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBpIC0gMTtcbiAgICAgIHZhciBvZmZzZXRlciA9IDE7XG4gICAgICBpZiAobWF0Y2godHJhaXRzW3N0YXJ0SW5kZXhdLCB0cmFpdHNbZW5kSW5kZXhdKSkge1xuICAgICAgICB0cmFpdHMuc3BsaWNlKGVuZEluZGV4LCAxKTtcbiAgICAgICAgdHJhaXRzLnNwbGljZShzdGFydEluZGV4LCAxKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICB0cmFpdHM6IHRyYWl0c1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG9mZnNldGVyIDwgNTApIHtcbiAgICAgICAgdmFyIHN0YXJ0Q2FuZGlkYXRlID0gdHJhaXRzW3N0YXJ0SW5kZXggLSBvZmZzZXRlcl07XG4gICAgICAgIHZhciBlbmRDYW5kaWRhdGUgPSB0cmFpdHNbZW5kSW5kZXggKyBvZmZzZXRlcl07XG4gICAgICAgIGlmIChtYXRjaChzdGFydENhbmRpZGF0ZSwgdHJhaXRzW2VuZEluZGV4XSkpIHtcbiAgICAgICAgICB0cmFpdHMuc3BsaWNlKGVuZEluZGV4LCAxKTtcbiAgICAgICAgICB0cmFpdHMuc3BsaWNlKHN0YXJ0SW5kZXggLSBvZmZzZXRlciwgMSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICAgICAgdHJhaXRzOiB0cmFpdHNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCh0cmFpdHNbc3RhcnRJbmRleF0sIGVuZENhbmRpZGF0ZSkpIHtcbiAgICAgICAgICB0cmFpdHMuc3BsaWNlKGVuZEluZGV4ICsgb2Zmc2V0ZXIsIDEpO1xuICAgICAgICAgIHRyYWl0cy5zcGxpY2Uoc3RhcnRJbmRleCwgMSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICAgICAgdHJhaXRzOiB0cmFpdHNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldGVyKys7XG4gICAgICB9XG4gICAgICBlcnJvcnMucHVzaChnZXRDbG9zaW5nVGFnTm90TWF0Y2hPcGVuaW5nVGFnKHtcbiAgICAgICAgdGFnczogW3RyYWl0c1tzdGFydEluZGV4XS5wYXJ0LCB0cmFpdHNbZW5kSW5kZXhdLnBhcnRdXG4gICAgICB9KSk7XG4gICAgICB0cmFpdHMuc3BsaWNlKGVuZEluZGV4LCAxKTtcbiAgICAgIHRyYWl0cy5zcGxpY2Uoc3RhcnRJbmRleCwgMSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFpdHM6IHRyYWl0cyxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgIH07XG4gICAgfVxuICAgIGkrKztcbiAgfVxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB0cmFpdHMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfcGFydCA9IHRyYWl0c1tfaTJdLnBhcnQ7XG4gICAgZXJyb3JzLnB1c2goZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbihfcGFydCkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHJhaXRzOiBbXSxcbiAgICBlcnJvcnM6IGVycm9yc1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGFpcnModHJhaXRzKSB7XG4gIHZhciBsZXZlbFRyYWl0cyA9IHt9O1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBwYWlycyA9IFtdO1xuICB2YXIgdHJhbnNmb3JtZWRUcmFpdHMgPSBbXTtcbiAgcHVzaEFycmF5KHRyYW5zZm9ybWVkVHJhaXRzLCB0cmFpdHMpO1xuICB3aGlsZSAodHJhbnNmb3JtZWRUcmFpdHMubGVuZ3RoID4gMCkge1xuICAgIHZhciByZXN1bHQgPSB0cmFuc2Zvcm1lcih0cmFuc2Zvcm1lZFRyYWl0cyk7XG4gICAgcHVzaEFycmF5KGVycm9ycywgcmVzdWx0LmVycm9ycyk7XG4gICAgdHJhbnNmb3JtZWRUcmFpdHMgPSByZXN1bHQudHJhaXRzO1xuICB9XG5cbiAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhpcyBjaGVjayBtYWtlcyB0aGUgZnVuY3Rpb24gcmV0dXJuIHF1aWNrZXJcbiAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhaXJzOiBwYWlycyxcbiAgICAgIGVycm9yczogZXJyb3JzXG4gICAgfTtcbiAgfVxuICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG4gIHZhciBjb3VudE9wZW4gPSAwO1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCB0cmFpdHMubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBjdXJyZW50VHJhaXQgPSB0cmFpdHNbX2k0XTtcbiAgICB2YXIgcGFydCA9IGN1cnJlbnRUcmFpdC5wYXJ0O1xuICAgIHZhciBjaGFuZ2UgPSBnZXRPcGVuQ291bnRDaGFuZ2UocGFydCk7XG4gICAgY291bnRPcGVuICs9IGNoYW5nZTtcbiAgICBpZiAoY2hhbmdlID09PSAxKSB7XG4gICAgICBsZXZlbFRyYWl0c1tjb3VudE9wZW5dID0gY3VycmVudFRyYWl0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnRUcmFpdCA9IGxldmVsVHJhaXRzW2NvdW50T3BlbiArIDFdO1xuICAgICAgaWYgKGNvdW50T3BlbiA9PT0gMCkge1xuICAgICAgICBwYWlycy5wdXNoKFtzdGFydFRyYWl0LCBjdXJyZW50VHJhaXRdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY291bnRPcGVuID0gY291bnRPcGVuID49IDAgPyBjb3VudE9wZW4gOiAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGFpcnM6IHBhaXJzLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG52YXIgRXhwYW5kUGFpclRyYWl0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXhwYW5kUGFpclRyYWl0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFeHBhbmRQYWlyVHJhaXQpO1xuICAgIHRoaXMubmFtZSA9IFwiRXhwYW5kUGFpclRyYWl0XCI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFeHBhbmRQYWlyVHJhaXQsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNUcmFuc2Zvcm1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpb25zVHJhbnNmb3JtZXIob3B0aW9ucywgZG9jeHRlbXBsYXRlcikge1xuICAgICAgaWYgKGRvY3h0ZW1wbGF0ZXIub3B0aW9ucy5wYXJhZ3JhcGhMb29wKSB7XG4gICAgICAgIHB1c2hBcnJheShkb2N4dGVtcGxhdGVyLmZpbGVUeXBlQ29uZmlnLmV4cGFuZFRhZ3MsIGRvY3h0ZW1wbGF0ZXIuZmlsZVR5cGVDb25maWcub25QYXJhZ3JhcGhMb29wKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwYW5kVGFncyA9IGRvY3h0ZW1wbGF0ZXIuZmlsZVR5cGVDb25maWcuZXhwYW5kVGFncztcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQsIF9yZWYpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgZ2V0VHJhaXRzID0gX3JlZi5nZXRUcmFpdHMsXG4gICAgICAgIF9wb3N0cGFyc2UgPSBfcmVmLnBvc3RwYXJzZSxcbiAgICAgICAgZmlsZVR5cGUgPSBfcmVmLmZpbGVUeXBlO1xuICAgICAgdmFyIHRyYWl0cyA9IGdldFRyYWl0cyh0cmFpdE5hbWUsIHBvc3RwYXJzZWQpO1xuICAgICAgdHJhaXRzID0gdHJhaXRzLm1hcChmdW5jdGlvbiAodHJhaXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYWl0IHx8IFtdO1xuICAgICAgfSk7XG4gICAgICB0cmFpdHMgPSBtZXJnZVNvcnQodHJhaXRzKTtcbiAgICAgIHZhciBfZ2V0UGFpcnMgPSBnZXRQYWlycyh0cmFpdHMpLFxuICAgICAgICBwYWlycyA9IF9nZXRQYWlycy5wYWlycyxcbiAgICAgICAgZXJyb3JzID0gX2dldFBhaXJzLmVycm9ycztcbiAgICAgIHZhciBsYXN0UmlnaHQgPSAwO1xuICAgICAgdmFyIGxhc3RQYWlyID0gbnVsbDtcbiAgICAgIHZhciBleHBhbmRlZFBhaXJzID0gcGFpcnMubWFwKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgIHZhciBleHBhbmRUbyA9IHBhaXJbMF0ucGFydC5leHBhbmRUbztcbiAgICAgICAgaWYgKGV4cGFuZFRvID09PSBcImF1dG9cIiAmJiBmaWxlVHlwZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0RXhwYW5kVG9EZWZhdWx0KHBvc3RwYXJzZWQsIHBhaXIsIF90aGlzLmV4cGFuZFRhZ3MpO1xuICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cGFuZFRvID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXhwYW5kVG8gfHwgZmlsZVR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdmFyIF9sZWZ0ID0gcGFpclswXS5vZmZzZXQ7XG4gICAgICAgICAgdmFyIF9yaWdodCA9IHBhaXJbMV0ub2Zmc2V0O1xuICAgICAgICAgIGlmIChfbGVmdCA8IGxhc3RSaWdodCAmJiAhX3RoaXMuZG9jeHRlbXBsYXRlci5vcHRpb25zLnN5bnRheC5hbGxvd1VuYmFsYW5jZWRMb29wcykge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb24ocGFpciwgbGFzdFBhaXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdFBhaXIgPSBwYWlyO1xuICAgICAgICAgIGxhc3RSaWdodCA9IF9yaWdodDtcbiAgICAgICAgICByZXR1cm4gW19sZWZ0LCBfcmlnaHRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZWZ0LCByaWdodDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZWZ0ID0gZ2V0TGVmdChwb3N0cGFyc2VkLCBleHBhbmRUbywgcGFpclswXS5vZmZzZXQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByaWdodCA9IGdldFJpZ2h0KHBvc3RwYXJzZWQsIGV4cGFuZFRvLCBwYWlyWzFdLm9mZnNldCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCA8IGxhc3RSaWdodCAmJiAhX3RoaXMuZG9jeHRlbXBsYXRlci5vcHRpb25zLnN5bnRheC5hbGxvd1VuYmFsYW5jZWRMb29wcykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uKHBhaXIsIGxhc3RQYWlyKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIGxhc3RQYWlyID0gcGFpcjtcbiAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICB9KTtcblxuICAgICAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhpcyBjaGVjayBtYWtlcyB0aGUgZnVuY3Rpb24gcmV0dXJuIHF1aWNrZXJcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvc3RwYXJzZWQ6IHBvc3RwYXJzZWQsXG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcbiAgICAgIHZhciBjdXJyZW50UGFpckluZGV4ID0gMDtcbiAgICAgIHZhciBpbm5lclBhcnRzO1xuICAgICAgdmFyIG5ld1BhcnNlZCA9IHBvc3RwYXJzZWQucmVkdWNlKGZ1bmN0aW9uIChuZXdQYXJzZWQsIHBhcnQsIGkpIHtcbiAgICAgICAgdmFyIGluUGFpciA9IGN1cnJlbnRQYWlySW5kZXggPCBwYWlycy5sZW5ndGggJiYgZXhwYW5kZWRQYWlyc1tjdXJyZW50UGFpckluZGV4XVswXSA8PSBpICYmIGkgPD0gZXhwYW5kZWRQYWlyc1tjdXJyZW50UGFpckluZGV4XVsxXTtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tjdXJyZW50UGFpckluZGV4XTtcbiAgICAgICAgdmFyIGV4cGFuZGVkUGFpciA9IGV4cGFuZGVkUGFpcnNbY3VycmVudFBhaXJJbmRleF07XG4gICAgICAgIGlmICghaW5QYWlyKSB7XG4gICAgICAgICAgbmV3UGFyc2VkLnB1c2gocGFydCk7XG4gICAgICAgICAgcmV0dXJuIG5ld1BhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSdyZSBpbnNpZGUgdGhlIHBhaXJcbiAgICAgICAgaWYgKGV4cGFuZGVkUGFpclswXSA9PT0gaSkge1xuICAgICAgICAgIC8vIFN0YXJ0IHBhaXJcbiAgICAgICAgICBpbm5lclBhcnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhaXJbMF0ub2Zmc2V0ICE9PSBpICYmIHBhaXJbMV0ub2Zmc2V0ICE9PSBpKSB7XG4gICAgICAgICAgLy8gRXhjbHVkZSBpbm5lciBwYWlyIGluZGV4ZXNcbiAgICAgICAgICBpbm5lclBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGFuZGVkUGFpclsxXSA9PT0gaSkge1xuICAgICAgICAgIC8vIEVuZCBwYWlyXG4gICAgICAgICAgdmFyIGJhc2VQYXJ0ID0gcG9zdHBhcnNlZFtwYWlyWzBdLm9mZnNldF07XG4gICAgICAgICAgYmFzZVBhcnQuc3VicGFyc2VkID0gX3Bvc3RwYXJzZShpbm5lclBhcnRzLCB7XG4gICAgICAgICAgICBiYXNlUGFydDogYmFzZVBhcnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBiYXNlUGFydC5lbmRMaW5kZXggPSBwYWlyWzFdLnBhcnQubEluZGV4O1xuICAgICAgICAgIGRlbGV0ZSBiYXNlUGFydC5sb2NhdGlvbjtcbiAgICAgICAgICBkZWxldGUgYmFzZVBhcnQuZXhwYW5kVG87XG4gICAgICAgICAgbmV3UGFyc2VkLnB1c2goYmFzZVBhcnQpO1xuICAgICAgICAgIGN1cnJlbnRQYWlySW5kZXgrKztcbiAgICAgICAgICB2YXIgX2V4cGFuZGVkUGFpciA9IGV4cGFuZGVkUGFpcnNbY3VycmVudFBhaXJJbmRleF07XG4gICAgICAgICAgd2hpbGUgKF9leHBhbmRlZFBhaXIgJiYgX2V4cGFuZGVkUGFpclswXSA8IGkpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIDpcbiAgICAgICAgICAgICAqIGV4cGFuZGVkUGFpcnMgPVtbNSw3Ml0sWzUxLDY3XSxbOTAsMTA2XV1cbiAgICAgICAgICAgICAqIFRoZW4gYWZ0ZXIgdHJlYXRpbmcgWzUsNzJdLCB3ZSBuZWVkIHRvIHRyZWF0IFs5MCwxMDZdXG4gICAgICAgICAgICAgKiBGaXhlZCBzaW5jZSB2My41OC40XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGN1cnJlbnRQYWlySW5kZXgrKztcbiAgICAgICAgICAgIF9leHBhbmRlZFBhaXIgPSBleHBhbmRlZFBhaXJzW2N1cnJlbnRQYWlySW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UGFyc2VkO1xuICAgICAgfSwgW10pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zdHBhcnNlZDogbmV3UGFyc2VkLFxuICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd3JhcHBlcihuZXcgRXhwYW5kUGFpclRyYWl0KCkpO1xufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/expand-pair-trait.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/loop.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/loop.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  chunkBy = _require.chunkBy,\n  last = _require.last,\n  isParagraphStart = _require.isParagraphStart,\n  isModule = _require.isModule,\n  pushArray = _require.pushArray,\n  isParagraphEnd = _require.isParagraphEnd,\n  isContent = _require.isContent,\n  startsWith = _require.startsWith,\n  isTagEnd = _require.isTagEnd,\n  isTagStart = _require.isTagStart,\n  getSingleAttribute = _require.getSingleAttribute,\n  setSingleAttribute = _require.setSingleAttribute;\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/filetypes.js\");\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/module-wrapper.js\");\nvar moduleName = \"loop\";\nfunction hasContent(parts) {\n  return parts.some(function (part) {\n    return isContent(part);\n  });\n}\nfunction getFirstMeaningFulPart(parsed) {\n  for (var _i2 = 0; _i2 < parsed.length; _i2++) {\n    var part = parsed[_i2];\n    if (part.type !== \"content\") {\n      return part;\n    }\n  }\n  return null;\n}\nfunction isInsideParagraphLoop(part) {\n  var firstMeaningfulPart = getFirstMeaningFulPart(part.subparsed);\n  return firstMeaningfulPart != null && firstMeaningfulPart.tag !== \"w:t\";\n}\nfunction getPageBreakIfApplies(part) {\n  return part.hasPageBreak && isInsideParagraphLoop(part) ? '<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>' : \"\";\n}\nfunction isEnclosedByParagraphs(parsed) {\n  return parsed.length && isParagraphStart(parsed[0]) && isParagraphEnd(last(parsed));\n}\nfunction getOffset(chunk) {\n  return hasContent(chunk) ? 0 : chunk.length;\n}\nfunction addPageBreakAtEnd(subRendered) {\n  var j = subRendered.parts.length - 1;\n  if (subRendered.parts[j] === \"</w:p>\") {\n    subRendered.parts.splice(j, 0, '<w:r><w:br w:type=\"page\"/></w:r>');\n  } else {\n    subRendered.parts.push('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n  }\n}\nfunction addPageBreakAtBeginning(subRendered) {\n  subRendered.parts.unshift('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n}\nfunction isContinuous(parts) {\n  return parts.some(function (part) {\n    return isTagStart(\"w:type\", part) && part.value.indexOf(\"continuous\") !== -1;\n  });\n}\nfunction isNextPage(parts) {\n  return parts.some(function (part) {\n    return isTagStart(\"w:type\", part) && part.value.indexOf('w:val=\"nextPage\"') !== -1;\n  });\n}\nfunction addSectionBefore(parts, sect) {\n  return pushArray([\"<w:p><w:pPr>\".concat(sect.map(function (_ref) {\n    var value = _ref.value;\n    return value;\n  }).join(\"\"), \"</w:pPr></w:p>\")], parts);\n}\nfunction addContinuousType(parts) {\n  var stop = false;\n  var inSectPr = false;\n  return parts.reduce(function (result, part) {\n    if (stop === false && startsWith(part, \"<w:sectPr\")) {\n      inSectPr = true;\n    }\n    if (inSectPr) {\n      if (startsWith(part, \"<w:type\")) {\n        stop = true;\n      }\n      if (stop === false && startsWith(part, \"</w:sectPr\")) {\n        result.push('<w:type w:val=\"continuous\"/>');\n      }\n    }\n    result.push(part);\n    return result;\n  }, []);\n}\nfunction dropHeaderFooterRefs(parts) {\n  return parts.filter(function (text) {\n    return !startsWith(text, \"<w:headerReference\") && !startsWith(text, \"<w:footerReference\");\n  });\n}\nfunction hasPageBreak(chunk) {\n  return chunk.some(function (part) {\n    return part.tag === \"w:br\" && part.value.indexOf('w:type=\"page\"') !== -1;\n  });\n}\nfunction hasImage(chunk) {\n  return chunk.some(function (_ref2) {\n    var tag = _ref2.tag;\n    return tag === \"w:drawing\";\n  });\n}\nfunction getSectPr(chunks) {\n  var collectSectPr = false;\n  var sectPrs = [];\n  for (var _i4 = 0; _i4 < chunks.length; _i4++) {\n    var part = chunks[_i4];\n    if (isTagStart(\"w:sectPr\", part)) {\n      sectPrs.push([]);\n      collectSectPr = true;\n    }\n    if (collectSectPr) {\n      sectPrs[sectPrs.length - 1].push(part);\n    }\n    if (isTagEnd(\"w:sectPr\", part)) {\n      collectSectPr = false;\n    }\n  }\n  return sectPrs;\n}\nfunction getSectPrHeaderFooterChangeCount(chunks) {\n  var collectSectPr = false;\n  var sectPrCount = 0;\n  for (var _i6 = 0; _i6 < chunks.length; _i6++) {\n    var part = chunks[_i6];\n    if (isTagStart(\"w:sectPr\", part)) {\n      collectSectPr = true;\n    }\n    if (collectSectPr) {\n      if (part.tag === \"w:headerReference\" || part.tag === \"w:footerReference\") {\n        sectPrCount++;\n        collectSectPr = false;\n      }\n    }\n    if (isTagEnd(\"w:sectPr\", part)) {\n      collectSectPr = false;\n    }\n  }\n  return sectPrCount;\n}\nfunction getLastSectPr(parsed) {\n  var sectPr = [];\n  var inSectPr = false;\n  for (var i = parsed.length - 1; i >= 0; i--) {\n    var part = parsed[i];\n    if (isTagEnd(\"w:sectPr\", part)) {\n      inSectPr = true;\n    }\n    if (isTagStart(\"w:sectPr\", part)) {\n      sectPr.unshift(part.value);\n      inSectPr = false;\n    }\n    if (inSectPr) {\n      sectPr.unshift(part.value);\n    }\n    if (isParagraphStart(part)) {\n      if (sectPr.length > 0) {\n        return sectPr.join(\"\");\n      }\n      break;\n    }\n  }\n  return \"\";\n}\nvar LoopModule = /*#__PURE__*/function () {\n  function LoopModule() {\n    _classCallCheck(this, LoopModule);\n    this.name = \"LoopModule\";\n    this.inXfrm = false;\n    this.totalSectPr = 0;\n    this.prefix = {\n      start: \"#\",\n      end: \"/\",\n      dash: /^-([^\\s]+)\\s(.+)/,\n      inverted: \"^\"\n    };\n  }\n  return _createClass(LoopModule, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(opts, docxtemplater) {\n      this.docxtemplater = docxtemplater;\n      return opts;\n    }\n  }, {\n    key: \"preparse\",\n    value: function preparse(parsed, _ref3) {\n      var contentType = _ref3.contentType;\n      if (filetypes.main.indexOf(contentType) !== -1) {\n        this.sects = getSectPr(parsed);\n      }\n    }\n  }, {\n    key: \"matchers\",\n    value: function matchers() {\n      var module = moduleName;\n      return [[this.prefix.start, module, {\n        expandTo: \"auto\",\n        location: \"start\",\n        inverted: false\n      }], [this.prefix.inverted, module, {\n        expandTo: \"auto\",\n        location: \"start\",\n        inverted: true\n      }], [this.prefix.end, module, {\n        location: \"end\"\n      }], [this.prefix.dash, module, function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 3),\n          expandTo = _ref5[1],\n          value = _ref5[2];\n        return {\n          location: \"start\",\n          inverted: false,\n          expandTo: expandTo,\n          value: value\n        };\n      }]];\n    }\n  }, {\n    key: \"getTraits\",\n    value: function getTraits(traitName, parsed) {\n      // Stryker disable all : because getTraits should disappear in v4\n      if (traitName !== \"expandPair\") {\n        return;\n      }\n      // Stryker restore all\n\n      return parsed.reduce(function (tags, part, offset) {\n        if (isModule(part, moduleName) && part.subparsed == null) {\n          tags.push({\n            part: part,\n            offset: offset\n          });\n        }\n        return tags;\n      }, []);\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(parsed, _ref6) {\n      var basePart = _ref6.basePart;\n      if (basePart && this.docxtemplater.fileType === \"docx\" && parsed.length > 0) {\n        basePart.sectPrCount = getSectPrHeaderFooterChangeCount(parsed);\n        this.totalSectPr += basePart.sectPrCount;\n        var sects = this.sects;\n        sects.some(function (sect, index) {\n          if (basePart.lIndex < sect[0].lIndex) {\n            if (index + 1 < sects.length && isContinuous(sects[index + 1])) {\n              basePart.addContinuousType = true;\n            }\n            return true;\n          }\n          if (parsed[0].lIndex < sect[0].lIndex && sect[0].lIndex < basePart.lIndex) {\n            if (isNextPage(sects[index])) {\n              basePart.addNextPage = {\n                index: index\n              };\n            }\n            return true;\n          }\n        });\n        basePart.lastParagrapSectPr = getLastSectPr(parsed);\n      }\n      if (!basePart || basePart.expandTo !== \"auto\" || basePart.module !== moduleName || !isEnclosedByParagraphs(parsed)) {\n        return parsed;\n      }\n      basePart.paragraphLoop = true;\n      var level = 0;\n      var chunks = chunkBy(parsed, function (p) {\n        if (isParagraphStart(p)) {\n          level++;\n          if (level === 1) {\n            return \"start\";\n          }\n        }\n        if (isParagraphEnd(p)) {\n          level--;\n          if (level === 0) {\n            return \"end\";\n          }\n        }\n        return null;\n      });\n      var firstChunk = chunks[0];\n      var lastChunk = last(chunks);\n      var firstOffset = getOffset(firstChunk);\n      var lastOffset = getOffset(lastChunk);\n      basePart.hasPageBreakBeginning = hasPageBreak(firstChunk);\n      basePart.hasPageBreak = hasPageBreak(lastChunk);\n      if (hasImage(firstChunk)) {\n        firstOffset = 0;\n      }\n      if (hasImage(lastChunk)) {\n        lastOffset = 0;\n      }\n      return parsed.slice(firstOffset, parsed.length - lastOffset);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(part, options) {\n      if (!isModule(part, moduleName)) {\n        return null;\n      }\n      var sm = options.scopeManager;\n      var promisedValue = sm.getValueAsync(part.value, {\n        part: part\n      });\n      var promises = [];\n      function loopOver(scope, i, length) {\n        var scopeManager = sm.createSubScopeManager(scope, part.value, i, part, length);\n        promises.push(options.resolve(_objectSpread(_objectSpread({}, options), {}, {\n          compiled: part.subparsed,\n          tags: {},\n          scopeManager: scopeManager\n        })));\n      }\n      var errorList = [];\n      return promisedValue.then(function (values) {\n        return new Promise(function (resolve) {\n          if (values instanceof Array) {\n            Promise.all(values).then(resolve);\n          } else {\n            resolve(values);\n          }\n        }).then(function (values) {\n          sm.loopOverValue(values, loopOver, part.inverted);\n          return Promise.all(promises).then(function (r) {\n            return r.map(function (_ref7) {\n              var resolved = _ref7.resolved,\n                errors = _ref7.errors;\n              errorList.push.apply(errorList, _toConsumableArray(errors));\n              return resolved;\n            });\n          }).then(function (value) {\n            if (errorList.length > 0) {\n              throw errorList;\n            }\n            return value;\n          });\n        });\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      if (part.tag === \"p:xfrm\") {\n        this.inXfrm = part.position === \"start\";\n      }\n      if (part.tag === \"a:ext\" && this.inXfrm) {\n        this.lastExt = part;\n        return part;\n      }\n      if (!isModule(part, moduleName)) {\n        return null;\n      }\n      var totalValue = [];\n      var errors = [];\n      var heightOffset = 0;\n      var self = this;\n      var firstTag = part.subparsed[0];\n      var tagHeight = 0;\n      if ((firstTag === null || firstTag === void 0 ? void 0 : firstTag.tag) === \"a:tr\") {\n        tagHeight = +getSingleAttribute(firstTag.value, \"h\");\n      }\n      heightOffset -= tagHeight;\n      var a16RowIdOffset = 0;\n      var insideParagraphLoop = isInsideParagraphLoop(part);\n      function loopOver(scope, i, length) {\n        heightOffset += tagHeight;\n        var scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i, part, length);\n        for (var _i8 = 0, _part$subparsed2 = part.subparsed; _i8 < _part$subparsed2.length; _i8++) {\n          var pp = _part$subparsed2[_i8];\n          if (isTagStart(\"a16:rowId\", pp)) {\n            var val = +getSingleAttribute(pp.value, \"val\") + a16RowIdOffset;\n            a16RowIdOffset = 1;\n            pp.value = setSingleAttribute(pp.value, \"val\", val);\n          }\n        }\n        var subRendered = options.render(_objectSpread(_objectSpread({}, options), {}, {\n          compiled: part.subparsed,\n          tags: {},\n          scopeManager: scopeManager\n        }));\n        if (part.hasPageBreak && i === length - 1 && insideParagraphLoop) {\n          addPageBreakAtEnd(subRendered);\n        }\n        var isNotFirst = scopeManager.scopePathItem.some(function (i) {\n          return i !== 0;\n        });\n        if (isNotFirst) {\n          if (part.sectPrCount === 1) {\n            subRendered.parts = dropHeaderFooterRefs(subRendered.parts);\n          }\n          if (part.addContinuousType) {\n            subRendered.parts = addContinuousType(subRendered.parts);\n          }\n        } else if (part.addNextPage) {\n          subRendered.parts = addSectionBefore(subRendered.parts, self.sects[part.addNextPage.index]);\n        }\n        if (part.addNextPage) {\n          addPageBreakAtEnd(subRendered);\n        }\n        if (part.hasPageBreakBeginning && insideParagraphLoop) {\n          addPageBreakAtBeginning(subRendered);\n        }\n        for (var _i10 = 0, _subRendered$parts2 = subRendered.parts; _i10 < _subRendered$parts2.length; _i10++) {\n          var _val = _subRendered$parts2[_i10];\n          totalValue.push(_val);\n        }\n        Array.prototype.push.apply(errors, subRendered.errors);\n      }\n      var result = options.scopeManager.loopOver(part.value, loopOver, part.inverted, {\n        part: part\n      });\n      // if the loop is showing empty content\n      if (result === false) {\n        if (part.lastParagrapSectPr) {\n          if (part.paragraphLoop) {\n            return {\n              value: \"<w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr></w:p>\")\n            };\n          }\n          return {\n            value: \"</w:t></w:r></w:p><w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr><w:r><w:t>\")\n          };\n        }\n        return {\n          value: getPageBreakIfApplies(part) || \"\",\n          errors: errors\n        };\n      }\n      if (heightOffset !== 0) {\n        var cy = +getSingleAttribute(this.lastExt.value, \"cy\");\n        this.lastExt.value = setSingleAttribute(this.lastExt.value, \"cy\", cy + heightOffset);\n      }\n      return {\n        value: options.joinUncorrupt(totalValue, _objectSpread(_objectSpread({}, options), {}, {\n          basePart: part\n        })),\n        errors: errors\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new LoopModule());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9sb29wLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQyx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qiw2Q0FBNkMsU0FBUywwREFBMEQsVUFBVSxnQ0FBZ0M7QUFDMUosbUNBQW1DLCtDQUErQyw4QkFBOEIsT0FBTyxrQkFBa0I7QUFDekksdUNBQXVDLGtHQUFrRyxpQkFBaUIsd0NBQXdDLE1BQU0seUNBQXlDLDZCQUE2QixVQUFVLFlBQVksa0VBQWtFLFdBQVcsWUFBWSxpQkFBaUIsVUFBVSxNQUFNLGlGQUFpRixVQUFVLG9CQUFvQjtBQUM3Z0IsOEJBQThCO0FBQzlCLGlDQUFpQztBQUNqQyxtQ0FBbUMsZ0JBQWdCLGNBQWMsT0FBTyxjQUFjO0FBQ3RGLGlDQUFpQyxxSEFBcUgsY0FBYztBQUNwSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsbUhBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1IQUFpQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsNkhBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsY0FBYztBQUNsRjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsK0JBQStCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGNBQWM7QUFDckY7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLG1DQUFtQztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxjQUFjO0FBQzdGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy8ucG5wbS9kb2N4dGVtcGxhdGVyQDMuNjAuMi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2xvb3AuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheShyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikgeyBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7IChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTsgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07IHJldHVybiBuOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkgeyB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgcltTeW1ib2wuaXRlcmF0b3JdIHx8IHJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSB0KSB7IHZhciBlLCBuLCBpLCB1LCBhID0gW10sIGYgPSAhMCwgbyA9ICExOyB0cnkgeyBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7IGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjsgZiA9ICExOyB9IGVsc2UgZm9yICg7ICEoZiA9IChlID0gaS5jYWxsKHQpKS5kb25lKSAmJiAoYS5wdXNoKGUudmFsdWUpLCBhLmxlbmd0aCAhPT0gbCk7IGYgPSAhMCk7IH0gY2F0Y2ggKHIpIHsgbyA9ICEwLCBuID0gcjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFmICYmIG51bGwgIT0gdFtcInJldHVyblwiXSAmJiAodSA9IHRbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2RvYy11dGlscy5qc1wiKSxcbiAgY2h1bmtCeSA9IF9yZXF1aXJlLmNodW5rQnksXG4gIGxhc3QgPSBfcmVxdWlyZS5sYXN0LFxuICBpc1BhcmFncmFwaFN0YXJ0ID0gX3JlcXVpcmUuaXNQYXJhZ3JhcGhTdGFydCxcbiAgaXNNb2R1bGUgPSBfcmVxdWlyZS5pc01vZHVsZSxcbiAgcHVzaEFycmF5ID0gX3JlcXVpcmUucHVzaEFycmF5LFxuICBpc1BhcmFncmFwaEVuZCA9IF9yZXF1aXJlLmlzUGFyYWdyYXBoRW5kLFxuICBpc0NvbnRlbnQgPSBfcmVxdWlyZS5pc0NvbnRlbnQsXG4gIHN0YXJ0c1dpdGggPSBfcmVxdWlyZS5zdGFydHNXaXRoLFxuICBpc1RhZ0VuZCA9IF9yZXF1aXJlLmlzVGFnRW5kLFxuICBpc1RhZ1N0YXJ0ID0gX3JlcXVpcmUuaXNUYWdTdGFydCxcbiAgZ2V0U2luZ2xlQXR0cmlidXRlID0gX3JlcXVpcmUuZ2V0U2luZ2xlQXR0cmlidXRlLFxuICBzZXRTaW5nbGVBdHRyaWJ1dGUgPSBfcmVxdWlyZS5zZXRTaW5nbGVBdHRyaWJ1dGU7XG52YXIgZmlsZXR5cGVzID0gcmVxdWlyZShcIi4uL2ZpbGV0eXBlcy5qc1wiKTtcbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIG1vZHVsZU5hbWUgPSBcImxvb3BcIjtcbmZ1bmN0aW9uIGhhc0NvbnRlbnQocGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLnNvbWUoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gaXNDb250ZW50KHBhcnQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0TWVhbmluZ0Z1bFBhcnQocGFyc2VkKSB7XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBhcnNlZC5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbX2kyXTtcbiAgICBpZiAocGFydC50eXBlICE9PSBcImNvbnRlbnRcIikge1xuICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNJbnNpZGVQYXJhZ3JhcGhMb29wKHBhcnQpIHtcbiAgdmFyIGZpcnN0TWVhbmluZ2Z1bFBhcnQgPSBnZXRGaXJzdE1lYW5pbmdGdWxQYXJ0KHBhcnQuc3VicGFyc2VkKTtcbiAgcmV0dXJuIGZpcnN0TWVhbmluZ2Z1bFBhcnQgIT0gbnVsbCAmJiBmaXJzdE1lYW5pbmdmdWxQYXJ0LnRhZyAhPT0gXCJ3OnRcIjtcbn1cbmZ1bmN0aW9uIGdldFBhZ2VCcmVha0lmQXBwbGllcyhwYXJ0KSB7XG4gIHJldHVybiBwYXJ0Lmhhc1BhZ2VCcmVhayAmJiBpc0luc2lkZVBhcmFncmFwaExvb3AocGFydCkgPyAnPHc6cD48dzpyPjx3OmJyIHc6dHlwZT1cInBhZ2VcIi8+PC93OnI+PC93OnA+JyA6IFwiXCI7XG59XG5mdW5jdGlvbiBpc0VuY2xvc2VkQnlQYXJhZ3JhcGhzKHBhcnNlZCkge1xuICByZXR1cm4gcGFyc2VkLmxlbmd0aCAmJiBpc1BhcmFncmFwaFN0YXJ0KHBhcnNlZFswXSkgJiYgaXNQYXJhZ3JhcGhFbmQobGFzdChwYXJzZWQpKTtcbn1cbmZ1bmN0aW9uIGdldE9mZnNldChjaHVuaykge1xuICByZXR1cm4gaGFzQ29udGVudChjaHVuaykgPyAwIDogY2h1bmsubGVuZ3RoO1xufVxuZnVuY3Rpb24gYWRkUGFnZUJyZWFrQXRFbmQoc3ViUmVuZGVyZWQpIHtcbiAgdmFyIGogPSBzdWJSZW5kZXJlZC5wYXJ0cy5sZW5ndGggLSAxO1xuICBpZiAoc3ViUmVuZGVyZWQucGFydHNbal0gPT09IFwiPC93OnA+XCIpIHtcbiAgICBzdWJSZW5kZXJlZC5wYXJ0cy5zcGxpY2UoaiwgMCwgJzx3OnI+PHc6YnIgdzp0eXBlPVwicGFnZVwiLz48L3c6cj4nKTtcbiAgfSBlbHNlIHtcbiAgICBzdWJSZW5kZXJlZC5wYXJ0cy5wdXNoKCc8dzpwPjx3OnI+PHc6YnIgdzp0eXBlPVwicGFnZVwiLz48L3c6cj48L3c6cD4nKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkUGFnZUJyZWFrQXRCZWdpbm5pbmcoc3ViUmVuZGVyZWQpIHtcbiAgc3ViUmVuZGVyZWQucGFydHMudW5zaGlmdCgnPHc6cD48dzpyPjx3OmJyIHc6dHlwZT1cInBhZ2VcIi8+PC93OnI+PC93OnA+Jyk7XG59XG5mdW5jdGlvbiBpc0NvbnRpbnVvdXMocGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLnNvbWUoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gaXNUYWdTdGFydChcInc6dHlwZVwiLCBwYXJ0KSAmJiBwYXJ0LnZhbHVlLmluZGV4T2YoXCJjb250aW51b3VzXCIpICE9PSAtMTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc05leHRQYWdlKHBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5zb21lKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIGlzVGFnU3RhcnQoXCJ3OnR5cGVcIiwgcGFydCkgJiYgcGFydC52YWx1ZS5pbmRleE9mKCd3OnZhbD1cIm5leHRQYWdlXCInKSAhPT0gLTE7XG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkU2VjdGlvbkJlZm9yZShwYXJ0cywgc2VjdCkge1xuICByZXR1cm4gcHVzaEFycmF5KFtcIjx3OnA+PHc6cFByPlwiLmNvbmNhdChzZWN0Lm1hcChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KS5qb2luKFwiXCIpLCBcIjwvdzpwUHI+PC93OnA+XCIpXSwgcGFydHMpO1xufVxuZnVuY3Rpb24gYWRkQ29udGludW91c1R5cGUocGFydHMpIHtcbiAgdmFyIHN0b3AgPSBmYWxzZTtcbiAgdmFyIGluU2VjdFByID0gZmFsc2U7XG4gIHJldHVybiBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgcGFydCkge1xuICAgIGlmIChzdG9wID09PSBmYWxzZSAmJiBzdGFydHNXaXRoKHBhcnQsIFwiPHc6c2VjdFByXCIpKSB7XG4gICAgICBpblNlY3RQciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpblNlY3RQcikge1xuICAgICAgaWYgKHN0YXJ0c1dpdGgocGFydCwgXCI8dzp0eXBlXCIpKSB7XG4gICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0b3AgPT09IGZhbHNlICYmIHN0YXJ0c1dpdGgocGFydCwgXCI8L3c6c2VjdFByXCIpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCc8dzp0eXBlIHc6dmFsPVwiY29udGludW91c1wiLz4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocGFydCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gZHJvcEhlYWRlckZvb3RlclJlZnMocGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLmZpbHRlcihmdW5jdGlvbiAodGV4dCkge1xuICAgIHJldHVybiAhc3RhcnRzV2l0aCh0ZXh0LCBcIjx3OmhlYWRlclJlZmVyZW5jZVwiKSAmJiAhc3RhcnRzV2l0aCh0ZXh0LCBcIjx3OmZvb3RlclJlZmVyZW5jZVwiKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYXNQYWdlQnJlYWsoY2h1bmspIHtcbiAgcmV0dXJuIGNodW5rLnNvbWUoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gcGFydC50YWcgPT09IFwidzpiclwiICYmIHBhcnQudmFsdWUuaW5kZXhPZigndzp0eXBlPVwicGFnZVwiJykgIT09IC0xO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGhhc0ltYWdlKGNodW5rKSB7XG4gIHJldHVybiBjaHVuay5zb21lKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB0YWcgPSBfcmVmMi50YWc7XG4gICAgcmV0dXJuIHRhZyA9PT0gXCJ3OmRyYXdpbmdcIjtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTZWN0UHIoY2h1bmtzKSB7XG4gIHZhciBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gIHZhciBzZWN0UHJzID0gW107XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IGNodW5rcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIHBhcnQgPSBjaHVua3NbX2k0XTtcbiAgICBpZiAoaXNUYWdTdGFydChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBzZWN0UHJzLnB1c2goW10pO1xuICAgICAgY29sbGVjdFNlY3RQciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjb2xsZWN0U2VjdFByKSB7XG4gICAgICBzZWN0UHJzW3NlY3RQcnMubGVuZ3RoIC0gMV0ucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgaWYgKGlzVGFnRW5kKFwidzpzZWN0UHJcIiwgcGFydCkpIHtcbiAgICAgIGNvbGxlY3RTZWN0UHIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlY3RQcnM7XG59XG5mdW5jdGlvbiBnZXRTZWN0UHJIZWFkZXJGb290ZXJDaGFuZ2VDb3VudChjaHVua3MpIHtcbiAgdmFyIGNvbGxlY3RTZWN0UHIgPSBmYWxzZTtcbiAgdmFyIHNlY3RQckNvdW50ID0gMDtcbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgY2h1bmtzLmxlbmd0aDsgX2k2KyspIHtcbiAgICB2YXIgcGFydCA9IGNodW5rc1tfaTZdO1xuICAgIGlmIChpc1RhZ1N0YXJ0KFwidzpzZWN0UHJcIiwgcGFydCkpIHtcbiAgICAgIGNvbGxlY3RTZWN0UHIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdFNlY3RQcikge1xuICAgICAgaWYgKHBhcnQudGFnID09PSBcInc6aGVhZGVyUmVmZXJlbmNlXCIgfHwgcGFydC50YWcgPT09IFwidzpmb290ZXJSZWZlcmVuY2VcIikge1xuICAgICAgICBzZWN0UHJDb3VudCsrO1xuICAgICAgICBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1RhZ0VuZChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWN0UHJDb3VudDtcbn1cbmZ1bmN0aW9uIGdldExhc3RTZWN0UHIocGFyc2VkKSB7XG4gIHZhciBzZWN0UHIgPSBbXTtcbiAgdmFyIGluU2VjdFByID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBwYXJzZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBpZiAoaXNUYWdFbmQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgaW5TZWN0UHIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNUYWdTdGFydChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBzZWN0UHIudW5zaGlmdChwYXJ0LnZhbHVlKTtcbiAgICAgIGluU2VjdFByID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpblNlY3RQcikge1xuICAgICAgc2VjdFByLnVuc2hpZnQocGFydC52YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc1BhcmFncmFwaFN0YXJ0KHBhcnQpKSB7XG4gICAgICBpZiAoc2VjdFByLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNlY3RQci5qb2luKFwiXCIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIlwiO1xufVxudmFyIExvb3BNb2R1bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMb29wTW9kdWxlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb29wTW9kdWxlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkxvb3BNb2R1bGVcIjtcbiAgICB0aGlzLmluWGZybSA9IGZhbHNlO1xuICAgIHRoaXMudG90YWxTZWN0UHIgPSAwO1xuICAgIHRoaXMucHJlZml4ID0ge1xuICAgICAgc3RhcnQ6IFwiI1wiLFxuICAgICAgZW5kOiBcIi9cIixcbiAgICAgIGRhc2g6IC9eLShbXlxcc10rKVxccyguKykvLFxuICAgICAgaW52ZXJ0ZWQ6IFwiXlwiXG4gICAgfTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKExvb3BNb2R1bGUsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNUcmFuc2Zvcm1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpb25zVHJhbnNmb3JtZXIob3B0cywgZG9jeHRlbXBsYXRlcikge1xuICAgICAgdGhpcy5kb2N4dGVtcGxhdGVyID0gZG9jeHRlbXBsYXRlcjtcbiAgICAgIHJldHVybiBvcHRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcmVwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcmVwYXJzZShwYXJzZWQsIF9yZWYzKSB7XG4gICAgICB2YXIgY29udGVudFR5cGUgPSBfcmVmMy5jb250ZW50VHlwZTtcbiAgICAgIGlmIChmaWxldHlwZXMubWFpbi5pbmRleE9mKGNvbnRlbnRUeXBlKSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5zZWN0cyA9IGdldFNlY3RQcihwYXJzZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVycygpIHtcbiAgICAgIHZhciBtb2R1bGUgPSBtb2R1bGVOYW1lO1xuICAgICAgcmV0dXJuIFtbdGhpcy5wcmVmaXguc3RhcnQsIG1vZHVsZSwge1xuICAgICAgICBleHBhbmRUbzogXCJhdXRvXCIsXG4gICAgICAgIGxvY2F0aW9uOiBcInN0YXJ0XCIsXG4gICAgICAgIGludmVydGVkOiBmYWxzZVxuICAgICAgfV0sIFt0aGlzLnByZWZpeC5pbnZlcnRlZCwgbW9kdWxlLCB7XG4gICAgICAgIGV4cGFuZFRvOiBcImF1dG9cIixcbiAgICAgICAgbG9jYXRpb246IFwic3RhcnRcIixcbiAgICAgICAgaW52ZXJ0ZWQ6IHRydWVcbiAgICAgIH1dLCBbdGhpcy5wcmVmaXguZW5kLCBtb2R1bGUsIHtcbiAgICAgICAgbG9jYXRpb246IFwiZW5kXCJcbiAgICAgIH1dLCBbdGhpcy5wcmVmaXguZGFzaCwgbW9kdWxlLCBmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgdmFyIF9yZWY1ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjQsIDMpLFxuICAgICAgICAgIGV4cGFuZFRvID0gX3JlZjVbMV0sXG4gICAgICAgICAgdmFsdWUgPSBfcmVmNVsyXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsb2NhdGlvbjogXCJzdGFydFwiLFxuICAgICAgICAgIGludmVydGVkOiBmYWxzZSxcbiAgICAgICAgICBleHBhbmRUbzogZXhwYW5kVG8sXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRyYWl0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmFpdHModHJhaXROYW1lLCBwYXJzZWQpIHtcbiAgICAgIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIGdldFRyYWl0cyBzaG91bGQgZGlzYXBwZWFyIGluIHY0XG4gICAgICBpZiAodHJhaXROYW1lICE9PSBcImV4cGFuZFBhaXJcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG5cbiAgICAgIHJldHVybiBwYXJzZWQucmVkdWNlKGZ1bmN0aW9uICh0YWdzLCBwYXJ0LCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKGlzTW9kdWxlKHBhcnQsIG1vZHVsZU5hbWUpICYmIHBhcnQuc3VicGFyc2VkID09IG51bGwpIHtcbiAgICAgICAgICB0YWdzLnB1c2goe1xuICAgICAgICAgICAgcGFydDogcGFydCxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgICB9LCBbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cGFyc2UocGFyc2VkLCBfcmVmNikge1xuICAgICAgdmFyIGJhc2VQYXJ0ID0gX3JlZjYuYmFzZVBhcnQ7XG4gICAgICBpZiAoYmFzZVBhcnQgJiYgdGhpcy5kb2N4dGVtcGxhdGVyLmZpbGVUeXBlID09PSBcImRvY3hcIiAmJiBwYXJzZWQubGVuZ3RoID4gMCkge1xuICAgICAgICBiYXNlUGFydC5zZWN0UHJDb3VudCA9IGdldFNlY3RQckhlYWRlckZvb3RlckNoYW5nZUNvdW50KHBhcnNlZCk7XG4gICAgICAgIHRoaXMudG90YWxTZWN0UHIgKz0gYmFzZVBhcnQuc2VjdFByQ291bnQ7XG4gICAgICAgIHZhciBzZWN0cyA9IHRoaXMuc2VjdHM7XG4gICAgICAgIHNlY3RzLnNvbWUoZnVuY3Rpb24gKHNlY3QsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKGJhc2VQYXJ0LmxJbmRleCA8IHNlY3RbMF0ubEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxIDwgc2VjdHMubGVuZ3RoICYmIGlzQ29udGludW91cyhzZWN0c1tpbmRleCArIDFdKSkge1xuICAgICAgICAgICAgICBiYXNlUGFydC5hZGRDb250aW51b3VzVHlwZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnNlZFswXS5sSW5kZXggPCBzZWN0WzBdLmxJbmRleCAmJiBzZWN0WzBdLmxJbmRleCA8IGJhc2VQYXJ0LmxJbmRleCkge1xuICAgICAgICAgICAgaWYgKGlzTmV4dFBhZ2Uoc2VjdHNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBiYXNlUGFydC5hZGROZXh0UGFnZSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJhc2VQYXJ0Lmxhc3RQYXJhZ3JhcFNlY3RQciA9IGdldExhc3RTZWN0UHIocGFyc2VkKTtcbiAgICAgIH1cbiAgICAgIGlmICghYmFzZVBhcnQgfHwgYmFzZVBhcnQuZXhwYW5kVG8gIT09IFwiYXV0b1wiIHx8IGJhc2VQYXJ0Lm1vZHVsZSAhPT0gbW9kdWxlTmFtZSB8fCAhaXNFbmNsb3NlZEJ5UGFyYWdyYXBocyhwYXJzZWQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBiYXNlUGFydC5wYXJhZ3JhcGhMb29wID0gdHJ1ZTtcbiAgICAgIHZhciBsZXZlbCA9IDA7XG4gICAgICB2YXIgY2h1bmtzID0gY2h1bmtCeShwYXJzZWQsIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmIChpc1BhcmFncmFwaFN0YXJ0KHApKSB7XG4gICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcInN0YXJ0XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhcmFncmFwaEVuZChwKSkge1xuICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlbmRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICAgIHZhciBmaXJzdENodW5rID0gY2h1bmtzWzBdO1xuICAgICAgdmFyIGxhc3RDaHVuayA9IGxhc3QoY2h1bmtzKTtcbiAgICAgIHZhciBmaXJzdE9mZnNldCA9IGdldE9mZnNldChmaXJzdENodW5rKTtcbiAgICAgIHZhciBsYXN0T2Zmc2V0ID0gZ2V0T2Zmc2V0KGxhc3RDaHVuayk7XG4gICAgICBiYXNlUGFydC5oYXNQYWdlQnJlYWtCZWdpbm5pbmcgPSBoYXNQYWdlQnJlYWsoZmlyc3RDaHVuayk7XG4gICAgICBiYXNlUGFydC5oYXNQYWdlQnJlYWsgPSBoYXNQYWdlQnJlYWsobGFzdENodW5rKTtcbiAgICAgIGlmIChoYXNJbWFnZShmaXJzdENodW5rKSkge1xuICAgICAgICBmaXJzdE9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoaGFzSW1hZ2UobGFzdENodW5rKSkge1xuICAgICAgICBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQuc2xpY2UoZmlyc3RPZmZzZXQsIHBhcnNlZC5sZW5ndGggLSBsYXN0T2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKHBhcnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghaXNNb2R1bGUocGFydCwgbW9kdWxlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgc20gPSBvcHRpb25zLnNjb3BlTWFuYWdlcjtcbiAgICAgIHZhciBwcm9taXNlZFZhbHVlID0gc20uZ2V0VmFsdWVBc3luYyhwYXJ0LnZhbHVlLCB7XG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pO1xuICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICBmdW5jdGlvbiBsb29wT3ZlcihzY29wZSwgaSwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzY29wZU1hbmFnZXIgPSBzbS5jcmVhdGVTdWJTY29wZU1hbmFnZXIoc2NvcGUsIHBhcnQudmFsdWUsIGksIHBhcnQsIGxlbmd0aCk7XG4gICAgICAgIHByb21pc2VzLnB1c2gob3B0aW9ucy5yZXNvbHZlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgY29tcGlsZWQ6IHBhcnQuc3VicGFyc2VkLFxuICAgICAgICAgIHRhZ3M6IHt9LFxuICAgICAgICAgIHNjb3BlTWFuYWdlcjogc2NvcGVNYW5hZ2VyXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3JMaXN0ID0gW107XG4gICAgICByZXR1cm4gcHJvbWlzZWRWYWx1ZS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBQcm9taXNlLmFsbCh2YWx1ZXMpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICAgIHNtLmxvb3BPdmVyVmFsdWUodmFsdWVzLCBsb29wT3ZlciwgcGFydC5pbnZlcnRlZCk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gci5tYXAoZnVuY3Rpb24gKF9yZWY3KSB7XG4gICAgICAgICAgICAgIHZhciByZXNvbHZlZCA9IF9yZWY3LnJlc29sdmVkLFxuICAgICAgICAgICAgICAgIGVycm9ycyA9IF9yZWY3LmVycm9ycztcbiAgICAgICAgICAgICAgZXJyb3JMaXN0LnB1c2guYXBwbHkoZXJyb3JMaXN0LCBfdG9Db25zdW1hYmxlQXJyYXkoZXJyb3JzKSk7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3JMaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJwOnhmcm1cIikge1xuICAgICAgICB0aGlzLmluWGZybSA9IHBhcnQucG9zaXRpb24gPT09IFwic3RhcnRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJhOmV4dFwiICYmIHRoaXMuaW5YZnJtKSB7XG4gICAgICAgIHRoaXMubGFzdEV4dCA9IHBhcnQ7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc01vZHVsZShwYXJ0LCBtb2R1bGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciB0b3RhbFZhbHVlID0gW107XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgaGVpZ2h0T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBmaXJzdFRhZyA9IHBhcnQuc3VicGFyc2VkWzBdO1xuICAgICAgdmFyIHRhZ0hlaWdodCA9IDA7XG4gICAgICBpZiAoKGZpcnN0VGFnID09PSBudWxsIHx8IGZpcnN0VGFnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdFRhZy50YWcpID09PSBcImE6dHJcIikge1xuICAgICAgICB0YWdIZWlnaHQgPSArZ2V0U2luZ2xlQXR0cmlidXRlKGZpcnN0VGFnLnZhbHVlLCBcImhcIik7XG4gICAgICB9XG4gICAgICBoZWlnaHRPZmZzZXQgLT0gdGFnSGVpZ2h0O1xuICAgICAgdmFyIGExNlJvd0lkT2Zmc2V0ID0gMDtcbiAgICAgIHZhciBpbnNpZGVQYXJhZ3JhcGhMb29wID0gaXNJbnNpZGVQYXJhZ3JhcGhMb29wKHBhcnQpO1xuICAgICAgZnVuY3Rpb24gbG9vcE92ZXIoc2NvcGUsIGksIGxlbmd0aCkge1xuICAgICAgICBoZWlnaHRPZmZzZXQgKz0gdGFnSGVpZ2h0O1xuICAgICAgICB2YXIgc2NvcGVNYW5hZ2VyID0gb3B0aW9ucy5zY29wZU1hbmFnZXIuY3JlYXRlU3ViU2NvcGVNYW5hZ2VyKHNjb3BlLCBwYXJ0LnZhbHVlLCBpLCBwYXJ0LCBsZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBfaTggPSAwLCBfcGFydCRzdWJwYXJzZWQyID0gcGFydC5zdWJwYXJzZWQ7IF9pOCA8IF9wYXJ0JHN1YnBhcnNlZDIubGVuZ3RoOyBfaTgrKykge1xuICAgICAgICAgIHZhciBwcCA9IF9wYXJ0JHN1YnBhcnNlZDJbX2k4XTtcbiAgICAgICAgICBpZiAoaXNUYWdTdGFydChcImExNjpyb3dJZFwiLCBwcCkpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSArZ2V0U2luZ2xlQXR0cmlidXRlKHBwLnZhbHVlLCBcInZhbFwiKSArIGExNlJvd0lkT2Zmc2V0O1xuICAgICAgICAgICAgYTE2Um93SWRPZmZzZXQgPSAxO1xuICAgICAgICAgICAgcHAudmFsdWUgPSBzZXRTaW5nbGVBdHRyaWJ1dGUocHAudmFsdWUsIFwidmFsXCIsIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJSZW5kZXJlZCA9IG9wdGlvbnMucmVuZGVyKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgY29tcGlsZWQ6IHBhcnQuc3VicGFyc2VkLFxuICAgICAgICAgIHRhZ3M6IHt9LFxuICAgICAgICAgIHNjb3BlTWFuYWdlcjogc2NvcGVNYW5hZ2VyXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHBhcnQuaGFzUGFnZUJyZWFrICYmIGkgPT09IGxlbmd0aCAtIDEgJiYgaW5zaWRlUGFyYWdyYXBoTG9vcCkge1xuICAgICAgICAgIGFkZFBhZ2VCcmVha0F0RW5kKHN1YlJlbmRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNOb3RGaXJzdCA9IHNjb3BlTWFuYWdlci5zY29wZVBhdGhJdGVtLnNvbWUoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAhPT0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc05vdEZpcnN0KSB7XG4gICAgICAgICAgaWYgKHBhcnQuc2VjdFByQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHN1YlJlbmRlcmVkLnBhcnRzID0gZHJvcEhlYWRlckZvb3RlclJlZnMoc3ViUmVuZGVyZWQucGFydHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5hZGRDb250aW51b3VzVHlwZSkge1xuICAgICAgICAgICAgc3ViUmVuZGVyZWQucGFydHMgPSBhZGRDb250aW51b3VzVHlwZShzdWJSZW5kZXJlZC5wYXJ0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhcnQuYWRkTmV4dFBhZ2UpIHtcbiAgICAgICAgICBzdWJSZW5kZXJlZC5wYXJ0cyA9IGFkZFNlY3Rpb25CZWZvcmUoc3ViUmVuZGVyZWQucGFydHMsIHNlbGYuc2VjdHNbcGFydC5hZGROZXh0UGFnZS5pbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LmFkZE5leHRQYWdlKSB7XG4gICAgICAgICAgYWRkUGFnZUJyZWFrQXRFbmQoc3ViUmVuZGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0Lmhhc1BhZ2VCcmVha0JlZ2lubmluZyAmJiBpbnNpZGVQYXJhZ3JhcGhMb29wKSB7XG4gICAgICAgICAgYWRkUGFnZUJyZWFrQXRCZWdpbm5pbmcoc3ViUmVuZGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pMTAgPSAwLCBfc3ViUmVuZGVyZWQkcGFydHMyID0gc3ViUmVuZGVyZWQucGFydHM7IF9pMTAgPCBfc3ViUmVuZGVyZWQkcGFydHMyLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgICAgdmFyIF92YWwgPSBfc3ViUmVuZGVyZWQkcGFydHMyW19pMTBdO1xuICAgICAgICAgIHRvdGFsVmFsdWUucHVzaChfdmFsKTtcbiAgICAgICAgfVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlcnJvcnMsIHN1YlJlbmRlcmVkLmVycm9ycyk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gb3B0aW9ucy5zY29wZU1hbmFnZXIubG9vcE92ZXIocGFydC52YWx1ZSwgbG9vcE92ZXIsIHBhcnQuaW52ZXJ0ZWQsIHtcbiAgICAgICAgcGFydDogcGFydFxuICAgICAgfSk7XG4gICAgICAvLyBpZiB0aGUgbG9vcCBpcyBzaG93aW5nIGVtcHR5IGNvbnRlbnRcbiAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChwYXJ0Lmxhc3RQYXJhZ3JhcFNlY3RQcikge1xuICAgICAgICAgIGlmIChwYXJ0LnBhcmFncmFwaExvb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBcIjx3OnA+PHc6cFByPlwiLmNvbmNhdChwYXJ0Lmxhc3RQYXJhZ3JhcFNlY3RQciwgXCI8L3c6cFByPjwvdzpwPlwiKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBcIjwvdzp0PjwvdzpyPjwvdzpwPjx3OnA+PHc6cFByPlwiLmNvbmNhdChwYXJ0Lmxhc3RQYXJhZ3JhcFNlY3RQciwgXCI8L3c6cFByPjx3OnI+PHc6dD5cIilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGdldFBhZ2VCcmVha0lmQXBwbGllcyhwYXJ0KSB8fCBcIlwiLFxuICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0T2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgIHZhciBjeSA9ICtnZXRTaW5nbGVBdHRyaWJ1dGUodGhpcy5sYXN0RXh0LnZhbHVlLCBcImN5XCIpO1xuICAgICAgICB0aGlzLmxhc3RFeHQudmFsdWUgPSBzZXRTaW5nbGVBdHRyaWJ1dGUodGhpcy5sYXN0RXh0LnZhbHVlLCBcImN5XCIsIGN5ICsgaGVpZ2h0T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBvcHRpb25zLmpvaW5VbmNvcnJ1cHQodG90YWxWYWx1ZSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICBiYXNlUGFydDogcGFydFxuICAgICAgICB9KSksXG4gICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBMb29wTW9kdWxlKCkpO1xufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/loop.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/rawxml.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/rawxml.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar traits = __webpack_require__(/*! ../traits.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/traits.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  isContent = _require.isContent;\nvar _require2 = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\"),\n  throwRawTagShouldBeOnlyTextInParagraph = _require2.throwRawTagShouldBeOnlyTextInParagraph,\n  getInvalidRawXMLValueException = _require2.getInvalidRawXMLValueException;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/module-wrapper.js\");\nvar moduleName = \"rawxml\";\nfunction getInner(_ref) {\n  var part = _ref.part,\n    left = _ref.left,\n    right = _ref.right,\n    postparsed = _ref.postparsed,\n    index = _ref.index;\n  var paragraphParts = postparsed.slice(left + 1, right);\n  for (var i = 0, len = paragraphParts.length; i < len; i++) {\n    if (i === index - left - 1) {\n      continue;\n    }\n    var p = paragraphParts[i];\n    if (isContent(p)) {\n      throwRawTagShouldBeOnlyTextInParagraph({\n        paragraphParts: paragraphParts,\n        part: part\n      });\n    }\n  }\n  return part;\n}\nvar RawXmlModule = /*#__PURE__*/function () {\n  function RawXmlModule() {\n    _classCallCheck(this, RawXmlModule);\n    this.name = \"RawXmlModule\";\n    this.prefix = \"@\";\n  }\n  return _createClass(RawXmlModule, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.fileTypeConfig = docxtemplater.fileTypeConfig;\n      return options;\n    }\n  }, {\n    key: \"matchers\",\n    value: function matchers() {\n      return [[this.prefix, moduleName]];\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed) {\n      return traits.expandToOne(postparsed, {\n        moduleName: moduleName,\n        getInner: getInner,\n        expandTo: this.fileTypeConfig.tagRawXml,\n        error: {\n          message: \"Raw tag not in paragraph\",\n          id: \"raw_tag_outerxml_invalid\",\n          explanation: function explanation(part) {\n            return \"The tag \\\"\".concat(part.value, \"\\\" is not inside a paragraph, putting raw tags inside an inline loop is disallowed.\");\n          }\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      if (part.module !== moduleName) {\n        return null;\n      }\n      var value;\n      var errors = [];\n      try {\n        value = options.scopeManager.getValue(part.value, {\n          part: part\n        });\n        value !== null && value !== void 0 ? value : value = options.nullGetter(part);\n      } catch (e) {\n        errors.push(e);\n        return {\n          errors: errors\n        };\n      }\n      value = value ? value : \"\";\n      if (typeof value === \"string\") {\n        return {\n          value: value\n        };\n      }\n      return {\n        errors: [getInvalidRawXMLValueException({\n          tag: part.value,\n          value: value,\n          offset: part.offset\n        })]\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new RawXmlModule());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9yYXd4bWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGFBQWEsbUJBQU8sQ0FBQyw2R0FBYztBQUNuQyxlQUFlLG1CQUFPLENBQUMsbUhBQWlCO0FBQ3hDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsNkdBQWM7QUFDdEM7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyw2SEFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy8ucG5wbS9kb2N4dGVtcGxhdGVyQDMuNjAuMi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3Jhd3htbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIHRyYWl0cyA9IHJlcXVpcmUoXCIuLi90cmFpdHMuanNcIik7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vZG9jLXV0aWxzLmpzXCIpLFxuICBpc0NvbnRlbnQgPSBfcmVxdWlyZS5pc0NvbnRlbnQ7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4uL2Vycm9ycy5qc1wiKSxcbiAgdGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGggPSBfcmVxdWlyZTIudGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGgsXG4gIGdldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbiA9IF9yZXF1aXJlMi5nZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb247XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBtb2R1bGVOYW1lID0gXCJyYXd4bWxcIjtcbmZ1bmN0aW9uIGdldElubmVyKF9yZWYpIHtcbiAgdmFyIHBhcnQgPSBfcmVmLnBhcnQsXG4gICAgbGVmdCA9IF9yZWYubGVmdCxcbiAgICByaWdodCA9IF9yZWYucmlnaHQsXG4gICAgcG9zdHBhcnNlZCA9IF9yZWYucG9zdHBhcnNlZCxcbiAgICBpbmRleCA9IF9yZWYuaW5kZXg7XG4gIHZhciBwYXJhZ3JhcGhQYXJ0cyA9IHBvc3RwYXJzZWQuc2xpY2UobGVmdCArIDEsIHJpZ2h0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcmFncmFwaFBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGkgPT09IGluZGV4IC0gbGVmdCAtIDEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgcCA9IHBhcmFncmFwaFBhcnRzW2ldO1xuICAgIGlmIChpc0NvbnRlbnQocCkpIHtcbiAgICAgIHRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoKHtcbiAgICAgICAgcGFyYWdyYXBoUGFydHM6IHBhcmFncmFwaFBhcnRzLFxuICAgICAgICBwYXJ0OiBwYXJ0XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnQ7XG59XG52YXIgUmF3WG1sTW9kdWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmF3WG1sTW9kdWxlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYXdYbWxNb2R1bGUpO1xuICAgIHRoaXMubmFtZSA9IFwiUmF3WG1sTW9kdWxlXCI7XG4gICAgdGhpcy5wcmVmaXggPSBcIkBcIjtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFJhd1htbE1vZHVsZSwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1RyYW5zZm9ybWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGlvbnNUcmFuc2Zvcm1lcihvcHRpb25zLCBkb2N4dGVtcGxhdGVyKSB7XG4gICAgICB0aGlzLmZpbGVUeXBlQ29uZmlnID0gZG9jeHRlbXBsYXRlci5maWxlVHlwZUNvbmZpZztcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVycygpIHtcbiAgICAgIHJldHVybiBbW3RoaXMucHJlZml4LCBtb2R1bGVOYW1lXV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cGFyc2UocG9zdHBhcnNlZCkge1xuICAgICAgcmV0dXJuIHRyYWl0cy5leHBhbmRUb09uZShwb3N0cGFyc2VkLCB7XG4gICAgICAgIG1vZHVsZU5hbWU6IG1vZHVsZU5hbWUsXG4gICAgICAgIGdldElubmVyOiBnZXRJbm5lcixcbiAgICAgICAgZXhwYW5kVG86IHRoaXMuZmlsZVR5cGVDb25maWcudGFnUmF3WG1sLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIG1lc3NhZ2U6IFwiUmF3IHRhZyBub3QgaW4gcGFyYWdyYXBoXCIsXG4gICAgICAgICAgaWQ6IFwicmF3X3RhZ19vdXRlcnhtbF9pbnZhbGlkXCIsXG4gICAgICAgICAgZXhwbGFuYXRpb246IGZ1bmN0aW9uIGV4cGxhbmF0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlRoZSB0YWcgXFxcIlwiLmNvbmNhdChwYXJ0LnZhbHVlLCBcIlxcXCIgaXMgbm90IGluc2lkZSBhIHBhcmFncmFwaCwgcHV0dGluZyByYXcgdGFncyBpbnNpZGUgYW4gaW5saW5lIGxvb3AgaXMgZGlzYWxsb3dlZC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihwYXJ0LCBvcHRpb25zKSB7XG4gICAgICBpZiAocGFydC5tb2R1bGUgIT09IG1vZHVsZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZSA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyLmdldFZhbHVlKHBhcnQudmFsdWUsIHtcbiAgICAgICAgICBwYXJ0OiBwYXJ0XG4gICAgICAgIH0pO1xuICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiB2YWx1ZSA9IG9wdGlvbnMubnVsbEdldHRlcihwYXJ0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUgPyB2YWx1ZSA6IFwiXCI7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcnM6IFtnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb24oe1xuICAgICAgICAgIHRhZzogcGFydC52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgb2Zmc2V0OiBwYXJ0Lm9mZnNldFxuICAgICAgICB9KV1cbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IFJhd1htbE1vZHVsZSgpKTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/rawxml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/render.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/render.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../errors.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\"),\n  getScopeCompilationError = _require.getScopeCompilationError,\n  getCorruptCharactersException = _require.getCorruptCharactersException;\nvar _require2 = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  utf8ToWord = _require2.utf8ToWord,\n  hasCorruptCharacters = _require2.hasCorruptCharacters,\n  removeCorruptCharacters = _require2.removeCorruptCharacters;\nvar _require3 = __webpack_require__(/*! ../content-types.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/content-types.js\"),\n  settingsContentType = _require3.settingsContentType,\n  coreContentType = _require3.coreContentType,\n  appContentType = _require3.appContentType,\n  customContentType = _require3.customContentType;\nvar ftprefix = {\n  docx: \"w\",\n  pptx: \"a\"\n};\nvar Render = /*#__PURE__*/function () {\n  function Render() {\n    _classCallCheck(this, Render);\n    this.name = \"Render\";\n    this.recordRun = false;\n    this.recordedRun = [];\n  }\n  return _createClass(Render, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.parser = docxtemplater.parser;\n      this.fileType = docxtemplater.fileType;\n      return options;\n    }\n  }, {\n    key: \"set\",\n    value: function set(obj) {\n      if (obj.compiled) {\n        this.compiled = obj.compiled;\n      }\n      if (obj.data != null) {\n        this.data = obj.data;\n      }\n    }\n  }, {\n    key: \"getRenderedMap\",\n    value: function getRenderedMap(mapper) {\n      var _this = this;\n      return Object.keys(this.compiled).reduce(function (mapper, from) {\n        mapper[from] = {\n          from: from,\n          data: _this.data\n        };\n        return mapper;\n      }, mapper);\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, options) {\n      var errors = [];\n      for (var _i2 = 0; _i2 < postparsed.length; _i2++) {\n        var p = postparsed[_i2];\n        if (p.type === \"placeholder\") {\n          var tag = p.value;\n          try {\n            options.cachedParsers[p.lIndex] = this.parser(tag, {\n              tag: p\n            });\n          } catch (rootError) {\n            errors.push(getScopeCompilationError({\n              tag: tag,\n              rootError: rootError,\n              offset: p.offset\n            }));\n          }\n        }\n      }\n      return {\n        postparsed: postparsed,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, _ref) {\n      var contentType = _ref.contentType,\n        scopeManager = _ref.scopeManager,\n        linebreaks = _ref.linebreaks,\n        nullGetter = _ref.nullGetter,\n        fileType = _ref.fileType,\n        stripInvalidXMLChars = _ref.stripInvalidXMLChars;\n      if (linebreaks && [settingsContentType, coreContentType, appContentType, customContentType].indexOf(contentType) !== -1) {\n        // Fixes issue tested in #docprops-linebreak\n        linebreaks = false;\n      }\n      if (linebreaks) {\n        this.recordRuns(part);\n      }\n      if (part.type !== \"placeholder\" || part.module) {\n        return;\n      }\n      var value;\n      try {\n        value = scopeManager.getValue(part.value, {\n          part: part\n        });\n      } catch (e) {\n        return {\n          errors: [e]\n        };\n      }\n      value !== null && value !== void 0 ? value : value = nullGetter(part);\n      if (typeof value === \"string\") {\n        if (stripInvalidXMLChars) {\n          value = removeCorruptCharacters(value);\n        } else if ([\"docx\", \"pptx\", \"xlsx\"].indexOf(fileType) !== -1 && hasCorruptCharacters(value)) {\n          return {\n            errors: [getCorruptCharactersException({\n              tag: part.value,\n              value: value,\n              offset: part.offset\n            })]\n          };\n        }\n      }\n      if (fileType === \"text\") {\n        return {\n          value: value\n        };\n      }\n      return {\n        value: linebreaks && typeof value === \"string\" ? this.renderLineBreaks(value) : utf8ToWord(value)\n      };\n    }\n  }, {\n    key: \"recordRuns\",\n    value: function recordRuns(part) {\n      if (part.tag === \"\".concat(ftprefix[this.fileType], \":r\")) {\n        this.recordedRun = [];\n      } else if (part.tag === \"\".concat(ftprefix[this.fileType], \":rPr\")) {\n        if (part.position === \"start\") {\n          this.recordRun = true;\n          this.recordedRun = [part.value];\n        }\n        if (part.position === \"end\" || part.position === \"selfclosing\") {\n          this.recordedRun.push(part.value);\n          this.recordRun = false;\n        }\n      } else if (this.recordRun) {\n        this.recordedRun.push(part.value);\n      }\n    }\n  }, {\n    key: \"renderLineBreaks\",\n    value: function renderLineBreaks(value) {\n      var _this2 = this;\n      var p = ftprefix[this.fileType];\n      var br = this.fileType === \"docx\" ? \"<w:r><w:br/></w:r>\" : \"<a:br/>\";\n      var lines = value.split(\"\\n\");\n      var runprops = this.recordedRun.join(\"\");\n      return lines.map(function (line) {\n        return utf8ToWord(line);\n      }).reduce(function (result, line, i) {\n        result.push(line);\n        if (i < lines.length - 1) {\n          result.push(\"</\".concat(p, \":t></\").concat(p, \":r>\").concat(br, \"<\").concat(p, \":r>\").concat(runprops, \"<\").concat(p, \":t\").concat(_this2.fileType === \"docx\" ? ' xml:space=\"preserve\"' : \"\", \">\"));\n        }\n        return result;\n      }, []);\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new Render());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9yZW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGNBQWMsbUJBQU8sQ0FBQyw2SEFBc0I7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLDZHQUFjO0FBQ3JDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxtSEFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsMkhBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9yZW5kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4uL2Vycm9ycy5qc1wiKSxcbiAgZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yID0gX3JlcXVpcmUuZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yLFxuICBnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIHV0ZjhUb1dvcmQgPSBfcmVxdWlyZTIudXRmOFRvV29yZCxcbiAgaGFzQ29ycnVwdENoYXJhY3RlcnMgPSBfcmVxdWlyZTIuaGFzQ29ycnVwdENoYXJhY3RlcnMsXG4gIHJlbW92ZUNvcnJ1cHRDaGFyYWN0ZXJzID0gX3JlcXVpcmUyLnJlbW92ZUNvcnJ1cHRDaGFyYWN0ZXJzO1xudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuLi9jb250ZW50LXR5cGVzLmpzXCIpLFxuICBzZXR0aW5nc0NvbnRlbnRUeXBlID0gX3JlcXVpcmUzLnNldHRpbmdzQ29udGVudFR5cGUsXG4gIGNvcmVDb250ZW50VHlwZSA9IF9yZXF1aXJlMy5jb3JlQ29udGVudFR5cGUsXG4gIGFwcENvbnRlbnRUeXBlID0gX3JlcXVpcmUzLmFwcENvbnRlbnRUeXBlLFxuICBjdXN0b21Db250ZW50VHlwZSA9IF9yZXF1aXJlMy5jdXN0b21Db250ZW50VHlwZTtcbnZhciBmdHByZWZpeCA9IHtcbiAgZG9jeDogXCJ3XCIsXG4gIHBwdHg6IFwiYVwiXG59O1xudmFyIFJlbmRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlbmRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVuZGVyKTtcbiAgICB0aGlzLm5hbWUgPSBcIlJlbmRlclwiO1xuICAgIHRoaXMucmVjb3JkUnVuID0gZmFsc2U7XG4gICAgdGhpcy5yZWNvcmRlZFJ1biA9IFtdO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVuZGVyLCBbe1xuICAgIGtleTogXCJvcHRpb25zVHJhbnNmb3JtZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW9uc1RyYW5zZm9ybWVyKG9wdGlvbnMsIGRvY3h0ZW1wbGF0ZXIpIHtcbiAgICAgIHRoaXMucGFyc2VyID0gZG9jeHRlbXBsYXRlci5wYXJzZXI7XG4gICAgICB0aGlzLmZpbGVUeXBlID0gZG9jeHRlbXBsYXRlci5maWxlVHlwZTtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0KG9iaikge1xuICAgICAgaWYgKG9iai5jb21waWxlZCkge1xuICAgICAgICB0aGlzLmNvbXBpbGVkID0gb2JqLmNvbXBpbGVkO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5kYXRhICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gb2JqLmRhdGE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJlbmRlcmVkTWFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlbmRlcmVkTWFwKG1hcHBlcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmNvbXBpbGVkKS5yZWR1Y2UoZnVuY3Rpb24gKG1hcHBlciwgZnJvbSkge1xuICAgICAgICBtYXBwZXJbZnJvbV0gPSB7XG4gICAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgICBkYXRhOiBfdGhpcy5kYXRhXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtYXBwZXI7XG4gICAgICB9LCBtYXBwZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBvc3RwYXJzZWQubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgcCA9IHBvc3RwYXJzZWRbX2kyXTtcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHAudmFsdWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FjaGVkUGFyc2Vyc1twLmxJbmRleF0gPSB0aGlzLnBhcnNlcih0YWcsIHtcbiAgICAgICAgICAgICAgdGFnOiBwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChyb290RXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKGdldFNjb3BlQ29tcGlsYXRpb25FcnJvcih7XG4gICAgICAgICAgICAgIHRhZzogdGFnLFxuICAgICAgICAgICAgICByb290RXJyb3I6IHJvb3RFcnJvcixcbiAgICAgICAgICAgICAgb2Zmc2V0OiBwLm9mZnNldFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZCxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFydCwgX3JlZikge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gX3JlZi5jb250ZW50VHlwZSxcbiAgICAgICAgc2NvcGVNYW5hZ2VyID0gX3JlZi5zY29wZU1hbmFnZXIsXG4gICAgICAgIGxpbmVicmVha3MgPSBfcmVmLmxpbmVicmVha3MsXG4gICAgICAgIG51bGxHZXR0ZXIgPSBfcmVmLm51bGxHZXR0ZXIsXG4gICAgICAgIGZpbGVUeXBlID0gX3JlZi5maWxlVHlwZSxcbiAgICAgICAgc3RyaXBJbnZhbGlkWE1MQ2hhcnMgPSBfcmVmLnN0cmlwSW52YWxpZFhNTENoYXJzO1xuICAgICAgaWYgKGxpbmVicmVha3MgJiYgW3NldHRpbmdzQ29udGVudFR5cGUsIGNvcmVDb250ZW50VHlwZSwgYXBwQ29udGVudFR5cGUsIGN1c3RvbUNvbnRlbnRUeXBlXS5pbmRleE9mKGNvbnRlbnRUeXBlKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gRml4ZXMgaXNzdWUgdGVzdGVkIGluICNkb2Nwcm9wcy1saW5lYnJlYWtcbiAgICAgICAgbGluZWJyZWFrcyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVicmVha3MpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRSdW5zKHBhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQudHlwZSAhPT0gXCJwbGFjZWhvbGRlclwiIHx8IHBhcnQubW9kdWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gc2NvcGVNYW5hZ2VyLmdldFZhbHVlKHBhcnQudmFsdWUsIHtcbiAgICAgICAgICBwYXJ0OiBwYXJ0XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycm9yczogW2VdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiB2YWx1ZSA9IG51bGxHZXR0ZXIocGFydCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChzdHJpcEludmFsaWRYTUxDaGFycykge1xuICAgICAgICAgIHZhbHVlID0gcmVtb3ZlQ29ycnVwdENoYXJhY3RlcnModmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKFtcImRvY3hcIiwgXCJwcHR4XCIsIFwieGxzeFwiXS5pbmRleE9mKGZpbGVUeXBlKSAhPT0gLTEgJiYgaGFzQ29ycnVwdENoYXJhY3RlcnModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yczogW2dldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgdGFnOiBwYXJ0LnZhbHVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIG9mZnNldDogcGFydC5vZmZzZXRcbiAgICAgICAgICAgIH0pXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWxlVHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBsaW5lYnJlYWtzICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHRoaXMucmVuZGVyTGluZUJyZWFrcyh2YWx1ZSkgOiB1dGY4VG9Xb3JkKHZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVjb3JkUnVuc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvcmRSdW5zKHBhcnQpIHtcbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJcIi5jb25jYXQoZnRwcmVmaXhbdGhpcy5maWxlVHlwZV0sIFwiOnJcIikpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRlZFJ1biA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0LnRhZyA9PT0gXCJcIi5jb25jYXQoZnRwcmVmaXhbdGhpcy5maWxlVHlwZV0sIFwiOnJQclwiKSkge1xuICAgICAgICBpZiAocGFydC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgdGhpcy5yZWNvcmRSdW4gPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVjb3JkZWRSdW4gPSBbcGFydC52YWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQucG9zaXRpb24gPT09IFwiZW5kXCIgfHwgcGFydC5wb3NpdGlvbiA9PT0gXCJzZWxmY2xvc2luZ1wiKSB7XG4gICAgICAgICAgdGhpcy5yZWNvcmRlZFJ1bi5wdXNoKHBhcnQudmFsdWUpO1xuICAgICAgICAgIHRoaXMucmVjb3JkUnVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWNvcmRSdW4pIHtcbiAgICAgICAgdGhpcy5yZWNvcmRlZFJ1bi5wdXNoKHBhcnQudmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJMaW5lQnJlYWtzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckxpbmVCcmVha3ModmFsdWUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHAgPSBmdHByZWZpeFt0aGlzLmZpbGVUeXBlXTtcbiAgICAgIHZhciBiciA9IHRoaXMuZmlsZVR5cGUgPT09IFwiZG9jeFwiID8gXCI8dzpyPjx3OmJyLz48L3c6cj5cIiA6IFwiPGE6YnIvPlwiO1xuICAgICAgdmFyIGxpbmVzID0gdmFsdWUuc3BsaXQoXCJcXG5cIik7XG4gICAgICB2YXIgcnVucHJvcHMgPSB0aGlzLnJlY29yZGVkUnVuLmpvaW4oXCJcIik7XG4gICAgICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiB1dGY4VG9Xb3JkKGxpbmUpO1xuICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGxpbmUsIGkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobGluZSk7XG4gICAgICAgIGlmIChpIDwgbGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFwiPC9cIi5jb25jYXQocCwgXCI6dD48L1wiKS5jb25jYXQocCwgXCI6cj5cIikuY29uY2F0KGJyLCBcIjxcIikuY29uY2F0KHAsIFwiOnI+XCIpLmNvbmNhdChydW5wcm9wcywgXCI8XCIpLmNvbmNhdChwLCBcIjp0XCIpLmNvbmNhdChfdGhpczIuZmlsZVR5cGUgPT09IFwiZG9jeFwiID8gJyB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiJyA6IFwiXCIsIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIFtdKTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd3JhcHBlcihuZXcgUmVuZGVyKCkpO1xufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/render.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/space-preserve.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/space-preserve.js ***!
  \*********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  isTextStart = _require.isTextStart,\n  isTextEnd = _require.isTextEnd,\n  endsWith = _require.endsWith,\n  startsWith = _require.startsWith;\nvar wTpreserve = '<w:t xml:space=\"preserve\">';\nvar wTpreservelen = wTpreserve.length;\nvar wtEnd = \"</w:t>\";\nvar wtEndlen = wtEnd.length;\nfunction isWtStart(part) {\n  return isTextStart(part) && part.tag === \"w:t\";\n}\nfunction addXMLPreserve(chunk, index) {\n  var tag = chunk[index].value;\n  if (chunk[index + 1].value === \"</w:t>\") {\n    return tag;\n  }\n  if (tag.indexOf('xml:space=\"preserve\"') !== -1) {\n    return tag;\n  }\n  return tag.substr(0, tag.length - 1) + ' xml:space=\"preserve\">';\n}\nfunction isInsideLoop(meta, chunk) {\n  return meta && meta.basePart && chunk.length > 1;\n}\nvar SpacePreserve = /*#__PURE__*/function () {\n  function SpacePreserve() {\n    _classCallCheck(this, SpacePreserve);\n    this.name = \"SpacePreserveModule\";\n  }\n  return _createClass(SpacePreserve, [{\n    key: \"postparse\",\n    value: function postparse(postparsed, meta) {\n      var chunk = [],\n        inTextTag = false,\n        endLindex = 0,\n        lastTextTag = 0;\n      function isStartingPlaceHolder(part, chunk) {\n        return part.type === \"placeholder\" && chunk.length > 1;\n      }\n      var result = postparsed.reduce(function (postparsed, part) {\n        if (isWtStart(part)) {\n          inTextTag = true;\n          lastTextTag = chunk.length;\n        }\n        if (!inTextTag) {\n          postparsed.push(part);\n          return postparsed;\n        }\n        chunk.push(part);\n        if (isInsideLoop(meta, chunk)) {\n          endLindex = meta.basePart.endLindex;\n          chunk[0].value = addXMLPreserve(chunk, 0);\n        }\n        if (isStartingPlaceHolder(part, chunk)) {\n          chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n          endLindex = part.endLindex;\n        }\n        if (isTextEnd(part) && part.lIndex > endLindex) {\n          if (endLindex !== 0) {\n            chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n          }\n          Array.prototype.push.apply(postparsed, chunk);\n          chunk = [];\n          inTextTag = false;\n          endLindex = 0;\n          lastTextTag = 0;\n        }\n        return postparsed;\n      }, []);\n      Array.prototype.push.apply(result, chunk);\n      return result;\n    }\n  }, {\n    key: \"postrender\",\n    value: function postrender(parts) {\n      var lastNonEmpty = \"\";\n      var lastNonEmptyIndex = 0;\n      for (var i = 0, len = parts.length; i < len; i++) {\n        var p = parts[i];\n        if (p === \"\") {\n          continue;\n        }\n        if (endsWith(lastNonEmpty, wTpreserve) && startsWith(p, wtEnd)) {\n          parts[lastNonEmptyIndex] = lastNonEmpty.substr(0, lastNonEmpty.length - wTpreservelen) + \"<w:t/>\";\n          p = p.substr(wtEndlen);\n        }\n        lastNonEmpty = p;\n        lastNonEmptyIndex = i;\n        parts[i] = p;\n      }\n      return parts;\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new SpacePreserve());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9zcGFjZS1wcmVzZXJ2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsY0FBYyxtQkFBTyxDQUFDLDZIQUFzQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsbUhBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy8ucG5wbS9kb2N4dGVtcGxhdGVyQDMuNjAuMi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3NwYWNlLXByZXNlcnZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIGlzVGV4dFN0YXJ0ID0gX3JlcXVpcmUuaXNUZXh0U3RhcnQsXG4gIGlzVGV4dEVuZCA9IF9yZXF1aXJlLmlzVGV4dEVuZCxcbiAgZW5kc1dpdGggPSBfcmVxdWlyZS5lbmRzV2l0aCxcbiAgc3RhcnRzV2l0aCA9IF9yZXF1aXJlLnN0YXJ0c1dpdGg7XG52YXIgd1RwcmVzZXJ2ZSA9ICc8dzp0IHhtbDpzcGFjZT1cInByZXNlcnZlXCI+JztcbnZhciB3VHByZXNlcnZlbGVuID0gd1RwcmVzZXJ2ZS5sZW5ndGg7XG52YXIgd3RFbmQgPSBcIjwvdzp0PlwiO1xudmFyIHd0RW5kbGVuID0gd3RFbmQubGVuZ3RoO1xuZnVuY3Rpb24gaXNXdFN0YXJ0KHBhcnQpIHtcbiAgcmV0dXJuIGlzVGV4dFN0YXJ0KHBhcnQpICYmIHBhcnQudGFnID09PSBcInc6dFwiO1xufVxuZnVuY3Rpb24gYWRkWE1MUHJlc2VydmUoY2h1bmssIGluZGV4KSB7XG4gIHZhciB0YWcgPSBjaHVua1tpbmRleF0udmFsdWU7XG4gIGlmIChjaHVua1tpbmRleCArIDFdLnZhbHVlID09PSBcIjwvdzp0PlwiKSB7XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuICBpZiAodGFnLmluZGV4T2YoJ3htbDpzcGFjZT1cInByZXNlcnZlXCInKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdGFnO1xuICB9XG4gIHJldHVybiB0YWcuc3Vic3RyKDAsIHRhZy5sZW5ndGggLSAxKSArICcgeG1sOnNwYWNlPVwicHJlc2VydmVcIj4nO1xufVxuZnVuY3Rpb24gaXNJbnNpZGVMb29wKG1ldGEsIGNodW5rKSB7XG4gIHJldHVybiBtZXRhICYmIG1ldGEuYmFzZVBhcnQgJiYgY2h1bmsubGVuZ3RoID4gMTtcbn1cbnZhciBTcGFjZVByZXNlcnZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3BhY2VQcmVzZXJ2ZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BhY2VQcmVzZXJ2ZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTcGFjZVByZXNlcnZlTW9kdWxlXCI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTcGFjZVByZXNlcnZlLCBbe1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG1ldGEpIHtcbiAgICAgIHZhciBjaHVuayA9IFtdLFxuICAgICAgICBpblRleHRUYWcgPSBmYWxzZSxcbiAgICAgICAgZW5kTGluZGV4ID0gMCxcbiAgICAgICAgbGFzdFRleHRUYWcgPSAwO1xuICAgICAgZnVuY3Rpb24gaXNTdGFydGluZ1BsYWNlSG9sZGVyKHBhcnQsIGNodW5rKSB7XG4gICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwicGxhY2Vob2xkZXJcIiAmJiBjaHVuay5sZW5ndGggPiAxO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHBvc3RwYXJzZWQucmVkdWNlKGZ1bmN0aW9uIChwb3N0cGFyc2VkLCBwYXJ0KSB7XG4gICAgICAgIGlmIChpc1d0U3RhcnQocGFydCkpIHtcbiAgICAgICAgICBpblRleHRUYWcgPSB0cnVlO1xuICAgICAgICAgIGxhc3RUZXh0VGFnID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5UZXh0VGFnKSB7XG4gICAgICAgICAgcG9zdHBhcnNlZC5wdXNoKHBhcnQpO1xuICAgICAgICAgIHJldHVybiBwb3N0cGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rLnB1c2gocGFydCk7XG4gICAgICAgIGlmIChpc0luc2lkZUxvb3AobWV0YSwgY2h1bmspKSB7XG4gICAgICAgICAgZW5kTGluZGV4ID0gbWV0YS5iYXNlUGFydC5lbmRMaW5kZXg7XG4gICAgICAgICAgY2h1bmtbMF0udmFsdWUgPSBhZGRYTUxQcmVzZXJ2ZShjaHVuaywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RhcnRpbmdQbGFjZUhvbGRlcihwYXJ0LCBjaHVuaykpIHtcbiAgICAgICAgICBjaHVua1tsYXN0VGV4dFRhZ10udmFsdWUgPSBhZGRYTUxQcmVzZXJ2ZShjaHVuaywgbGFzdFRleHRUYWcpO1xuICAgICAgICAgIGVuZExpbmRleCA9IHBhcnQuZW5kTGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RleHRFbmQocGFydCkgJiYgcGFydC5sSW5kZXggPiBlbmRMaW5kZXgpIHtcbiAgICAgICAgICBpZiAoZW5kTGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICBjaHVua1tsYXN0VGV4dFRhZ10udmFsdWUgPSBhZGRYTUxQcmVzZXJ2ZShjaHVuaywgbGFzdFRleHRUYWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShwb3N0cGFyc2VkLCBjaHVuayk7XG4gICAgICAgICAgY2h1bmsgPSBbXTtcbiAgICAgICAgICBpblRleHRUYWcgPSBmYWxzZTtcbiAgICAgICAgICBlbmRMaW5kZXggPSAwO1xuICAgICAgICAgIGxhc3RUZXh0VGFnID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zdHBhcnNlZDtcbiAgICAgIH0sIFtdKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgY2h1bmspO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdHJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cmVuZGVyKHBhcnRzKSB7XG4gICAgICB2YXIgbGFzdE5vbkVtcHR5ID0gXCJcIjtcbiAgICAgIHZhciBsYXN0Tm9uRW1wdHlJbmRleCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBwYXJ0c1tpXTtcbiAgICAgICAgaWYgKHAgPT09IFwiXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kc1dpdGgobGFzdE5vbkVtcHR5LCB3VHByZXNlcnZlKSAmJiBzdGFydHNXaXRoKHAsIHd0RW5kKSkge1xuICAgICAgICAgIHBhcnRzW2xhc3ROb25FbXB0eUluZGV4XSA9IGxhc3ROb25FbXB0eS5zdWJzdHIoMCwgbGFzdE5vbkVtcHR5Lmxlbmd0aCAtIHdUcHJlc2VydmVsZW4pICsgXCI8dzp0Lz5cIjtcbiAgICAgICAgICBwID0gcC5zdWJzdHIod3RFbmRsZW4pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3ROb25FbXB0eSA9IHA7XG4gICAgICAgIGxhc3ROb25FbXB0eUluZGV4ID0gaTtcbiAgICAgICAgcGFydHNbaV0gPSBwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBTcGFjZVByZXNlcnZlKCkpO1xufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/modules/space-preserve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/parser.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/parser.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  wordToUtf8 = _require.wordToUtf8;\nvar _require2 = __webpack_require__(/*! ./prefix-matcher.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/prefix-matcher.js\"),\n  match = _require2.match,\n  getValue = _require2.getValue,\n  getValues = _require2.getValues;\nfunction getMatchers(modules, options) {\n  var matchers = [];\n  for (var _i2 = 0; _i2 < modules.length; _i2++) {\n    var _module = modules[_i2];\n    if (_module.matchers) {\n      var mmm = _module.matchers(options);\n      if (!(mmm instanceof Array)) {\n        throw new Error(\"module matcher returns a non array\");\n      }\n      matchers.push.apply(matchers, _toConsumableArray(mmm));\n    }\n  }\n  return matchers;\n}\nfunction getMatches(matchers, placeHolderContent, options) {\n  var matches = [];\n  for (var _i4 = 0; _i4 < matchers.length; _i4++) {\n    var matcher = matchers[_i4];\n    var _matcher = _slicedToArray(matcher, 2),\n      prefix = _matcher[0],\n      _module2 = _matcher[1];\n    var properties = matcher[2] || {};\n    if (options.match(prefix, placeHolderContent)) {\n      var values = options.getValues(prefix, placeHolderContent);\n      if (typeof properties === \"function\") {\n        properties = properties(values);\n      }\n      if (!properties.value) {\n        var _values = _slicedToArray(values, 2);\n        properties.value = _values[1];\n      }\n      matches.push(_objectSpread({\n        type: \"placeholder\",\n        prefix: prefix,\n        module: _module2,\n        onMatch: properties.onMatch,\n        priority: properties.priority\n      }, properties));\n    }\n  }\n  return matches;\n}\nfunction moduleParse(placeHolderContent, options) {\n  var modules = options.modules;\n  var startOffset = options.startOffset;\n  var endLindex = options.lIndex;\n  var moduleParsed;\n  options.offset = startOffset;\n  options.match = match;\n  options.getValue = getValue;\n  options.getValues = getValues;\n  var matchers = getMatchers(modules, options);\n  var matches = getMatches(matchers, placeHolderContent, options);\n  if (matches.length > 0) {\n    var bestMatch = null;\n    for (var _i6 = 0; _i6 < matches.length; _i6++) {\n      var _match = matches[_i6];\n      _match.priority || (_match.priority = -_match.value.length);\n      if (!bestMatch || _match.priority > bestMatch.priority) {\n        bestMatch = _match;\n      }\n    }\n    bestMatch.offset = startOffset;\n    delete bestMatch.priority;\n    bestMatch.endLindex = endLindex;\n    bestMatch.lIndex = endLindex;\n    bestMatch.raw = placeHolderContent;\n    if (bestMatch.onMatch) {\n      bestMatch.onMatch(bestMatch);\n    }\n    delete bestMatch.onMatch;\n    delete bestMatch.prefix;\n    return bestMatch;\n  }\n  for (var _i8 = 0; _i8 < modules.length; _i8++) {\n    var _module3 = modules[_i8];\n    moduleParsed = _module3.parse(placeHolderContent, options);\n    if (moduleParsed) {\n      moduleParsed.offset = startOffset;\n      moduleParsed.endLindex = endLindex;\n      moduleParsed.lIndex = endLindex;\n      moduleParsed.raw = placeHolderContent;\n      return moduleParsed;\n    }\n  }\n  return {\n    type: \"placeholder\",\n    value: placeHolderContent,\n    offset: startOffset,\n    endLindex: endLindex,\n    lIndex: endLindex\n  };\n}\nvar parser = {\n  preparse: function preparse(parsed, modules, options) {\n    function preparse(parsed, options) {\n      for (var _i10 = 0; _i10 < modules.length; _i10++) {\n        var _module4 = modules[_i10];\n        parsed = _module4.preparse(parsed, options) || parsed;\n      }\n      return parsed;\n    }\n    return preparse(parsed, options);\n  },\n  parse: function parse(lexed, modules, options) {\n    var inPlaceHolder = false;\n    var placeHolderContent = \"\";\n    var startOffset;\n    var tailParts = [];\n    var droppedTags = options.fileTypeConfig.droppedTagsInsidePlaceholder || [];\n    return lexed.reduce(function (parsed, token) {\n      if (token.type === \"delimiter\") {\n        inPlaceHolder = token.position === \"start\";\n        if (token.position === \"end\") {\n          options.parse = function (placeHolderContent) {\n            return moduleParse(placeHolderContent, _objectSpread(_objectSpread(_objectSpread({}, options), token), {}, {\n              startOffset: startOffset,\n              modules: modules\n            }));\n          };\n          parsed.push(options.parse(wordToUtf8(placeHolderContent)));\n          Array.prototype.push.apply(parsed, tailParts);\n          tailParts = [];\n        }\n        if (token.position === \"start\") {\n          tailParts = [];\n          startOffset = token.offset;\n        }\n        placeHolderContent = \"\";\n        return parsed;\n      }\n      if (!inPlaceHolder) {\n        parsed.push(token);\n        return parsed;\n      }\n      if (token.type !== \"content\" || token.position !== \"insidetag\") {\n        if (droppedTags.indexOf(token.tag) !== -1) {\n          return parsed;\n        }\n        tailParts.push(token);\n        return parsed;\n      }\n      placeHolderContent += token.value;\n      return parsed;\n    }, []);\n  },\n  postparse: function postparse(postparsed, modules, options) {\n    function getTraits(traitName, postparsed) {\n      return modules.map(function (module) {\n        return module.getTraits(traitName, postparsed);\n      });\n    }\n    var errors = [];\n    function _postparse(postparsed, options) {\n      return modules.reduce(function (postparsed, module) {\n        var r = module.postparse(postparsed, _objectSpread(_objectSpread({}, options), {}, {\n          postparse: function postparse(parsed, opts) {\n            return _postparse(parsed, _objectSpread(_objectSpread({}, options), opts));\n          },\n          getTraits: getTraits\n        }));\n        if (r == null) {\n          return postparsed;\n        }\n        if (r.errors) {\n          Array.prototype.push.apply(errors, r.errors);\n          return r.postparsed;\n        }\n        return r;\n      }, postparsed);\n    }\n    return {\n      postparsed: _postparse(postparsed, options),\n      errors: errors\n    };\n  }\n};\nmodule.exports = parser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLHVDQUF1QyxrR0FBa0csaUJBQWlCLHdDQUF3QyxNQUFNLHlDQUF5Qyw2QkFBNkIsVUFBVSxZQUFZLGtFQUFrRSxXQUFXLFlBQVksaUJBQWlCLFVBQVUsTUFBTSxpRkFBaUYsVUFBVSxvQkFBb0I7QUFDN2dCLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLGVBQWUsbUJBQU8sQ0FBQyxrSEFBZ0I7QUFDdkM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0SEFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLHNCQUFzQjtBQUNySDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxjQUFjO0FBQ3pGO0FBQ0Esb0VBQW9FO0FBQ3BFLFdBQVc7QUFDWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzLy5wbnBtL2RvY3h0ZW1wbGF0ZXJAMy42MC4yL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3BhcnNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkgeyBpZiAocikgeyBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpOyB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpOyByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDsgfSB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHsgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTsgfVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICB3b3JkVG9VdGY4ID0gX3JlcXVpcmUud29yZFRvVXRmODtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9wcmVmaXgtbWF0Y2hlci5qc1wiKSxcbiAgbWF0Y2ggPSBfcmVxdWlyZTIubWF0Y2gsXG4gIGdldFZhbHVlID0gX3JlcXVpcmUyLmdldFZhbHVlLFxuICBnZXRWYWx1ZXMgPSBfcmVxdWlyZTIuZ2V0VmFsdWVzO1xuZnVuY3Rpb24gZ2V0TWF0Y2hlcnMobW9kdWxlcywgb3B0aW9ucykge1xuICB2YXIgbWF0Y2hlcnMgPSBbXTtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbW9kdWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9tb2R1bGUgPSBtb2R1bGVzW19pMl07XG4gICAgaWYgKF9tb2R1bGUubWF0Y2hlcnMpIHtcbiAgICAgIHZhciBtbW0gPSBfbW9kdWxlLm1hdGNoZXJzKG9wdGlvbnMpO1xuICAgICAgaWYgKCEobW1tIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vZHVsZSBtYXRjaGVyIHJldHVybnMgYSBub24gYXJyYXlcIik7XG4gICAgICB9XG4gICAgICBtYXRjaGVycy5wdXNoLmFwcGx5KG1hdGNoZXJzLCBfdG9Db25zdW1hYmxlQXJyYXkobW1tKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVycztcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXMobWF0Y2hlcnMsIHBsYWNlSG9sZGVyQ29udGVudCwgb3B0aW9ucykge1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBtYXRjaGVycy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIG1hdGNoZXIgPSBtYXRjaGVyc1tfaTRdO1xuICAgIHZhciBfbWF0Y2hlciA9IF9zbGljZWRUb0FycmF5KG1hdGNoZXIsIDIpLFxuICAgICAgcHJlZml4ID0gX21hdGNoZXJbMF0sXG4gICAgICBfbW9kdWxlMiA9IF9tYXRjaGVyWzFdO1xuICAgIHZhciBwcm9wZXJ0aWVzID0gbWF0Y2hlclsyXSB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5tYXRjaChwcmVmaXgsIHBsYWNlSG9sZGVyQ29udGVudCkpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBvcHRpb25zLmdldFZhbHVlcyhwcmVmaXgsIHBsYWNlSG9sZGVyQ29udGVudCk7XG4gICAgICBpZiAodHlwZW9mIHByb3BlcnRpZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKCFwcm9wZXJ0aWVzLnZhbHVlKSB7XG4gICAgICAgIHZhciBfdmFsdWVzID0gX3NsaWNlZFRvQXJyYXkodmFsdWVzLCAyKTtcbiAgICAgICAgcHJvcGVydGllcy52YWx1ZSA9IF92YWx1ZXNbMV07XG4gICAgICB9XG4gICAgICBtYXRjaGVzLnB1c2goX29iamVjdFNwcmVhZCh7XG4gICAgICAgIHR5cGU6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgIG1vZHVsZTogX21vZHVsZTIsXG4gICAgICAgIG9uTWF0Y2g6IHByb3BlcnRpZXMub25NYXRjaCxcbiAgICAgICAgcHJpb3JpdHk6IHByb3BlcnRpZXMucHJpb3JpdHlcbiAgICAgIH0sIHByb3BlcnRpZXMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5mdW5jdGlvbiBtb2R1bGVQYXJzZShwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgdmFyIG1vZHVsZXMgPSBvcHRpb25zLm1vZHVsZXM7XG4gIHZhciBzdGFydE9mZnNldCA9IG9wdGlvbnMuc3RhcnRPZmZzZXQ7XG4gIHZhciBlbmRMaW5kZXggPSBvcHRpb25zLmxJbmRleDtcbiAgdmFyIG1vZHVsZVBhcnNlZDtcbiAgb3B0aW9ucy5vZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgb3B0aW9ucy5tYXRjaCA9IG1hdGNoO1xuICBvcHRpb25zLmdldFZhbHVlID0gZ2V0VmFsdWU7XG4gIG9wdGlvbnMuZ2V0VmFsdWVzID0gZ2V0VmFsdWVzO1xuICB2YXIgbWF0Y2hlcnMgPSBnZXRNYXRjaGVycyhtb2R1bGVzLCBvcHRpb25zKTtcbiAgdmFyIG1hdGNoZXMgPSBnZXRNYXRjaGVzKG1hdGNoZXJzLCBwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpO1xuICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGJlc3RNYXRjaCA9IG51bGw7XG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbWF0Y2hlcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgICB2YXIgX21hdGNoID0gbWF0Y2hlc1tfaTZdO1xuICAgICAgX21hdGNoLnByaW9yaXR5IHx8IChfbWF0Y2gucHJpb3JpdHkgPSAtX21hdGNoLnZhbHVlLmxlbmd0aCk7XG4gICAgICBpZiAoIWJlc3RNYXRjaCB8fCBfbWF0Y2gucHJpb3JpdHkgPiBiZXN0TWF0Y2gucHJpb3JpdHkpIHtcbiAgICAgICAgYmVzdE1hdGNoID0gX21hdGNoO1xuICAgICAgfVxuICAgIH1cbiAgICBiZXN0TWF0Y2gub2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgZGVsZXRlIGJlc3RNYXRjaC5wcmlvcml0eTtcbiAgICBiZXN0TWF0Y2guZW5kTGluZGV4ID0gZW5kTGluZGV4O1xuICAgIGJlc3RNYXRjaC5sSW5kZXggPSBlbmRMaW5kZXg7XG4gICAgYmVzdE1hdGNoLnJhdyA9IHBsYWNlSG9sZGVyQ29udGVudDtcbiAgICBpZiAoYmVzdE1hdGNoLm9uTWF0Y2gpIHtcbiAgICAgIGJlc3RNYXRjaC5vbk1hdGNoKGJlc3RNYXRjaCk7XG4gICAgfVxuICAgIGRlbGV0ZSBiZXN0TWF0Y2gub25NYXRjaDtcbiAgICBkZWxldGUgYmVzdE1hdGNoLnByZWZpeDtcbiAgICByZXR1cm4gYmVzdE1hdGNoO1xuICB9XG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IG1vZHVsZXMubGVuZ3RoOyBfaTgrKykge1xuICAgIHZhciBfbW9kdWxlMyA9IG1vZHVsZXNbX2k4XTtcbiAgICBtb2R1bGVQYXJzZWQgPSBfbW9kdWxlMy5wYXJzZShwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpO1xuICAgIGlmIChtb2R1bGVQYXJzZWQpIHtcbiAgICAgIG1vZHVsZVBhcnNlZC5vZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgIG1vZHVsZVBhcnNlZC5lbmRMaW5kZXggPSBlbmRMaW5kZXg7XG4gICAgICBtb2R1bGVQYXJzZWQubEluZGV4ID0gZW5kTGluZGV4O1xuICAgICAgbW9kdWxlUGFyc2VkLnJhdyA9IHBsYWNlSG9sZGVyQ29udGVudDtcbiAgICAgIHJldHVybiBtb2R1bGVQYXJzZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwbGFjZWhvbGRlclwiLFxuICAgIHZhbHVlOiBwbGFjZUhvbGRlckNvbnRlbnQsXG4gICAgb2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICBlbmRMaW5kZXg6IGVuZExpbmRleCxcbiAgICBsSW5kZXg6IGVuZExpbmRleFxuICB9O1xufVxudmFyIHBhcnNlciA9IHtcbiAgcHJlcGFyc2U6IGZ1bmN0aW9uIHByZXBhcnNlKHBhcnNlZCwgbW9kdWxlcywgb3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIHByZXBhcnNlKHBhcnNlZCwgb3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBtb2R1bGVzLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlNCA9IG1vZHVsZXNbX2kxMF07XG4gICAgICAgIHBhcnNlZCA9IF9tb2R1bGU0LnByZXBhcnNlKHBhcnNlZCwgb3B0aW9ucykgfHwgcGFyc2VkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgcmV0dXJuIHByZXBhcnNlKHBhcnNlZCwgb3B0aW9ucyk7XG4gIH0sXG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShsZXhlZCwgbW9kdWxlcywgb3B0aW9ucykge1xuICAgIHZhciBpblBsYWNlSG9sZGVyID0gZmFsc2U7XG4gICAgdmFyIHBsYWNlSG9sZGVyQ29udGVudCA9IFwiXCI7XG4gICAgdmFyIHN0YXJ0T2Zmc2V0O1xuICAgIHZhciB0YWlsUGFydHMgPSBbXTtcbiAgICB2YXIgZHJvcHBlZFRhZ3MgPSBvcHRpb25zLmZpbGVUeXBlQ29uZmlnLmRyb3BwZWRUYWdzSW5zaWRlUGxhY2Vob2xkZXIgfHwgW107XG4gICAgcmV0dXJuIGxleGVkLnJlZHVjZShmdW5jdGlvbiAocGFyc2VkLCB0b2tlbikge1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFwiZGVsaW1pdGVyXCIpIHtcbiAgICAgICAgaW5QbGFjZUhvbGRlciA9IHRva2VuLnBvc2l0aW9uID09PSBcInN0YXJ0XCI7XG4gICAgICAgIGlmICh0b2tlbi5wb3NpdGlvbiA9PT0gXCJlbmRcIikge1xuICAgICAgICAgIG9wdGlvbnMucGFyc2UgPSBmdW5jdGlvbiAocGxhY2VIb2xkZXJDb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlUGFyc2UocGxhY2VIb2xkZXJDb250ZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHRva2VuKSwge30sIHtcbiAgICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICBtb2R1bGVzOiBtb2R1bGVzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBwYXJzZWQucHVzaChvcHRpb25zLnBhcnNlKHdvcmRUb1V0ZjgocGxhY2VIb2xkZXJDb250ZW50KSkpO1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHBhcnNlZCwgdGFpbFBhcnRzKTtcbiAgICAgICAgICB0YWlsUGFydHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4ucG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuICAgICAgICAgIHRhaWxQYXJ0cyA9IFtdO1xuICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gdG9rZW4ub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHBsYWNlSG9sZGVyQ29udGVudCA9IFwiXCI7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBpZiAoIWluUGxhY2VIb2xkZXIpIHtcbiAgICAgICAgcGFyc2VkLnB1c2godG9rZW4pO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFwiY29udGVudFwiIHx8IHRva2VuLnBvc2l0aW9uICE9PSBcImluc2lkZXRhZ1wiKSB7XG4gICAgICAgIGlmIChkcm9wcGVkVGFncy5pbmRleE9mKHRva2VuLnRhZykgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICB0YWlsUGFydHMucHVzaCh0b2tlbik7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBwbGFjZUhvbGRlckNvbnRlbnQgKz0gdG9rZW4udmFsdWU7XG4gICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH0sIFtdKTtcbiAgfSxcbiAgcG9zdHBhcnNlOiBmdW5jdGlvbiBwb3N0cGFyc2UocG9zdHBhcnNlZCwgbW9kdWxlcywgb3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGdldFRyYWl0cyh0cmFpdE5hbWUsIHBvc3RwYXJzZWQpIHtcbiAgICAgIHJldHVybiBtb2R1bGVzLm1hcChmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUuZ2V0VHJhaXRzKHRyYWl0TmFtZSwgcG9zdHBhcnNlZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIGZ1bmN0aW9uIF9wb3N0cGFyc2UocG9zdHBhcnNlZCwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChwb3N0cGFyc2VkLCBtb2R1bGUpIHtcbiAgICAgICAgdmFyIHIgPSBtb2R1bGUucG9zdHBhcnNlKHBvc3RwYXJzZWQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgcG9zdHBhcnNlOiBmdW5jdGlvbiBwb3N0cGFyc2UocGFyc2VkLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3Bvc3RwYXJzZShwYXJzZWQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIG9wdHMpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFRyYWl0czogZ2V0VHJhaXRzXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHIgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBwb3N0cGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyLmVycm9ycykge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVycm9ycywgci5lcnJvcnMpO1xuICAgICAgICAgIHJldHVybiByLnBvc3RwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9LCBwb3N0cGFyc2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3RwYXJzZWQ6IF9wb3N0cGFyc2UocG9zdHBhcnNlZCwgb3B0aW9ucyksXG4gICAgICBlcnJvcnM6IGVycm9yc1xuICAgIH07XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlcjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/postrender.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/postrender.js ***!
  \*********************************************************************************************/
/***/ ((module) => {

eval("\n\n/*\n * Convert string to array (typed, when possible)\n * Stryker disable all : because this is a utility function that was copied\n * from\n * https://github.com/open-xml-templating/pizzip/blob/34a840553c604980859dc6d0dcd1f89b6e5527b3/es6/utf8.js#L33\n */\nfunction string2buf(str) {\n  var c,\n    c2,\n    mPos,\n    i,\n    bufLen = 0;\n  var strLen = str.length;\n\n  // count binary size\n  for (mPos = 0; mPos < strLen; mPos++) {\n    c = str.charCodeAt(mPos);\n    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n      c2 = str.charCodeAt(mPos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        mPos++;\n      }\n    }\n    bufLen += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  var buf = new Uint8Array(bufLen);\n\n  // convert\n  for (i = 0, mPos = 0; i < bufLen; mPos++) {\n    c = str.charCodeAt(mPos);\n    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n      c2 = str.charCodeAt(mPos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        mPos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xc0 | c >>> 6;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xe0 | c >>> 12;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | c >>> 18;\n      buf[i++] = 0x80 | c >>> 12 & 0x3f;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    }\n  }\n  return buf;\n}\n// Stryker restore all\n\nfunction postrender(parts, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    parts = _module.postrender(parts, options);\n  }\n  var fullLength = 0;\n  var newParts = options.joinUncorrupt(parts, options);\n  var longStr = \"\";\n  var lenStr = 0;\n  var maxCompact = 65536;\n  var uintArrays = [];\n  for (var i = 0, len = newParts.length; i < len; i++) {\n    var part = newParts[i];\n\n    /*\n     * This condition should be hit in the integration test at :\n     * it(\"should not regress with long file (hit maxCompact value of 65536)\", function () {\n     * Stryker disable all : because this is an optimisation that won't make any tests fail\n     */\n    if (part.length + lenStr > maxCompact) {\n      var _arr = string2buf(longStr);\n      fullLength += _arr.length;\n      uintArrays.push(_arr);\n      longStr = \"\";\n    }\n    // Stryker restore all\n\n    longStr += part;\n    lenStr += part.length;\n    delete newParts[i];\n  }\n  var arr = string2buf(longStr);\n  fullLength += arr.length;\n  uintArrays.push(arr);\n  var array = new Uint8Array(fullLength);\n  var j = 0;\n\n  // Stryker disable all : because this is an optimisation that won't make any tests fail\n  for (var _i4 = 0; _i4 < uintArrays.length; _i4++) {\n    var buf = uintArrays[_i4];\n    for (var _i5 = 0; _i5 < buf.length; ++_i5) {\n      array[_i5 + j] = buf[_i5];\n    }\n    j += buf.length;\n  } // Stryker restore all\n  return array;\n}\nmodule.exports = postrender;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcG9zdHJlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCxnQ0FBZ0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzLy5wbnBtL2RvY3h0ZW1wbGF0ZXJAMy42MC4yL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3Bvc3RyZW5kZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qXG4gKiBDb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG4gKiBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGlzIGEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IHdhcyBjb3BpZWRcbiAqIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXhtbC10ZW1wbGF0aW5nL3BpenppcC9ibG9iLzM0YTg0MDU1M2M2MDQ5ODA4NTlkYzZkMGRjZDFmODliNmU1NTI3YjMvZXM2L3V0ZjguanMjTDMzXG4gKi9cbmZ1bmN0aW9uIHN0cmluZzJidWYoc3RyKSB7XG4gIHZhciBjLFxuICAgIGMyLFxuICAgIG1Qb3MsXG4gICAgaSxcbiAgICBidWZMZW4gPSAwO1xuICB2YXIgc3RyTGVuID0gc3RyLmxlbmd0aDtcblxuICAvLyBjb3VudCBiaW5hcnkgc2l6ZVxuICBmb3IgKG1Qb3MgPSAwOyBtUG9zIDwgc3RyTGVuOyBtUG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobVBvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIG1Qb3MgKyAxIDwgc3RyTGVuKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1Qb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoYyAtIDB4ZDgwMCA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtUG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGJ1ZkxlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmTGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1Qb3MgPSAwOyBpIDwgYnVmTGVuOyBtUG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobVBvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIG1Qb3MgKyAxIDwgc3RyTGVuKSB7XG4gICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1Qb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoYyAtIDB4ZDgwMCA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICBtUG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4YzAgfCBjID4+PiA2O1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgfSBlbHNlIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgLyogdGhyZWUgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhlMCB8IGMgPj4+IDEyO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyA+Pj4gNiAmIDB4M2Y7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGYwIHwgYyA+Pj4gMTg7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjID4+PiAxMiAmIDB4M2Y7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjID4+PiA2ICYgMHgzZjtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYnVmO1xufVxuLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuXG5mdW5jdGlvbiBwb3N0cmVuZGVyKHBhcnRzLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIF9pMiA9IDAsIF9vcHRpb25zJG1vZHVsZXMyID0gb3B0aW9ucy5tb2R1bGVzOyBfaTIgPCBfb3B0aW9ucyRtb2R1bGVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9tb2R1bGUgPSBfb3B0aW9ucyRtb2R1bGVzMltfaTJdO1xuICAgIHBhcnRzID0gX21vZHVsZS5wb3N0cmVuZGVyKHBhcnRzLCBvcHRpb25zKTtcbiAgfVxuICB2YXIgZnVsbExlbmd0aCA9IDA7XG4gIHZhciBuZXdQYXJ0cyA9IG9wdGlvbnMuam9pblVuY29ycnVwdChwYXJ0cywgb3B0aW9ucyk7XG4gIHZhciBsb25nU3RyID0gXCJcIjtcbiAgdmFyIGxlblN0ciA9IDA7XG4gIHZhciBtYXhDb21wYWN0ID0gNjU1MzY7XG4gIHZhciB1aW50QXJyYXlzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBuZXdQYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwYXJ0ID0gbmV3UGFydHNbaV07XG5cbiAgICAvKlxuICAgICAqIFRoaXMgY29uZGl0aW9uIHNob3VsZCBiZSBoaXQgaW4gdGhlIGludGVncmF0aW9uIHRlc3QgYXQgOlxuICAgICAqIGl0KFwic2hvdWxkIG5vdCByZWdyZXNzIHdpdGggbG9uZyBmaWxlIChoaXQgbWF4Q29tcGFjdCB2YWx1ZSBvZiA2NTUzNilcIiwgZnVuY3Rpb24gKCkge1xuICAgICAqIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgaXMgYW4gb3B0aW1pc2F0aW9uIHRoYXQgd29uJ3QgbWFrZSBhbnkgdGVzdHMgZmFpbFxuICAgICAqL1xuICAgIGlmIChwYXJ0Lmxlbmd0aCArIGxlblN0ciA+IG1heENvbXBhY3QpIHtcbiAgICAgIHZhciBfYXJyID0gc3RyaW5nMmJ1Zihsb25nU3RyKTtcbiAgICAgIGZ1bGxMZW5ndGggKz0gX2Fyci5sZW5ndGg7XG4gICAgICB1aW50QXJyYXlzLnB1c2goX2Fycik7XG4gICAgICBsb25nU3RyID0gXCJcIjtcbiAgICB9XG4gICAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuXG4gICAgbG9uZ1N0ciArPSBwYXJ0O1xuICAgIGxlblN0ciArPSBwYXJ0Lmxlbmd0aDtcbiAgICBkZWxldGUgbmV3UGFydHNbaV07XG4gIH1cbiAgdmFyIGFyciA9IHN0cmluZzJidWYobG9uZ1N0cik7XG4gIGZ1bGxMZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgdWludEFycmF5cy5wdXNoKGFycik7XG4gIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KGZ1bGxMZW5ndGgpO1xuICB2YXIgaiA9IDA7XG5cbiAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhpcyBpcyBhbiBvcHRpbWlzYXRpb24gdGhhdCB3b24ndCBtYWtlIGFueSB0ZXN0cyBmYWlsXG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHVpbnRBcnJheXMubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBidWYgPSB1aW50QXJyYXlzW19pNF07XG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgYnVmLmxlbmd0aDsgKytfaTUpIHtcbiAgICAgIGFycmF5W19pNSArIGpdID0gYnVmW19pNV07XG4gICAgfVxuICAgIGogKz0gYnVmLmxlbmd0aDtcbiAgfSAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG4gIHJldHVybiBhcnJheTtcbn1cbm1vZHVsZS5leHBvcnRzID0gcG9zdHJlbmRlcjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/postrender.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/prefix-matcher.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/prefix-matcher.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar nbspRegex = new RegExp(String.fromCharCode(160), \"g\");\nfunction replaceNbsps(str) {\n  return str.replace(nbspRegex, \" \");\n}\nfunction match(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return replaceNbsps(placeHolderContent.substr(0, condition.length)) === condition;\n  }\n  if (condition instanceof RegExp) {\n    return condition.test(replaceNbsps(placeHolderContent));\n  }\n  if (type === \"function\") {\n    return !!condition(placeHolderContent);\n  }\n}\nfunction getValue(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return replaceNbsps(placeHolderContent).substr(condition.length);\n  }\n  if (condition instanceof RegExp) {\n    return replaceNbsps(placeHolderContent).match(condition)[1];\n  }\n  if (type === \"function\") {\n    return condition(placeHolderContent);\n  }\n}\nfunction getValues(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return [placeHolderContent, replaceNbsps(placeHolderContent).substr(condition.length)];\n  }\n  if (condition instanceof RegExp) {\n    return replaceNbsps(placeHolderContent).match(condition);\n  }\n  if (type === \"function\") {\n    return [placeHolderContent, condition(placeHolderContent)];\n  }\n}\nmodule.exports = {\n  match: match,\n  getValue: getValue,\n  getValues: getValues\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcHJlZml4LW1hdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy8ucG5wbS9kb2N4dGVtcGxhdGVyQDMuNjAuMi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wcmVmaXgtbWF0Y2hlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxudmFyIG5ic3BSZWdleCA9IG5ldyBSZWdFeHAoU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApLCBcImdcIik7XG5mdW5jdGlvbiByZXBsYWNlTmJzcHMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShuYnNwUmVnZXgsIFwiIFwiKTtcbn1cbmZ1bmN0aW9uIG1hdGNoKGNvbmRpdGlvbiwgcGxhY2VIb2xkZXJDb250ZW50KSB7XG4gIHZhciB0eXBlID0gX3R5cGVvZihjb25kaXRpb24pO1xuICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiByZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50LnN1YnN0cigwLCBjb25kaXRpb24ubGVuZ3RoKSkgPT09IGNvbmRpdGlvbjtcbiAgfVxuICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIGNvbmRpdGlvbi50ZXN0KHJlcGxhY2VOYnNwcyhwbGFjZUhvbGRlckNvbnRlbnQpKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuICEhY29uZGl0aW9uKHBsYWNlSG9sZGVyQ29udGVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlKGNvbmRpdGlvbiwgcGxhY2VIb2xkZXJDb250ZW50KSB7XG4gIHZhciB0eXBlID0gX3R5cGVvZihjb25kaXRpb24pO1xuICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiByZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50KS5zdWJzdHIoY29uZGl0aW9uLmxlbmd0aCk7XG4gIH1cbiAgaWYgKGNvbmRpdGlvbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50KS5tYXRjaChjb25kaXRpb24pWzFdO1xuICB9XG4gIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY29uZGl0aW9uKHBsYWNlSG9sZGVyQ29udGVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlcyhjb25kaXRpb24sIHBsYWNlSG9sZGVyQ29udGVudCkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YoY29uZGl0aW9uKTtcbiAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gW3BsYWNlSG9sZGVyQ29udGVudCwgcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudCkuc3Vic3RyKGNvbmRpdGlvbi5sZW5ndGgpXTtcbiAgfVxuICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VOYnNwcyhwbGFjZUhvbGRlckNvbnRlbnQpLm1hdGNoKGNvbmRpdGlvbik7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBbcGxhY2VIb2xkZXJDb250ZW50LCBjb25kaXRpb24ocGxhY2VIb2xkZXJDb250ZW50KV07XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXRjaDogbWF0Y2gsXG4gIGdldFZhbHVlOiBnZXRWYWx1ZSxcbiAgZ2V0VmFsdWVzOiBnZXRWYWx1ZXNcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/prefix-matcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/render.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/render.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\"),\n  throwUnimplementedTagType = _require.throwUnimplementedTagType,\n  XTScopeParserError = _require.XTScopeParserError;\nvar _require2 = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require2.pushArray;\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleRender(part, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    var moduleRendered = _module.render(part, options);\n    if (moduleRendered) {\n      return moduleRendered;\n    }\n  }\n  return false;\n}\nfunction render(options) {\n  var baseNullGetter = options.baseNullGetter;\n  var compiled = options.compiled,\n    scopeManager = options.scopeManager;\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n  var errors = [];\n  var parts = compiled.map(function (part, i) {\n    options.index = i;\n    options.resolvedId = getResolvedId(part, options);\n    var moduleRendered;\n    try {\n      moduleRendered = moduleRender(part, options);\n    } catch (e) {\n      if (e instanceof XTScopeParserError) {\n        errors.push(e);\n        return part;\n      }\n      throw e;\n    }\n    if (moduleRendered) {\n      if (moduleRendered.errors) {\n        Array.prototype.push.apply(errors, moduleRendered.errors);\n      }\n      return moduleRendered;\n    }\n    if (part.type === \"content\" || part.type === \"tag\") {\n      return part;\n    }\n    throwUnimplementedTagType(part, i);\n  }).reduce(function (parts, _ref) {\n    var value = _ref.value;\n    if (value instanceof Array) {\n      pushArray(parts, value);\n    } else if (value) {\n      parts.push(value);\n    }\n    return parts;\n  }, []);\n  return {\n    errors: errors,\n    parts: parts\n  };\n}\nmodule.exports = render;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcmVuZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyw0R0FBYTtBQUNwQztBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsa0hBQWdCO0FBQ3hDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsOEhBQXNCO0FBQ2xEO0FBQ0EseURBQXlELGdDQUFnQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcmVuZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIiksXG4gIHRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGUgPSBfcmVxdWlyZS50aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlLFxuICBYVFNjb3BlUGFyc2VyRXJyb3IgPSBfcmVxdWlyZS5YVFNjb3BlUGFyc2VyRXJyb3I7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZTIucHVzaEFycmF5O1xudmFyIGdldFJlc29sdmVkSWQgPSByZXF1aXJlKFwiLi9nZXQtcmVzb2x2ZWQtaWQuanNcIik7XG5mdW5jdGlvbiBtb2R1bGVSZW5kZXIocGFydCwgb3B0aW9ucykge1xuICBmb3IgKHZhciBfaTIgPSAwLCBfb3B0aW9ucyRtb2R1bGVzMiA9IG9wdGlvbnMubW9kdWxlczsgX2kyIDwgX29wdGlvbnMkbW9kdWxlczIubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfbW9kdWxlID0gX29wdGlvbnMkbW9kdWxlczJbX2kyXTtcbiAgICB2YXIgbW9kdWxlUmVuZGVyZWQgPSBfbW9kdWxlLnJlbmRlcihwYXJ0LCBvcHRpb25zKTtcbiAgICBpZiAobW9kdWxlUmVuZGVyZWQpIHtcbiAgICAgIHJldHVybiBtb2R1bGVSZW5kZXJlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gcmVuZGVyKG9wdGlvbnMpIHtcbiAgdmFyIGJhc2VOdWxsR2V0dGVyID0gb3B0aW9ucy5iYXNlTnVsbEdldHRlcjtcbiAgdmFyIGNvbXBpbGVkID0gb3B0aW9ucy5jb21waWxlZCxcbiAgICBzY29wZU1hbmFnZXIgPSBvcHRpb25zLnNjb3BlTWFuYWdlcjtcbiAgb3B0aW9ucy5udWxsR2V0dGVyID0gZnVuY3Rpb24gKHBhcnQsIHNtKSB7XG4gICAgcmV0dXJuIGJhc2VOdWxsR2V0dGVyKHBhcnQsIHNtIHx8IHNjb3BlTWFuYWdlcik7XG4gIH07XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHBhcnRzID0gY29tcGlsZWQubWFwKGZ1bmN0aW9uIChwYXJ0LCBpKSB7XG4gICAgb3B0aW9ucy5pbmRleCA9IGk7XG4gICAgb3B0aW9ucy5yZXNvbHZlZElkID0gZ2V0UmVzb2x2ZWRJZChwYXJ0LCBvcHRpb25zKTtcbiAgICB2YXIgbW9kdWxlUmVuZGVyZWQ7XG4gICAgdHJ5IHtcbiAgICAgIG1vZHVsZVJlbmRlcmVkID0gbW9kdWxlUmVuZGVyKHBhcnQsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgWFRTY29wZVBhcnNlckVycm9yKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGlmIChtb2R1bGVSZW5kZXJlZCkge1xuICAgICAgaWYgKG1vZHVsZVJlbmRlcmVkLmVycm9ycykge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlcnJvcnMsIG1vZHVsZVJlbmRlcmVkLmVycm9ycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kdWxlUmVuZGVyZWQ7XG4gICAgfVxuICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiY29udGVudFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0YWdcIikge1xuICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgfVxuICAgIHRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGUocGFydCwgaSk7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAocGFydHMsIF9yZWYpIHtcbiAgICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBwdXNoQXJyYXkocGFydHMsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICBwYXJ0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9LCBbXSk7XG4gIHJldHVybiB7XG4gICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgcGFydHM6IHBhcnRzXG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/render.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/resolve.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/resolve.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleResolve(part, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    var moduleResolved = _module.resolve(part, options);\n    if (moduleResolved) {\n      return moduleResolved;\n    }\n  }\n  return false;\n}\nfunction resolve(options) {\n  var resolved = [];\n  var baseNullGetter = options.baseNullGetter;\n  var compiled = options.compiled,\n    scopeManager = options.scopeManager;\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n  options.resolved = resolved;\n  var errors = [];\n  return Promise.all(compiled.filter(function (part) {\n    return [\"content\", \"tag\"].indexOf(part.type) === -1;\n  }).reduce(function (promises, part) {\n    var moduleResolved = moduleResolve(part, _objectSpread(_objectSpread({}, options), {}, {\n      resolvedId: getResolvedId(part, options)\n    }));\n    var result;\n    if (moduleResolved) {\n      result = moduleResolved.then(function (value) {\n        resolved.push({\n          tag: part.value,\n          lIndex: part.lIndex,\n          value: value\n        });\n      });\n    } else if (part.type === \"placeholder\") {\n      result = scopeManager.getValueAsync(part.value, {\n        part: part\n      }).then(function (value) {\n        return value == null ? options.nullGetter(part) : value;\n      }).then(function (value) {\n        resolved.push({\n          tag: part.value,\n          lIndex: part.lIndex,\n          value: value\n        });\n        return value;\n      });\n    } else {\n      return;\n    }\n    promises.push(result[\"catch\"](function (e) {\n      if (e instanceof Array) {\n        errors.push.apply(errors, _toConsumableArray(e));\n      } else {\n        errors.push(e);\n      }\n    }));\n    return promises;\n  }, [])).then(function () {\n    return {\n      errors: errors,\n      resolved: resolved\n    };\n  });\n}\nmodule.exports = resolve;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcmVzb2x2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSiwrQkFBK0I7QUFDL0IsaUNBQWlDO0FBQ2pDLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxvQkFBb0IsbUJBQU8sQ0FBQyw4SEFBc0I7QUFDbEQ7QUFDQSx5REFBeUQsZ0NBQWdDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMkVBQTJFLGNBQWM7QUFDekY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcmVzb2x2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7IGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIGdldFJlc29sdmVkSWQgPSByZXF1aXJlKFwiLi9nZXQtcmVzb2x2ZWQtaWQuanNcIik7XG5mdW5jdGlvbiBtb2R1bGVSZXNvbHZlKHBhcnQsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgX2kyID0gMCwgX29wdGlvbnMkbW9kdWxlczIgPSBvcHRpb25zLm1vZHVsZXM7IF9pMiA8IF9vcHRpb25zJG1vZHVsZXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX21vZHVsZSA9IF9vcHRpb25zJG1vZHVsZXMyW19pMl07XG4gICAgdmFyIG1vZHVsZVJlc29sdmVkID0gX21vZHVsZS5yZXNvbHZlKHBhcnQsIG9wdGlvbnMpO1xuICAgIGlmIChtb2R1bGVSZXNvbHZlZCkge1xuICAgICAgcmV0dXJuIG1vZHVsZVJlc29sdmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZXNvbHZlKG9wdGlvbnMpIHtcbiAgdmFyIHJlc29sdmVkID0gW107XG4gIHZhciBiYXNlTnVsbEdldHRlciA9IG9wdGlvbnMuYmFzZU51bGxHZXR0ZXI7XG4gIHZhciBjb21waWxlZCA9IG9wdGlvbnMuY29tcGlsZWQsXG4gICAgc2NvcGVNYW5hZ2VyID0gb3B0aW9ucy5zY29wZU1hbmFnZXI7XG4gIG9wdGlvbnMubnVsbEdldHRlciA9IGZ1bmN0aW9uIChwYXJ0LCBzbSkge1xuICAgIHJldHVybiBiYXNlTnVsbEdldHRlcihwYXJ0LCBzbSB8fCBzY29wZU1hbmFnZXIpO1xuICB9O1xuICBvcHRpb25zLnJlc29sdmVkID0gcmVzb2x2ZWQ7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGNvbXBpbGVkLmZpbHRlcihmdW5jdGlvbiAocGFydCkge1xuICAgIHJldHVybiBbXCJjb250ZW50XCIsIFwidGFnXCJdLmluZGV4T2YocGFydC50eXBlKSA9PT0gLTE7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAocHJvbWlzZXMsIHBhcnQpIHtcbiAgICB2YXIgbW9kdWxlUmVzb2x2ZWQgPSBtb2R1bGVSZXNvbHZlKHBhcnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICByZXNvbHZlZElkOiBnZXRSZXNvbHZlZElkKHBhcnQsIG9wdGlvbnMpXG4gICAgfSkpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKG1vZHVsZVJlc29sdmVkKSB7XG4gICAgICByZXN1bHQgPSBtb2R1bGVSZXNvbHZlZC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlZC5wdXNoKHtcbiAgICAgICAgICB0YWc6IHBhcnQudmFsdWUsXG4gICAgICAgICAgbEluZGV4OiBwYXJ0LmxJbmRleCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHBhcnQudHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiKSB7XG4gICAgICByZXN1bHQgPSBzY29wZU1hbmFnZXIuZ2V0VmFsdWVBc3luYyhwYXJ0LnZhbHVlLCB7XG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gb3B0aW9ucy5udWxsR2V0dGVyKHBhcnQpIDogdmFsdWU7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlZC5wdXNoKHtcbiAgICAgICAgICB0YWc6IHBhcnQudmFsdWUsXG4gICAgICAgICAgbEluZGV4OiBwYXJ0LmxJbmRleCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb21pc2VzLnB1c2gocmVzdWx0W1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBfdG9Db25zdW1hYmxlQXJyYXkoZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICB9XG4gICAgfSkpO1xuICAgIHJldHVybiBwcm9taXNlcztcbiAgfSwgW10pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICByZXNvbHZlZDogcmVzb2x2ZWRcbiAgICB9O1xuICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gcmVzb2x2ZTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/resolve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/scope-manager.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/scope-manager.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\"),\n  getScopeParserExecutionError = _require.getScopeParserExecutionError;\nvar _require2 = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/utils.js\"),\n  last = _require2.last;\nvar _require3 = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  concatArrays = _require3.concatArrays;\nfunction find(list, fn) {\n  var length = list.length >>> 0;\n  var value;\n  for (var i = 0; i < length; i++) {\n    value = list[i];\n    if (fn.call(this, value, i, list)) {\n      return value;\n    }\n  }\n  return undefined;\n}\nfunction _getValue(tag, meta, num) {\n  var _this = this;\n  var scope = this.scopeList[num];\n  if (this.root.finishedResolving) {\n    var w = this.resolved;\n    var _loop = function _loop() {\n      var lIndex = _this.scopeLindex[i];\n      w = find(w, function (r) {\n        return r.lIndex === lIndex;\n      });\n      w = w.value[_this.scopePathItem[i]];\n    };\n    for (var i = this.resolveOffset, len = this.scopePath.length; i < len; i++) {\n      _loop();\n    }\n    return find(w, function (r) {\n      return meta.part.lIndex === r.lIndex;\n    }).value;\n  }\n  // search in the scopes (in reverse order) and keep the first defined value\n  var result;\n  var parser;\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  }\n  try {\n    result = parser.get(scope, this.getContext(meta, num));\n  } catch (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }\n  if (result == null && num > 0) {\n    return _getValue.call(this, tag, meta, num - 1);\n  }\n  return result;\n}\nfunction _getValueAsync(tag, meta, num) {\n  var _this2 = this;\n  var scope = this.scopeList[num];\n  // search in the scopes (in reverse order) and keep the first defined value\n  var parser;\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  }\n  return Promise.resolve().then(function () {\n    return parser.get(scope, _this2.getContext(meta, num));\n  })[\"catch\"](function (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }).then(function (result) {\n    if (result == null && num > 0) {\n      return _getValueAsync.call(_this2, tag, meta, num - 1);\n    }\n    return result;\n  });\n}\nvar ScopeManager = /*#__PURE__*/function () {\n  function ScopeManager(options) {\n    _classCallCheck(this, ScopeManager);\n    this.root = options.root || this;\n    this.resolveOffset = options.resolveOffset || 0;\n    this.scopePath = options.scopePath;\n    this.scopePathItem = options.scopePathItem;\n    this.scopePathLength = options.scopePathLength;\n    this.scopeList = options.scopeList;\n    this.scopeType = \"\";\n    this.scopeTypes = options.scopeTypes;\n    this.scopeLindex = options.scopeLindex;\n    this.parser = options.parser;\n    this.resolved = options.resolved;\n    this.cachedParsers = options.cachedParsers;\n  }\n  return _createClass(ScopeManager, [{\n    key: \"loopOver\",\n    value: function loopOver(tag, functor, inverted, meta) {\n      return this.loopOverValue(this.getValue(tag, meta), functor, inverted);\n    }\n  }, {\n    key: \"functorIfInverted\",\n    value: function functorIfInverted(inverted, functor, value, i, length) {\n      if (inverted) {\n        functor(value, i, length);\n      }\n      return inverted;\n    }\n  }, {\n    key: \"isValueFalsy\",\n    value: function isValueFalsy(value, type) {\n      return value == null || !value || type === \"[object Array]\" && value.length === 0;\n    }\n  }, {\n    key: \"loopOverValue\",\n    value: function loopOverValue(value, functor, inverted) {\n      if (this.root.finishedResolving) {\n        inverted = false;\n      }\n      var type = Object.prototype.toString.call(value);\n      if (this.isValueFalsy(value, type)) {\n        this.scopeType = false;\n        return this.functorIfInverted(inverted, functor, last(this.scopeList), 0, 1);\n      }\n      if (type === \"[object Array]\") {\n        this.scopeType = \"array\";\n        for (var i = 0; i < value.length; i++) {\n          this.functorIfInverted(!inverted, functor, value[i], i, value.length);\n        }\n        return true;\n      }\n      if (type === \"[object Object]\") {\n        this.scopeType = \"object\";\n        return this.functorIfInverted(!inverted, functor, value, 0, 1);\n      }\n      return this.functorIfInverted(!inverted, functor, last(this.scopeList), 0, 1);\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(tag, meta) {\n      var result = _getValue.call(this, tag, meta, this.scopeList.length - 1);\n      if (typeof result === \"function\") {\n        return result(this.scopeList[this.scopeList.length - 1], this);\n      }\n      return result;\n    }\n  }, {\n    key: \"getValueAsync\",\n    value: function getValueAsync(tag, meta) {\n      var _this3 = this;\n      return _getValueAsync.call(this, tag, meta, this.scopeList.length - 1).then(function (result) {\n        if (typeof result === \"function\") {\n          return result(_this3.scopeList[_this3.scopeList.length - 1], _this3);\n        }\n        return result;\n      });\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(meta, num) {\n      return {\n        num: num,\n        meta: meta,\n        scopeList: this.scopeList,\n        resolved: this.resolved,\n        scopePath: this.scopePath,\n        scopeTypes: this.scopeTypes,\n        scopePathItem: this.scopePathItem,\n        scopePathLength: this.scopePathLength\n      };\n    }\n  }, {\n    key: \"createSubScopeManager\",\n    value: function createSubScopeManager(scope, tag, i, part, length) {\n      return new ScopeManager({\n        root: this.root,\n        resolveOffset: this.resolveOffset,\n        resolved: this.resolved,\n        parser: this.parser,\n        cachedParsers: this.cachedParsers,\n        scopeTypes: concatArrays([this.scopeTypes, [this.scopeType]]),\n        scopeList: concatArrays([this.scopeList, [scope]]),\n        scopePath: concatArrays([this.scopePath, [tag]]),\n        scopePathItem: concatArrays([this.scopePathItem, [i]]),\n        scopePathLength: concatArrays([this.scopePathLength, [length]]),\n        scopeLindex: concatArrays([this.scopeLindex, [part.lIndex]])\n      });\n    }\n  }]);\n}();\nmodule.exports = function (options) {\n  options.scopePath = [];\n  options.scopePathItem = [];\n  options.scopePathLength = [];\n  options.scopeTypes = [];\n  options.scopeLindex = [];\n  options.scopeList = [options.tags];\n  return new ScopeManager(options);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvc2NvcGUtbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsZUFBZSxtQkFBTyxDQUFDLDRHQUFhO0FBQ3BDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsMEdBQVk7QUFDcEM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxrSEFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0VBQWtFLFNBQVM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzLy5wbnBtL2RvY3h0ZW1wbGF0ZXJAMy42MC4yL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3Njb3BlLW1hbmFnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvciA9IF9yZXF1aXJlLmdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3I7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIiksXG4gIGxhc3QgPSBfcmVxdWlyZTIubGFzdDtcbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIGNvbmNhdEFycmF5cyA9IF9yZXF1aXJlMy5jb25jYXRBcnJheXM7XG5mdW5jdGlvbiBmaW5kKGxpc3QsIGZuKSB7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aCA+Pj4gMDtcbiAgdmFyIHZhbHVlO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFsdWUgPSBsaXN0W2ldO1xuICAgIGlmIChmbi5jYWxsKHRoaXMsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gX2dldFZhbHVlKHRhZywgbWV0YSwgbnVtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGVMaXN0W251bV07XG4gIGlmICh0aGlzLnJvb3QuZmluaXNoZWRSZXNvbHZpbmcpIHtcbiAgICB2YXIgdyA9IHRoaXMucmVzb2x2ZWQ7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgbEluZGV4ID0gX3RoaXMuc2NvcGVMaW5kZXhbaV07XG4gICAgICB3ID0gZmluZCh3LCBmdW5jdGlvbiAocikge1xuICAgICAgICByZXR1cm4gci5sSW5kZXggPT09IGxJbmRleDtcbiAgICAgIH0pO1xuICAgICAgdyA9IHcudmFsdWVbX3RoaXMuc2NvcGVQYXRoSXRlbVtpXV07XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5yZXNvbHZlT2Zmc2V0LCBsZW4gPSB0aGlzLnNjb3BlUGF0aC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgX2xvb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmQodywgZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBtZXRhLnBhcnQubEluZGV4ID09PSByLmxJbmRleDtcbiAgICB9KS52YWx1ZTtcbiAgfVxuICAvLyBzZWFyY2ggaW4gdGhlIHNjb3BlcyAoaW4gcmV2ZXJzZSBvcmRlcikgYW5kIGtlZXAgdGhlIGZpcnN0IGRlZmluZWQgdmFsdWVcbiAgdmFyIHJlc3VsdDtcbiAgdmFyIHBhcnNlcjtcbiAgaWYgKCF0aGlzLmNhY2hlZFBhcnNlcnMgfHwgIW1ldGEucGFydCkge1xuICAgIHBhcnNlciA9IHRoaXMucGFyc2VyKHRhZywge1xuICAgICAgdGFnOiBtZXRhLnBhcnQsXG4gICAgICBzY29wZVBhdGg6IHRoaXMuc2NvcGVQYXRoXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodGhpcy5jYWNoZWRQYXJzZXJzW21ldGEucGFydC5sSW5kZXhdKSB7XG4gICAgcGFyc2VyID0gdGhpcy5jYWNoZWRQYXJzZXJzW21ldGEucGFydC5sSW5kZXhdO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlciA9IHRoaXMuY2FjaGVkUGFyc2Vyc1ttZXRhLnBhcnQubEluZGV4XSA9IHRoaXMucGFyc2VyKHRhZywge1xuICAgICAgdGFnOiBtZXRhLnBhcnQsXG4gICAgICBzY29wZVBhdGg6IHRoaXMuc2NvcGVQYXRoXG4gICAgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBwYXJzZXIuZ2V0KHNjb3BlLCB0aGlzLmdldENvbnRleHQobWV0YSwgbnVtKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcih7XG4gICAgICB0YWc6IHRhZyxcbiAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgIG9mZnNldDogbWV0YS5wYXJ0Lm9mZnNldFxuICAgIH0pO1xuICB9XG4gIGlmIChyZXN1bHQgPT0gbnVsbCAmJiBudW0gPiAwKSB7XG4gICAgcmV0dXJuIF9nZXRWYWx1ZS5jYWxsKHRoaXMsIHRhZywgbWV0YSwgbnVtIC0gMSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9nZXRWYWx1ZUFzeW5jKHRhZywgbWV0YSwgbnVtKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuICB2YXIgc2NvcGUgPSB0aGlzLnNjb3BlTGlzdFtudW1dO1xuICAvLyBzZWFyY2ggaW4gdGhlIHNjb3BlcyAoaW4gcmV2ZXJzZSBvcmRlcikgYW5kIGtlZXAgdGhlIGZpcnN0IGRlZmluZWQgdmFsdWVcbiAgdmFyIHBhcnNlcjtcbiAgaWYgKCF0aGlzLmNhY2hlZFBhcnNlcnMgfHwgIW1ldGEucGFydCkge1xuICAgIHBhcnNlciA9IHRoaXMucGFyc2VyKHRhZywge1xuICAgICAgdGFnOiBtZXRhLnBhcnQsXG4gICAgICBzY29wZVBhdGg6IHRoaXMuc2NvcGVQYXRoXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodGhpcy5jYWNoZWRQYXJzZXJzW21ldGEucGFydC5sSW5kZXhdKSB7XG4gICAgcGFyc2VyID0gdGhpcy5jYWNoZWRQYXJzZXJzW21ldGEucGFydC5sSW5kZXhdO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlciA9IHRoaXMuY2FjaGVkUGFyc2Vyc1ttZXRhLnBhcnQubEluZGV4XSA9IHRoaXMucGFyc2VyKHRhZywge1xuICAgICAgdGFnOiBtZXRhLnBhcnQsXG4gICAgICBzY29wZVBhdGg6IHRoaXMuc2NvcGVQYXRoXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwYXJzZXIuZ2V0KHNjb3BlLCBfdGhpczIuZ2V0Q29udGV4dChtZXRhLCBudW0pKTtcbiAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICB0aHJvdyBnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yKHtcbiAgICAgIHRhZzogdGFnLFxuICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgb2Zmc2V0OiBtZXRhLnBhcnQub2Zmc2V0XG4gICAgfSk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiBudW0gPiAwKSB7XG4gICAgICByZXR1cm4gX2dldFZhbHVlQXN5bmMuY2FsbChfdGhpczIsIHRhZywgbWV0YSwgbnVtIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxudmFyIFNjb3BlTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjb3BlTWFuYWdlcihvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNjb3BlTWFuYWdlcik7XG4gICAgdGhpcy5yb290ID0gb3B0aW9ucy5yb290IHx8IHRoaXM7XG4gICAgdGhpcy5yZXNvbHZlT2Zmc2V0ID0gb3B0aW9ucy5yZXNvbHZlT2Zmc2V0IHx8IDA7XG4gICAgdGhpcy5zY29wZVBhdGggPSBvcHRpb25zLnNjb3BlUGF0aDtcbiAgICB0aGlzLnNjb3BlUGF0aEl0ZW0gPSBvcHRpb25zLnNjb3BlUGF0aEl0ZW07XG4gICAgdGhpcy5zY29wZVBhdGhMZW5ndGggPSBvcHRpb25zLnNjb3BlUGF0aExlbmd0aDtcbiAgICB0aGlzLnNjb3BlTGlzdCA9IG9wdGlvbnMuc2NvcGVMaXN0O1xuICAgIHRoaXMuc2NvcGVUeXBlID0gXCJcIjtcbiAgICB0aGlzLnNjb3BlVHlwZXMgPSBvcHRpb25zLnNjb3BlVHlwZXM7XG4gICAgdGhpcy5zY29wZUxpbmRleCA9IG9wdGlvbnMuc2NvcGVMaW5kZXg7XG4gICAgdGhpcy5wYXJzZXIgPSBvcHRpb25zLnBhcnNlcjtcbiAgICB0aGlzLnJlc29sdmVkID0gb3B0aW9ucy5yZXNvbHZlZDtcbiAgICB0aGlzLmNhY2hlZFBhcnNlcnMgPSBvcHRpb25zLmNhY2hlZFBhcnNlcnM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTY29wZU1hbmFnZXIsIFt7XG4gICAga2V5OiBcImxvb3BPdmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvb3BPdmVyKHRhZywgZnVuY3RvciwgaW52ZXJ0ZWQsIG1ldGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvb3BPdmVyVmFsdWUodGhpcy5nZXRWYWx1ZSh0YWcsIG1ldGEpLCBmdW5jdG9yLCBpbnZlcnRlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZ1bmN0b3JJZkludmVydGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZ1bmN0b3JJZkludmVydGVkKGludmVydGVkLCBmdW5jdG9yLCB2YWx1ZSwgaSwgbGVuZ3RoKSB7XG4gICAgICBpZiAoaW52ZXJ0ZWQpIHtcbiAgICAgICAgZnVuY3Rvcih2YWx1ZSwgaSwgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnZlcnRlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNWYWx1ZUZhbHN5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVmFsdWVGYWxzeSh2YWx1ZSwgdHlwZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgIXZhbHVlIHx8IHR5cGUgPT09IFwiW29iamVjdCBBcnJheV1cIiAmJiB2YWx1ZS5sZW5ndGggPT09IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvb3BPdmVyVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9vcE92ZXJWYWx1ZSh2YWx1ZSwgZnVuY3RvciwgaW52ZXJ0ZWQpIHtcbiAgICAgIGlmICh0aGlzLnJvb3QuZmluaXNoZWRSZXNvbHZpbmcpIHtcbiAgICAgICAgaW52ZXJ0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIGlmICh0aGlzLmlzVmFsdWVGYWxzeSh2YWx1ZSwgdHlwZSkpIHtcbiAgICAgICAgdGhpcy5zY29wZVR5cGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3RvcklmSW52ZXJ0ZWQoaW52ZXJ0ZWQsIGZ1bmN0b3IsIGxhc3QodGhpcy5zY29wZUxpc3QpLCAwLCAxKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgdGhpcy5zY29wZVR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmZ1bmN0b3JJZkludmVydGVkKCFpbnZlcnRlZCwgZnVuY3RvciwgdmFsdWVbaV0sIGksIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgICB0aGlzLnNjb3BlVHlwZSA9IFwib2JqZWN0XCI7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bmN0b3JJZkludmVydGVkKCFpbnZlcnRlZCwgZnVuY3RvciwgdmFsdWUsIDAsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZnVuY3RvcklmSW52ZXJ0ZWQoIWludmVydGVkLCBmdW5jdG9yLCBsYXN0KHRoaXMuc2NvcGVMaXN0KSwgMCwgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKHRhZywgbWV0YSkge1xuICAgICAgdmFyIHJlc3VsdCA9IF9nZXRWYWx1ZS5jYWxsKHRoaXMsIHRhZywgbWV0YSwgdGhpcy5zY29wZUxpc3QubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQodGhpcy5zY29wZUxpc3RbdGhpcy5zY29wZUxpc3QubGVuZ3RoIC0gMV0sIHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVBc3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZUFzeW5jKHRhZywgbWV0YSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICByZXR1cm4gX2dldFZhbHVlQXN5bmMuY2FsbCh0aGlzLCB0YWcsIG1ldGEsIHRoaXMuc2NvcGVMaXN0Lmxlbmd0aCAtIDEpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdChfdGhpczMuc2NvcGVMaXN0W190aGlzMy5zY29wZUxpc3QubGVuZ3RoIC0gMV0sIF90aGlzMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRleHQobWV0YSwgbnVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBudW06IG51bSxcbiAgICAgICAgbWV0YTogbWV0YSxcbiAgICAgICAgc2NvcGVMaXN0OiB0aGlzLnNjb3BlTGlzdCxcbiAgICAgICAgcmVzb2x2ZWQ6IHRoaXMucmVzb2x2ZWQsXG4gICAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGgsXG4gICAgICAgIHNjb3BlVHlwZXM6IHRoaXMuc2NvcGVUeXBlcyxcbiAgICAgICAgc2NvcGVQYXRoSXRlbTogdGhpcy5zY29wZVBhdGhJdGVtLFxuICAgICAgICBzY29wZVBhdGhMZW5ndGg6IHRoaXMuc2NvcGVQYXRoTGVuZ3RoXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVTdWJTY29wZU1hbmFnZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU3ViU2NvcGVNYW5hZ2VyKHNjb3BlLCB0YWcsIGksIHBhcnQsIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBTY29wZU1hbmFnZXIoe1xuICAgICAgICByb290OiB0aGlzLnJvb3QsXG4gICAgICAgIHJlc29sdmVPZmZzZXQ6IHRoaXMucmVzb2x2ZU9mZnNldCxcbiAgICAgICAgcmVzb2x2ZWQ6IHRoaXMucmVzb2x2ZWQsXG4gICAgICAgIHBhcnNlcjogdGhpcy5wYXJzZXIsXG4gICAgICAgIGNhY2hlZFBhcnNlcnM6IHRoaXMuY2FjaGVkUGFyc2VycyxcbiAgICAgICAgc2NvcGVUeXBlczogY29uY2F0QXJyYXlzKFt0aGlzLnNjb3BlVHlwZXMsIFt0aGlzLnNjb3BlVHlwZV1dKSxcbiAgICAgICAgc2NvcGVMaXN0OiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVMaXN0LCBbc2NvcGVdXSksXG4gICAgICAgIHNjb3BlUGF0aDogY29uY2F0QXJyYXlzKFt0aGlzLnNjb3BlUGF0aCwgW3RhZ11dKSxcbiAgICAgICAgc2NvcGVQYXRoSXRlbTogY29uY2F0QXJyYXlzKFt0aGlzLnNjb3BlUGF0aEl0ZW0sIFtpXV0pLFxuICAgICAgICBzY29wZVBhdGhMZW5ndGg6IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZVBhdGhMZW5ndGgsIFtsZW5ndGhdXSksXG4gICAgICAgIHNjb3BlTGluZGV4OiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVMaW5kZXgsIFtwYXJ0LmxJbmRleF1dKVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMuc2NvcGVQYXRoID0gW107XG4gIG9wdGlvbnMuc2NvcGVQYXRoSXRlbSA9IFtdO1xuICBvcHRpb25zLnNjb3BlUGF0aExlbmd0aCA9IFtdO1xuICBvcHRpb25zLnNjb3BlVHlwZXMgPSBbXTtcbiAgb3B0aW9ucy5zY29wZUxpbmRleCA9IFtdO1xuICBvcHRpb25zLnNjb3BlTGlzdCA9IFtvcHRpb25zLnRhZ3NdO1xuICByZXR1cm4gbmV3IFNjb3BlTWFuYWdlcihvcHRpb25zKTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/scope-manager.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/traits.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/traits.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  getRightOrNull = _require.getRightOrNull,\n  getRight = _require.getRight,\n  getLeft = _require.getLeft,\n  getLeftOrNull = _require.getLeftOrNull,\n  chunkBy = _require.chunkBy,\n  isTagStart = _require.isTagStart,\n  isTagEnd = _require.isTagEnd,\n  isContent = _require.isContent,\n  last = _require.last,\n  first = _require.first;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/errors.js\"),\n  XTTemplateError = _require2.XTTemplateError,\n  throwExpandNotFound = _require2.throwExpandNotFound,\n  getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\nfunction lastTagIsOpenTag(tags, tag) {\n  if (tags.length === 0) {\n    return false;\n  }\n  var innerLastTag = last(tags).substr(1);\n  return innerLastTag.indexOf(tag) === 0;\n}\nfunction getListXmlElements(parts) {\n  /*\n   * Gets the list of closing and opening tags between two texts. It doesn't take\n   * into account tags that are opened then closed. Those that are closed then\n   * opened are kept\n   *\n   * Example input :\n   *\n   * [\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"table1\",\n   * \t\t...\n   * \t},\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"t1data1\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"position\": \"end\",\n   * \t\t\"text\": true,\n   * \t\t\"value\": \"</w:t>\",\n   * \t\t\"tag\": \"w:t\",\n   * \t\t\"lIndex\": 112\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:r>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:p>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:tc>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:tc>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"content\",\n   * \t\t\"value\": \"<w:tcPr><w:tcW w:w=\"2444\" w:type=\"dxa\"/><w:tcBorders><w:top w:val=\"nil\"/><w:left w:val=\"nil\"/><w:bottom w:val=\"nil\"/><w:right w:val=\"nil\"/></w:tcBorders><w:shd w:val=\"clear\" w:color=\"auto\" w:fill=\"FFFFFF\"/></w:tcPr>\",\n   * \t},\n   * \t...\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:r>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:t xml:space=\"preserve\">\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"t1data4\",\n   * \t}\n   * ]\n   *\n   * Returns\n   *\n   * \t[\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:t>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:r>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:p>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:tc>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:tc>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:p>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:r>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:t>\",\n   * \t\t},\n   * \t]\n   */\n\n  var result = [];\n  for (var _i2 = 0; _i2 < parts.length; _i2++) {\n    var _parts$_i = parts[_i2],\n      position = _parts$_i.position,\n      value = _parts$_i.value,\n      tag = _parts$_i.tag;\n    // Stryker disable all : because removing this condition would also work but we want to make the API future proof\n    if (!tag) {\n      continue;\n    }\n    // Stryker restore all\n    if (position === \"end\") {\n      if (lastTagIsOpenTag(result, tag)) {\n        result.pop();\n      } else {\n        result.push(value);\n      }\n    } else if (position === \"start\") {\n      result.push(value);\n    }\n    // ignore position === \"selfclosing\"\n  }\n  return result;\n}\nfunction has(name, xmlElements) {\n  for (var _i4 = 0; _i4 < xmlElements.length; _i4++) {\n    var xmlElement = xmlElements[_i4];\n    if (xmlElement.indexOf(\"<\".concat(name)) === 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getExpandToDefault(postparsed, pair, expandTags) {\n  var parts = postparsed.slice(pair[0].offset, pair[1].offset);\n  var xmlElements = getListXmlElements(parts);\n  var closingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] === \"/\";\n  }).length;\n  var startingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] !== \"/\" && tag[tag.length - 2] !== \"/\";\n  }).length;\n  if (closingTagCount !== startingTagCount) {\n    return {\n      error: getLoopPositionProducesInvalidXMLError({\n        tag: first(pair).part.value,\n        offset: [first(pair).part.offset, last(pair).part.offset]\n      })\n    };\n  }\n  var _loop = function _loop() {\n      var _expandTags$_i = expandTags[_i6],\n        contains = _expandTags$_i.contains,\n        expand = _expandTags$_i.expand,\n        onlyTextInTag = _expandTags$_i.onlyTextInTag;\n      if (has(contains, xmlElements)) {\n        if (onlyTextInTag) {\n          var left = getLeftOrNull(postparsed, contains, pair[0].offset);\n          var right = getRightOrNull(postparsed, contains, pair[1].offset);\n          if (left === null || right === null) {\n            return 0; // continue\n          }\n          var chunks = chunkBy(postparsed.slice(left, right), function (p) {\n            return isTagStart(contains, p) ? \"start\" : isTagEnd(contains, p) ? \"end\" : null;\n          });\n          var firstChunk = first(chunks);\n          var lastChunk = last(chunks);\n          var firstContent = firstChunk.filter(isContent);\n          var lastContent = lastChunk.filter(isContent);\n          if (firstContent.length !== 1 || lastContent.length !== 1) {\n            return 0; // continue\n          }\n        }\n        return {\n          v: {\n            value: expand\n          }\n        };\n      }\n    },\n    _ret;\n  for (var _i6 = 0; _i6 < expandTags.length; _i6++) {\n    _ret = _loop();\n    if (_ret === 0) continue;\n    if (_ret) return _ret.v;\n  }\n  return {};\n}\nfunction getExpandLimit(part, index, postparsed, options) {\n  var expandTo = part.expandTo || options.expandTo;\n  // Stryker disable all : because this condition can be removed in v4 (the only usage was the image module before version 3.12.3 of the image module\n  if (!expandTo) {\n    return;\n  }\n  // Stryker restore all\n  var right, left;\n  try {\n    left = getLeft(postparsed, expandTo, index);\n    right = getRight(postparsed, expandTo, index);\n  } catch (rootError) {\n    var errProps = _objectSpread({\n      part: part,\n      rootError: rootError,\n      postparsed: postparsed,\n      expandTo: expandTo,\n      index: index\n    }, options.error);\n    if (options.onError) {\n      var errorResult = options.onError(errProps);\n      if (errorResult === \"ignore\") {\n        return;\n      }\n    }\n    throwExpandNotFound(errProps);\n  }\n  return [left, right];\n}\nfunction expandOne(_ref, part, postparsed, options) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    left = _ref2[0],\n    right = _ref2[1];\n  var index = postparsed.indexOf(part);\n  var leftParts = postparsed.slice(left, index);\n  var rightParts = postparsed.slice(index + 1, right + 1);\n  var inner = options.getInner({\n    postparse: options.postparse,\n    index: index,\n    part: part,\n    leftParts: leftParts,\n    rightParts: rightParts,\n    left: left,\n    right: right,\n    postparsed: postparsed\n  });\n  if (!inner.length) {\n    inner.expanded = [leftParts, rightParts];\n    inner = [inner];\n  }\n  return {\n    left: left,\n    right: right,\n    inner: inner\n  };\n}\n\n/* eslint-disable-next-line complexity */\nfunction expandToOne(postparsed, options) {\n  var errors = [];\n  if (postparsed.errors) {\n    errors = postparsed.errors;\n    postparsed = postparsed.postparsed;\n  }\n  var limits = [];\n  for (var i = 0, len = postparsed.length; i < len; i++) {\n    var part = postparsed[i];\n    if (part.type === \"placeholder\" && part.module === options.moduleName &&\n    /*\n     * The part.subparsed check is used to fix this github issue :\n     * https://github.com/open-xml-templating/docxtemplater/issues/671\n     */\n    !part.subparsed && !part.expanded) {\n      try {\n        var limit = getExpandLimit(part, i, postparsed, options);\n        if (!limit) {\n          continue;\n        }\n        var _limit = _slicedToArray(limit, 2),\n          left = _limit[0],\n          right = _limit[1];\n        limits.push({\n          left: left,\n          right: right,\n          part: part,\n          i: i,\n          leftPart: postparsed[left],\n          rightPart: postparsed[right]\n        });\n      } catch (error) {\n        // The Error can only be a\n        errors.push(error);\n      }\n    }\n  }\n  limits.sort(function (l1, l2) {\n    if (l1.left === l2.left) {\n      return l2.part.lIndex < l1.part.lIndex ? 1 : -1;\n    }\n    return l2.left < l1.left ? 1 : -1;\n  });\n  var maxRight = -1;\n  var offset = 0;\n  for (var _i7 = 0, _len = limits.length; _i7 < _len; _i7++) {\n    var _postparsed;\n    var _limit2 = limits[_i7];\n    maxRight = Math.max(maxRight, _i7 > 0 ? limits[_i7 - 1].right : 0);\n    if (_limit2.left < maxRight) {\n      continue;\n    }\n    var result = void 0;\n    try {\n      result = expandOne([_limit2.left + offset, _limit2.right + offset], _limit2.part, postparsed, options);\n    } catch (error) {\n      if (options.onError) {\n        var errorResult = options.onError(_objectSpread({\n          part: _limit2.part,\n          rootError: error,\n          postparsed: postparsed,\n          expandOne: expandOne\n        }, options.errors));\n        if (errorResult === \"ignore\") {\n          continue;\n        }\n      }\n      if (error instanceof XTTemplateError) {\n        errors.push(error);\n      } else {\n        throw error;\n      }\n    }\n    if (!result) {\n      continue;\n    }\n    offset += result.inner.length - (result.right + 1 - result.left);\n    (_postparsed = postparsed).splice.apply(_postparsed, [result.left, result.right + 1 - result.left].concat(_toConsumableArray(result.inner)));\n  }\n  return {\n    postparsed: postparsed,\n    errors: errors\n  };\n}\nmodule.exports = {\n  expandToOne: expandToOne,\n  getExpandToDefault: getExpandToDefault\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvdHJhaXRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSixtQ0FBbUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUN6SSx1Q0FBdUMsa0dBQWtHLGlCQUFpQix3Q0FBd0MsTUFBTSx5Q0FBeUMsNkJBQTZCLFVBQVUsWUFBWSxrRUFBa0UsV0FBVyxZQUFZLGlCQUFpQixVQUFVLE1BQU0saUZBQWlGLFVBQVUsb0JBQW9CO0FBQzdnQiw4QkFBOEI7QUFDOUIseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGVBQWUsbUJBQU8sQ0FBQyxrSEFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw0R0FBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy8ucG5wbS9kb2N4dGVtcGxhdGVyQDMuNjAuMi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy90cmFpdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShyKSB7IHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheShyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikgeyBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpOyB9XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgZ2V0UmlnaHRPck51bGwgPSBfcmVxdWlyZS5nZXRSaWdodE9yTnVsbCxcbiAgZ2V0UmlnaHQgPSBfcmVxdWlyZS5nZXRSaWdodCxcbiAgZ2V0TGVmdCA9IF9yZXF1aXJlLmdldExlZnQsXG4gIGdldExlZnRPck51bGwgPSBfcmVxdWlyZS5nZXRMZWZ0T3JOdWxsLFxuICBjaHVua0J5ID0gX3JlcXVpcmUuY2h1bmtCeSxcbiAgaXNUYWdTdGFydCA9IF9yZXF1aXJlLmlzVGFnU3RhcnQsXG4gIGlzVGFnRW5kID0gX3JlcXVpcmUuaXNUYWdFbmQsXG4gIGlzQ29udGVudCA9IF9yZXF1aXJlLmlzQ29udGVudCxcbiAgbGFzdCA9IF9yZXF1aXJlLmxhc3QsXG4gIGZpcnN0ID0gX3JlcXVpcmUuZmlyc3Q7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICBYVFRlbXBsYXRlRXJyb3IgPSBfcmVxdWlyZTIuWFRUZW1wbGF0ZUVycm9yLFxuICB0aHJvd0V4cGFuZE5vdEZvdW5kID0gX3JlcXVpcmUyLnRocm93RXhwYW5kTm90Rm91bmQsXG4gIGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yID0gX3JlcXVpcmUyLmdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yO1xuZnVuY3Rpb24gbGFzdFRhZ0lzT3BlblRhZyh0YWdzLCB0YWcpIHtcbiAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbm5lckxhc3RUYWcgPSBsYXN0KHRhZ3MpLnN1YnN0cigxKTtcbiAgcmV0dXJuIGlubmVyTGFzdFRhZy5pbmRleE9mKHRhZykgPT09IDA7XG59XG5mdW5jdGlvbiBnZXRMaXN0WG1sRWxlbWVudHMocGFydHMpIHtcbiAgLypcbiAgICogR2V0cyB0aGUgbGlzdCBvZiBjbG9zaW5nIGFuZCBvcGVuaW5nIHRhZ3MgYmV0d2VlbiB0d28gdGV4dHMuIEl0IGRvZXNuJ3QgdGFrZVxuICAgKiBpbnRvIGFjY291bnQgdGFncyB0aGF0IGFyZSBvcGVuZWQgdGhlbiBjbG9zZWQuIFRob3NlIHRoYXQgYXJlIGNsb3NlZCB0aGVuXG4gICAqIG9wZW5lZCBhcmUga2VwdFxuICAgKlxuICAgKiBFeGFtcGxlIGlucHV0IDpcbiAgICpcbiAgICogW1xuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInBsYWNlaG9sZGVyXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwidGFibGUxXCIsXG4gICAqIFx0XHQuLi5cbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInBsYWNlaG9sZGVyXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwidDFkYXRhMVwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gICAqIFx0XHRcInBvc2l0aW9uXCI6IFwiZW5kXCIsXG4gICAqIFx0XHRcInRleHRcIjogdHJ1ZSxcbiAgICogXHRcdFwidmFsdWVcIjogXCI8L3c6dD5cIixcbiAgICogXHRcdFwidGFnXCI6IFwidzp0XCIsXG4gICAqIFx0XHRcImxJbmRleFwiOiAxMTJcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjwvdzpyPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPC93OnA+XCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCI8L3c6dGM+XCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCI8dzp0Yz5cIixcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcImNvbnRlbnRcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCI8dzp0Y1ByPjx3OnRjVyB3Onc9XCIyNDQ0XCIgdzp0eXBlPVwiZHhhXCIvPjx3OnRjQm9yZGVycz48dzp0b3Agdzp2YWw9XCJuaWxcIi8+PHc6bGVmdCB3OnZhbD1cIm5pbFwiLz48dzpib3R0b20gdzp2YWw9XCJuaWxcIi8+PHc6cmlnaHQgdzp2YWw9XCJuaWxcIi8+PC93OnRjQm9yZGVycz48dzpzaGQgdzp2YWw9XCJjbGVhclwiIHc6Y29sb3I9XCJhdXRvXCIgdzpmaWxsPVwiRkZGRkZGXCIvPjwvdzp0Y1ByPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0Li4uXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPHc6cj5cIixcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjx3OnQgeG1sOnNwYWNlPVwicHJlc2VydmVcIj5cIixcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInBsYWNlaG9sZGVyXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwidDFkYXRhNFwiLFxuICAgKiBcdH1cbiAgICogXVxuICAgKlxuICAgKiBSZXR1cm5zXG4gICAqXG4gICAqIFx0W1xuICAgKiBcdFx0e1xuICAgKiBcdFx0XHRcInRhZ1wiOiBcIjwvdzp0PlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8L3c6cj5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPC93OnA+XCIsXG4gICAqIFx0XHR9LFxuICAgKiBcdFx0e1xuICAgKiBcdFx0XHRcInRhZ1wiOiBcIjwvdzp0Yz5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPHc6dGM+XCIsXG4gICAqIFx0XHR9LFxuICAgKiBcdFx0e1xuICAgKiBcdFx0XHRcInRhZ1wiOiBcIjx3OnA+XCIsXG4gICAqIFx0XHR9LFxuICAgKiBcdFx0e1xuICAgKiBcdFx0XHRcInRhZ1wiOiBcIjx3OnI+XCIsXG4gICAqIFx0XHR9LFxuICAgKiBcdFx0e1xuICAgKiBcdFx0XHRcInRhZ1wiOiBcIjx3OnQ+XCIsXG4gICAqIFx0XHR9LFxuICAgKiBcdF1cbiAgICovXG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYXJ0cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9wYXJ0cyRfaSA9IHBhcnRzW19pMl0sXG4gICAgICBwb3NpdGlvbiA9IF9wYXJ0cyRfaS5wb3NpdGlvbixcbiAgICAgIHZhbHVlID0gX3BhcnRzJF9pLnZhbHVlLFxuICAgICAgdGFnID0gX3BhcnRzJF9pLnRhZztcbiAgICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSByZW1vdmluZyB0aGlzIGNvbmRpdGlvbiB3b3VsZCBhbHNvIHdvcmsgYnV0IHdlIHdhbnQgdG8gbWFrZSB0aGUgQVBJIGZ1dHVyZSBwcm9vZlxuICAgIGlmICghdGFnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJlbmRcIikge1xuICAgICAgaWYgKGxhc3RUYWdJc09wZW5UYWcocmVzdWx0LCB0YWcpKSB7XG4gICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gaWdub3JlIHBvc2l0aW9uID09PSBcInNlbGZjbG9zaW5nXCJcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaGFzKG5hbWUsIHhtbEVsZW1lbnRzKSB7XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHhtbEVsZW1lbnRzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgeG1sRWxlbWVudCA9IHhtbEVsZW1lbnRzW19pNF07XG4gICAgaWYgKHhtbEVsZW1lbnQuaW5kZXhPZihcIjxcIi5jb25jYXQobmFtZSkpID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0RXhwYW5kVG9EZWZhdWx0KHBvc3RwYXJzZWQsIHBhaXIsIGV4cGFuZFRhZ3MpIHtcbiAgdmFyIHBhcnRzID0gcG9zdHBhcnNlZC5zbGljZShwYWlyWzBdLm9mZnNldCwgcGFpclsxXS5vZmZzZXQpO1xuICB2YXIgeG1sRWxlbWVudHMgPSBnZXRMaXN0WG1sRWxlbWVudHMocGFydHMpO1xuICB2YXIgY2xvc2luZ1RhZ0NvdW50ID0geG1sRWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uICh0YWcpIHtcbiAgICByZXR1cm4gdGFnWzFdID09PSBcIi9cIjtcbiAgfSkubGVuZ3RoO1xuICB2YXIgc3RhcnRpbmdUYWdDb3VudCA9IHhtbEVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAodGFnKSB7XG4gICAgcmV0dXJuIHRhZ1sxXSAhPT0gXCIvXCIgJiYgdGFnW3RhZy5sZW5ndGggLSAyXSAhPT0gXCIvXCI7XG4gIH0pLmxlbmd0aDtcbiAgaWYgKGNsb3NpbmdUYWdDb3VudCAhPT0gc3RhcnRpbmdUYWdDb3VudCkge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3Ioe1xuICAgICAgICB0YWc6IGZpcnN0KHBhaXIpLnBhcnQudmFsdWUsXG4gICAgICAgIG9mZnNldDogW2ZpcnN0KHBhaXIpLnBhcnQub2Zmc2V0LCBsYXN0KHBhaXIpLnBhcnQub2Zmc2V0XVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgdmFyIF9leHBhbmRUYWdzJF9pID0gZXhwYW5kVGFnc1tfaTZdLFxuICAgICAgICBjb250YWlucyA9IF9leHBhbmRUYWdzJF9pLmNvbnRhaW5zLFxuICAgICAgICBleHBhbmQgPSBfZXhwYW5kVGFncyRfaS5leHBhbmQsXG4gICAgICAgIG9ubHlUZXh0SW5UYWcgPSBfZXhwYW5kVGFncyRfaS5vbmx5VGV4dEluVGFnO1xuICAgICAgaWYgKGhhcyhjb250YWlucywgeG1sRWxlbWVudHMpKSB7XG4gICAgICAgIGlmIChvbmx5VGV4dEluVGFnKSB7XG4gICAgICAgICAgdmFyIGxlZnQgPSBnZXRMZWZ0T3JOdWxsKHBvc3RwYXJzZWQsIGNvbnRhaW5zLCBwYWlyWzBdLm9mZnNldCk7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gZ2V0UmlnaHRPck51bGwocG9zdHBhcnNlZCwgY29udGFpbnMsIHBhaXJbMV0ub2Zmc2V0KTtcbiAgICAgICAgICBpZiAobGVmdCA9PT0gbnVsbCB8fCByaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjaHVua3MgPSBjaHVua0J5KHBvc3RwYXJzZWQuc2xpY2UobGVmdCwgcmlnaHQpLCBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzVGFnU3RhcnQoY29udGFpbnMsIHApID8gXCJzdGFydFwiIDogaXNUYWdFbmQoY29udGFpbnMsIHApID8gXCJlbmRcIiA6IG51bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGZpcnN0Q2h1bmsgPSBmaXJzdChjaHVua3MpO1xuICAgICAgICAgIHZhciBsYXN0Q2h1bmsgPSBsYXN0KGNodW5rcyk7XG4gICAgICAgICAgdmFyIGZpcnN0Q29udGVudCA9IGZpcnN0Q2h1bmsuZmlsdGVyKGlzQ29udGVudCk7XG4gICAgICAgICAgdmFyIGxhc3RDb250ZW50ID0gbGFzdENodW5rLmZpbHRlcihpc0NvbnRlbnQpO1xuICAgICAgICAgIGlmIChmaXJzdENvbnRlbnQubGVuZ3RoICE9PSAxIHx8IGxhc3RDb250ZW50Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdjoge1xuICAgICAgICAgICAgdmFsdWU6IGV4cGFuZFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9yZXQ7XG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGV4cGFuZFRhZ3MubGVuZ3RoOyBfaTYrKykge1xuICAgIF9yZXQgPSBfbG9vcCgpO1xuICAgIGlmIChfcmV0ID09PSAwKSBjb250aW51ZTtcbiAgICBpZiAoX3JldCkgcmV0dXJuIF9yZXQudjtcbiAgfVxuICByZXR1cm4ge307XG59XG5mdW5jdGlvbiBnZXRFeHBhbmRMaW1pdChwYXJ0LCBpbmRleCwgcG9zdHBhcnNlZCwgb3B0aW9ucykge1xuICB2YXIgZXhwYW5kVG8gPSBwYXJ0LmV4cGFuZFRvIHx8IG9wdGlvbnMuZXhwYW5kVG87XG4gIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgY29uZGl0aW9uIGNhbiBiZSByZW1vdmVkIGluIHY0ICh0aGUgb25seSB1c2FnZSB3YXMgdGhlIGltYWdlIG1vZHVsZSBiZWZvcmUgdmVyc2lvbiAzLjEyLjMgb2YgdGhlIGltYWdlIG1vZHVsZVxuICBpZiAoIWV4cGFuZFRvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcbiAgdmFyIHJpZ2h0LCBsZWZ0O1xuICB0cnkge1xuICAgIGxlZnQgPSBnZXRMZWZ0KHBvc3RwYXJzZWQsIGV4cGFuZFRvLCBpbmRleCk7XG4gICAgcmlnaHQgPSBnZXRSaWdodChwb3N0cGFyc2VkLCBleHBhbmRUbywgaW5kZXgpO1xuICB9IGNhdGNoIChyb290RXJyb3IpIHtcbiAgICB2YXIgZXJyUHJvcHMgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICByb290RXJyb3I6IHJvb3RFcnJvcixcbiAgICAgIHBvc3RwYXJzZWQ6IHBvc3RwYXJzZWQsXG4gICAgICBleHBhbmRUbzogZXhwYW5kVG8sXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9LCBvcHRpb25zLmVycm9yKTtcbiAgICBpZiAob3B0aW9ucy5vbkVycm9yKSB7XG4gICAgICB2YXIgZXJyb3JSZXN1bHQgPSBvcHRpb25zLm9uRXJyb3IoZXJyUHJvcHMpO1xuICAgICAgaWYgKGVycm9yUmVzdWx0ID09PSBcImlnbm9yZVwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3dFeHBhbmROb3RGb3VuZChlcnJQcm9wcyk7XG4gIH1cbiAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG59XG5mdW5jdGlvbiBleHBhbmRPbmUoX3JlZiwgcGFydCwgcG9zdHBhcnNlZCwgb3B0aW9ucykge1xuICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICBsZWZ0ID0gX3JlZjJbMF0sXG4gICAgcmlnaHQgPSBfcmVmMlsxXTtcbiAgdmFyIGluZGV4ID0gcG9zdHBhcnNlZC5pbmRleE9mKHBhcnQpO1xuICB2YXIgbGVmdFBhcnRzID0gcG9zdHBhcnNlZC5zbGljZShsZWZ0LCBpbmRleCk7XG4gIHZhciByaWdodFBhcnRzID0gcG9zdHBhcnNlZC5zbGljZShpbmRleCArIDEsIHJpZ2h0ICsgMSk7XG4gIHZhciBpbm5lciA9IG9wdGlvbnMuZ2V0SW5uZXIoe1xuICAgIHBvc3RwYXJzZTogb3B0aW9ucy5wb3N0cGFyc2UsXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIHBhcnQ6IHBhcnQsXG4gICAgbGVmdFBhcnRzOiBsZWZ0UGFydHMsXG4gICAgcmlnaHRQYXJ0czogcmlnaHRQYXJ0cyxcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkXG4gIH0pO1xuICBpZiAoIWlubmVyLmxlbmd0aCkge1xuICAgIGlubmVyLmV4cGFuZGVkID0gW2xlZnRQYXJ0cywgcmlnaHRQYXJ0c107XG4gICAgaW5uZXIgPSBbaW5uZXJdO1xuICB9XG4gIHJldHVybiB7XG4gICAgbGVmdDogbGVmdCxcbiAgICByaWdodDogcmlnaHQsXG4gICAgaW5uZXI6IGlubmVyXG4gIH07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5ICovXG5mdW5jdGlvbiBleHBhbmRUb09uZShwb3N0cGFyc2VkLCBvcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKHBvc3RwYXJzZWQuZXJyb3JzKSB7XG4gICAgZXJyb3JzID0gcG9zdHBhcnNlZC5lcnJvcnM7XG4gICAgcG9zdHBhcnNlZCA9IHBvc3RwYXJzZWQucG9zdHBhcnNlZDtcbiAgfVxuICB2YXIgbGltaXRzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb3N0cGFyc2VkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBwb3N0cGFyc2VkW2ldO1xuICAgIGlmIChwYXJ0LnR5cGUgPT09IFwicGxhY2Vob2xkZXJcIiAmJiBwYXJ0Lm1vZHVsZSA9PT0gb3B0aW9ucy5tb2R1bGVOYW1lICYmXG4gICAgLypcbiAgICAgKiBUaGUgcGFydC5zdWJwYXJzZWQgY2hlY2sgaXMgdXNlZCB0byBmaXggdGhpcyBnaXRodWIgaXNzdWUgOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuLXhtbC10ZW1wbGF0aW5nL2RvY3h0ZW1wbGF0ZXIvaXNzdWVzLzY3MVxuICAgICAqL1xuICAgICFwYXJ0LnN1YnBhcnNlZCAmJiAhcGFydC5leHBhbmRlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGxpbWl0ID0gZ2V0RXhwYW5kTGltaXQocGFydCwgaSwgcG9zdHBhcnNlZCwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2xpbWl0ID0gX3NsaWNlZFRvQXJyYXkobGltaXQsIDIpLFxuICAgICAgICAgIGxlZnQgPSBfbGltaXRbMF0sXG4gICAgICAgICAgcmlnaHQgPSBfbGltaXRbMV07XG4gICAgICAgIGxpbWl0cy5wdXNoKHtcbiAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgIGk6IGksXG4gICAgICAgICAgbGVmdFBhcnQ6IHBvc3RwYXJzZWRbbGVmdF0sXG4gICAgICAgICAgcmlnaHRQYXJ0OiBwb3N0cGFyc2VkW3JpZ2h0XVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFRoZSBFcnJvciBjYW4gb25seSBiZSBhXG4gICAgICAgIGVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGltaXRzLnNvcnQoZnVuY3Rpb24gKGwxLCBsMikge1xuICAgIGlmIChsMS5sZWZ0ID09PSBsMi5sZWZ0KSB7XG4gICAgICByZXR1cm4gbDIucGFydC5sSW5kZXggPCBsMS5wYXJ0LmxJbmRleCA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIGwyLmxlZnQgPCBsMS5sZWZ0ID8gMSA6IC0xO1xuICB9KTtcbiAgdmFyIG1heFJpZ2h0ID0gLTE7XG4gIHZhciBvZmZzZXQgPSAwO1xuICBmb3IgKHZhciBfaTcgPSAwLCBfbGVuID0gbGltaXRzLmxlbmd0aDsgX2k3IDwgX2xlbjsgX2k3KyspIHtcbiAgICB2YXIgX3Bvc3RwYXJzZWQ7XG4gICAgdmFyIF9saW1pdDIgPSBsaW1pdHNbX2k3XTtcbiAgICBtYXhSaWdodCA9IE1hdGgubWF4KG1heFJpZ2h0LCBfaTcgPiAwID8gbGltaXRzW19pNyAtIDFdLnJpZ2h0IDogMCk7XG4gICAgaWYgKF9saW1pdDIubGVmdCA8IG1heFJpZ2h0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZXhwYW5kT25lKFtfbGltaXQyLmxlZnQgKyBvZmZzZXQsIF9saW1pdDIucmlnaHQgKyBvZmZzZXRdLCBfbGltaXQyLnBhcnQsIHBvc3RwYXJzZWQsIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAob3B0aW9ucy5vbkVycm9yKSB7XG4gICAgICAgIHZhciBlcnJvclJlc3VsdCA9IG9wdGlvbnMub25FcnJvcihfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICBwYXJ0OiBfbGltaXQyLnBhcnQsXG4gICAgICAgICAgcm9vdEVycm9yOiBlcnJvcixcbiAgICAgICAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkLFxuICAgICAgICAgIGV4cGFuZE9uZTogZXhwYW5kT25lXG4gICAgICAgIH0sIG9wdGlvbnMuZXJyb3JzKSk7XG4gICAgICAgIGlmIChlcnJvclJlc3VsdCA9PT0gXCJpZ25vcmVcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBYVFRlbXBsYXRlRXJyb3IpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IHJlc3VsdC5pbm5lci5sZW5ndGggLSAocmVzdWx0LnJpZ2h0ICsgMSAtIHJlc3VsdC5sZWZ0KTtcbiAgICAoX3Bvc3RwYXJzZWQgPSBwb3N0cGFyc2VkKS5zcGxpY2UuYXBwbHkoX3Bvc3RwYXJzZWQsIFtyZXN1bHQubGVmdCwgcmVzdWx0LnJpZ2h0ICsgMSAtIHJlc3VsdC5sZWZ0XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHJlc3VsdC5pbm5lcikpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHBvc3RwYXJzZWQ6IHBvc3RwYXJzZWQsXG4gICAgZXJyb3JzOiBlcnJvcnNcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBleHBhbmRUb09uZTogZXhwYW5kVG9PbmUsXG4gIGdldEV4cGFuZFRvRGVmYXVsdDogZ2V0RXhwYW5kVG9EZWZhdWx0XG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/traits.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/utils.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/utils.js ***!
  \****************************************************************************************/
/***/ ((module) => {

eval("\n\nfunction last(a) {\n  return a[a.length - 1];\n}\nfunction first(a) {\n  return a[0];\n}\nmodule.exports = {\n  last: last,\n  first: first\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvbm9kZV9tb2R1bGVzLy5wbnBtL2RvY3h0ZW1wbGF0ZXJAMy42MC4yL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBsYXN0KGEpIHtcbiAgcmV0dXJuIGFbYS5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGZpcnN0KGEpIHtcbiAgcmV0dXJuIGFbMF07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbGFzdDogbGFzdCxcbiAgZmlyc3Q6IGZpcnN0XG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/xml-matcher.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/xml-matcher.js ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  pregMatchAll = _require.pregMatchAll;\nmodule.exports = function xmlMatcher(content, tagsXmlArray) {\n  var res = {\n    content: content\n  };\n  var taj = tagsXmlArray.join(\"|\");\n  var regexp = new RegExp(\"(?:(<(?:\".concat(taj, \")[^>]*>)([^<>]*)</(?:\").concat(taj, \")>)|(<(?:\").concat(taj, \")[^>]*/>)\"), \"g\");\n  res.matches = pregMatchAll(regexp, res.content);\n  return res;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMveG1sLW1hdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLGtIQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMveG1sLW1hdGNoZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgcHJlZ01hdGNoQWxsID0gX3JlcXVpcmUucHJlZ01hdGNoQWxsO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4bWxNYXRjaGVyKGNvbnRlbnQsIHRhZ3NYbWxBcnJheSkge1xuICB2YXIgcmVzID0ge1xuICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgfTtcbiAgdmFyIHRhaiA9IHRhZ3NYbWxBcnJheS5qb2luKFwifFwiKTtcbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoXCIoPzooPCg/OlwiLmNvbmNhdCh0YWosIFwiKVtePl0qPikoW148Pl0qKTwvKD86XCIpLmNvbmNhdCh0YWosIFwiKT4pfCg8KD86XCIpLmNvbmNhdCh0YWosIFwiKVtePl0qLz4pXCIpLCBcImdcIik7XG4gIHJlcy5tYXRjaGVzID0gcHJlZ01hdGNoQWxsKHJlZ2V4cCwgcmVzLmNvbnRlbnQpO1xuICByZXR1cm4gcmVzO1xufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/xml-matcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/xml-templater.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/xml-templater.js ***!
  \************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray,\n  wordToUtf8 = _require.wordToUtf8,\n  convertSpaces = _require.convertSpaces;\nvar xmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/xml-matcher.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/lexer.js\");\nvar Parser = __webpack_require__(/*! ./parser.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/parser.js\");\nvar _render = __webpack_require__(/*! ./render.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/render.js\");\nvar postrender = __webpack_require__(/*! ./postrender.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/postrender.js\");\nvar resolve = __webpack_require__(/*! ./resolve.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/resolve.js\");\nvar joinUncorrupt = __webpack_require__(/*! ./join-uncorrupt.js */ \"(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/join-uncorrupt.js\");\nfunction _getFullText(content, tagsXmlArray) {\n  var matcher = xmlMatcher(content, tagsXmlArray);\n  var result = matcher.matches.map(function (match) {\n    return match.array[2];\n  });\n  return wordToUtf8(convertSpaces(result.join(\"\")));\n}\nmodule.exports = /*#__PURE__*/function () {\n  function XmlTemplater(content, options) {\n    _classCallCheck(this, XmlTemplater);\n    this.cachedParsers = {};\n    this.content = content;\n    for (var key in options) {\n      this[key] = options[key];\n    }\n    this.setModules({\n      inspect: {\n        filePath: options.filePath\n      }\n    });\n  }\n  return _createClass(XmlTemplater, [{\n    key: \"resolveTags\",\n    value: function resolveTags(tags) {\n      var _this = this;\n      this.tags = tags;\n      var options = this.getOptions();\n      var filePath = this.filePath;\n      options.scopeManager = this.scopeManager;\n      options.resolve = resolve;\n      var errors = [];\n      return Promise.all(this.modules.map(function (module) {\n        return Promise.resolve(module.preResolve(options))[\"catch\"](function (e) {\n          errors.push(e);\n        });\n      })).then(function () {\n        if (errors.length !== 0) {\n          throw errors;\n        }\n        return resolve(options).then(function (_ref) {\n          var resolved = _ref.resolved,\n            errors = _ref.errors;\n          errors = errors.map(function (error) {\n            var _error;\n            // If a string is thrown, convert it to a real Error\n            if (!(error instanceof Error)) {\n              error = new Error(error);\n            }\n            /*\n             * error properties might not be defined if some foreign error\n             * (unhandled error not thrown by docxtemplater willingly) is\n             * thrown.\n             */\n            (_error = error).properties || (_error.properties = {});\n            error.properties.file = filePath;\n            return error;\n          });\n          if (errors.length !== 0) {\n            throw errors;\n          }\n          return Promise.all(resolved).then(function (resolved) {\n            options.scopeManager.root.finishedResolving = true;\n            options.scopeManager.resolved = resolved;\n            _this.setModules({\n              inspect: {\n                resolved: resolved,\n                filePath: filePath\n              }\n            });\n            return resolved;\n          });\n        })[\"catch\"](function (error) {\n          _this.errorChecker(error);\n          throw error;\n        });\n      });\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText() {\n      return _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      for (var _i2 = 0, _this$modules2 = this.modules; _i2 < _this$modules2.length; _i2++) {\n        var _module = _this$modules2[_i2];\n        _module.set(obj);\n      }\n    }\n  }, {\n    key: \"preparse\",\n    value: function preparse() {\n      this.allErrors = [];\n      this.xmllexed = Lexer.xmlparse(this.content, {\n        text: this.fileTypeConfig.tagsXmlTextArray,\n        other: this.fileTypeConfig.tagsXmlLexedArray\n      });\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          xmllexed: this.xmllexed\n        }\n      });\n      var _Lexer$parse = Lexer.parse(this.xmllexed, this.delimiters, this.syntax, this.fileType),\n        lexed = _Lexer$parse.lexed,\n        lexerErrors = _Lexer$parse.errors;\n      pushArray(this.allErrors, lexerErrors);\n      this.lexed = lexed;\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          lexed: this.lexed\n        }\n      });\n      var options = this.getOptions();\n      this.lexed = Parser.preparse(this.lexed, this.modules, options);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      this.setModules({\n        inspect: {\n          filePath: this.filePath\n        }\n      });\n      var options = this.getOptions();\n      this.parsed = Parser.parse(this.lexed, this.modules, options);\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          parsed: this.parsed\n        }\n      });\n      var _Parser$postparse = Parser.postparse(this.parsed, this.modules, options),\n        postparsed = _Parser$postparse.postparsed,\n        postparsedErrors = _Parser$postparse.errors;\n      this.postparsed = postparsed;\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          postparsed: this.postparsed\n        }\n      });\n      pushArray(this.allErrors, postparsedErrors);\n      this.errorChecker(this.allErrors);\n      return this;\n    }\n  }, {\n    key: \"errorChecker\",\n    value: function errorChecker(errors) {\n      for (var _i4 = 0, _errors2 = errors; _i4 < _errors2.length; _i4++) {\n        var error = _errors2[_i4];\n        /*\n         * error properties might not be defined if some foreign\n         * (unhandled error not thrown by docxtemplater willingly) is\n         * thrown.\n         */\n        error.properties || (error.properties = {});\n        error.properties.file = this.filePath;\n      }\n      for (var _i6 = 0, _this$modules4 = this.modules; _i6 < _this$modules4.length; _i6++) {\n        var _module2 = _this$modules4[_i6];\n        errors = _module2.errorsTransformer(errors);\n      }\n    }\n  }, {\n    key: \"baseNullGetter\",\n    value: function baseNullGetter(part, sm) {\n      var _this2 = this;\n      var value = this.modules.reduce(function (value, module) {\n        if (value != null) {\n          return value;\n        }\n        return module.nullGetter(part, sm, _this2);\n      }, null);\n      if (value != null) {\n        return value;\n      }\n      return this.nullGetter(part, sm);\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return {\n        compiled: this.postparsed,\n        cachedParsers: this.cachedParsers,\n        tags: this.tags,\n        modules: this.modules,\n        parser: this.parser,\n        contentType: this.contentType,\n        relsType: this.relsType,\n        baseNullGetter: this.baseNullGetter.bind(this),\n        filePath: this.filePath,\n        fileTypeConfig: this.fileTypeConfig,\n        fileType: this.fileType,\n        linebreaks: this.linebreaks,\n        stripInvalidXMLChars: this.stripInvalidXMLChars\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render(to) {\n      this.filePath = to;\n      var options = this.getOptions();\n      options.resolved = this.scopeManager.resolved;\n      options.scopeManager = this.scopeManager;\n      options.render = _render;\n      options.joinUncorrupt = joinUncorrupt;\n      var _render2 = _render(options),\n        errors = _render2.errors,\n        parts = _render2.parts;\n      if (errors.length > 0) {\n        this.allErrors = errors;\n        this.errorChecker(errors);\n        return this;\n      }\n      this.content = postrender(parts, options);\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          content: this.content\n        }\n      });\n      return this;\n    }\n  }]);\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZG9jeHRlbXBsYXRlckAzLjYwLjIvbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMveG1sLXRlbXBsYXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsZUFBZSxtQkFBTyxDQUFDLGtIQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxzSEFBa0I7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLDBHQUFZO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyw0R0FBYTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsNEdBQWE7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsb0hBQWlCO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyw4R0FBYztBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQyw0SEFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVEQUF1RCw2QkFBNkI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSx1REFBdUQsNkJBQTZCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L25vZGVfbW9kdWxlcy8ucG5wbS9kb2N4dGVtcGxhdGVyQDMuNjAuMi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy94bWwtdGVtcGxhdGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlLnB1c2hBcnJheSxcbiAgd29yZFRvVXRmOCA9IF9yZXF1aXJlLndvcmRUb1V0ZjgsXG4gIGNvbnZlcnRTcGFjZXMgPSBfcmVxdWlyZS5jb252ZXJ0U3BhY2VzO1xudmFyIHhtbE1hdGNoZXIgPSByZXF1aXJlKFwiLi94bWwtbWF0Y2hlci5qc1wiKTtcbnZhciBMZXhlciA9IHJlcXVpcmUoXCIuL2xleGVyLmpzXCIpO1xudmFyIFBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlci5qc1wiKTtcbnZhciBfcmVuZGVyID0gcmVxdWlyZShcIi4vcmVuZGVyLmpzXCIpO1xudmFyIHBvc3RyZW5kZXIgPSByZXF1aXJlKFwiLi9wb3N0cmVuZGVyLmpzXCIpO1xudmFyIHJlc29sdmUgPSByZXF1aXJlKFwiLi9yZXNvbHZlLmpzXCIpO1xudmFyIGpvaW5VbmNvcnJ1cHQgPSByZXF1aXJlKFwiLi9qb2luLXVuY29ycnVwdC5qc1wiKTtcbmZ1bmN0aW9uIF9nZXRGdWxsVGV4dChjb250ZW50LCB0YWdzWG1sQXJyYXkpIHtcbiAgdmFyIG1hdGNoZXIgPSB4bWxNYXRjaGVyKGNvbnRlbnQsIHRhZ3NYbWxBcnJheSk7XG4gIHZhciByZXN1bHQgPSBtYXRjaGVyLm1hdGNoZXMubWFwKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBtYXRjaC5hcnJheVsyXTtcbiAgfSk7XG4gIHJldHVybiB3b3JkVG9VdGY4KGNvbnZlcnRTcGFjZXMocmVzdWx0LmpvaW4oXCJcIikpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWG1sVGVtcGxhdGVyKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWG1sVGVtcGxhdGVyKTtcbiAgICB0aGlzLmNhY2hlZFBhcnNlcnMgPSB7fTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICBpbnNwZWN0OiB7XG4gICAgICAgIGZpbGVQYXRoOiBvcHRpb25zLmZpbGVQYXRoXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhYbWxUZW1wbGF0ZXIsIFt7XG4gICAga2V5OiBcInJlc29sdmVUYWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVUYWdzKHRhZ3MpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIHZhciBmaWxlUGF0aCA9IHRoaXMuZmlsZVBhdGg7XG4gICAgICBvcHRpb25zLnNjb3BlTWFuYWdlciA9IHRoaXMuc2NvcGVNYW5hZ2VyO1xuICAgICAgb3B0aW9ucy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLm1vZHVsZXMubWFwKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtb2R1bGUucHJlUmVzb2x2ZShvcHRpb25zKSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUob3B0aW9ucykudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciByZXNvbHZlZCA9IF9yZWYucmVzb2x2ZWQsXG4gICAgICAgICAgICBlcnJvcnMgPSBfcmVmLmVycm9ycztcbiAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIF9lcnJvcjtcbiAgICAgICAgICAgIC8vIElmIGEgc3RyaW5nIGlzIHRocm93biwgY29udmVydCBpdCB0byBhIHJlYWwgRXJyb3JcbiAgICAgICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBlcnJvciBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCBiZSBkZWZpbmVkIGlmIHNvbWUgZm9yZWlnbiBlcnJvclxuICAgICAgICAgICAgICogKHVuaGFuZGxlZCBlcnJvciBub3QgdGhyb3duIGJ5IGRvY3h0ZW1wbGF0ZXIgd2lsbGluZ2x5KSBpc1xuICAgICAgICAgICAgICogdGhyb3duLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoX2Vycm9yID0gZXJyb3IpLnByb3BlcnRpZXMgfHwgKF9lcnJvci5wcm9wZXJ0aWVzID0ge30pO1xuICAgICAgICAgICAgZXJyb3IucHJvcGVydGllcy5maWxlID0gZmlsZVBhdGg7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IGVycm9ycztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc29sdmVkKS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zY29wZU1hbmFnZXIucm9vdC5maW5pc2hlZFJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICBvcHRpb25zLnNjb3BlTWFuYWdlci5yZXNvbHZlZCA9IHJlc29sdmVkO1xuICAgICAgICAgICAgX3RoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZDogcmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IGZpbGVQYXRoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIF90aGlzLmVycm9yQ2hlY2tlcihlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZ1bGxUZXh0KCkge1xuICAgICAgcmV0dXJuIF9nZXRGdWxsVGV4dCh0aGlzLmNvbnRlbnQsIHRoaXMuZmlsZVR5cGVDb25maWcudGFnc1htbFRleHRBcnJheSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1vZHVsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TW9kdWxlcyhvYmopIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDAsIF90aGlzJG1vZHVsZXMyID0gdGhpcy5tb2R1bGVzOyBfaTIgPCBfdGhpcyRtb2R1bGVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlID0gX3RoaXMkbW9kdWxlczJbX2kyXTtcbiAgICAgICAgX21vZHVsZS5zZXQob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyc2UoKSB7XG4gICAgICB0aGlzLmFsbEVycm9ycyA9IFtdO1xuICAgICAgdGhpcy54bWxsZXhlZCA9IExleGVyLnhtbHBhcnNlKHRoaXMuY29udGVudCwge1xuICAgICAgICB0ZXh0OiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ3NYbWxUZXh0QXJyYXksXG4gICAgICAgIG90aGVyOiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ3NYbWxMZXhlZEFycmF5XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICB4bWxsZXhlZDogdGhpcy54bWxsZXhlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBfTGV4ZXIkcGFyc2UgPSBMZXhlci5wYXJzZSh0aGlzLnhtbGxleGVkLCB0aGlzLmRlbGltaXRlcnMsIHRoaXMuc3ludGF4LCB0aGlzLmZpbGVUeXBlKSxcbiAgICAgICAgbGV4ZWQgPSBfTGV4ZXIkcGFyc2UubGV4ZWQsXG4gICAgICAgIGxleGVyRXJyb3JzID0gX0xleGVyJHBhcnNlLmVycm9ycztcbiAgICAgIHB1c2hBcnJheSh0aGlzLmFsbEVycm9ycywgbGV4ZXJFcnJvcnMpO1xuICAgICAgdGhpcy5sZXhlZCA9IGxleGVkO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoLFxuICAgICAgICAgIGxleGVkOiB0aGlzLmxleGVkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIHRoaXMubGV4ZWQgPSBQYXJzZXIucHJlcGFyc2UodGhpcy5sZXhlZCwgdGhpcy5tb2R1bGVzLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGhcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgdGhpcy5wYXJzZWQgPSBQYXJzZXIucGFyc2UodGhpcy5sZXhlZCwgdGhpcy5tb2R1bGVzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICBwYXJzZWQ6IHRoaXMucGFyc2VkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIF9QYXJzZXIkcG9zdHBhcnNlID0gUGFyc2VyLnBvc3RwYXJzZSh0aGlzLnBhcnNlZCwgdGhpcy5tb2R1bGVzLCBvcHRpb25zKSxcbiAgICAgICAgcG9zdHBhcnNlZCA9IF9QYXJzZXIkcG9zdHBhcnNlLnBvc3RwYXJzZWQsXG4gICAgICAgIHBvc3RwYXJzZWRFcnJvcnMgPSBfUGFyc2VyJHBvc3RwYXJzZS5lcnJvcnM7XG4gICAgICB0aGlzLnBvc3RwYXJzZWQgPSBwb3N0cGFyc2VkO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoLFxuICAgICAgICAgIHBvc3RwYXJzZWQ6IHRoaXMucG9zdHBhcnNlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHB1c2hBcnJheSh0aGlzLmFsbEVycm9ycywgcG9zdHBhcnNlZEVycm9ycyk7XG4gICAgICB0aGlzLmVycm9yQ2hlY2tlcih0aGlzLmFsbEVycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJyb3JDaGVja2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yQ2hlY2tlcihlcnJvcnMpIHtcbiAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9lcnJvcnMyID0gZXJyb3JzOyBfaTQgPCBfZXJyb3JzMi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IF9lcnJvcnMyW19pNF07XG4gICAgICAgIC8qXG4gICAgICAgICAqIGVycm9yIHByb3BlcnRpZXMgbWlnaHQgbm90IGJlIGRlZmluZWQgaWYgc29tZSBmb3JlaWduXG4gICAgICAgICAqICh1bmhhbmRsZWQgZXJyb3Igbm90IHRocm93biBieSBkb2N4dGVtcGxhdGVyIHdpbGxpbmdseSkgaXNcbiAgICAgICAgICogdGhyb3duLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3IucHJvcGVydGllcyB8fCAoZXJyb3IucHJvcGVydGllcyA9IHt9KTtcbiAgICAgICAgZXJyb3IucHJvcGVydGllcy5maWxlID0gdGhpcy5maWxlUGF0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pNiA9IDAsIF90aGlzJG1vZHVsZXM0ID0gdGhpcy5tb2R1bGVzOyBfaTYgPCBfdGhpcyRtb2R1bGVzNC5sZW5ndGg7IF9pNisrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlMiA9IF90aGlzJG1vZHVsZXM0W19pNl07XG4gICAgICAgIGVycm9ycyA9IF9tb2R1bGUyLmVycm9yc1RyYW5zZm9ybWVyKGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhc2VOdWxsR2V0dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhc2VOdWxsR2V0dGVyKHBhcnQsIHNtKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlLCBtb2R1bGUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZHVsZS5udWxsR2V0dGVyKHBhcnQsIHNtLCBfdGhpczIpO1xuICAgICAgfSwgbnVsbCk7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5udWxsR2V0dGVyKHBhcnQsIHNtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRPcHRpb25zKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGlsZWQ6IHRoaXMucG9zdHBhcnNlZCxcbiAgICAgICAgY2FjaGVkUGFyc2VyczogdGhpcy5jYWNoZWRQYXJzZXJzLFxuICAgICAgICB0YWdzOiB0aGlzLnRhZ3MsXG4gICAgICAgIG1vZHVsZXM6IHRoaXMubW9kdWxlcyxcbiAgICAgICAgcGFyc2VyOiB0aGlzLnBhcnNlcixcbiAgICAgICAgY29udGVudFR5cGU6IHRoaXMuY29udGVudFR5cGUsXG4gICAgICAgIHJlbHNUeXBlOiB0aGlzLnJlbHNUeXBlLFxuICAgICAgICBiYXNlTnVsbEdldHRlcjogdGhpcy5iYXNlTnVsbEdldHRlci5iaW5kKHRoaXMpLFxuICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgZmlsZVR5cGVDb25maWc6IHRoaXMuZmlsZVR5cGVDb25maWcsXG4gICAgICAgIGZpbGVUeXBlOiB0aGlzLmZpbGVUeXBlLFxuICAgICAgICBsaW5lYnJlYWtzOiB0aGlzLmxpbmVicmVha3MsXG4gICAgICAgIHN0cmlwSW52YWxpZFhNTENoYXJzOiB0aGlzLnN0cmlwSW52YWxpZFhNTENoYXJzXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHRvKSB7XG4gICAgICB0aGlzLmZpbGVQYXRoID0gdG87XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgb3B0aW9ucy5yZXNvbHZlZCA9IHRoaXMuc2NvcGVNYW5hZ2VyLnJlc29sdmVkO1xuICAgICAgb3B0aW9ucy5zY29wZU1hbmFnZXIgPSB0aGlzLnNjb3BlTWFuYWdlcjtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gX3JlbmRlcjtcbiAgICAgIG9wdGlvbnMuam9pblVuY29ycnVwdCA9IGpvaW5VbmNvcnJ1cHQ7XG4gICAgICB2YXIgX3JlbmRlcjIgPSBfcmVuZGVyKG9wdGlvbnMpLFxuICAgICAgICBlcnJvcnMgPSBfcmVuZGVyMi5lcnJvcnMsXG4gICAgICAgIHBhcnRzID0gX3JlbmRlcjIucGFydHM7XG4gICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5hbGxFcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMuZXJyb3JDaGVja2VyKGVycm9ycyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250ZW50ID0gcG9zdHJlbmRlcihwYXJ0cywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XSk7XG59KCk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/docxtemplater@3.60.2/node_modules/docxtemplater/js/xml-templater.js\n");

/***/ })

};
;