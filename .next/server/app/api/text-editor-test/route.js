/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/text-editor-test/route";
exports.ids = ["app/api/text-editor-test/route"];
exports.modules = {

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Ftext-editor-test%2Froute&page=%2Fapi%2Ftext-editor-test%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftext-editor-test%2Froute.ts&appDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Ftext-editor-test%2Froute&page=%2Fapi%2Ftext-editor-test%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftext-editor-test%2Froute.ts&appDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_brandonbrewer_Documents_Linguosity_Linguosity_src_app_api_text_editor_test_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/text-editor-test/route.ts */ \"(rsc)/./src/app/api/text-editor-test/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/text-editor-test/route\",\n        pathname: \"/api/text-editor-test\",\n        filename: \"route\",\n        bundlePath: \"app/api/text-editor-test/route\"\n    },\n    resolvedPagePath: \"/Users/brandonbrewer/Documents/Linguosity/Linguosity/src/app/api/text-editor-test/route.ts\",\n    nextConfigOutput,\n    userland: _Users_brandonbrewer_Documents_Linguosity_Linguosity_src_app_api_text_editor_test_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZ0ZXh0LWVkaXRvci10ZXN0JTJGcm91dGUmcGFnZT0lMkZhcGklMkZ0ZXh0LWVkaXRvci10ZXN0JTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGdGV4dC1lZGl0b3ItdGVzdCUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmJyYW5kb25icmV3ZXIlMkZEb2N1bWVudHMlMkZMaW5ndW9zaXR5JTJGTGluZ3Vvc2l0eSUyRnNyYyUyRmFwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9JTJGVXNlcnMlMkZicmFuZG9uYnJld2VyJTJGRG9jdW1lbnRzJTJGTGluZ3Vvc2l0eSUyRkxpbmd1b3NpdHkmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9JnByZWZlcnJlZFJlZ2lvbj0mbWlkZGxld2FyZUNvbmZpZz1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQ3FCO0FBQzBDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5R0FBbUI7QUFDM0M7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQXNEO0FBQzlEO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQzBGOztBQUUxRiIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L3NyYy9hcHAvYXBpL3RleHQtZWRpdG9yLXRlc3Qvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL3RleHQtZWRpdG9yLXRlc3Qvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS90ZXh0LWVkaXRvci10ZXN0XCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS90ZXh0LWVkaXRvci10ZXN0L3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9zcmMvYXBwL2FwaS90ZXh0LWVkaXRvci10ZXN0L3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgd29ya0FzeW5jU3RvcmFnZSwgd29ya1VuaXRBc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgd29ya0FzeW5jU3RvcmFnZSxcbiAgICAgICAgd29ya1VuaXRBc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Ftext-editor-test%2Froute&page=%2Fapi%2Ftext-editor-test%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftext-editor-test%2Froute.ts&appDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/./src/app/api/text-editor-test/route.ts":
/*!***********************************************!*\
  !*** ./src/app/api/text-editor-test/route.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n\n/**\n * Normalize input data from various sources (text, PDF, audio)\n * @param input - Input data in various formats\n */ async function normalizeInput(input) {\n    // Handle different input formats\n    if (typeof input === 'string') {\n        return input;\n    } else if (input.text) {\n        return input.text;\n    } else if (input.pdfData) {\n        // Return the base64 PDF data - Claude will process it with its document capability\n        return input.pdfData;\n    }\n    return JSON.stringify(input);\n}\n/**\n * Create a default report skeleton if none exists\n */ function createReportSkeleton() {\n    return {\n        header: {\n            studentInformation: {\n                firstName: \"\",\n                lastName: \"\",\n                DOB: \"\",\n                reportDate: \"\",\n                evaluationDate: \"\",\n                parents: [],\n                homeLanguage: \"\"\n            },\n            reasonForReferral: \"\",\n            confidentialityStatement: \"\"\n        },\n        background: {\n            studentDemographicsAndBackground: {\n                educationalHistory: \"\"\n            },\n            healthReport: {\n                medicalHistory: \"\",\n                visionAndHearingScreening: \"\",\n                medicationsAndAllergies: \"\"\n            },\n            earlyInterventionHistory: \"\",\n            familyHistory: {\n                familyStructure: \"\",\n                languageAndCulturalBackground: \"\",\n                socioeconomicFactors: \"\"\n            },\n            parentGuardianConcerns: \"\"\n        },\n        assessmentResults: {\n            observations: {\n                classroomObservations: \"\",\n                playBasedInformalObservations: \"\",\n                socialInteractionObservations: \"\"\n            },\n            assessmentProceduresAndTools: {\n                overviewOfAssessmentMethods: \"\",\n                assessmentToolsUsed: [] // IDs of assessment tools\n            },\n            domains: {\n                receptive: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                },\n                expressive: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                },\n                pragmatic: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                },\n                articulation: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                },\n                voice: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                },\n                fluency: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                }\n            }\n        },\n        conclusion: {\n            eligibility: {\n                domains: {\n                    receptive: false,\n                    expressive: false,\n                    pragmatic: false,\n                    articulation: false,\n                    voice: false,\n                    fluency: false\n                },\n                californiaEdCode: \"\"\n            },\n            conclusion: {\n                summary: \"\"\n            },\n            recommendations: {\n                services: {\n                    typeOfService: \"\",\n                    frequency: \"\",\n                    setting: \"\"\n                },\n                accommodations: [],\n                facilitationStrategies: []\n            },\n            parentFriendlyGlossary: {\n                terms: {}\n            }\n        },\n        metadata: {\n            lastUpdated: new Date().toISOString(),\n            version: 1\n        }\n    };\n}\n/**\n * Update a specific domain section with new data\n */ function updateDomainSection(report, domain, updates) {\n    const updatedReport = {\n        ...report\n    };\n    // Initialize domain if it doesn't exist\n    if (!updatedReport.assessmentResults.domains[domain]) {\n        updatedReport.assessmentResults.domains[domain] = {\n            isConcern: false,\n            topicSentence: '',\n            strengths: [],\n            needs: [],\n            impactStatement: ''\n        };\n    }\n    // Update specific fields\n    if (updates.isConcern !== undefined) {\n        updatedReport.assessmentResults.domains[domain].isConcern = updates.isConcern;\n    }\n    if (updates.topicSentence) {\n        updatedReport.assessmentResults.domains[domain].topicSentence = updates.topicSentence;\n    }\n    if (updates.strengths && updates.strengths.length > 0) {\n        updatedReport.assessmentResults.domains[domain].strengths = [\n            ...updatedReport.assessmentResults.domains[domain].strengths || [],\n            ...updates.strengths\n        ];\n    }\n    if (updates.needs && updates.needs.length > 0) {\n        updatedReport.assessmentResults.domains[domain].needs = [\n            ...updatedReport.assessmentResults.domains[domain].needs || [],\n            ...updates.needs\n        ];\n    }\n    if (updates.impactStatement) {\n        updatedReport.assessmentResults.domains[domain].impactStatement = updates.impactStatement;\n    }\n    // Also update the eligibility status if this is an area of concern\n    if (updates.isConcern !== undefined) {\n        updatedReport.conclusion.eligibility.domains[domain] = updates.isConcern;\n    }\n    // Update metadata\n    updatedReport.metadata.lastUpdated = new Date().toISOString();\n    updatedReport.metadata.version += 1;\n    return updatedReport;\n}\n/**\n * API endpoint to test Claude's text editor tool with JSON report updates\n */ async function POST(request) {\n    const requestId = `req_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 7)}`;\n    console.log(`[${requestId}] 🚀 REQUEST STARTED: Text Editor API called`);\n    try {\n        // Extract request parameters\n        const { input, report: existingReport, updateSection, pdfData } = await request.json();\n        // Determine if this is a PDF upload or text input\n        const isPdfUpload = !!pdfData;\n        const inputData = isPdfUpload ? {\n            pdfData\n        } : input;\n        console.log(`[${requestId}] 📥 Received request payload:`, {\n            inputType: isPdfUpload ? 'PDF' : 'text',\n            inputSize: isPdfUpload ? `${pdfData.length} chars (base64)` : typeof input === 'string' ? `${input.substring(0, 50)}${input.length > 50 ? '...' : ''}` : input,\n            reportProvided: !!existingReport,\n            updateSection: updateSection || 'auto-detect'\n        });\n        // Validate request parameters\n        if (!inputData && !isPdfUpload) {\n            console.log(`[${requestId}] ❌ Validation failed: Missing input data`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Input data is required'\n            }, {\n                status: 400\n            });\n        }\n        // Create or use existing report\n        const report = existingReport || createReportSkeleton();\n        console.log(`[${requestId}] 📋 Using ${existingReport ? 'provided' : 'default'} report structure with ${Object.keys(report.domains || {}).length} domains`);\n        // Get API key from environment variables\n        const apiKey = process.env.ANTHROPIC_API_KEY;\n        // Check if API key is available\n        if (!apiKey) {\n            console.log(`[${requestId}] ❌ Missing API key: ANTHROPIC_API_KEY not set`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'ANTHROPIC_API_KEY is not set in environment variables'\n            }, {\n                status: 500\n            });\n        }\n        try {\n            // Normalize input data (handles text, PDF, etc.)\n            console.log(`[${requestId}] 🔄 Normalizing input data...`);\n            const normalizedInput = await normalizeInput(inputData);\n            console.log(`[${requestId}] ✅ Input normalized, length: ${normalizedInput.length} chars`);\n            // Log if this is a PDF upload\n            if (isPdfUpload) {\n                console.log(`[${requestId}] 📄 Processing PDF data...`);\n            }\n            // Determine which section to update\n            const sectionToUpdate = updateSection || 'auto-detect';\n            console.log(`[${requestId}] 🎯 Target section: ${sectionToUpdate}`);\n            // Prepare the report section that Claude will view and edit\n            let viewContent;\n            let targetPath;\n            console.log(`[${requestId}] 📑 Preparing view content for Claude...`);\n            // Helper function to get a nested value from an object using a path string\n            const getNestedValue = (obj, path)=>{\n                return path.split('.').reduce((o, key)=>o?.[key], obj);\n            };\n            // Extract the main section (header, background, assessmentResults, conclusion)\n            const getMainSection = (path)=>{\n                if (path.startsWith('header.')) return 'header';\n                if (path.startsWith('background.')) return 'background';\n                if (path.startsWith('assessmentResults.')) return 'assessmentResults';\n                if (path.startsWith('conclusion.')) return 'conclusion';\n                return null;\n            };\n            if (sectionToUpdate === 'auto-detect') {\n                // For auto-detect, we only send a summary of each section to save tokens\n                const reportSummary = {\n                    header: {\n                        studentName: `${report.header.studentInformation.firstName} ${report.header.studentInformation.lastName}`,\n                        reasonForReferral: report.header.reasonForReferral?.substring(0, 100) + '...'\n                    },\n                    assessmentResults: {\n                        domains: Object.keys(report.assessmentResults.domains).reduce((acc, domain)=>{\n                            acc[domain] = {\n                                isConcern: report.assessmentResults.domains[domain].isConcern,\n                                topicSentence: report.assessmentResults.domains[domain].topicSentence\n                            };\n                            return acc;\n                        }, {})\n                    },\n                    conclusion: {\n                        summary: report.conclusion.conclusion.summary?.substring(0, 100) + '...'\n                    }\n                };\n                viewContent = JSON.stringify(reportSummary, null, 2);\n                targetPath = '';\n                console.log(`[${requestId}] 🔍 Auto-detect mode: Sending summary report structure (${viewContent.length} chars)`);\n            } else if (sectionToUpdate.startsWith('assessmentResults.domains.')) {\n                // Extract domain name from path\n                const domainName = sectionToUpdate.split('.')[2];\n                viewContent = JSON.stringify(report.assessmentResults.domains[domainName] || {}, null, 2);\n                targetPath = sectionToUpdate;\n                console.log(`[${requestId}] 🔍 Domain-specific update: ${domainName}`, report.assessmentResults.domains[domainName] || 'domain not found');\n            } else {\n                // Handle other specific paths by determining which main section it belongs to\n                const mainSection = getMainSection(sectionToUpdate);\n                if (mainSection) {\n                    // Send just that section of the report\n                    viewContent = JSON.stringify(report[mainSection], null, 2);\n                    targetPath = sectionToUpdate;\n                    console.log(`[${requestId}] 🔍 Section update: ${mainSection} -> ${sectionToUpdate}`);\n                } else {\n                    // If we can't determine the section, get the specific path or default to summary\n                    const nestedValue = getNestedValue(report, sectionToUpdate);\n                    viewContent = nestedValue ? JSON.stringify(nestedValue, null, 2) : JSON.stringify({\n                        header: report.header,\n                        assessmentResults: {\n                            domains: report.assessmentResults.domains\n                        }\n                    }, null, 2);\n                    targetPath = sectionToUpdate;\n                    console.log(`[${requestId}] 🔍 Other section update: ${sectionToUpdate}`);\n                }\n            }\n            // Call the Anthropic API directly\n            console.log(`[${requestId}] 🔌 Making first API call to Claude...`);\n            // Create appropriate system prompt based on input type\n            const systemPrompt = `You are an expert educational speech-language pathologist that specializes in writing detailed assessment reports. \nYour task is to update a JSON report structure based on ${isPdfUpload ? 'the contents of the uploaded PDF document' : 'user input'}.\n\nREPORT STRUCTURE:\nThe report is organized into four main sections:\n1. header - Student information and referral reason\n2. background - Health history, family info, and parent concerns\n3. assessmentResults - Observations, assessment tools, and domain evaluations\n4. conclusion - Eligibility determination, summary, and recommendations\n\nINSTRUCTIONS:\n1. DO NOT use the text editor tool's str_replace command for these updates\n2. INSTEAD, use the JSON path command approach described below\n3. Format your response as a regular text message containing the JSON command\n\nJSON PATH COMMAND FORMAT:\n\\`\\`\\`json\n{\n  \"command\": \"update_key\",\n  \"path\": \"assessmentResults.domains.pragmatic.strengths\",\n  \"action\": \"append\",\n  \"value\": [\"Your observation here\"]\n}\n\\`\\`\\`\n\nWhere:\n- path: The exact JSON path to update (using the new structure paths, e.g., \"assessmentResults.domains.pragmatic.strengths\")\n- action: Use \"append\" for arrays, \"replace\" for fields, or \"merge\" for objects\n- value: The new value to insert, properly formatted as JSON\n\nFor domain sections, maintain these guidelines:\n- topicSentence: A clear statement summarizing the domain findings\n- strengths: Array of specific skills and abilities the student demonstrates\n- needs: Array of specific difficulties the student exhibits\n- impactStatement: How challenges affect educational performance\n\nDO NOT respond with a direct text answer. ALWAYS respond with a JSON command as shown above.`;\n            // Prepare the user message based on input type\n            let userMessage = '';\n            let userContent = [];\n            if (isPdfUpload) {\n                // Construct message for PDF content\n                userContent = [\n                    {\n                        type: \"text\",\n                        text: `I need to update the speech-language report based on the content in this PDF document. ${sectionToUpdate !== 'auto-detect' ? `Please focus on updating the ${sectionToUpdate} section.` : 'Please analyze the PDF and determine which section of the report to update.'}\\n\\nHere is the current report structure:\\n\\`\\`\\`json\\n${viewContent}\\n\\`\\`\\`\\n\\nFor standardized tests like GFTA, CELF, etc., identify key scores and findings, and update the appropriate domain section. Extract any relevant phonological processes, error patterns, or specific strengths/needs.\\n\\nRespond with an update_key JSON command as described in the system prompt.`\n                    },\n                    {\n                        type: \"document\",\n                        source: {\n                            type: \"base64\",\n                            media_type: \"application/pdf\",\n                            data: normalizedInput\n                        }\n                    }\n                ];\n            } else {\n                // Construct message for text content\n                userContent = [\n                    {\n                        type: \"text\",\n                        text: `I need to update the speech-language report based on this new information:\n\"${normalizedInput}\"\n\nHere is the current report structure:\n\\`\\`\\`json\n${viewContent}\n\\`\\`\\`\n\n${sectionToUpdate === 'auto-detect' ? 'Please analyze the input and determine which section of the report to update.' : `Please update the ${sectionToUpdate} section.`}\n\nDO NOT use the text editor tool. Instead, respond with an update_key JSON command.\n\nFor example, if updating pragmatic domain strengths, respond with:\n\\`\\`\\`json\n{\n  \"command\": \"update_key\",\n  \"path\": \"assessmentResults.domains.pragmatic.strengths\",\n  \"action\": \"append\",\n  \"value\": [\"Student maintains eye contact during conversations\"]\n}\n\\`\\`\\`\n\nGuidelines:\n- For strengths/needs arrays: use \"append\" and array values\n- For topic sentences: use \"replace\" and string value\n- Empty/missing fields need to be created with appropriate value types\n- Analyze which domain fits best: receptive, expressive, pragmatic, articulation, voice, fluency\n- The domains are found at the path \"assessmentResults.domains.[domainName]\"\n\nIMPORTANT: Format your entire response as a text message containing only the JSON command. DO NOT use the text editor tool.`\n                    }\n                ];\n            }\n            const firstApiPayload = {\n                model: 'claude-3-7-sonnet-20250219',\n                max_tokens: 1024,\n                system: systemPrompt,\n                tools: [\n                    {\n                        type: 'text_editor_20250124',\n                        name: 'str_replace_editor'\n                    }\n                ],\n                messages: [\n                    {\n                        role: 'user',\n                        content: userContent\n                    }\n                ]\n            };\n            console.log(`[${requestId}] 📤 First API payload prepared, user message length: ${normalizedInput.length}`);\n            const response = await fetch('https://api.anthropic.com/v1/messages', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'x-api-key': apiKey,\n                    'anthropic-version': '2023-06-01'\n                },\n                body: JSON.stringify(firstApiPayload)\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.log(`[${requestId}] ❌ First API call failed:`, errorData);\n                throw new Error(errorData.error?.message || `API error: ${response.status}`);\n            }\n            let claudeResponse = await response.json();\n            console.log(`[${requestId}] ✅ First Claude response received, content blocks:`, claudeResponse.content.map((block)=>({\n                    type: block.type,\n                    ...block.type === 'tool_use' ? {\n                        command: block.input?.command\n                    } : {}\n                })));\n            // Handle the two-way conversation flow with Claude for the text editor tool\n            let finalCommand = null;\n            // Check if Claude is using a tool\n            const toolUseBlock = claudeResponse.content.find((block)=>block.type === 'tool_use' && block.name === 'str_replace_editor');\n            // Log the tool use block\n            if (toolUseBlock) {\n                console.log(`[${requestId}] 🛠️ Claude is using tool: ${toolUseBlock.name}, command: ${toolUseBlock.input?.command}`);\n            } else {\n                console.log(`[${requestId}] ⚠️ No tool use block found in Claude's response`);\n            }\n            // If Claude is using the \"view\" command first (common with text editor)\n            if (toolUseBlock && toolUseBlock.input && toolUseBlock.input.command === 'view') {\n                console.log(`[${requestId}] 👁️ Claude is requesting to view content first. Sending content...`);\n                // Send back the content that Claude requested to view\n                console.log(`[${requestId}] 🔌 Making second API call to Claude with view result...`);\n                // Create a second API payload that's consistent with the first\n                let secondUserContent = [];\n                if (isPdfUpload) {\n                    // Construct message for PDF content with previous view result\n                    secondUserContent = [\n                        {\n                            type: \"text\",\n                            text: `I need to update the speech-language report based on the content in this PDF document. ${sectionToUpdate !== 'auto-detect' ? `Please focus on updating the ${sectionToUpdate} section.` : 'Please analyze the PDF and determine which section of the report to update.'}\\n\\nRespond with an update_key JSON command as described in the system prompt.`\n                        },\n                        {\n                            type: \"document\",\n                            source: {\n                                type: \"base64\",\n                                media_type: \"application/pdf\",\n                                data: normalizedInput\n                            }\n                        }\n                    ];\n                } else {\n                    // Construct message for text content with previous view result\n                    secondUserContent = [\n                        {\n                            type: \"text\",\n                            text: `I need to update the speech-language report based on this new information:\n\"${normalizedInput}\"\n\n${sectionToUpdate === 'auto-detect' ? 'Please analyze the input and determine which section of the report to update.' : `Please update the ${sectionToUpdate} section.`}\n\nDO NOT use the text editor tool. Instead, respond with an update_key JSON command.\n\nGuidelines:\n- For strengths/needs arrays: use \"append\" and array values\n- For topic sentences: use \"replace\" and string value\n- Empty/missing fields need to be created with appropriate value types\n- Analyze which domain fits best: receptive, expressive, pragmatic, articulation, voice, fluency\n- The domains are found at the path \"assessmentResults.domains.[domainName]\"\n\nIMPORTANT: Format your entire response as a text message containing only the JSON command. DO NOT use the text editor tool.`\n                        }\n                    ];\n                }\n                const secondApiPayload = {\n                    model: 'claude-3-7-sonnet-20250219',\n                    max_tokens: 1024,\n                    system: systemPrompt,\n                    tools: [\n                        {\n                            type: 'text_editor_20250124',\n                            name: 'str_replace_editor'\n                        }\n                    ],\n                    messages: [\n                        {\n                            role: 'user',\n                            content: secondUserContent\n                        },\n                        {\n                            role: 'assistant',\n                            content: [\n                                {\n                                    type: 'text',\n                                    text: 'I\\'ll help you update the report using the text editor tool.'\n                                },\n                                {\n                                    type: 'tool_use',\n                                    id: toolUseBlock.id,\n                                    name: 'str_replace_editor',\n                                    input: toolUseBlock.input\n                                }\n                            ]\n                        },\n                        {\n                            role: 'user',\n                            content: [\n                                {\n                                    type: 'tool_result',\n                                    tool_use_id: toolUseBlock.id,\n                                    content: viewContent\n                                }\n                            ]\n                        }\n                    ]\n                };\n                const secondResponse = await fetch('https://api.anthropic.com/v1/messages', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'x-api-key': apiKey,\n                        'anthropic-version': '2023-06-01'\n                    },\n                    body: JSON.stringify(secondApiPayload)\n                });\n                if (!secondResponse.ok) {\n                    const errorData = await secondResponse.json();\n                    console.log(`[${requestId}] ❌ Second API call failed:`, errorData);\n                    throw new Error(errorData.error?.message || `API error in second request: ${secondResponse.status}`);\n                }\n                // Get Claude's response with the actual edit\n                claudeResponse = await secondResponse.json();\n                console.log(`[${requestId}] ✅ Second Claude response received, content blocks:`, claudeResponse.content.map((block)=>({\n                        type: block.type,\n                        ...block.type === 'tool_use' ? {\n                            command: block.input?.command\n                        } : {}\n                    })));\n                // Now check for the str_replace command\n                const secondToolUseBlock = claudeResponse.content.find((block)=>block.type === 'tool_use' && block.name === 'str_replace_editor');\n                if (secondToolUseBlock) {\n                    console.log(`[${requestId}] 🛠️ Second response tool use: ${secondToolUseBlock.name}, command: ${secondToolUseBlock.input?.command}`);\n                    if (secondToolUseBlock.input && (secondToolUseBlock.input.command === 'str_replace' || secondToolUseBlock.input.command === 'insert')) {\n                        finalCommand = secondToolUseBlock.input;\n                        console.log(`[${requestId}] ✅ Got final command:`, {\n                            command: finalCommand.command,\n                            old_str: finalCommand.old_str ? `${finalCommand.old_str.substring(0, 50)}...` : undefined,\n                            new_str: finalCommand.new_str ? `${finalCommand.new_str.substring(0, 50)}...` : undefined,\n                            text: finalCommand.text ? `${finalCommand.text.substring(0, 50)}...` : undefined,\n                            position: finalCommand.position\n                        });\n                    } else {\n                        console.log(`[${requestId}] ⚠️ Second tool use block doesn't contain str_replace or insert command:`, secondToolUseBlock.input);\n                    }\n                } else {\n                    console.log(`[${requestId}] ⚠️ No tool use block found in Claude's second response`);\n                }\n            } else if (toolUseBlock && toolUseBlock.input && (toolUseBlock.input.command === 'str_replace' || toolUseBlock.input.command === 'insert')) {\n                // Claude directly used str_replace or insert (unusual but possible)\n                finalCommand = toolUseBlock.input;\n                console.log(`[${requestId}] ✅ Got final command directly from first response:`, {\n                    command: finalCommand.command,\n                    old_str: finalCommand.old_str ? `${finalCommand.old_str.substring(0, 50)}...` : undefined,\n                    new_str: finalCommand.new_str ? `${finalCommand.new_str.substring(0, 50)}...` : undefined,\n                    text: finalCommand.text ? `${finalCommand.text.substring(0, 50)}...` : undefined,\n                    position: finalCommand.position\n                });\n            } else {\n                console.log(`[${requestId}] ⚠️ No usable command found in Claude's responses`);\n            }\n            // Check if there's a JSON path update command in Claude's response text\n            let updateKeyCommand = null;\n            const textBlocks = claudeResponse.content.filter((block)=>block.type === 'text');\n            for (const block of textBlocks){\n                // Look for JSON objects in the text that might contain our command\n                const jsonMatches = block.text.match(/```json\\s*({[\\s\\S]*?})\\s*```|({[\\s\\S]*\"command\"[\\s\\S]*})/g);\n                if (jsonMatches) {\n                    for (const match of jsonMatches){\n                        try {\n                            // Extract the JSON object from markdown code blocks or plain text\n                            const jsonStr = match.replace(/```json\\s*|\\s*```/g, '').trim();\n                            const jsonObj = JSON.parse(jsonStr);\n                            // Check if this is an update_key command\n                            if (jsonObj.command === 'update_key' && jsonObj.path && jsonObj.action && jsonObj.value !== undefined) {\n                                updateKeyCommand = jsonObj;\n                                console.log(`[${requestId}] 🔑 Found update_key command in text:`, updateKeyCommand);\n                                break;\n                            }\n                        } catch (e) {\n                            console.warn(`[${requestId}] ⚠️ Failed to parse potential JSON command:`, e);\n                        }\n                    }\n                }\n                if (updateKeyCommand) break;\n            }\n            // Process the command if we have one (either update_key or text editor command)\n            if (updateKeyCommand) {\n                console.log(`[${requestId}] 🔄 Processing update_key command...`);\n                console.log(`[${requestId}] 📊 Update details: path=${updateKeyCommand.path}, action=${updateKeyCommand.action}`);\n                let updatedReport = {\n                    ...report\n                };\n                let affectedDomain = '';\n                // Extract domain if path starts with domains.X\n                if (updateKeyCommand.path.startsWith('domains.')) {\n                    const pathParts = updateKeyCommand.path.split('.');\n                    if (pathParts.length >= 2) {\n                        affectedDomain = pathParts[1];\n                        console.log(`[${requestId}] 🎯 Affected domain from path: ${affectedDomain}`);\n                    }\n                }\n                try {\n                    // Apply the update based on the path and action\n                    const pathParts = updateKeyCommand.path.split('.');\n                    let current = updatedReport;\n                    // Navigate to the parent object of the target property\n                    for(let i = 0; i < pathParts.length - 1; i++){\n                        if (!current[pathParts[i]]) {\n                            // Create missing objects in the path\n                            current[pathParts[i]] = {};\n                            console.log(`[${requestId}] 🏗️ Created missing object at ${pathParts.slice(0, i + 1).join('.')}`);\n                        }\n                        current = current[pathParts[i]];\n                    }\n                    // Get the target property name\n                    const targetProp = pathParts[pathParts.length - 1];\n                    // Apply the action\n                    switch(updateKeyCommand.action){\n                        case 'append':\n                            // For arrays, append the new values\n                            if (!current[targetProp]) {\n                                current[targetProp] = [];\n                            } else if (!Array.isArray(current[targetProp])) {\n                                // Convert to array if not already\n                                current[targetProp] = [\n                                    current[targetProp]\n                                ];\n                            }\n                            // Handle both single value and array of values\n                            if (Array.isArray(updateKeyCommand.value)) {\n                                current[targetProp] = [\n                                    ...current[targetProp],\n                                    ...updateKeyCommand.value\n                                ];\n                            } else {\n                                current[targetProp].push(updateKeyCommand.value);\n                            }\n                            console.log(`[${requestId}] ✅ Appended to ${updateKeyCommand.path}, new length: ${current[targetProp].length}`);\n                            break;\n                        case 'replace':\n                            // Replace the value entirely\n                            current[targetProp] = updateKeyCommand.value;\n                            console.log(`[${requestId}] ✅ Replaced ${updateKeyCommand.path}`);\n                            break;\n                        case 'merge':\n                            // For objects, merge properties\n                            if (!current[targetProp] || typeof current[targetProp] !== 'object' || Array.isArray(current[targetProp])) {\n                                current[targetProp] = {};\n                            }\n                            current[targetProp] = {\n                                ...current[targetProp],\n                                ...updateKeyCommand.value\n                            };\n                            console.log(`[${requestId}] ✅ Merged into ${updateKeyCommand.path}`);\n                            break;\n                        default:\n                            console.warn(`[${requestId}] ⚠️ Unknown action: ${updateKeyCommand.action}`);\n                    }\n                    // Update metadata\n                    updatedReport.metadata.lastUpdated = new Date().toISOString();\n                    updatedReport.metadata.version = (updatedReport.metadata.version || 0) + 1;\n                    console.log(`[${requestId}] ✅ Successfully applied update_key command`);\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        report: updatedReport,\n                        command: updateKeyCommand,\n                        affectedDomain\n                    });\n                } catch (error) {\n                    console.error(`[${requestId}] ❌ Error applying update_key command:`, error);\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        error: 'Failed to apply update_key command',\n                        details: error instanceof Error ? error.message : 'Unknown error',\n                        command: updateKeyCommand\n                    }, {\n                        status: 400\n                    });\n                }\n            } else if (finalCommand) {\n                console.log(`[${requestId}] 🔄 Processing ${finalCommand.command} command...`);\n                // Get Claude's analysis of which domain/section to update\n                let affectedDomain = '';\n                let updatedReport = {\n                    ...report\n                };\n                if (sectionToUpdate === 'auto-detect') {\n                    // Extract domain from Claude's response text\n                    const textContent = claudeResponse.content.filter((block)=>block.type === 'text').map((block)=>block.text).join('\\n');\n                    // Extract domain from text - look for specific patterns like \"pragmatic domain\" or \"update the pragmatic\"\n                    console.log(`[${requestId}] 🔍 Analyzing text for domain keywords...`);\n                    // List of domain keywords to search for\n                    const domainKeywords = [\n                        'receptive',\n                        'expressive',\n                        'pragmatic',\n                        'articulation',\n                        'voice',\n                        'fluency'\n                    ];\n                    let foundDomain = '';\n                    // First look for the path pattern in JSON commands\n                    const pathRegex = /\"path\":\\s*\"assessmentResults\\.domains\\.([^.\"]+)\"/;\n                    const pathMatch = textContent.match(pathRegex);\n                    if (pathMatch && pathMatch[1]) {\n                        foundDomain = pathMatch[1];\n                        console.log(`[${requestId}] 🔍 Found domain in JSON path: \"${foundDomain}\"`);\n                    } else {\n                        // Check for domain keywords in the text\n                        for (const domain of domainKeywords){\n                            const pattern = new RegExp(`\\\\b${domain}\\\\b`, 'i');\n                            if (pattern.test(textContent)) {\n                                console.log(`[${requestId}] 🔍 Found domain keyword in text: \"${domain}\"`);\n                                foundDomain = domain;\n                                break;\n                            }\n                        }\n                    }\n                    affectedDomain = foundDomain;\n                    console.log(`[${requestId}] 🔍 Auto-detected domain: ${affectedDomain || 'none detected'}`);\n                    console.log(`[${requestId}] 📝 Text content for domain detection:`, textContent);\n                } else if (sectionToUpdate.startsWith('assessmentResults.domains.')) {\n                    affectedDomain = sectionToUpdate.split('.')[2];\n                    console.log(`[${requestId}] 🎯 Using specified domain: ${affectedDomain}`);\n                }\n                if (finalCommand.command === 'str_replace') {\n                    console.log(`[${requestId}] 🔄 Processing str_replace command...`);\n                    console.log(`[${requestId}] ⚠️ Note: str_replace is being used instead of the recommended update_key command`);\n                    let updatedContent = '';\n                    try {\n                        // First, check if the str_replace command is targeting a specific domain\n                        // We need to detect this by seeing if the old_str contains specific domain JSON\n                        const strContainsDomainPattern = Object.keys(report.assessmentResults.domains).some((domain)=>{\n                            const pattern = `\"${domain}\":\\\\s*{`;\n                            const regex = new RegExp(pattern, 'i');\n                            return regex.test(finalCommand.old_str || '');\n                        });\n                        console.log(`[${requestId}] 🔍 Command contains domain pattern in old_str: ${strContainsDomainPattern}`);\n                        // If we've auto-detected a domain and it exists in the report\n                        if (affectedDomain && report.assessmentResults.domains[affectedDomain]) {\n                            console.log(`[${requestId}] 🔄 Updating specific domain: ${affectedDomain}`);\n                            // Check if Claude's str_replace is directly targeting this domain section\n                            if (finalCommand.old_str && finalCommand.old_str.includes(`\"${affectedDomain}\"`)) {\n                                console.log(`[${requestId}] 🎯 Direct match: Claude's command targets ${affectedDomain} domain`);\n                                // Implement a more careful search and replace for the specific domain\n                                // Start with the full report JSON\n                                const fullReportJson = JSON.stringify(report, null, 2);\n                                // Find the domain section in the JSON\n                                const domainPattern = new RegExp(`(\\\\s*\"${affectedDomain}\"\\\\s*:\\\\s*{[^}]*})`, 's');\n                                const domainMatch = fullReportJson.match(domainPattern);\n                                if (domainMatch) {\n                                    console.log(`[${requestId}] ✅ Found domain section in JSON`);\n                                    // Replace just the domain section\n                                    updatedContent = fullReportJson.replace(domainMatch[0], finalCommand.new_str.trim());\n                                    try {\n                                        // Parse the complete updated report\n                                        updatedReport = JSON.parse(updatedContent);\n                                        console.log(`[${requestId}] ✅ Successfully replaced domain section in full report`);\n                                    } catch (parseError) {\n                                        console.error(`[${requestId}] ❌ JSON parse error after domain replacement:`, parseError);\n                                        // Fallback to updating just the domain section\n                                        const domainSection = JSON.parse(JSON.stringify(report.assessmentResults.domains[affectedDomain]));\n                                        const domainJson = JSON.stringify(domainSection, null, 2);\n                                        try {\n                                            // Try to extract just the domain object from Claude's new_str\n                                            const domainObjectMatch = finalCommand.new_str.match(/{\\s*\"topicSentence\".*}/s);\n                                            if (domainObjectMatch) {\n                                                const newDomainSection = JSON.parse(domainObjectMatch[0]);\n                                                updatedReport = updateDomainSection(report, affectedDomain, newDomainSection);\n                                                console.log(`[${requestId}] ✅ Fallback: Updated domain section via extraction`);\n                                            } else {\n                                                throw new Error('Could not extract domain object from new_str');\n                                            }\n                                        } catch (extractError) {\n                                            console.error(`[${requestId}] ❌ Failed to extract domain object:`, extractError);\n                                            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                                                error: 'Failed to update report - invalid JSON format',\n                                                details: {\n                                                    originalError: parseError.message,\n                                                    extractError: extractError.message\n                                                }\n                                            }, {\n                                                status: 400\n                                            });\n                                        }\n                                    }\n                                } else {\n                                    console.error(`[${requestId}] ❌ Could not find domain section in JSON`);\n                                    // Fallback to updating via domain object\n                                    const domainSection = JSON.parse(JSON.stringify(report.assessmentResults.domains[affectedDomain]));\n                                    console.log(`[${requestId}] 📊 Original domain section:`, domainSection);\n                                    // Manually construct an updated domain section based on the content\n                                    const extractedContent = {};\n                                    // Try to extract topic sentence\n                                    const tsMatch = finalCommand.new_str.match(/\"topicSentence\":\\s*\"([^\"]*)\"/);\n                                    if (tsMatch) extractedContent['topicSentence'] = tsMatch[1];\n                                    // Try to extract evidence (simplified)\n                                    const evidenceMatch = finalCommand.new_str.match(/\"evidence\":\\s*\\[(.*?)\\]/s);\n                                    if (evidenceMatch) {\n                                        try {\n                                            extractedContent['evidence'] = JSON.parse(`[${evidenceMatch[1]}]`);\n                                        } catch (e) {\n                                            console.warn(`[${requestId}] ⚠️ Could not parse evidence`, e);\n                                        }\n                                    }\n                                    // Try to extract challenges (simplified)\n                                    const challengesMatch = finalCommand.new_str.match(/\"challenges\":\\s*\\[(.*?)\\]/s);\n                                    if (challengesMatch) {\n                                        try {\n                                            extractedContent['challenges'] = JSON.parse(`[${challengesMatch[1]}]`);\n                                        } catch (e) {\n                                            console.warn(`[${requestId}] ⚠️ Could not parse challenges`, e);\n                                        }\n                                    }\n                                    // Update the domain with the extracted content\n                                    updatedReport = updateDomainSection(report, affectedDomain, extractedContent);\n                                    console.log(`[${requestId}] ✅ Used extraction to update domain section`);\n                                }\n                            } else {\n                                // Standard domain section update\n                                const domainSection = JSON.parse(JSON.stringify(report.assessmentResults.domains[affectedDomain]));\n                                console.log(`[${requestId}] 📊 Original domain section:`, domainSection);\n                                console.log(`[${requestId}] 🔄 Applying str_replace:`, {\n                                    old_str_length: finalCommand.old_str?.length || 0,\n                                    new_str_length: finalCommand.new_str?.length || 0\n                                });\n                                // Instead of a general replace, we'll try to improve the domain directly\n                                if (finalCommand.new_str && finalCommand.new_str.includes('\"topicSentence\"')) {\n                                    // Try to extract JSON structure from the new string\n                                    const jsonMatch = finalCommand.new_str.match(/({[\\s\\S]*})/);\n                                    if (jsonMatch) {\n                                        try {\n                                            // Parse the JSON from the new string\n                                            const updatedDomainSection = JSON.parse(jsonMatch[1]);\n                                            // Update the specific domain in the report\n                                            updatedReport = updateDomainSection(report, affectedDomain, updatedDomainSection);\n                                            console.log(`[${requestId}] ✅ Successfully extracted and updated domain JSON`);\n                                        } catch (jsonError) {\n                                            console.error(`[${requestId}] ❌ Error parsing extracted JSON:`, jsonError);\n                                            // Fallback to standard replacement\n                                            updatedContent = JSON.stringify(domainSection).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                            const updatedDomainSection = JSON.parse(updatedContent);\n                                            updatedReport = updateDomainSection(report, affectedDomain, updatedDomainSection);\n                                        }\n                                    } else {\n                                        // No JSON structure found, use standard replacement\n                                        updatedContent = JSON.stringify(domainSection).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                        const updatedDomainSection = JSON.parse(updatedContent);\n                                        updatedReport = updateDomainSection(report, affectedDomain, updatedDomainSection);\n                                    }\n                                } else {\n                                    // Standard replacement\n                                    updatedContent = JSON.stringify(domainSection).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                    const updatedDomainSection = JSON.parse(updatedContent);\n                                    updatedReport = updateDomainSection(report, affectedDomain, updatedDomainSection);\n                                }\n                                console.log(`[${requestId}] ✅ Domain section updated successfully`);\n                            }\n                        } else if (strContainsDomainPattern) {\n                            // We detected a domain pattern in the str_replace command, so try to extract the domain name\n                            console.log(`[${requestId}] 🔎 Trying to extract domain from str_replace command...`);\n                            let extractedDomain = '';\n                            for (const domain of Object.keys(report.assessmentResults.domains)){\n                                if (finalCommand.old_str?.includes(`\"${domain}\"`)) {\n                                    extractedDomain = domain;\n                                    break;\n                                }\n                            }\n                            if (extractedDomain) {\n                                console.log(`[${requestId}] 🔍 Extracted domain from command: ${extractedDomain}`);\n                                affectedDomain = extractedDomain;\n                                // Now update using the full report update, then re-process with the correct domain\n                                updatedContent = JSON.stringify(report, null, 2).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                try {\n                                    updatedReport = JSON.parse(updatedContent);\n                                    console.log(`[${requestId}] ✅ Updated report with extracted domain: ${extractedDomain}`);\n                                } catch (parseError) {\n                                    console.error(`[${requestId}] ❌ Parse error with extracted domain update:`, parseError);\n                                    // Fallback to just updating the domain section\n                                    const domainSection = JSON.parse(JSON.stringify(report.assessmentResults.domains[extractedDomain]));\n                                    const updatedDomainSection = {\n                                        ...domainSection,\n                                        topicSentence: finalCommand.new_str.match(/\"topicSentence\":\\s*\"([^\"]*)\"/)?.[1] || domainSection.topicSentence,\n                                        evidence: [\n                                            ...domainSection.evidence || [],\n                                            normalizedInput\n                                        ]\n                                    };\n                                    updatedReport = updateDomainSection(report, extractedDomain, updatedDomainSection);\n                                }\n                            } else {\n                                // Fall back to full report update\n                                console.log(`[${requestId}] 🔄 Updating entire report (domain pattern found but couldn't extract domain)`);\n                                updatedContent = JSON.stringify(report, null, 2).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                updatedReport = JSON.parse(updatedContent);\n                            }\n                        } else {\n                            // For whole report updates or other sections\n                            if (sectionToUpdate === 'auto-detect') {\n                                console.log(`[${requestId}] 🔄 Updating entire report (no specific domain identified)`);\n                                // Full report update\n                                updatedContent = JSON.stringify(report, null, 2).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                updatedReport = JSON.parse(updatedContent);\n                                console.log(`[${requestId}] ✅ Full report updated successfully`);\n                            } else {\n                                console.log(`[${requestId}] 🔄 Updating specific non-domain section: ${sectionToUpdate}`);\n                                // Specific non-domain section update\n                                updatedContent = viewContent.replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                // This is simplified; you'd need to merge this into the right section\n                                // based on the sectionToUpdate path\n                                try {\n                                    updatedReport = {\n                                        ...report\n                                    };\n                                    // Simple path-based setter (would need a more robust version in production)\n                                    const pathParts = sectionToUpdate.split('.');\n                                    let current = updatedReport;\n                                    for(let i = 0; i < pathParts.length - 1; i++){\n                                        current = current[pathParts[i]];\n                                    }\n                                    current[pathParts[pathParts.length - 1]] = JSON.parse(updatedContent);\n                                    console.log(`[${requestId}] ✅ Specific section updated successfully: ${sectionToUpdate}`);\n                                } catch (e) {\n                                    console.error(`[${requestId}] ❌ Error updating specific path:`, e);\n                                }\n                            }\n                        }\n                    } catch (parseError) {\n                        console.error(`[${requestId}] ❌ Error parsing updated JSON:`, parseError);\n                        console.log(`[${requestId}] 📋 Problem content:`, updatedContent);\n                        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                            error: 'Invalid JSON produced by text editor command',\n                            originalCommand: finalCommand,\n                            parseError: parseError.message\n                        }, {\n                            status: 400\n                        });\n                    }\n                    // Update metadata\n                    const originalTimestamp = updatedReport.metadata.lastUpdated;\n                    updatedReport.metadata.lastUpdated = new Date().toISOString();\n                    updatedReport.metadata.version = (updatedReport.metadata.version || 0) + 1;\n                    console.log(`[${requestId}] 📊 Metadata updated:`, {\n                        oldTimestamp: originalTimestamp,\n                        newTimestamp: updatedReport.metadata.lastUpdated,\n                        newVersion: updatedReport.metadata.version\n                    });\n                    console.log(`[${requestId}] ✅ Report update complete, returning response`);\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        report: updatedReport,\n                        command: finalCommand,\n                        affectedDomain\n                    });\n                } else if (finalCommand.command === 'insert') {\n                    console.log(`[${requestId}] ⚠️ Insert command not fully implemented`);\n                    // Handle insert command - this would be more complex and depends on your specific needs\n                    // For simplicity in this demo, we'll just acknowledge it\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        report,\n                        error: 'Insert command not fully implemented yet',\n                        command: finalCommand\n                    });\n                }\n            }\n            // If no tool command found, return the original report\n            console.log(`[${requestId}] ⚠️ No tool command found in Claude's response, returning original report`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                report,\n                error: 'Claude did not provide a JSON update command'\n            });\n        } catch (apiError) {\n            console.error(`[${requestId}] ❌ Error calling Claude API:`, apiError);\n            // Fallback for testing without API\n            console.log(`[${requestId}] ⚠️ Using fallback mode for testing`);\n            const updatedReport = {\n                ...report\n            };\n            // Simple domain detection based on keywords\n            const inputLower = input.toLowerCase();\n            let targetDomain = 'articulation';\n            if (inputLower.includes('understand') || inputLower.includes('follow') || inputLower.includes('direction')) {\n                targetDomain = 'receptive';\n            } else if (inputLower.includes('express') || inputLower.includes('vocabulary') || inputLower.includes('sentence')) {\n                targetDomain = 'expressive';\n            } else if (inputLower.includes('social') || inputLower.includes('eye contact') || inputLower.includes('peer')) {\n                targetDomain = 'pragmatic';\n            } else if (inputLower.includes('sound') || inputLower.includes('pronounce') || inputLower.includes('intelligible')) {\n                targetDomain = 'articulation';\n            }\n            console.log(`[${requestId}] 🔍 Fallback detected domain: ${targetDomain}`);\n            // Create a simulated update\n            const updates = {\n                strengths: [\n                    input\n                ]\n            };\n            if (!updatedReport.assessmentResults.domains[targetDomain].topicSentence) {\n                updates.topicSentence = `Student demonstrates challenges in ${targetDomain} language skills.`;\n            }\n            const simulatedReport = updateDomainSection(updatedReport, targetDomain, updates);\n            console.log(`[${requestId}] ✅ Simulated update applied to domain: ${targetDomain}`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                report: simulatedReport,\n                apiError: apiError instanceof Error ? apiError.message : 'API call failed',\n                simulated: true,\n                affectedDomain: targetDomain\n            });\n        }\n    } catch (error) {\n        console.error(`[${requestId}] ❌ Error processing text editor request:`, error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: 'Failed to process the request',\n            details: error instanceof Error ? error.message : 'Unknown error'\n        }, {\n            status: 500\n        });\n    } finally{\n        console.log(`[${requestId}] 🏁 REQUEST COMPLETED: Text Editor API`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS90ZXh0LWVkaXRvci10ZXN0L3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdEO0FBaUh4RDs7O0NBR0MsR0FDRCxlQUFlQyxlQUFlQyxLQUFVO0lBQ3RDLGlDQUFpQztJQUNqQyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUM3QixPQUFPQTtJQUNULE9BQU8sSUFBSUEsTUFBTUMsSUFBSSxFQUFFO1FBQ3JCLE9BQU9ELE1BQU1DLElBQUk7SUFDbkIsT0FBTyxJQUFJRCxNQUFNRSxPQUFPLEVBQUU7UUFDeEIsbUZBQW1GO1FBQ25GLE9BQU9GLE1BQU1FLE9BQU87SUFDdEI7SUFDQSxPQUFPQyxLQUFLQyxTQUFTLENBQUNKO0FBQ3hCO0FBRUE7O0NBRUMsR0FDRCxTQUFTSztJQUNQLE9BQU87UUFDTEMsUUFBUTtZQUNOQyxvQkFBb0I7Z0JBQ2xCQyxXQUFXO2dCQUNYQyxVQUFVO2dCQUNWQyxLQUFLO2dCQUNMQyxZQUFZO2dCQUNaQyxnQkFBZ0I7Z0JBQ2hCQyxTQUFTLEVBQUU7Z0JBQ1hDLGNBQWM7WUFDaEI7WUFDQUMsbUJBQW1CO1lBQ25CQywwQkFBMEI7UUFDNUI7UUFDQUMsWUFBWTtZQUNWQyxrQ0FBa0M7Z0JBQ2hDQyxvQkFBb0I7WUFDdEI7WUFDQUMsY0FBYztnQkFDWkMsZ0JBQWdCO2dCQUNoQkMsMkJBQTJCO2dCQUMzQkMseUJBQXlCO1lBQzNCO1lBQ0FDLDBCQUEwQjtZQUMxQkMsZUFBZTtnQkFDYkMsaUJBQWlCO2dCQUNqQkMsK0JBQStCO2dCQUMvQkMsc0JBQXNCO1lBQ3hCO1lBQ0FDLHdCQUF3QjtRQUMxQjtRQUNBQyxtQkFBbUI7WUFDakJDLGNBQWM7Z0JBQ1pDLHVCQUF1QjtnQkFDdkJDLCtCQUErQjtnQkFDL0JDLCtCQUErQjtZQUNqQztZQUNBQyw4QkFBOEI7Z0JBQzVCQyw2QkFBNkI7Z0JBQzdCQyxxQkFBcUIsRUFBRSxDQUFDLDBCQUEwQjtZQUNwRDtZQUNBQyxTQUFTO2dCQUNQQyxXQUFXO29CQUNU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QUFFUCxVQUFVLCtCQUErQixFQUFFdUosY0FBYztZQUV6RSw0QkFBNEI7WUFDNUIsTUFBTTdKLFVBQWtDO2dCQUN0QzdCLFdBQVc7b0JBQUMxQztpQkFBTTtZQUNwQjtZQUVBLElBQUksQ0FBQ3dFLGNBQWMxQyxpQkFBaUIsQ0FBQ1EsT0FBTyxDQUFDOEwsYUFBYSxDQUFDM0wsYUFBYSxFQUFFO2dCQUN4RThCLFFBQVE5QixhQUFhLEdBQUcsQ0FBQyxtQ0FBbUMsRUFBRTJMLGFBQWEsaUJBQWlCLENBQUM7WUFDL0Y7WUFFQSxNQUFNQyxrQkFBa0JqSyxvQkFBb0JJLGVBQWU0SixjQUFjN0o7WUFDekVZLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRVAsVUFBVSx3Q0FBd0MsRUFBRXVKLGNBQWM7WUFFbEYsT0FBT3RPLHFEQUFZQSxDQUFDeUYsSUFBSSxDQUFDO2dCQUN2QmxCLFFBQVFnSztnQkFDUkosVUFBVUEsb0JBQW9CbEYsUUFBUWtGLFNBQVNqRixPQUFPLEdBQUc7Z0JBQ3pEc0YsV0FBVztnQkFDWHZELGdCQUFnQnFEO1lBQ2xCO1FBQ0Y7SUFDRixFQUFFLE9BQU92SSxPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRWhCLFVBQVUseUNBQXlDLENBQUMsRUFBRWdCO1FBQ3hFLE9BQU8vRixxREFBWUEsQ0FBQ3lGLElBQUksQ0FDdEI7WUFBRU0sT0FBTztZQUFpQzRGLFNBQVM1RixpQkFBaUJrRCxRQUFRbEQsTUFBTW1ELE9BQU8sR0FBRztRQUFnQixHQUM1RztZQUFFbEQsUUFBUTtRQUFJO0lBRWxCLFNBQVU7UUFDUlgsUUFBUUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFUCxVQUFVLHVDQUF1QyxDQUFDO0lBQ3BFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvc3JjL2FwcC9hcGkvdGV4dC1lZGl0b3ItdGVzdC9yb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgQXNzZXNzbWVudFRvb2wsIGdldEFzc2Vzc21lbnRUb29sQnlJZCB9IGZyb20gJ0AvbGliL2Fzc2Vzc21lbnQtdG9vbHMnO1xuXG4vLyBEZWZpbmUgZG9tYWluIHNlY3Rpb24gc3RydWN0dXJlXG5pbnRlcmZhY2UgRG9tYWluU2VjdGlvbiB7XG4gIGlzQ29uY2VybjogYm9vbGVhbjtcbiAgdG9waWNTZW50ZW5jZTogc3RyaW5nO1xuICBzdHJlbmd0aHM6IHN0cmluZ1tdO1xuICBuZWVkczogc3RyaW5nW107XG4gIGltcGFjdFN0YXRlbWVudDogc3RyaW5nO1xuICBsYXN0VXBkYXRlZD86IHN0cmluZztcbn1cblxuLy8gRGVmaW5lIHNlY3Rpb25zIG9mIHRoZSBzcGVlY2gtbGFuZ3VhZ2UgcmVwb3J0XG5pbnRlcmZhY2UgUmVwb3J0SGVhZGVyIHtcbiAgc3R1ZGVudEluZm9ybWF0aW9uOiB7XG4gICAgZmlyc3ROYW1lOiBzdHJpbmc7XG4gICAgbGFzdE5hbWU6IHN0cmluZztcbiAgICBET0I6IHN0cmluZztcbiAgICByZXBvcnREYXRlOiBzdHJpbmc7XG4gICAgZXZhbHVhdGlvbkRhdGU6IHN0cmluZztcbiAgICBwYXJlbnRzOiBzdHJpbmdbXTtcbiAgICBob21lTGFuZ3VhZ2U6IHN0cmluZztcbiAgfTtcbiAgcmVhc29uRm9yUmVmZXJyYWw6IHN0cmluZztcbiAgY29uZmlkZW50aWFsaXR5U3RhdGVtZW50OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZXBvcnRCYWNrZ3JvdW5kIHtcbiAgc3R1ZGVudERlbW9ncmFwaGljc0FuZEJhY2tncm91bmQ6IHtcbiAgICBlZHVjYXRpb25hbEhpc3Rvcnk6IHN0cmluZztcbiAgfTtcbiAgaGVhbHRoUmVwb3J0OiB7XG4gICAgbWVkaWNhbEhpc3Rvcnk6IHN0cmluZztcbiAgICB2aXNpb25BbmRIZWFyaW5nU2NyZWVuaW5nOiBzdHJpbmc7XG4gICAgbWVkaWNhdGlvbnNBbmRBbGxlcmdpZXM6IHN0cmluZztcbiAgfTtcbiAgZWFybHlJbnRlcnZlbnRpb25IaXN0b3J5OiBzdHJpbmc7XG4gIGZhbWlseUhpc3Rvcnk6IHtcbiAgICBmYW1pbHlTdHJ1Y3R1cmU6IHN0cmluZztcbiAgICBsYW5ndWFnZUFuZEN1bHR1cmFsQmFja2dyb3VuZDogc3RyaW5nO1xuICAgIHNvY2lvZWNvbm9taWNGYWN0b3JzOiBzdHJpbmc7XG4gIH07XG4gIHBhcmVudEd1YXJkaWFuQ29uY2VybnM6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlcG9ydEFzc2Vzc21lbnRSZXN1bHRzIHtcbiAgb2JzZXJ2YXRpb25zOiB7XG4gICAgY2xhc3Nyb29tT2JzZXJ2YXRpb25zPzogc3RyaW5nO1xuICAgIHBsYXlCYXNlZEluZm9ybWFsT2JzZXJ2YXRpb25zPzogc3RyaW5nO1xuICAgIHNvY2lhbEludGVyYWN0aW9uT2JzZXJ2YXRpb25zPzogc3RyaW5nO1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgYXNzZXNzbWVudFByb2NlZHVyZXNBbmRUb29sczoge1xuICAgIG92ZXJ2aWV3T2ZBc3Nlc3NtZW50TWV0aG9kczogc3RyaW5nO1xuICAgIGFzc2Vzc21lbnRUb29sc1VzZWQ6IHN0cmluZ1tdOyAvLyBTdG9yZSBvbmx5IHRoZSBJRHMgb2YgYXNzZXNzbWVudCB0b29sc1xuICB9O1xuICBkb21haW5zOiB7XG4gICAgcmVjZXB0aXZlOiBEb21haW5TZWN0aW9uO1xuICAgIGV4cHJlc3NpdmU6IERvbWFpblNlY3Rpb247XG4gICAgcHJhZ21hdGljOiBEb21haW5TZWN0aW9uO1xuICAgIGFydGljdWxhdGlvbjogRG9tYWluU2VjdGlvbjtcbiAgICB2b2ljZTogRG9tYWluU2VjdGlvbjtcbiAgICBmbHVlbmN5OiBEb21haW5TZWN0aW9uO1xuICAgIFtrZXk6IHN0cmluZ106IERvbWFpblNlY3Rpb247XG4gIH07XG59XG5cbmludGVyZmFjZSBSZXBvcnRDb25jbHVzaW9uIHtcbiAgZWxpZ2liaWxpdHk6IHtcbiAgICBkb21haW5zOiB7XG4gICAgICByZWNlcHRpdmU6IGJvb2xlYW47XG4gICAgICBleHByZXNzaXZlOiBib29sZWFuO1xuICAgICAgcHJhZ21hdGljOiBib29sZWFuO1xuICAgICAgYXJ0aWN1bGF0aW9uOiBib29sZWFuO1xuICAgICAgdm9pY2U6IGJvb2xlYW47XG4gICAgICBmbHVlbmN5OiBib29sZWFuO1xuICAgICAgW2tleTogc3RyaW5nXTogYm9vbGVhbjtcbiAgICB9O1xuICAgIGNhbGlmb3JuaWFFZENvZGU6IHN0cmluZztcbiAgfTtcbiAgY29uY2x1c2lvbjoge1xuICAgIHN1bW1hcnk6IHN0cmluZztcbiAgfTtcbiAgcmVjb21tZW5kYXRpb25zOiB7XG4gICAgc2VydmljZXM6IHtcbiAgICAgIHR5cGVPZlNlcnZpY2U6IHN0cmluZztcbiAgICAgIGZyZXF1ZW5jeTogc3RyaW5nO1xuICAgICAgc2V0dGluZzogc3RyaW5nO1xuICAgIH07XG4gICAgYWNjb21tb2RhdGlvbnM6IHN0cmluZ1tdO1xuICAgIGZhY2lsaXRhdGlvblN0cmF0ZWdpZXM6IHN0cmluZ1tdO1xuICB9O1xuICBwYXJlbnRGcmllbmRseUdsb3NzYXJ5Pzoge1xuICAgIHRlcm1zOiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbn1cblxuLy8gVGhlIHRvcC1sZXZlbCByZXBvcnQgY29tYmluaW5nIGFsbCBzZWN0aW9uc1xuaW50ZXJmYWNlIFNwZWVjaExhbmd1YWdlUmVwb3J0IHtcbiAgaGVhZGVyOiBSZXBvcnRIZWFkZXI7XG4gIGJhY2tncm91bmQ6IFJlcG9ydEJhY2tncm91bmQ7XG4gIGFzc2Vzc21lbnRSZXN1bHRzOiBSZXBvcnRBc3Nlc3NtZW50UmVzdWx0cztcbiAgY29uY2x1c2lvbjogUmVwb3J0Q29uY2x1c2lvbjtcbiAgbWV0YWRhdGE6IHtcbiAgICBsYXN0VXBkYXRlZDogc3RyaW5nO1xuICAgIHZlcnNpb246IG51bWJlcjtcbiAgICBjcmVhdGVkQnk/OiBzdHJpbmc7XG4gIH07XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGlucHV0IGRhdGEgZnJvbSB2YXJpb3VzIHNvdXJjZXMgKHRleHQsIFBERiwgYXVkaW8pXG4gKiBAcGFyYW0gaW5wdXQgLSBJbnB1dCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xuICovXG5hc3luYyBmdW5jdGlvbiBub3JtYWxpemVJbnB1dChpbnB1dDogYW55KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgLy8gSGFuZGxlIGRpZmZlcmVudCBpbnB1dCBmb3JtYXRzXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2UgaWYgKGlucHV0LnRleHQpIHtcbiAgICByZXR1cm4gaW5wdXQudGV4dDtcbiAgfSBlbHNlIGlmIChpbnB1dC5wZGZEYXRhKSB7XG4gICAgLy8gUmV0dXJuIHRoZSBiYXNlNjQgUERGIGRhdGEgLSBDbGF1ZGUgd2lsbCBwcm9jZXNzIGl0IHdpdGggaXRzIGRvY3VtZW50IGNhcGFiaWxpdHlcbiAgICByZXR1cm4gaW5wdXQucGRmRGF0YTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlZmF1bHQgcmVwb3J0IHNrZWxldG9uIGlmIG5vbmUgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlcG9ydFNrZWxldG9uKCk6IFNwZWVjaExhbmd1YWdlUmVwb3J0IHtcbiAgcmV0dXJuIHtcbiAgICBoZWFkZXI6IHtcbiAgICAgIHN0dWRlbnRJbmZvcm1hdGlvbjoge1xuICAgICAgICBmaXJzdE5hbWU6IFwiXCIsXG4gICAgICAgIGxhc3ROYW1lOiBcIlwiLFxuICAgICAgICBET0I6IFwiXCIsXG4gICAgICAgIHJlcG9ydERhdGU6IFwiXCIsXG4gICAgICAgIGV2YWx1YXRpb25EYXRlOiBcIlwiLFxuICAgICAgICBwYXJlbnRzOiBbXSxcbiAgICAgICAgaG9tZUxhbmd1YWdlOiBcIlwiXG4gICAgICB9LFxuICAgICAgcmVhc29uRm9yUmVmZXJyYWw6IFwiXCIsXG4gICAgICBjb25maWRlbnRpYWxpdHlTdGF0ZW1lbnQ6IFwiXCJcbiAgICB9LFxuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIHN0dWRlbnREZW1vZ3JhcGhpY3NBbmRCYWNrZ3JvdW5kOiB7XG4gICAgICAgIGVkdWNhdGlvbmFsSGlzdG9yeTogXCJcIlxuICAgICAgfSxcbiAgICAgIGhlYWx0aFJlcG9ydDoge1xuICAgICAgICBtZWRpY2FsSGlzdG9yeTogXCJcIixcbiAgICAgICAgdmlzaW9uQW5kSGVhcmluZ1NjcmVlbmluZzogXCJcIixcbiAgICAgICAgbWVkaWNhdGlvbnNBbmRBbGxlcmdpZXM6IFwiXCJcbiAgICAgIH0sXG4gICAgICBlYXJseUludGVydmVudGlvbkhpc3Rvcnk6IFwiXCIsXG4gICAgICBmYW1pbHlIaXN0b3J5OiB7XG4gICAgICAgIGZhbWlseVN0cnVjdHVyZTogXCJcIixcbiAgICAgICAgbGFuZ3VhZ2VBbmRDdWx0dXJhbEJhY2tncm91bmQ6IFwiXCIsXG4gICAgICAgIHNvY2lvZWNvbm9taWNGYWN0b3JzOiBcIlwiXG4gICAgICB9LFxuICAgICAgcGFyZW50R3VhcmRpYW5Db25jZXJuczogXCJcIlxuICAgIH0sXG4gICAgYXNzZXNzbWVudFJlc3VsdHM6IHtcbiAgICAgIG9ic2VydmF0aW9uczoge1xuICAgICAgICBjbGFzc3Jvb21PYnNlcnZhdGlvbnM6IFwiXCIsXG4gICAgICAgIHBsYXlCYXNlZEluZm9ybWFsT2JzZXJ2YXRpb25zOiBcIlwiLFxuICAgICAgICBzb2NpYWxJbnRlcmFjdGlvbk9ic2VydmF0aW9uczogXCJcIlxuICAgICAgfSxcbiAgICAgIGFzc2Vzc21lbnRQcm9jZWR1cmVzQW5kVG9vbHM6IHtcbiAgICAgICAgb3ZlcnZpZXdPZkFzc2Vzc21lbnRNZXRob2RzOiBcIlwiLFxuICAgICAgICBhc3Nlc3NtZW50VG9vbHNVc2VkOiBbXSAvLyBJRHMgb2YgYXNzZXNzbWVudCB0b29sc1xuICAgICAgfSxcbiAgICAgIGRvbWFpbnM6IHtcbiAgICAgICAgcmVjZXB0aXZlOiB7XG4gICAgICAgICAgaXNDb25jZXJuOiBmYWxzZSxcbiAgICAgICAgICB0b3BpY1NlbnRlbmNlOiBcIlwiLFxuICAgICAgICAgIHN0cmVuZ3RoczogW10sXG4gICAgICAgICAgbmVlZHM6IFtdLFxuICAgICAgICAgIGltcGFjdFN0YXRlbWVudDogXCJcIlxuICAgICAgICB9LFxuICAgICAgICBleHByZXNzaXZlOiB7XG4gICAgICAgICAgaXNDb25jZXJuOiBmYWxzZSxcbiAgICAgICAgICB0b3BpY1NlbnRlbmNlOiBcIlwiLFxuICAgICAgICAgIHN0cmVuZ3RoczogW10sXG4gICAgICAgICAgbmVlZHM6IFtdLFxuICAgICAgICAgIGltcGFjdFN0YXRlbWVudDogXCJcIlxuICAgICAgICB9LFxuICAgICAgICBwcmFnbWF0aWM6IHtcbiAgICAgICAgICBpc0NvbmNlcm46IGZhbHNlLFxuICAgICAgICAgIHRvcGljU2VudGVuY2U6IFwiXCIsXG4gICAgICAgICAgc3RyZW5ndGhzOiBbXSxcbiAgICAgICAgICBuZWVkczogW10sXG4gICAgICAgICAgaW1wYWN0U3RhdGVtZW50OiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIGFydGljdWxhdGlvbjoge1xuICAgICAgICAgIGlzQ29uY2VybjogZmFsc2UsXG4gICAgICAgICAgdG9waWNTZW50ZW5jZTogXCJcIixcbiAgICAgICAgICBzdHJlbmd0aHM6IFtdLFxuICAgICAgICAgIG5lZWRzOiBbXSxcbiAgICAgICAgICBpbXBhY3RTdGF0ZW1lbnQ6IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgdm9pY2U6IHtcbiAgICAgICAgICBpc0NvbmNlcm46IGZhbHNlLFxuICAgICAgICAgIHRvcGljU2VudGVuY2U6IFwiXCIsXG4gICAgICAgICAgc3RyZW5ndGhzOiBbXSxcbiAgICAgICAgICBuZWVkczogW10sXG4gICAgICAgICAgaW1wYWN0U3RhdGVtZW50OiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIGZsdWVuY3k6IHtcbiAgICAgICAgICBpc0NvbmNlcm46IGZhbHNlLFxuICAgICAgICAgIHRvcGljU2VudGVuY2U6IFwiXCIsXG4gICAgICAgICAgc3RyZW5ndGhzOiBbXSxcbiAgICAgICAgICBuZWVkczogW10sXG4gICAgICAgICAgaW1wYWN0U3RhdGVtZW50OiBcIlwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbmNsdXNpb246IHtcbiAgICAgIGVsaWdpYmlsaXR5OiB7XG4gICAgICAgIGRvbWFpbnM6IHtcbiAgICAgICAgICByZWNlcHRpdmU6IGZhbHNlLFxuICAgICAgICAgIGV4cHJlc3NpdmU6IGZhbHNlLFxuICAgICAgICAgIHByYWdtYXRpYzogZmFsc2UsXG4gICAgICAgICAgYXJ0aWN1bGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICB2b2ljZTogZmFsc2UsXG4gICAgICAgICAgZmx1ZW5jeTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgY2FsaWZvcm5pYUVkQ29kZTogXCJcIlxuICAgICAgfSxcbiAgICAgIGNvbmNsdXNpb246IHtcbiAgICAgICAgc3VtbWFyeTogXCJcIlxuICAgICAgfSxcbiAgICAgIHJlY29tbWVuZGF0aW9uczoge1xuICAgICAgICBzZXJ2aWNlczoge1xuICAgICAgICAgIHR5cGVPZlNlcnZpY2U6IFwiXCIsXG4gICAgICAgICAgZnJlcXVlbmN5OiBcIlwiLFxuICAgICAgICAgIHNldHRpbmc6IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgYWNjb21tb2RhdGlvbnM6IFtdLFxuICAgICAgICBmYWNpbGl0YXRpb25TdHJhdGVnaWVzOiBbXVxuICAgICAgfSxcbiAgICAgIHBhcmVudEZyaWVuZGx5R2xvc3Nhcnk6IHtcbiAgICAgICAgdGVybXM6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRhZGF0YToge1xuICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVXBkYXRlIGEgc3BlY2lmaWMgZG9tYWluIHNlY3Rpb24gd2l0aCBuZXcgZGF0YVxuICovXG5mdW5jdGlvbiB1cGRhdGVEb21haW5TZWN0aW9uKFxuICByZXBvcnQ6IFNwZWVjaExhbmd1YWdlUmVwb3J0LFxuICBkb21haW46IHN0cmluZyxcbiAgdXBkYXRlczogUGFydGlhbDxEb21haW5TZWN0aW9uPlxuKTogU3BlZWNoTGFuZ3VhZ2VSZXBvcnQge1xuICBjb25zdCB1cGRhdGVkUmVwb3J0ID0geyAuLi5yZXBvcnQgfTtcbiAgXG4gIC8vIEluaXRpYWxpemUgZG9tYWluIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgaWYgKCF1cGRhdGVkUmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXSkge1xuICAgIHVwZGF0ZWRSZXBvcnQuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWluc1tkb21haW5dID0ge1xuICAgICAgaXNDb25jZXJuOiBmYWxzZSxcbiAgICAgIHRvcGljU2VudGVuY2U6ICcnLFxuICAgICAgc3RyZW5ndGhzOiBbXSxcbiAgICAgIG5lZWRzOiBbXSxcbiAgICAgIGltcGFjdFN0YXRlbWVudDogJydcbiAgICB9O1xuICB9XG4gIFxuICAvLyBVcGRhdGUgc3BlY2lmaWMgZmllbGRzXG4gIGlmICh1cGRhdGVzLmlzQ29uY2VybiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXBkYXRlZFJlcG9ydC5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zW2RvbWFpbl0uaXNDb25jZXJuID0gdXBkYXRlcy5pc0NvbmNlcm47XG4gIH1cbiAgXG4gIGlmICh1cGRhdGVzLnRvcGljU2VudGVuY2UpIHtcbiAgICB1cGRhdGVkUmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS50b3BpY1NlbnRlbmNlID0gdXBkYXRlcy50b3BpY1NlbnRlbmNlO1xuICB9XG4gIFxuICBpZiAodXBkYXRlcy5zdHJlbmd0aHMgJiYgdXBkYXRlcy5zdHJlbmd0aHMubGVuZ3RoID4gMCkge1xuICAgIHVwZGF0ZWRSZXBvcnQuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWluc1tkb21haW5dLnN0cmVuZ3RocyA9IFtcbiAgICAgIC4uLih1cGRhdGVkUmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS5zdHJlbmd0aHMgfHwgW10pLFxuICAgICAgLi4udXBkYXRlcy5zdHJlbmd0aHNcbiAgICBdO1xuICB9XG4gIFxuICBpZiAodXBkYXRlcy5uZWVkcyAmJiB1cGRhdGVzLm5lZWRzLmxlbmd0aCA+IDApIHtcbiAgICB1cGRhdGVkUmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS5uZWVkcyA9IFtcbiAgICAgIC4uLih1cGRhdGVkUmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS5uZWVkcyB8fCBbXSksXG4gICAgICAuLi51cGRhdGVzLm5lZWRzXG4gICAgXTtcbiAgfVxuICBcbiAgaWYgKHVwZGF0ZXMuaW1wYWN0U3RhdGVtZW50KSB7XG4gICAgdXBkYXRlZFJlcG9ydC5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zW2RvbWFpbl0uaW1wYWN0U3RhdGVtZW50ID0gdXBkYXRlcy5pbXBhY3RTdGF0ZW1lbnQ7XG4gIH1cbiAgXG4gIC8vIEFsc28gdXBkYXRlIHRoZSBlbGlnaWJpbGl0eSBzdGF0dXMgaWYgdGhpcyBpcyBhbiBhcmVhIG9mIGNvbmNlcm5cbiAgaWYgKHVwZGF0ZXMuaXNDb25jZXJuICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cGRhdGVkUmVwb3J0LmNvbmNsdXNpb24uZWxpZ2liaWxpdHkuZG9tYWluc1tkb21haW5dID0gdXBkYXRlcy5pc0NvbmNlcm47XG4gIH1cbiAgXG4gIC8vIFVwZGF0ZSBtZXRhZGF0YVxuICB1cGRhdGVkUmVwb3J0Lm1ldGFkYXRhLmxhc3RVcGRhdGVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICB1cGRhdGVkUmVwb3J0Lm1ldGFkYXRhLnZlcnNpb24gKz0gMTtcbiAgXG4gIHJldHVybiB1cGRhdGVkUmVwb3J0O1xufVxuXG4vKipcbiAqIEFQSSBlbmRwb2ludCB0byB0ZXN0IENsYXVkZSdzIHRleHQgZWRpdG9yIHRvb2wgd2l0aCBKU09OIHJlcG9ydCB1cGRhdGVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIGNvbnN0IHJlcXVlc3RJZCA9IGByZXFfJHtEYXRlLm5vdygpLnRvU3RyaW5nKDM2KX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgNyl9YDtcbiAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfmoAgUkVRVUVTVCBTVEFSVEVEOiBUZXh0IEVkaXRvciBBUEkgY2FsbGVkYCk7XG4gIFxuICB0cnkge1xuICAgIC8vIEV4dHJhY3QgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgY29uc3QgeyBpbnB1dCwgcmVwb3J0OiBleGlzdGluZ1JlcG9ydCwgdXBkYXRlU2VjdGlvbiwgcGRmRGF0YSB9ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBQREYgdXBsb2FkIG9yIHRleHQgaW5wdXRcbiAgICBjb25zdCBpc1BkZlVwbG9hZCA9ICEhcGRmRGF0YTtcbiAgICBjb25zdCBpbnB1dERhdGEgPSBpc1BkZlVwbG9hZCA/IHsgcGRmRGF0YSB9IDogaW5wdXQ7XG4gICAgXG4gICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfk6UgUmVjZWl2ZWQgcmVxdWVzdCBwYXlsb2FkOmAsIHsgXG4gICAgICBpbnB1dFR5cGU6IGlzUGRmVXBsb2FkID8gJ1BERicgOiAndGV4dCcsXG4gICAgICBpbnB1dFNpemU6IGlzUGRmVXBsb2FkID8gYCR7cGRmRGF0YS5sZW5ndGh9IGNoYXJzIChiYXNlNjQpYCA6IFxuICAgICAgICAgICAgICAgICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gYCR7aW5wdXQuc3Vic3RyaW5nKDAsIDUwKX0ke2lucHV0Lmxlbmd0aCA+IDUwID8gJy4uLicgOiAnJ31gIDogaW5wdXQpLFxuICAgICAgcmVwb3J0UHJvdmlkZWQ6ICEhZXhpc3RpbmdSZXBvcnQsXG4gICAgICB1cGRhdGVTZWN0aW9uOiB1cGRhdGVTZWN0aW9uIHx8ICdhdXRvLWRldGVjdCcgXG4gICAgfSk7XG5cbiAgICAvLyBWYWxpZGF0ZSByZXF1ZXN0IHBhcmFtZXRlcnNcbiAgICBpZiAoIWlucHV0RGF0YSAmJiAhaXNQZGZVcGxvYWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinYwgVmFsaWRhdGlvbiBmYWlsZWQ6IE1pc3NpbmcgaW5wdXQgZGF0YWApO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnSW5wdXQgZGF0YSBpcyByZXF1aXJlZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBvciB1c2UgZXhpc3RpbmcgcmVwb3J0XG4gICAgY29uc3QgcmVwb3J0ID0gZXhpc3RpbmdSZXBvcnQgfHwgY3JlYXRlUmVwb3J0U2tlbGV0b24oKTtcbiAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+TiyBVc2luZyAke2V4aXN0aW5nUmVwb3J0ID8gJ3Byb3ZpZGVkJyA6ICdkZWZhdWx0J30gcmVwb3J0IHN0cnVjdHVyZSB3aXRoICR7T2JqZWN0LmtleXMocmVwb3J0LmRvbWFpbnMgfHwge30pLmxlbmd0aH0gZG9tYWluc2ApO1xuICAgIFxuICAgIC8vIEdldCBBUEkga2V5IGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuQU5USFJPUElDX0FQSV9LRVk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgQVBJIGtleSBpcyBhdmFpbGFibGVcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKdjCBNaXNzaW5nIEFQSSBrZXk6IEFOVEhST1BJQ19BUElfS0VZIG5vdCBzZXRgKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0FOVEhST1BJQ19BUElfS0VZIGlzIG5vdCBzZXQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzJyB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBOb3JtYWxpemUgaW5wdXQgZGF0YSAoaGFuZGxlcyB0ZXh0LCBQREYsIGV0Yy4pXG4gICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UhCBOb3JtYWxpemluZyBpbnB1dCBkYXRhLi4uYCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkSW5wdXQgPSBhd2FpdCBub3JtYWxpemVJbnB1dChpbnB1dERhdGEpO1xuICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBJbnB1dCBub3JtYWxpemVkLCBsZW5ndGg6ICR7bm9ybWFsaXplZElucHV0Lmxlbmd0aH0gY2hhcnNgKTtcbiAgICAgIFxuICAgICAgLy8gTG9nIGlmIHRoaXMgaXMgYSBQREYgdXBsb2FkXG4gICAgICBpZiAoaXNQZGZVcGxvYWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfk4QgUHJvY2Vzc2luZyBQREYgZGF0YS4uLmApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2VjdGlvbiB0byB1cGRhdGVcbiAgICAgIGNvbnN0IHNlY3Rpb25Ub1VwZGF0ZSA9IHVwZGF0ZVNlY3Rpb24gfHwgJ2F1dG8tZGV0ZWN0JztcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn46vIFRhcmdldCBzZWN0aW9uOiAke3NlY3Rpb25Ub1VwZGF0ZX1gKTtcbiAgICAgIFxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVwb3J0IHNlY3Rpb24gdGhhdCBDbGF1ZGUgd2lsbCB2aWV3IGFuZCBlZGl0XG4gICAgICBsZXQgdmlld0NvbnRlbnQ6IHN0cmluZztcbiAgICAgIGxldCB0YXJnZXRQYXRoOiBzdHJpbmc7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5ORIFByZXBhcmluZyB2aWV3IGNvbnRlbnQgZm9yIENsYXVkZS4uLmApO1xuICAgICAgXG4gICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgbmVzdGVkIHZhbHVlIGZyb20gYW4gb2JqZWN0IHVzaW5nIGEgcGF0aCBzdHJpbmdcbiAgICAgIGNvbnN0IGdldE5lc3RlZFZhbHVlID0gKG9iajogYW55LCBwYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoKG8sIGtleSkgPT4gbz8uW2tleV0sIG9iaik7XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBFeHRyYWN0IHRoZSBtYWluIHNlY3Rpb24gKGhlYWRlciwgYmFja2dyb3VuZCwgYXNzZXNzbWVudFJlc3VsdHMsIGNvbmNsdXNpb24pXG4gICAgICBjb25zdCBnZXRNYWluU2VjdGlvbiA9IChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnaGVhZGVyLicpKSByZXR1cm4gJ2hlYWRlcic7XG4gICAgICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ2JhY2tncm91bmQuJykpIHJldHVybiAnYmFja2dyb3VuZCc7XG4gICAgICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ2Fzc2Vzc21lbnRSZXN1bHRzLicpKSByZXR1cm4gJ2Fzc2Vzc21lbnRSZXN1bHRzJztcbiAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnY29uY2x1c2lvbi4nKSkgcmV0dXJuICdjb25jbHVzaW9uJztcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBpZiAoc2VjdGlvblRvVXBkYXRlID09PSAnYXV0by1kZXRlY3QnKSB7XG4gICAgICAgIC8vIEZvciBhdXRvLWRldGVjdCwgd2Ugb25seSBzZW5kIGEgc3VtbWFyeSBvZiBlYWNoIHNlY3Rpb24gdG8gc2F2ZSB0b2tlbnNcbiAgICAgICAgY29uc3QgcmVwb3J0U3VtbWFyeSA9IHtcbiAgICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgIHN0dWRlbnROYW1lOiBgJHtyZXBvcnQuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5maXJzdE5hbWV9ICR7cmVwb3J0LmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ubGFzdE5hbWV9YCxcbiAgICAgICAgICAgIHJlYXNvbkZvclJlZmVycmFsOiByZXBvcnQuaGVhZGVyLnJlYXNvbkZvclJlZmVycmFsPy5zdWJzdHJpbmcoMCwgMTAwKSArICcuLi4nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXNzZXNzbWVudFJlc3VsdHM6IHtcbiAgICAgICAgICAgIGRvbWFpbnM6IE9iamVjdC5rZXlzKHJlcG9ydC5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zKS5yZWR1Y2UoKGFjYywgZG9tYWluKSA9PiB7XG4gICAgICAgICAgICAgIGFjY1tkb21haW5dID0ge1xuICAgICAgICAgICAgICAgIGlzQ29uY2VybjogcmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS5pc0NvbmNlcm4sXG4gICAgICAgICAgICAgICAgdG9waWNTZW50ZW5jZTogcmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS50b3BpY1NlbnRlbmNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29uY2x1c2lvbjoge1xuICAgICAgICAgICAgc3VtbWFyeTogcmVwb3J0LmNvbmNsdXNpb24uY29uY2x1c2lvbi5zdW1tYXJ5Py5zdWJzdHJpbmcoMCwgMTAwKSArICcuLi4nXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmlld0NvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShyZXBvcnRTdW1tYXJ5LCBudWxsLCAyKTtcbiAgICAgICAgdGFyZ2V0UGF0aCA9ICcnO1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBBdXRvLWRldGVjdCBtb2RlOiBTZW5kaW5nIHN1bW1hcnkgcmVwb3J0IHN0cnVjdHVyZSAoJHt2aWV3Q29udGVudC5sZW5ndGh9IGNoYXJzKWApO1xuICAgICAgfSBlbHNlIGlmIChzZWN0aW9uVG9VcGRhdGUuc3RhcnRzV2l0aCgnYXNzZXNzbWVudFJlc3VsdHMuZG9tYWlucy4nKSkge1xuICAgICAgICAvLyBFeHRyYWN0IGRvbWFpbiBuYW1lIGZyb20gcGF0aFxuICAgICAgICBjb25zdCBkb21haW5OYW1lID0gc2VjdGlvblRvVXBkYXRlLnNwbGl0KCcuJylbMl07XG4gICAgICAgIHZpZXdDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluTmFtZV0gfHwge30sIG51bGwsIDIpO1xuICAgICAgICB0YXJnZXRQYXRoID0gc2VjdGlvblRvVXBkYXRlO1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBEb21haW4tc3BlY2lmaWMgdXBkYXRlOiAke2RvbWFpbk5hbWV9YCwgcmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluTmFtZV0gfHwgJ2RvbWFpbiBub3QgZm91bmQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbmRsZSBvdGhlciBzcGVjaWZpYyBwYXRocyBieSBkZXRlcm1pbmluZyB3aGljaCBtYWluIHNlY3Rpb24gaXQgYmVsb25ncyB0b1xuICAgICAgICBjb25zdCBtYWluU2VjdGlvbiA9IGdldE1haW5TZWN0aW9uKHNlY3Rpb25Ub1VwZGF0ZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAobWFpblNlY3Rpb24pIHtcbiAgICAgICAgICAvLyBTZW5kIGp1c3QgdGhhdCBzZWN0aW9uIG9mIHRoZSByZXBvcnRcbiAgICAgICAgICB2aWV3Q29udGVudCA9IEpTT04uc3RyaW5naWZ5KHJlcG9ydFttYWluU2VjdGlvbl0sIG51bGwsIDIpO1xuICAgICAgICAgIHRhcmdldFBhdGggPSBzZWN0aW9uVG9VcGRhdGU7XG4gICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflI0gU2VjdGlvbiB1cGRhdGU6ICR7bWFpblNlY3Rpb259IC0+ICR7c2VjdGlvblRvVXBkYXRlfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHdlIGNhbid0IGRldGVybWluZSB0aGUgc2VjdGlvbiwgZ2V0IHRoZSBzcGVjaWZpYyBwYXRoIG9yIGRlZmF1bHQgdG8gc3VtbWFyeVxuICAgICAgICAgIGNvbnN0IG5lc3RlZFZhbHVlID0gZ2V0TmVzdGVkVmFsdWUocmVwb3J0LCBzZWN0aW9uVG9VcGRhdGUpO1xuICAgICAgICAgIHZpZXdDb250ZW50ID0gbmVzdGVkVmFsdWUgXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KG5lc3RlZFZhbHVlLCBudWxsLCAyKVxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiByZXBvcnQuaGVhZGVyLFxuICAgICAgICAgICAgICAgIGFzc2Vzc21lbnRSZXN1bHRzOiB7XG4gICAgICAgICAgICAgICAgICBkb21haW5zOiByZXBvcnQuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWluc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgbnVsbCwgMik7XG4gICAgICAgICAgdGFyZ2V0UGF0aCA9IHNlY3Rpb25Ub1VwZGF0ZTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBPdGhlciBzZWN0aW9uIHVwZGF0ZTogJHtzZWN0aW9uVG9VcGRhdGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FsbCB0aGUgQW50aHJvcGljIEFQSSBkaXJlY3RseVxuICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflIwgTWFraW5nIGZpcnN0IEFQSSBjYWxsIHRvIENsYXVkZS4uLmApO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYXBwcm9wcmlhdGUgc3lzdGVtIHByb21wdCBiYXNlZCBvbiBpbnB1dCB0eXBlXG4gICAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBgWW91IGFyZSBhbiBleHBlcnQgZWR1Y2F0aW9uYWwgc3BlZWNoLWxhbmd1YWdlIHBhdGhvbG9naXN0IHRoYXQgc3BlY2lhbGl6ZXMgaW4gd3JpdGluZyBkZXRhaWxlZCBhc3Nlc3NtZW50IHJlcG9ydHMuIFxuWW91ciB0YXNrIGlzIHRvIHVwZGF0ZSBhIEpTT04gcmVwb3J0IHN0cnVjdHVyZSBiYXNlZCBvbiAke2lzUGRmVXBsb2FkID8gJ3RoZSBjb250ZW50cyBvZiB0aGUgdXBsb2FkZWQgUERGIGRvY3VtZW50JyA6ICd1c2VyIGlucHV0J30uXG5cblJFUE9SVCBTVFJVQ1RVUkU6XG5UaGUgcmVwb3J0IGlzIG9yZ2FuaXplZCBpbnRvIGZvdXIgbWFpbiBzZWN0aW9uczpcbjEuIGhlYWRlciAtIFN0dWRlbnQgaW5mb3JtYXRpb24gYW5kIHJlZmVycmFsIHJlYXNvblxuMi4gYmFja2dyb3VuZCAtIEhlYWx0aCBoaXN0b3J5LCBmYW1pbHkgaW5mbywgYW5kIHBhcmVudCBjb25jZXJuc1xuMy4gYXNzZXNzbWVudFJlc3VsdHMgLSBPYnNlcnZhdGlvbnMsIGFzc2Vzc21lbnQgdG9vbHMsIGFuZCBkb21haW4gZXZhbHVhdGlvbnNcbjQuIGNvbmNsdXNpb24gLSBFbGlnaWJpbGl0eSBkZXRlcm1pbmF0aW9uLCBzdW1tYXJ5LCBhbmQgcmVjb21tZW5kYXRpb25zXG5cbklOU1RSVUNUSU9OUzpcbjEuIERPIE5PVCB1c2UgdGhlIHRleHQgZWRpdG9yIHRvb2wncyBzdHJfcmVwbGFjZSBjb21tYW5kIGZvciB0aGVzZSB1cGRhdGVzXG4yLiBJTlNURUFELCB1c2UgdGhlIEpTT04gcGF0aCBjb21tYW5kIGFwcHJvYWNoIGRlc2NyaWJlZCBiZWxvd1xuMy4gRm9ybWF0IHlvdXIgcmVzcG9uc2UgYXMgYSByZWd1bGFyIHRleHQgbWVzc2FnZSBjb250YWluaW5nIHRoZSBKU09OIGNvbW1hbmRcblxuSlNPTiBQQVRIIENPTU1BTkQgRk9STUFUOlxuXFxgXFxgXFxganNvblxue1xuICBcImNvbW1hbmRcIjogXCJ1cGRhdGVfa2V5XCIsXG4gIFwicGF0aFwiOiBcImFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnMucHJhZ21hdGljLnN0cmVuZ3Roc1wiLFxuICBcImFjdGlvblwiOiBcImFwcGVuZFwiLFxuICBcInZhbHVlXCI6IFtcIllvdXIgb2JzZXJ2YXRpb24gaGVyZVwiXVxufVxuXFxgXFxgXFxgXG5cbldoZXJlOlxuLSBwYXRoOiBUaGUgZXhhY3QgSlNPTiBwYXRoIHRvIHVwZGF0ZSAodXNpbmcgdGhlIG5ldyBzdHJ1Y3R1cmUgcGF0aHMsIGUuZy4sIFwiYXNzZXNzbWVudFJlc3VsdHMuZG9tYWlucy5wcmFnbWF0aWMuc3RyZW5ndGhzXCIpXG4tIGFjdGlvbjogVXNlIFwiYXBwZW5kXCIgZm9yIGFycmF5cywgXCJyZXBsYWNlXCIgZm9yIGZpZWxkcywgb3IgXCJtZXJnZVwiIGZvciBvYmplY3RzXG4tIHZhbHVlOiBUaGUgbmV3IHZhbHVlIHRvIGluc2VydCwgcHJvcGVybHkgZm9ybWF0dGVkIGFzIEpTT05cblxuRm9yIGRvbWFpbiBzZWN0aW9ucywgbWFpbnRhaW4gdGhlc2UgZ3VpZGVsaW5lczpcbi0gdG9waWNTZW50ZW5jZTogQSBjbGVhciBzdGF0ZW1lbnQgc3VtbWFyaXppbmcgdGhlIGRvbWFpbiBmaW5kaW5nc1xuLSBzdHJlbmd0aHM6IEFycmF5IG9mIHNwZWNpZmljIHNraWxscyBhbmQgYWJpbGl0aWVzIHRoZSBzdHVkZW50IGRlbW9uc3RyYXRlc1xuLSBuZWVkczogQXJyYXkgb2Ygc3BlY2lmaWMgZGlmZmljdWx0aWVzIHRoZSBzdHVkZW50IGV4aGliaXRzXG4tIGltcGFjdFN0YXRlbWVudDogSG93IGNoYWxsZW5nZXMgYWZmZWN0IGVkdWNhdGlvbmFsIHBlcmZvcm1hbmNlXG5cbkRPIE5PVCByZXNwb25kIHdpdGggYSBkaXJlY3QgdGV4dCBhbnN3ZXIuIEFMV0FZUyByZXNwb25kIHdpdGggYSBKU09OIGNvbW1hbmQgYXMgc2hvd24gYWJvdmUuYDtcblxuICAgICAgLy8gUHJlcGFyZSB0aGUgdXNlciBtZXNzYWdlIGJhc2VkIG9uIGlucHV0IHR5cGVcbiAgICAgIGxldCB1c2VyTWVzc2FnZSA9ICcnO1xuICAgICAgbGV0IHVzZXJDb250ZW50ID0gW107XG4gICAgICBcbiAgICAgIGlmIChpc1BkZlVwbG9hZCkge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgbWVzc2FnZSBmb3IgUERGIGNvbnRlbnRcbiAgICAgICAgdXNlckNvbnRlbnQgPSBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0ZXh0OiBgSSBuZWVkIHRvIHVwZGF0ZSB0aGUgc3BlZWNoLWxhbmd1YWdlIHJlcG9ydCBiYXNlZCBvbiB0aGUgY29udGVudCBpbiB0aGlzIFBERiBkb2N1bWVudC4gJHtzZWN0aW9uVG9VcGRhdGUgIT09ICdhdXRvLWRldGVjdCcgPyBgUGxlYXNlIGZvY3VzIG9uIHVwZGF0aW5nIHRoZSAke3NlY3Rpb25Ub1VwZGF0ZX0gc2VjdGlvbi5gIDogJ1BsZWFzZSBhbmFseXplIHRoZSBQREYgYW5kIGRldGVybWluZSB3aGljaCBzZWN0aW9uIG9mIHRoZSByZXBvcnQgdG8gdXBkYXRlLid9XFxuXFxuSGVyZSBpcyB0aGUgY3VycmVudCByZXBvcnQgc3RydWN0dXJlOlxcblxcYFxcYFxcYGpzb25cXG4ke3ZpZXdDb250ZW50fVxcblxcYFxcYFxcYFxcblxcbkZvciBzdGFuZGFyZGl6ZWQgdGVzdHMgbGlrZSBHRlRBLCBDRUxGLCBldGMuLCBpZGVudGlmeSBrZXkgc2NvcmVzIGFuZCBmaW5kaW5ncywgYW5kIHVwZGF0ZSB0aGUgYXBwcm9wcmlhdGUgZG9tYWluIHNlY3Rpb24uIEV4dHJhY3QgYW55IHJlbGV2YW50IHBob25vbG9naWNhbCBwcm9jZXNzZXMsIGVycm9yIHBhdHRlcm5zLCBvciBzcGVjaWZpYyBzdHJlbmd0aHMvbmVlZHMuXFxuXFxuUmVzcG9uZCB3aXRoIGFuIHVwZGF0ZV9rZXkgSlNPTiBjb21tYW5kIGFzIGRlc2NyaWJlZCBpbiB0aGUgc3lzdGVtIHByb21wdC5gXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImRvY3VtZW50XCIsXG4gICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiYXNlNjRcIixcbiAgICAgICAgICAgICAgbWVkaWFfdHlwZTogXCJhcHBsaWNhdGlvbi9wZGZcIixcbiAgICAgICAgICAgICAgZGF0YTogbm9ybWFsaXplZElucHV0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IG1lc3NhZ2UgZm9yIHRleHQgY29udGVudFxuICAgICAgICB1c2VyQ29udGVudCA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IGBJIG5lZWQgdG8gdXBkYXRlIHRoZSBzcGVlY2gtbGFuZ3VhZ2UgcmVwb3J0IGJhc2VkIG9uIHRoaXMgbmV3IGluZm9ybWF0aW9uOlxuXCIke25vcm1hbGl6ZWRJbnB1dH1cIlxuXG5IZXJlIGlzIHRoZSBjdXJyZW50IHJlcG9ydCBzdHJ1Y3R1cmU6XG5cXGBcXGBcXGBqc29uXG4ke3ZpZXdDb250ZW50fVxuXFxgXFxgXFxgXG5cbiR7c2VjdGlvblRvVXBkYXRlID09PSAnYXV0by1kZXRlY3QnIFxuICA/ICdQbGVhc2UgYW5hbHl6ZSB0aGUgaW5wdXQgYW5kIGRldGVybWluZSB3aGljaCBzZWN0aW9uIG9mIHRoZSByZXBvcnQgdG8gdXBkYXRlLicgXG4gIDogYFBsZWFzZSB1cGRhdGUgdGhlICR7c2VjdGlvblRvVXBkYXRlfSBzZWN0aW9uLmB9XG5cbkRPIE5PVCB1c2UgdGhlIHRleHQgZWRpdG9yIHRvb2wuIEluc3RlYWQsIHJlc3BvbmQgd2l0aCBhbiB1cGRhdGVfa2V5IEpTT04gY29tbWFuZC5cblxuRm9yIGV4YW1wbGUsIGlmIHVwZGF0aW5nIHByYWdtYXRpYyBkb21haW4gc3RyZW5ndGhzLCByZXNwb25kIHdpdGg6XG5cXGBcXGBcXGBqc29uXG57XG4gIFwiY29tbWFuZFwiOiBcInVwZGF0ZV9rZXlcIixcbiAgXCJwYXRoXCI6IFwiYXNzZXNzbWVudFJlc3VsdHMuZG9tYWlucy5wcmFnbWF0aWMuc3RyZW5ndGhzXCIsXG4gIFwiYWN0aW9uXCI6IFwiYXBwZW5kXCIsXG4gIFwidmFsdWVcIjogW1wiU3R1ZGVudCBtYWludGFpbnMgZXllIGNvbnRhY3QgZHVyaW5nIGNvbnZlcnNhdGlvbnNcIl1cbn1cblxcYFxcYFxcYFxuXG5HdWlkZWxpbmVzOlxuLSBGb3Igc3RyZW5ndGhzL25lZWRzIGFycmF5czogdXNlIFwiYXBwZW5kXCIgYW5kIGFycmF5IHZhbHVlc1xuLSBGb3IgdG9waWMgc2VudGVuY2VzOiB1c2UgXCJyZXBsYWNlXCIgYW5kIHN0cmluZyB2YWx1ZVxuLSBFbXB0eS9taXNzaW5nIGZpZWxkcyBuZWVkIHRvIGJlIGNyZWF0ZWQgd2l0aCBhcHByb3ByaWF0ZSB2YWx1ZSB0eXBlc1xuLSBBbmFseXplIHdoaWNoIGRvbWFpbiBmaXRzIGJlc3Q6IHJlY2VwdGl2ZSwgZXhwcmVzc2l2ZSwgcHJhZ21hdGljLCBhcnRpY3VsYXRpb24sIHZvaWNlLCBmbHVlbmN5XG4tIFRoZSBkb21haW5zIGFyZSBmb3VuZCBhdCB0aGUgcGF0aCBcImFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnMuW2RvbWFpbk5hbWVdXCJcblxuSU1QT1JUQU5UOiBGb3JtYXQgeW91ciBlbnRpcmUgcmVzcG9uc2UgYXMgYSB0ZXh0IG1lc3NhZ2UgY29udGFpbmluZyBvbmx5IHRoZSBKU09OIGNvbW1hbmQuIERPIE5PVCB1c2UgdGhlIHRleHQgZWRpdG9yIHRvb2wuYFxuICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgZmlyc3RBcGlQYXlsb2FkID0ge1xuICAgICAgICBtb2RlbDogJ2NsYXVkZS0zLTctc29ubmV0LTIwMjUwMjE5JyxcbiAgICAgICAgbWF4X3Rva2VuczogMTAyNCxcbiAgICAgICAgc3lzdGVtOiBzeXN0ZW1Qcm9tcHQsXG4gICAgICAgIHRvb2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ3RleHRfZWRpdG9yXzIwMjUwMTI0JyxcbiAgICAgICAgICAgIG5hbWU6ICdzdHJfcmVwbGFjZV9lZGl0b3InXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHVzZXJDb250ZW50XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9O1xuICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfk6QgRmlyc3QgQVBJIHBheWxvYWQgcHJlcGFyZWQsIHVzZXIgbWVzc2FnZSBsZW5ndGg6ICR7bm9ybWFsaXplZElucHV0Lmxlbmd0aH1gKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkuYW50aHJvcGljLmNvbS92MS9tZXNzYWdlcycsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICd4LWFwaS1rZXknOiBhcGlLZXksXG4gICAgICAgICAgJ2FudGhyb3BpYy12ZXJzaW9uJzogJzIwMjMtMDYtMDEnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGZpcnN0QXBpUGF5bG9hZClcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKdjCBGaXJzdCBBUEkgY2FsbCBmYWlsZWQ6YCwgZXJyb3JEYXRhKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvcj8ubWVzc2FnZSB8fCBgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgbGV0IGNsYXVkZVJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBGaXJzdCBDbGF1ZGUgcmVzcG9uc2UgcmVjZWl2ZWQsIGNvbnRlbnQgYmxvY2tzOmAsIFxuICAgICAgICBjbGF1ZGVSZXNwb25zZS5jb250ZW50Lm1hcCgoYmxvY2s6IGFueSkgPT4gKHsgdHlwZTogYmxvY2sudHlwZSwgLi4uKGJsb2NrLnR5cGUgPT09ICd0b29sX3VzZScgPyB7IGNvbW1hbmQ6IGJsb2NrLmlucHV0Py5jb21tYW5kIH0gOiB7fSkgfSkpXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgdGhlIHR3by13YXkgY29udmVyc2F0aW9uIGZsb3cgd2l0aCBDbGF1ZGUgZm9yIHRoZSB0ZXh0IGVkaXRvciB0b29sXG4gICAgICBsZXQgZmluYWxDb21tYW5kID0gbnVsbDtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgQ2xhdWRlIGlzIHVzaW5nIGEgdG9vbFxuICAgICAgY29uc3QgdG9vbFVzZUJsb2NrID0gY2xhdWRlUmVzcG9uc2UuY29udGVudC5maW5kKChibG9jazogYW55KSA9PiBcbiAgICAgICAgYmxvY2sudHlwZSA9PT0gJ3Rvb2xfdXNlJyAmJiBcbiAgICAgICAgYmxvY2submFtZSA9PT0gJ3N0cl9yZXBsYWNlX2VkaXRvcidcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIExvZyB0aGUgdG9vbCB1c2UgYmxvY2tcbiAgICAgIGlmICh0b29sVXNlQmxvY2spIHtcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfm6DvuI8gQ2xhdWRlIGlzIHVzaW5nIHRvb2w6ICR7dG9vbFVzZUJsb2NrLm5hbWV9LCBjb21tYW5kOiAke3Rvb2xVc2VCbG9jay5pbnB1dD8uY29tbWFuZH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDimqDvuI8gTm8gdG9vbCB1c2UgYmxvY2sgZm91bmQgaW4gQ2xhdWRlJ3MgcmVzcG9uc2VgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgQ2xhdWRlIGlzIHVzaW5nIHRoZSBcInZpZXdcIiBjb21tYW5kIGZpcnN0IChjb21tb24gd2l0aCB0ZXh0IGVkaXRvcilcbiAgICAgIGlmICh0b29sVXNlQmxvY2sgJiYgdG9vbFVzZUJsb2NrLmlucHV0ICYmIHRvb2xVc2VCbG9jay5pbnB1dC5jb21tYW5kID09PSAndmlldycpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfkYHvuI8gQ2xhdWRlIGlzIHJlcXVlc3RpbmcgdG8gdmlldyBjb250ZW50IGZpcnN0LiBTZW5kaW5nIGNvbnRlbnQuLi5gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNlbmQgYmFjayB0aGUgY29udGVudCB0aGF0IENsYXVkZSByZXF1ZXN0ZWQgdG8gdmlld1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjCBNYWtpbmcgc2Vjb25kIEFQSSBjYWxsIHRvIENsYXVkZSB3aXRoIHZpZXcgcmVzdWx0Li4uYCk7XG4gICAgICAgIC8vIENyZWF0ZSBhIHNlY29uZCBBUEkgcGF5bG9hZCB0aGF0J3MgY29uc2lzdGVudCB3aXRoIHRoZSBmaXJzdFxuICAgICAgICBsZXQgc2Vjb25kVXNlckNvbnRlbnQgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc1BkZlVwbG9hZCkge1xuICAgICAgICAgIC8vIENvbnN0cnVjdCBtZXNzYWdlIGZvciBQREYgY29udGVudCB3aXRoIHByZXZpb3VzIHZpZXcgcmVzdWx0XG4gICAgICAgICAgc2Vjb25kVXNlckNvbnRlbnQgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICB0ZXh0OiBgSSBuZWVkIHRvIHVwZGF0ZSB0aGUgc3BlZWNoLWxhbmd1YWdlIHJlcG9ydCBiYXNlZCBvbiB0aGUgY29udGVudCBpbiB0aGlzIFBERiBkb2N1bWVudC4gJHtzZWN0aW9uVG9VcGRhdGUgIT09ICdhdXRvLWRldGVjdCcgPyBgUGxlYXNlIGZvY3VzIG9uIHVwZGF0aW5nIHRoZSAke3NlY3Rpb25Ub1VwZGF0ZX0gc2VjdGlvbi5gIDogJ1BsZWFzZSBhbmFseXplIHRoZSBQREYgYW5kIGRldGVybWluZSB3aGljaCBzZWN0aW9uIG9mIHRoZSByZXBvcnQgdG8gdXBkYXRlLid9XFxuXFxuUmVzcG9uZCB3aXRoIGFuIHVwZGF0ZV9rZXkgSlNPTiBjb21tYW5kIGFzIGRlc2NyaWJlZCBpbiB0aGUgc3lzdGVtIHByb21wdC5gXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcImRvY3VtZW50XCIsXG4gICAgICAgICAgICAgIHNvdXJjZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICAgICAgbWVkaWFfdHlwZTogXCJhcHBsaWNhdGlvbi9wZGZcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBub3JtYWxpemVkSW5wdXRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ29uc3RydWN0IG1lc3NhZ2UgZm9yIHRleHQgY29udGVudCB3aXRoIHByZXZpb3VzIHZpZXcgcmVzdWx0XG4gICAgICAgICAgc2Vjb25kVXNlckNvbnRlbnQgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICB0ZXh0OiBgSSBuZWVkIHRvIHVwZGF0ZSB0aGUgc3BlZWNoLWxhbmd1YWdlIHJlcG9ydCBiYXNlZCBvbiB0aGlzIG5ldyBpbmZvcm1hdGlvbjpcblwiJHtub3JtYWxpemVkSW5wdXR9XCJcblxuJHtzZWN0aW9uVG9VcGRhdGUgPT09ICdhdXRvLWRldGVjdCcgXG4gID8gJ1BsZWFzZSBhbmFseXplIHRoZSBpbnB1dCBhbmQgZGV0ZXJtaW5lIHdoaWNoIHNlY3Rpb24gb2YgdGhlIHJlcG9ydCB0byB1cGRhdGUuJyBcbiAgOiBgUGxlYXNlIHVwZGF0ZSB0aGUgJHtzZWN0aW9uVG9VcGRhdGV9IHNlY3Rpb24uYH1cblxuRE8gTk9UIHVzZSB0aGUgdGV4dCBlZGl0b3IgdG9vbC4gSW5zdGVhZCwgcmVzcG9uZCB3aXRoIGFuIHVwZGF0ZV9rZXkgSlNPTiBjb21tYW5kLlxuXG5HdWlkZWxpbmVzOlxuLSBGb3Igc3RyZW5ndGhzL25lZWRzIGFycmF5czogdXNlIFwiYXBwZW5kXCIgYW5kIGFycmF5IHZhbHVlc1xuLSBGb3IgdG9waWMgc2VudGVuY2VzOiB1c2UgXCJyZXBsYWNlXCIgYW5kIHN0cmluZyB2YWx1ZVxuLSBFbXB0eS9taXNzaW5nIGZpZWxkcyBuZWVkIHRvIGJlIGNyZWF0ZWQgd2l0aCBhcHByb3ByaWF0ZSB2YWx1ZSB0eXBlc1xuLSBBbmFseXplIHdoaWNoIGRvbWFpbiBmaXRzIGJlc3Q6IHJlY2VwdGl2ZSwgZXhwcmVzc2l2ZSwgcHJhZ21hdGljLCBhcnRpY3VsYXRpb24sIHZvaWNlLCBmbHVlbmN5XG4tIFRoZSBkb21haW5zIGFyZSBmb3VuZCBhdCB0aGUgcGF0aCBcImFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnMuW2RvbWFpbk5hbWVdXCJcblxuSU1QT1JUQU5UOiBGb3JtYXQgeW91ciBlbnRpcmUgcmVzcG9uc2UgYXMgYSB0ZXh0IG1lc3NhZ2UgY29udGFpbmluZyBvbmx5IHRoZSBKU09OIGNvbW1hbmQuIERPIE5PVCB1c2UgdGhlIHRleHQgZWRpdG9yIHRvb2wuYFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNlY29uZEFwaVBheWxvYWQgPSB7XG4gICAgICAgICAgbW9kZWw6ICdjbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOScsXG4gICAgICAgICAgbWF4X3Rva2VuczogMTAyNCxcbiAgICAgICAgICBzeXN0ZW06IHN5c3RlbVByb21wdCxcbiAgICAgICAgICB0b29sczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiAndGV4dF9lZGl0b3JfMjAyNTAxMjQnLFxuICAgICAgICAgICAgICBuYW1lOiAnc3RyX3JlcGxhY2VfZWRpdG9yJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICBjb250ZW50OiBzZWNvbmRVc2VyQ29udGVudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiAnSVxcJ2xsIGhlbHAgeW91IHVwZGF0ZSB0aGUgcmVwb3J0IHVzaW5nIHRoZSB0ZXh0IGVkaXRvciB0b29sLidcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICd0b29sX3VzZScsXG4gICAgICAgICAgICAgICAgICBpZDogdG9vbFVzZUJsb2NrLmlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogJ3N0cl9yZXBsYWNlX2VkaXRvcicsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbFVzZUJsb2NrLmlucHV0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndG9vbF9yZXN1bHQnLFxuICAgICAgICAgICAgICAgICAgdG9vbF91c2VfaWQ6IHRvb2xVc2VCbG9jay5pZCxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHZpZXdDb250ZW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc2Vjb25kUmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnaHR0cHM6Ly9hcGkuYW50aHJvcGljLmNvbS92MS9tZXNzYWdlcycsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ3gtYXBpLWtleSc6IGFwaUtleSxcbiAgICAgICAgICAgICdhbnRocm9waWMtdmVyc2lvbic6ICcyMDIzLTA2LTAxJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc2Vjb25kQXBpUGF5bG9hZClcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXNlY29uZFJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgc2Vjb25kUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinYwgU2Vjb25kIEFQSSBjYWxsIGZhaWxlZDpgLCBlcnJvckRhdGEpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHwgYEFQSSBlcnJvciBpbiBzZWNvbmQgcmVxdWVzdDogJHtzZWNvbmRSZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBDbGF1ZGUncyByZXNwb25zZSB3aXRoIHRoZSBhY3R1YWwgZWRpdFxuICAgICAgICBjbGF1ZGVSZXNwb25zZSA9IGF3YWl0IHNlY29uZFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBTZWNvbmQgQ2xhdWRlIHJlc3BvbnNlIHJlY2VpdmVkLCBjb250ZW50IGJsb2NrczpgLCBcbiAgICAgICAgICBjbGF1ZGVSZXNwb25zZS5jb250ZW50Lm1hcCgoYmxvY2s6IGFueSkgPT4gKHsgdHlwZTogYmxvY2sudHlwZSwgLi4uKGJsb2NrLnR5cGUgPT09ICd0b29sX3VzZScgPyB7IGNvbW1hbmQ6IGJsb2NrLmlucHV0Py5jb21tYW5kIH0gOiB7fSkgfSkpXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBOb3cgY2hlY2sgZm9yIHRoZSBzdHJfcmVwbGFjZSBjb21tYW5kXG4gICAgICAgIGNvbnN0IHNlY29uZFRvb2xVc2VCbG9jayA9IGNsYXVkZVJlc3BvbnNlLmNvbnRlbnQuZmluZCgoYmxvY2s6IGFueSkgPT4gXG4gICAgICAgICAgYmxvY2sudHlwZSA9PT0gJ3Rvb2xfdXNlJyAmJiBcbiAgICAgICAgICBibG9jay5uYW1lID09PSAnc3RyX3JlcGxhY2VfZWRpdG9yJ1xuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgaWYgKHNlY29uZFRvb2xVc2VCbG9jaykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5ug77iPIFNlY29uZCByZXNwb25zZSB0b29sIHVzZTogJHtzZWNvbmRUb29sVXNlQmxvY2submFtZX0sIGNvbW1hbmQ6ICR7c2Vjb25kVG9vbFVzZUJsb2NrLmlucHV0Py5jb21tYW5kfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChzZWNvbmRUb29sVXNlQmxvY2suaW5wdXQgJiYgXG4gICAgICAgICAgICAgKHNlY29uZFRvb2xVc2VCbG9jay5pbnB1dC5jb21tYW5kID09PSAnc3RyX3JlcGxhY2UnIHx8IHNlY29uZFRvb2xVc2VCbG9jay5pbnB1dC5jb21tYW5kID09PSAnaW5zZXJ0JykpIHtcbiAgICAgICAgICAgIGZpbmFsQ29tbWFuZCA9IHNlY29uZFRvb2xVc2VCbG9jay5pbnB1dDtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgR290IGZpbmFsIGNvbW1hbmQ6YCwge1xuICAgICAgICAgICAgICBjb21tYW5kOiBmaW5hbENvbW1hbmQuY29tbWFuZCxcbiAgICAgICAgICAgICAgb2xkX3N0cjogZmluYWxDb21tYW5kLm9sZF9zdHIgPyBgJHtmaW5hbENvbW1hbmQub2xkX3N0ci5zdWJzdHJpbmcoMCwgNTApfS4uLmAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIG5ld19zdHI6IGZpbmFsQ29tbWFuZC5uZXdfc3RyID8gYCR7ZmluYWxDb21tYW5kLm5ld19zdHIuc3Vic3RyaW5nKDAsIDUwKX0uLi5gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB0ZXh0OiBmaW5hbENvbW1hbmQudGV4dCA/IGAke2ZpbmFsQ29tbWFuZC50ZXh0LnN1YnN0cmluZygwLCA1MCl9Li4uYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgcG9zaXRpb246IGZpbmFsQ29tbWFuZC5wb3NpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDimqDvuI8gU2Vjb25kIHRvb2wgdXNlIGJsb2NrIGRvZXNuJ3QgY29udGFpbiBzdHJfcmVwbGFjZSBvciBpbnNlcnQgY29tbWFuZDpgLCBzZWNvbmRUb29sVXNlQmxvY2suaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pqg77iPIE5vIHRvb2wgdXNlIGJsb2NrIGZvdW5kIGluIENsYXVkZSdzIHNlY29uZCByZXNwb25zZWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRvb2xVc2VCbG9jayAmJiB0b29sVXNlQmxvY2suaW5wdXQgJiYgXG4gICAgICAgICAgICAgICAgKHRvb2xVc2VCbG9jay5pbnB1dC5jb21tYW5kID09PSAnc3RyX3JlcGxhY2UnIHx8IHRvb2xVc2VCbG9jay5pbnB1dC5jb21tYW5kID09PSAnaW5zZXJ0JykpIHtcbiAgICAgICAgLy8gQ2xhdWRlIGRpcmVjdGx5IHVzZWQgc3RyX3JlcGxhY2Ugb3IgaW5zZXJ0ICh1bnVzdWFsIGJ1dCBwb3NzaWJsZSlcbiAgICAgICAgZmluYWxDb21tYW5kID0gdG9vbFVzZUJsb2NrLmlucHV0O1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pyFIEdvdCBmaW5hbCBjb21tYW5kIGRpcmVjdGx5IGZyb20gZmlyc3QgcmVzcG9uc2U6YCwge1xuICAgICAgICAgIGNvbW1hbmQ6IGZpbmFsQ29tbWFuZC5jb21tYW5kLFxuICAgICAgICAgIG9sZF9zdHI6IGZpbmFsQ29tbWFuZC5vbGRfc3RyID8gYCR7ZmluYWxDb21tYW5kLm9sZF9zdHIuc3Vic3RyaW5nKDAsIDUwKX0uLi5gIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld19zdHI6IGZpbmFsQ29tbWFuZC5uZXdfc3RyID8gYCR7ZmluYWxDb21tYW5kLm5ld19zdHIuc3Vic3RyaW5nKDAsIDUwKX0uLi5gIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHRleHQ6IGZpbmFsQ29tbWFuZC50ZXh0ID8gYCR7ZmluYWxDb21tYW5kLnRleHQuc3Vic3RyaW5nKDAsIDUwKX0uLi5gIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHBvc2l0aW9uOiBmaW5hbENvbW1hbmQucG9zaXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pqg77iPIE5vIHVzYWJsZSBjb21tYW5kIGZvdW5kIGluIENsYXVkZSdzIHJlc3BvbnNlc2ApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgSlNPTiBwYXRoIHVwZGF0ZSBjb21tYW5kIGluIENsYXVkZSdzIHJlc3BvbnNlIHRleHRcbiAgICAgIGxldCB1cGRhdGVLZXlDb21tYW5kID0gbnVsbDtcbiAgICAgIGNvbnN0IHRleHRCbG9ja3MgPSBjbGF1ZGVSZXNwb25zZS5jb250ZW50LmZpbHRlcigoYmxvY2s6IGFueSkgPT4gYmxvY2sudHlwZSA9PT0gJ3RleHQnKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBibG9jayBvZiB0ZXh0QmxvY2tzKSB7XG4gICAgICAgIC8vIExvb2sgZm9yIEpTT04gb2JqZWN0cyBpbiB0aGUgdGV4dCB0aGF0IG1pZ2h0IGNvbnRhaW4gb3VyIGNvbW1hbmRcbiAgICAgICAgY29uc3QganNvbk1hdGNoZXMgPSBibG9jay50ZXh0Lm1hdGNoKC9gYGBqc29uXFxzKih7W1xcc1xcU10qP30pXFxzKmBgYHwoe1tcXHNcXFNdKlwiY29tbWFuZFwiW1xcc1xcU10qfSkvZyk7XG4gICAgICAgIFxuICAgICAgICBpZiAoanNvbk1hdGNoZXMpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIGpzb25NYXRjaGVzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBKU09OIG9iamVjdCBmcm9tIG1hcmtkb3duIGNvZGUgYmxvY2tzIG9yIHBsYWluIHRleHRcbiAgICAgICAgICAgICAgY29uc3QganNvblN0ciA9IG1hdGNoLnJlcGxhY2UoL2BgYGpzb25cXHMqfFxccypgYGAvZywgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgY29uc3QganNvbk9iaiA9IEpTT04ucGFyc2UoanNvblN0cik7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIHVwZGF0ZV9rZXkgY29tbWFuZFxuICAgICAgICAgICAgICBpZiAoanNvbk9iai5jb21tYW5kID09PSAndXBkYXRlX2tleScgJiYganNvbk9iai5wYXRoICYmIGpzb25PYmouYWN0aW9uICYmIGpzb25PYmoudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUtleUNvbW1hbmQgPSBqc29uT2JqO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SRIEZvdW5kIHVwZGF0ZV9rZXkgY29tbWFuZCBpbiB0ZXh0OmAsIHVwZGF0ZUtleUNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgWyR7cmVxdWVzdElkfV0g4pqg77iPIEZhaWxlZCB0byBwYXJzZSBwb3RlbnRpYWwgSlNPTiBjb21tYW5kOmAsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHVwZGF0ZUtleUNvbW1hbmQpIGJyZWFrO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIHRoZSBjb21tYW5kIGlmIHdlIGhhdmUgb25lIChlaXRoZXIgdXBkYXRlX2tleSBvciB0ZXh0IGVkaXRvciBjb21tYW5kKVxuICAgICAgaWYgKHVwZGF0ZUtleUNvbW1hbmQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflIQgUHJvY2Vzc2luZyB1cGRhdGVfa2V5IGNvbW1hbmQuLi5gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfk4ogVXBkYXRlIGRldGFpbHM6IHBhdGg9JHt1cGRhdGVLZXlDb21tYW5kLnBhdGh9LCBhY3Rpb249JHt1cGRhdGVLZXlDb21tYW5kLmFjdGlvbn1gKTtcbiAgICAgICAgXG4gICAgICAgIGxldCB1cGRhdGVkUmVwb3J0ID0geyAuLi5yZXBvcnQgfTtcbiAgICAgICAgbGV0IGFmZmVjdGVkRG9tYWluID0gJyc7XG4gICAgICAgIFxuICAgICAgICAvLyBFeHRyYWN0IGRvbWFpbiBpZiBwYXRoIHN0YXJ0cyB3aXRoIGRvbWFpbnMuWFxuICAgICAgICBpZiAodXBkYXRlS2V5Q29tbWFuZC5wYXRoLnN0YXJ0c1dpdGgoJ2RvbWFpbnMuJykpIHtcbiAgICAgICAgICBjb25zdCBwYXRoUGFydHMgPSB1cGRhdGVLZXlDb21tYW5kLnBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICBpZiAocGF0aFBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBhZmZlY3RlZERvbWFpbiA9IHBhdGhQYXJ0c1sxXTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn46vIEFmZmVjdGVkIGRvbWFpbiBmcm9tIHBhdGg6ICR7YWZmZWN0ZWREb21haW59YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEFwcGx5IHRoZSB1cGRhdGUgYmFzZWQgb24gdGhlIHBhdGggYW5kIGFjdGlvblxuICAgICAgICAgIGNvbnN0IHBhdGhQYXJ0cyA9IHVwZGF0ZUtleUNvbW1hbmQucGF0aC5zcGxpdCgnLicpO1xuICAgICAgICAgIGxldCBjdXJyZW50ID0gdXBkYXRlZFJlcG9ydDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBOYXZpZ2F0ZSB0byB0aGUgcGFyZW50IG9iamVjdCBvZiB0aGUgdGFyZ2V0IHByb3BlcnR5XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoUGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRbcGF0aFBhcnRzW2ldXSkge1xuICAgICAgICAgICAgICAvLyBDcmVhdGUgbWlzc2luZyBvYmplY3RzIGluIHRoZSBwYXRoXG4gICAgICAgICAgICAgIGN1cnJlbnRbcGF0aFBhcnRzW2ldXSA9IHt9O1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+Pl++4jyBDcmVhdGVkIG1pc3Npbmcgb2JqZWN0IGF0ICR7cGF0aFBhcnRzLnNsaWNlKDAsIGkrMSkuam9pbignLicpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGF0aFBhcnRzW2ldXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IHRoZSB0YXJnZXQgcHJvcGVydHkgbmFtZVxuICAgICAgICAgIGNvbnN0IHRhcmdldFByb3AgPSBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFwcGx5IHRoZSBhY3Rpb25cbiAgICAgICAgICBzd2l0Y2ggKHVwZGF0ZUtleUNvbW1hbmQuYWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdhcHBlbmQnOlxuICAgICAgICAgICAgICAvLyBGb3IgYXJyYXlzLCBhcHBlbmQgdGhlIG5ldyB2YWx1ZXNcbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50W3RhcmdldFByb3BdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFt0YXJnZXRQcm9wXSA9IFtdO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGN1cnJlbnRbdGFyZ2V0UHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBhcnJheSBpZiBub3QgYWxyZWFkeVxuICAgICAgICAgICAgICAgIGN1cnJlbnRbdGFyZ2V0UHJvcF0gPSBbY3VycmVudFt0YXJnZXRQcm9wXV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEhhbmRsZSBib3RoIHNpbmdsZSB2YWx1ZSBhbmQgYXJyYXkgb2YgdmFsdWVzXG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHVwZGF0ZUtleUNvbW1hbmQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFt0YXJnZXRQcm9wXSA9IFsuLi5jdXJyZW50W3RhcmdldFByb3BdLCAuLi51cGRhdGVLZXlDb21tYW5kLnZhbHVlXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50W3RhcmdldFByb3BdLnB1c2godXBkYXRlS2V5Q29tbWFuZC52YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgQXBwZW5kZWQgdG8gJHt1cGRhdGVLZXlDb21tYW5kLnBhdGh9LCBuZXcgbGVuZ3RoOiAke2N1cnJlbnRbdGFyZ2V0UHJvcF0ubGVuZ3RofWApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlICdyZXBsYWNlJzpcbiAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgdmFsdWUgZW50aXJlbHlcbiAgICAgICAgICAgICAgY3VycmVudFt0YXJnZXRQcm9wXSA9IHVwZGF0ZUtleUNvbW1hbmQudmFsdWU7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgUmVwbGFjZWQgJHt1cGRhdGVLZXlDb21tYW5kLnBhdGh9YCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGNhc2UgJ21lcmdlJzpcbiAgICAgICAgICAgICAgLy8gRm9yIG9iamVjdHMsIG1lcmdlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50W3RhcmdldFByb3BdIHx8IHR5cGVvZiBjdXJyZW50W3RhcmdldFByb3BdICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KGN1cnJlbnRbdGFyZ2V0UHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFt0YXJnZXRQcm9wXSA9IHt9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjdXJyZW50W3RhcmdldFByb3BdID0geyBcbiAgICAgICAgICAgICAgICAuLi5jdXJyZW50W3RhcmdldFByb3BdLCBcbiAgICAgICAgICAgICAgICAuLi51cGRhdGVLZXlDb21tYW5kLnZhbHVlIFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBNZXJnZWQgaW50byAke3VwZGF0ZUtleUNvbW1hbmQucGF0aH1gKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbJHtyZXF1ZXN0SWR9XSDimqDvuI8gVW5rbm93biBhY3Rpb246ICR7dXBkYXRlS2V5Q29tbWFuZC5hY3Rpb259YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBtZXRhZGF0YVxuICAgICAgICAgIHVwZGF0ZWRSZXBvcnQubWV0YWRhdGEubGFzdFVwZGF0ZWQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgdXBkYXRlZFJlcG9ydC5tZXRhZGF0YS52ZXJzaW9uID0gKHVwZGF0ZWRSZXBvcnQubWV0YWRhdGEudmVyc2lvbiB8fCAwKSArIDE7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBTdWNjZXNzZnVsbHkgYXBwbGllZCB1cGRhdGVfa2V5IGNvbW1hbmRgKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgcmVwb3J0OiB1cGRhdGVkUmVwb3J0LFxuICAgICAgICAgICAgY29tbWFuZDogdXBkYXRlS2V5Q29tbWFuZCxcbiAgICAgICAgICAgIGFmZmVjdGVkRG9tYWluXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7cmVxdWVzdElkfV0g4p2MIEVycm9yIGFwcGx5aW5nIHVwZGF0ZV9rZXkgY29tbWFuZDpgLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIGFwcGx5IHVwZGF0ZV9rZXkgY29tbWFuZCcsXG4gICAgICAgICAgICBkZXRhaWxzOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyxcbiAgICAgICAgICAgIGNvbW1hbmQ6IHVwZGF0ZUtleUNvbW1hbmRcbiAgICAgICAgICB9LCB7IHN0YXR1czogNDAwIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGZpbmFsQ29tbWFuZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UhCBQcm9jZXNzaW5nICR7ZmluYWxDb21tYW5kLmNvbW1hbmR9IGNvbW1hbmQuLi5gKTtcbiAgICAgICAgLy8gR2V0IENsYXVkZSdzIGFuYWx5c2lzIG9mIHdoaWNoIGRvbWFpbi9zZWN0aW9uIHRvIHVwZGF0ZVxuICAgICAgICBsZXQgYWZmZWN0ZWREb21haW4gPSAnJztcbiAgICAgICAgbGV0IHVwZGF0ZWRSZXBvcnQgPSB7IC4uLnJlcG9ydCB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKHNlY3Rpb25Ub1VwZGF0ZSA9PT0gJ2F1dG8tZGV0ZWN0Jykge1xuICAgICAgICAgIC8vIEV4dHJhY3QgZG9tYWluIGZyb20gQ2xhdWRlJ3MgcmVzcG9uc2UgdGV4dFxuICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gY2xhdWRlUmVzcG9uc2UuY29udGVudFxuICAgICAgICAgICAgLmZpbHRlcigoYmxvY2s6IGFueSkgPT4gYmxvY2sudHlwZSA9PT0gJ3RleHQnKVxuICAgICAgICAgICAgLm1hcCgoYmxvY2s6IGFueSkgPT4gYmxvY2sudGV4dClcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBFeHRyYWN0IGRvbWFpbiBmcm9tIHRleHQgLSBsb29rIGZvciBzcGVjaWZpYyBwYXR0ZXJucyBsaWtlIFwicHJhZ21hdGljIGRvbWFpblwiIG9yIFwidXBkYXRlIHRoZSBwcmFnbWF0aWNcIlxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SNIEFuYWx5emluZyB0ZXh0IGZvciBkb21haW4ga2V5d29yZHMuLi5gKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBMaXN0IG9mIGRvbWFpbiBrZXl3b3JkcyB0byBzZWFyY2ggZm9yXG4gICAgICAgICAgY29uc3QgZG9tYWluS2V5d29yZHMgPSBbJ3JlY2VwdGl2ZScsICdleHByZXNzaXZlJywgJ3ByYWdtYXRpYycsICdhcnRpY3VsYXRpb24nLCAndm9pY2UnLCAnZmx1ZW5jeSddO1xuICAgICAgICAgIGxldCBmb3VuZERvbWFpbiA9ICcnO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZpcnN0IGxvb2sgZm9yIHRoZSBwYXRoIHBhdHRlcm4gaW4gSlNPTiBjb21tYW5kc1xuICAgICAgICAgIGNvbnN0IHBhdGhSZWdleCA9IC9cInBhdGhcIjpcXHMqXCJhc3Nlc3NtZW50UmVzdWx0c1xcLmRvbWFpbnNcXC4oW14uXCJdKylcIi87XG4gICAgICAgICAgY29uc3QgcGF0aE1hdGNoID0gdGV4dENvbnRlbnQubWF0Y2gocGF0aFJlZ2V4KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocGF0aE1hdGNoICYmIHBhdGhNYXRjaFsxXSkge1xuICAgICAgICAgICAgZm91bmREb21haW4gPSBwYXRoTWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBGb3VuZCBkb21haW4gaW4gSlNPTiBwYXRoOiBcIiR7Zm91bmREb21haW59XCJgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGRvbWFpbiBrZXl3b3JkcyBpbiB0aGUgdGV4dFxuICAgICAgICAgICAgZm9yIChjb25zdCBkb21haW4gb2YgZG9tYWluS2V5d29yZHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoYFxcXFxiJHtkb21haW59XFxcXGJgLCAnaScpO1xuICAgICAgICAgICAgICBpZiAocGF0dGVybi50ZXN0KHRleHRDb250ZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SNIEZvdW5kIGRvbWFpbiBrZXl3b3JkIGluIHRleHQ6IFwiJHtkb21haW59XCJgKTtcbiAgICAgICAgICAgICAgICBmb3VuZERvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBhZmZlY3RlZERvbWFpbiA9IGZvdW5kRG9tYWluO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SNIEF1dG8tZGV0ZWN0ZWQgZG9tYWluOiAke2FmZmVjdGVkRG9tYWluIHx8ICdub25lIGRldGVjdGVkJ31gKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+TnSBUZXh0IGNvbnRlbnQgZm9yIGRvbWFpbiBkZXRlY3Rpb246YCwgdGV4dENvbnRlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlY3Rpb25Ub1VwZGF0ZS5zdGFydHNXaXRoKCdhc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zLicpKSB7XG4gICAgICAgICAgYWZmZWN0ZWREb21haW4gPSBzZWN0aW9uVG9VcGRhdGUuc3BsaXQoJy4nKVsyXTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+OryBVc2luZyBzcGVjaWZpZWQgZG9tYWluOiAke2FmZmVjdGVkRG9tYWlufWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoZmluYWxDb21tYW5kLmNvbW1hbmQgPT09ICdzdHJfcmVwbGFjZScpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UhCBQcm9jZXNzaW5nIHN0cl9yZXBsYWNlIGNvbW1hbmQuLi5gKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pqg77iPIE5vdGU6IHN0cl9yZXBsYWNlIGlzIGJlaW5nIHVzZWQgaW5zdGVhZCBvZiB0aGUgcmVjb21tZW5kZWQgdXBkYXRlX2tleSBjb21tYW5kYCk7XG4gICAgICAgICAgbGV0IHVwZGF0ZWRDb250ZW50ID0gJyc7XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBjaGVjayBpZiB0aGUgc3RyX3JlcGxhY2UgY29tbWFuZCBpcyB0YXJnZXRpbmcgYSBzcGVjaWZpYyBkb21haW5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGV0ZWN0IHRoaXMgYnkgc2VlaW5nIGlmIHRoZSBvbGRfc3RyIGNvbnRhaW5zIHNwZWNpZmljIGRvbWFpbiBKU09OXG4gICAgICAgICAgICBjb25zdCBzdHJDb250YWluc0RvbWFpblBhdHRlcm4gPSBPYmplY3Qua2V5cyhyZXBvcnQuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWlucykuc29tZShkb21haW4gPT4ge1xuICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gYFwiJHtkb21haW59XCI6XFxcXHMqe2A7XG4gICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnaScpO1xuICAgICAgICAgICAgICByZXR1cm4gcmVnZXgudGVzdChmaW5hbENvbW1hbmQub2xkX3N0ciB8fCAnJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflI0gQ29tbWFuZCBjb250YWlucyBkb21haW4gcGF0dGVybiBpbiBvbGRfc3RyOiAke3N0ckNvbnRhaW5zRG9tYWluUGF0dGVybn1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgd2UndmUgYXV0by1kZXRlY3RlZCBhIGRvbWFpbiBhbmQgaXQgZXhpc3RzIGluIHRoZSByZXBvcnRcbiAgICAgICAgICAgIGlmIChhZmZlY3RlZERvbWFpbiAmJiByZXBvcnQuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWluc1thZmZlY3RlZERvbWFpbl0pIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflIQgVXBkYXRpbmcgc3BlY2lmaWMgZG9tYWluOiAke2FmZmVjdGVkRG9tYWlufWApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgQ2xhdWRlJ3Mgc3RyX3JlcGxhY2UgaXMgZGlyZWN0bHkgdGFyZ2V0aW5nIHRoaXMgZG9tYWluIHNlY3Rpb25cbiAgICAgICAgICAgICAgaWYgKGZpbmFsQ29tbWFuZC5vbGRfc3RyICYmIGZpbmFsQ29tbWFuZC5vbGRfc3RyLmluY2x1ZGVzKGBcIiR7YWZmZWN0ZWREb21haW59XCJgKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn46vIERpcmVjdCBtYXRjaDogQ2xhdWRlJ3MgY29tbWFuZCB0YXJnZXRzICR7YWZmZWN0ZWREb21haW59IGRvbWFpbmApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEltcGxlbWVudCBhIG1vcmUgY2FyZWZ1bCBzZWFyY2ggYW5kIHJlcGxhY2UgZm9yIHRoZSBzcGVjaWZpYyBkb21haW5cbiAgICAgICAgICAgICAgICAvLyBTdGFydCB3aXRoIHRoZSBmdWxsIHJlcG9ydCBKU09OXG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbFJlcG9ydEpzb24gPSBKU09OLnN0cmluZ2lmeShyZXBvcnQsIG51bGwsIDIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGRvbWFpbiBzZWN0aW9uIGluIHRoZSBKU09OXG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluUGF0dGVybiA9IG5ldyBSZWdFeHAoYChcXFxccypcIiR7YWZmZWN0ZWREb21haW59XCJcXFxccyo6XFxcXHMqe1tefV0qfSlgLCAncycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbk1hdGNoID0gZnVsbFJlcG9ydEpzb24ubWF0Y2goZG9tYWluUGF0dGVybik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbk1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pyFIEZvdW5kIGRvbWFpbiBzZWN0aW9uIGluIEpTT05gKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBqdXN0IHRoZSBkb21haW4gc2VjdGlvblxuICAgICAgICAgICAgICAgICAgdXBkYXRlZENvbnRlbnQgPSBmdWxsUmVwb3J0SnNvbi5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICBkb21haW5NYXRjaFswXSwgXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsQ29tbWFuZC5uZXdfc3RyLnRyaW0oKVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGNvbXBsZXRlIHVwZGF0ZWQgcmVwb3J0XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRSZXBvcnQgPSBKU09OLnBhcnNlKHVwZGF0ZWRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBTdWNjZXNzZnVsbHkgcmVwbGFjZWQgZG9tYWluIHNlY3Rpb24gaW4gZnVsbCByZXBvcnRgKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7cmVxdWVzdElkfV0g4p2MIEpTT04gcGFyc2UgZXJyb3IgYWZ0ZXIgZG9tYWluIHJlcGxhY2VtZW50OmAsIHBhcnNlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gdXBkYXRpbmcganVzdCB0aGUgZG9tYWluIHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9tYWluU2VjdGlvbiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbYWZmZWN0ZWREb21haW5dKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpbkpzb24gPSBKU09OLnN0cmluZ2lmeShkb21haW5TZWN0aW9uLCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QganVzdCB0aGUgZG9tYWluIG9iamVjdCBmcm9tIENsYXVkZSdzIG5ld19zdHJcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkb21haW5PYmplY3RNYXRjaCA9IGZpbmFsQ29tbWFuZC5uZXdfc3RyLm1hdGNoKC97XFxzKlwidG9waWNTZW50ZW5jZVwiLip9L3MpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5PYmplY3RNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3RG9tYWluU2VjdGlvbiA9IEpTT04ucGFyc2UoZG9tYWluT2JqZWN0TWF0Y2hbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFJlcG9ydCA9IHVwZGF0ZURvbWFpblNlY3Rpb24ocmVwb3J0LCBhZmZlY3RlZERvbWFpbiwgbmV3RG9tYWluU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pyFIEZhbGxiYWNrOiBVcGRhdGVkIGRvbWFpbiBzZWN0aW9uIHZpYSBleHRyYWN0aW9uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGV4dHJhY3QgZG9tYWluIG9iamVjdCBmcm9tIG5ld19zdHInKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4dHJhY3RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske3JlcXVlc3RJZH1dIOKdjCBGYWlsZWQgdG8gZXh0cmFjdCBkb21haW4gb2JqZWN0OmAsIGV4dHJhY3RFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAnRmFpbGVkIHRvIHVwZGF0ZSByZXBvcnQgLSBpbnZhbGlkIEpTT04gZm9ybWF0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvcjogcGFyc2VFcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0RXJyb3I6IGV4dHJhY3RFcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtyZXF1ZXN0SWR9XSDinYwgQ291bGQgbm90IGZpbmQgZG9tYWluIHNlY3Rpb24gaW4gSlNPTmApO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byB1cGRhdGluZyB2aWEgZG9tYWluIG9iamVjdFxuICAgICAgICAgICAgICAgICAgY29uc3QgZG9tYWluU2VjdGlvbiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbYWZmZWN0ZWREb21haW5dKSk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+TiiBPcmlnaW5hbCBkb21haW4gc2VjdGlvbjpgLCBkb21haW5TZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29uc3RydWN0IGFuIHVwZGF0ZWQgZG9tYWluIHNlY3Rpb24gYmFzZWQgb24gdGhlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhY3RlZENvbnRlbnQgPSB7fTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgdG9waWMgc2VudGVuY2VcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHRzTWF0Y2ggPSBmaW5hbENvbW1hbmQubmV3X3N0ci5tYXRjaCgvXCJ0b3BpY1NlbnRlbmNlXCI6XFxzKlwiKFteXCJdKilcIi8pO1xuICAgICAgICAgICAgICAgICAgaWYgKHRzTWF0Y2gpIGV4dHJhY3RlZENvbnRlbnRbJ3RvcGljU2VudGVuY2UnXSA9IHRzTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBleHRyYWN0IGV2aWRlbmNlIChzaW1wbGlmaWVkKVxuICAgICAgICAgICAgICAgICAgY29uc3QgZXZpZGVuY2VNYXRjaCA9IGZpbmFsQ29tbWFuZC5uZXdfc3RyLm1hdGNoKC9cImV2aWRlbmNlXCI6XFxzKlxcWyguKj8pXFxdL3MpO1xuICAgICAgICAgICAgICAgICAgaWYgKGV2aWRlbmNlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0ZWRDb250ZW50WydldmlkZW5jZSddID0gSlNPTi5wYXJzZShgWyR7ZXZpZGVuY2VNYXRjaFsxXX1dYCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFske3JlcXVlc3RJZH1dIOKaoO+4jyBDb3VsZCBub3QgcGFyc2UgZXZpZGVuY2VgLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZXh0cmFjdCBjaGFsbGVuZ2VzIChzaW1wbGlmaWVkKVxuICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbGxlbmdlc01hdGNoID0gZmluYWxDb21tYW5kLm5ld19zdHIubWF0Y2goL1wiY2hhbGxlbmdlc1wiOlxccypcXFsoLio/KVxcXS9zKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFsbGVuZ2VzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYWN0ZWRDb250ZW50WydjaGFsbGVuZ2VzJ10gPSBKU09OLnBhcnNlKGBbJHtjaGFsbGVuZ2VzTWF0Y2hbMV19XWApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbJHtyZXF1ZXN0SWR9XSDimqDvuI8gQ291bGQgbm90IHBhcnNlIGNoYWxsZW5nZXNgLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGRvbWFpbiB3aXRoIHRoZSBleHRyYWN0ZWQgY29udGVudFxuICAgICAgICAgICAgICAgICAgdXBkYXRlZFJlcG9ydCA9IHVwZGF0ZURvbWFpblNlY3Rpb24ocmVwb3J0LCBhZmZlY3RlZERvbWFpbiwgZXh0cmFjdGVkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pyFIFVzZWQgZXh0cmFjdGlvbiB0byB1cGRhdGUgZG9tYWluIHNlY3Rpb25gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhbmRhcmQgZG9tYWluIHNlY3Rpb24gdXBkYXRlXG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluU2VjdGlvbiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbYWZmZWN0ZWREb21haW5dKSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfk4ogT3JpZ2luYWwgZG9tYWluIHNlY3Rpb246YCwgZG9tYWluU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflIQgQXBwbHlpbmcgc3RyX3JlcGxhY2U6YCwge1xuICAgICAgICAgICAgICAgICAgb2xkX3N0cl9sZW5ndGg6IGZpbmFsQ29tbWFuZC5vbGRfc3RyPy5sZW5ndGggfHwgMCxcbiAgICAgICAgICAgICAgICAgIG5ld19zdHJfbGVuZ3RoOiBmaW5hbENvbW1hbmQubmV3X3N0cj8ubGVuZ3RoIHx8IDBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGEgZ2VuZXJhbCByZXBsYWNlLCB3ZSdsbCB0cnkgdG8gaW1wcm92ZSB0aGUgZG9tYWluIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsQ29tbWFuZC5uZXdfc3RyICYmIGZpbmFsQ29tbWFuZC5uZXdfc3RyLmluY2x1ZGVzKCdcInRvcGljU2VudGVuY2VcIicpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZXh0cmFjdCBKU09OIHN0cnVjdHVyZSBmcm9tIHRoZSBuZXcgc3RyaW5nXG4gICAgICAgICAgICAgICAgICBjb25zdCBqc29uTWF0Y2ggPSBmaW5hbENvbW1hbmQubmV3X3N0ci5tYXRjaCgvKHtbXFxzXFxTXSp9KS8pO1xuICAgICAgICAgICAgICAgICAgaWYgKGpzb25NYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBKU09OIGZyb20gdGhlIG5ldyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkRG9tYWluU2VjdGlvbiA9IEpTT04ucGFyc2UoanNvbk1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNwZWNpZmljIGRvbWFpbiBpbiB0aGUgcmVwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFJlcG9ydCA9IHVwZGF0ZURvbWFpblNlY3Rpb24ocmVwb3J0LCBhZmZlY3RlZERvbWFpbiwgdXBkYXRlZERvbWFpblNlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgU3VjY2Vzc2Z1bGx5IGV4dHJhY3RlZCBhbmQgdXBkYXRlZCBkb21haW4gSlNPTmApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChqc29uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtyZXF1ZXN0SWR9XSDinYwgRXJyb3IgcGFyc2luZyBleHRyYWN0ZWQgSlNPTjpgLCBqc29uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHN0YW5kYXJkIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZENvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShkb21haW5TZWN0aW9uKS5yZXBsYWNlKGZpbmFsQ29tbWFuZC5vbGRfc3RyIHx8ICcnLCBmaW5hbENvbW1hbmQubmV3X3N0ciB8fCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZERvbWFpblNlY3Rpb24gPSBKU09OLnBhcnNlKHVwZGF0ZWRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkUmVwb3J0ID0gdXBkYXRlRG9tYWluU2VjdGlvbihyZXBvcnQsIGFmZmVjdGVkRG9tYWluLCB1cGRhdGVkRG9tYWluU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIEpTT04gc3RydWN0dXJlIGZvdW5kLCB1c2Ugc3RhbmRhcmQgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZENvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShkb21haW5TZWN0aW9uKS5yZXBsYWNlKGZpbmFsQ29tbWFuZC5vbGRfc3RyIHx8ICcnLCBmaW5hbENvbW1hbmQubmV3X3N0ciB8fCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWREb21haW5TZWN0aW9uID0gSlNPTi5wYXJzZSh1cGRhdGVkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRSZXBvcnQgPSB1cGRhdGVEb21haW5TZWN0aW9uKHJlcG9ydCwgYWZmZWN0ZWREb21haW4sIHVwZGF0ZWREb21haW5TZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gU3RhbmRhcmQgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoZG9tYWluU2VjdGlvbikucmVwbGFjZShmaW5hbENvbW1hbmQub2xkX3N0ciB8fCAnJywgZmluYWxDb21tYW5kLm5ld19zdHIgfHwgJycpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZERvbWFpblNlY3Rpb24gPSBKU09OLnBhcnNlKHVwZGF0ZWRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRSZXBvcnQgPSB1cGRhdGVEb21haW5TZWN0aW9uKHJlcG9ydCwgYWZmZWN0ZWREb21haW4sIHVwZGF0ZWREb21haW5TZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBEb21haW4gc2VjdGlvbiB1cGRhdGVkIHN1Y2Nlc3NmdWxseWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0ckNvbnRhaW5zRG9tYWluUGF0dGVybikge1xuICAgICAgICAgICAgICAvLyBXZSBkZXRlY3RlZCBhIGRvbWFpbiBwYXR0ZXJuIGluIHRoZSBzdHJfcmVwbGFjZSBjb21tYW5kLCBzbyB0cnkgdG8gZXh0cmFjdCB0aGUgZG9tYWluIG5hbWVcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflI4gVHJ5aW5nIHRvIGV4dHJhY3QgZG9tYWluIGZyb20gc3RyX3JlcGxhY2UgY29tbWFuZC4uLmApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgbGV0IGV4dHJhY3RlZERvbWFpbiA9ICcnO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRvbWFpbiBvZiBPYmplY3Qua2V5cyhyZXBvcnQuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWlucykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxDb21tYW5kLm9sZF9zdHI/LmluY2x1ZGVzKGBcIiR7ZG9tYWlufVwiYCkpIHtcbiAgICAgICAgICAgICAgICAgIGV4dHJhY3RlZERvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKGV4dHJhY3RlZERvbWFpbikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SNIEV4dHJhY3RlZCBkb21haW4gZnJvbSBjb21tYW5kOiAke2V4dHJhY3RlZERvbWFpbn1gKTtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZERvbWFpbiA9IGV4dHJhY3RlZERvbWFpbjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBOb3cgdXBkYXRlIHVzaW5nIHRoZSBmdWxsIHJlcG9ydCB1cGRhdGUsIHRoZW4gcmUtcHJvY2VzcyB3aXRoIHRoZSBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocmVwb3J0LCBudWxsLCAyKS5yZXBsYWNlKGZpbmFsQ29tbWFuZC5vbGRfc3RyIHx8ICcnLCBmaW5hbENvbW1hbmQubmV3X3N0ciB8fCAnJyk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRSZXBvcnQgPSBKU09OLnBhcnNlKHVwZGF0ZWRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgVXBkYXRlZCByZXBvcnQgd2l0aCBleHRyYWN0ZWQgZG9tYWluOiAke2V4dHJhY3RlZERvbWFpbn1gKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtyZXF1ZXN0SWR9XSDinYwgUGFyc2UgZXJyb3Igd2l0aCBleHRyYWN0ZWQgZG9tYWluIHVwZGF0ZTpgLCBwYXJzZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8ganVzdCB1cGRhdGluZyB0aGUgZG9tYWluIHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpblNlY3Rpb24gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlcG9ydC5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zW2V4dHJhY3RlZERvbWFpbl0pKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWREb21haW5TZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5kb21haW5TZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICB0b3BpY1NlbnRlbmNlOiBmaW5hbENvbW1hbmQubmV3X3N0ci5tYXRjaCgvXCJ0b3BpY1NlbnRlbmNlXCI6XFxzKlwiKFteXCJdKilcIi8pPy5bMV0gfHwgZG9tYWluU2VjdGlvbi50b3BpY1NlbnRlbmNlLFxuICAgICAgICAgICAgICAgICAgICBldmlkZW5jZTogWy4uLihkb21haW5TZWN0aW9uLmV2aWRlbmNlIHx8IFtdKSwgbm9ybWFsaXplZElucHV0XVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRSZXBvcnQgPSB1cGRhdGVEb21haW5TZWN0aW9uKHJlcG9ydCwgZXh0cmFjdGVkRG9tYWluLCB1cGRhdGVkRG9tYWluU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBmdWxsIHJlcG9ydCB1cGRhdGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UhCBVcGRhdGluZyBlbnRpcmUgcmVwb3J0IChkb21haW4gcGF0dGVybiBmb3VuZCBidXQgY291bGRuJ3QgZXh0cmFjdCBkb21haW4pYCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlZENvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShyZXBvcnQsIG51bGwsIDIpLnJlcGxhY2UoZmluYWxDb21tYW5kLm9sZF9zdHIgfHwgJycsIGZpbmFsQ29tbWFuZC5uZXdfc3RyIHx8ICcnKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkUmVwb3J0ID0gSlNPTi5wYXJzZSh1cGRhdGVkQ29udGVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZvciB3aG9sZSByZXBvcnQgdXBkYXRlcyBvciBvdGhlciBzZWN0aW9uc1xuICAgICAgICAgICAgICBpZiAoc2VjdGlvblRvVXBkYXRlID09PSAnYXV0by1kZXRlY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflIQgVXBkYXRpbmcgZW50aXJlIHJlcG9ydCAobm8gc3BlY2lmaWMgZG9tYWluIGlkZW50aWZpZWQpYCk7XG4gICAgICAgICAgICAgICAgLy8gRnVsbCByZXBvcnQgdXBkYXRlXG4gICAgICAgICAgICAgICAgdXBkYXRlZENvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShyZXBvcnQsIG51bGwsIDIpLnJlcGxhY2UoZmluYWxDb21tYW5kLm9sZF9zdHIgfHwgJycsIGZpbmFsQ29tbWFuZC5uZXdfc3RyIHx8ICcnKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkUmVwb3J0ID0gSlNPTi5wYXJzZSh1cGRhdGVkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBGdWxsIHJlcG9ydCB1cGRhdGVkIHN1Y2Nlc3NmdWxseWApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SEIFVwZGF0aW5nIHNwZWNpZmljIG5vbi1kb21haW4gc2VjdGlvbjogJHtzZWN0aW9uVG9VcGRhdGV9YCk7XG4gICAgICAgICAgICAgICAgLy8gU3BlY2lmaWMgbm9uLWRvbWFpbiBzZWN0aW9uIHVwZGF0ZVxuICAgICAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50ID0gdmlld0NvbnRlbnQucmVwbGFjZShmaW5hbENvbW1hbmQub2xkX3N0ciB8fCAnJywgZmluYWxDb21tYW5kLm5ld19zdHIgfHwgJycpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgc2ltcGxpZmllZDsgeW91J2QgbmVlZCB0byBtZXJnZSB0aGlzIGludG8gdGhlIHJpZ2h0IHNlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBiYXNlZCBvbiB0aGUgc2VjdGlvblRvVXBkYXRlIHBhdGhcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdXBkYXRlZFJlcG9ydCA9IHsgLi4ucmVwb3J0IH07XG4gICAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGF0aC1iYXNlZCBzZXR0ZXIgKHdvdWxkIG5lZWQgYSBtb3JlIHJvYnVzdCB2ZXJzaW9uIGluIHByb2R1Y3Rpb24pXG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXRoUGFydHMgPSBzZWN0aW9uVG9VcGRhdGUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdXBkYXRlZFJlcG9ydDtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aFBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoUGFydHNbaV1dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY3VycmVudFtwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIDFdXSA9IEpTT04ucGFyc2UodXBkYXRlZENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBTcGVjaWZpYyBzZWN0aW9uIHVwZGF0ZWQgc3VjY2Vzc2Z1bGx5OiAke3NlY3Rpb25Ub1VwZGF0ZX1gKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtyZXF1ZXN0SWR9XSDinYwgRXJyb3IgdXBkYXRpbmcgc3BlY2lmaWMgcGF0aDpgLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtyZXF1ZXN0SWR9XSDinYwgRXJyb3IgcGFyc2luZyB1cGRhdGVkIEpTT046YCwgcGFyc2VFcnJvcik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+TiyBQcm9ibGVtIGNvbnRlbnQ6YCwgdXBkYXRlZENvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEpTT04gcHJvZHVjZWQgYnkgdGV4dCBlZGl0b3IgY29tbWFuZCcsXG4gICAgICAgICAgICAgIG9yaWdpbmFsQ29tbWFuZDogZmluYWxDb21tYW5kLFxuICAgICAgICAgICAgICBwYXJzZUVycm9yOiBwYXJzZUVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBtZXRhZGF0YVxuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsVGltZXN0YW1wID0gdXBkYXRlZFJlcG9ydC5tZXRhZGF0YS5sYXN0VXBkYXRlZDtcbiAgICAgICAgICB1cGRhdGVkUmVwb3J0Lm1ldGFkYXRhLmxhc3RVcGRhdGVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgIHVwZGF0ZWRSZXBvcnQubWV0YWRhdGEudmVyc2lvbiA9ICh1cGRhdGVkUmVwb3J0Lm1ldGFkYXRhLnZlcnNpb24gfHwgMCkgKyAxO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5OKIE1ldGFkYXRhIHVwZGF0ZWQ6YCwgeyBcbiAgICAgICAgICAgIG9sZFRpbWVzdGFtcDogb3JpZ2luYWxUaW1lc3RhbXAsXG4gICAgICAgICAgICBuZXdUaW1lc3RhbXA6IHVwZGF0ZWRSZXBvcnQubWV0YWRhdGEubGFzdFVwZGF0ZWQsXG4gICAgICAgICAgICBuZXdWZXJzaW9uOiB1cGRhdGVkUmVwb3J0Lm1ldGFkYXRhLnZlcnNpb24gXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBSZXBvcnQgdXBkYXRlIGNvbXBsZXRlLCByZXR1cm5pbmcgcmVzcG9uc2VgKTtcbiAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgcmVwb3J0OiB1cGRhdGVkUmVwb3J0LFxuICAgICAgICAgICAgY29tbWFuZDogZmluYWxDb21tYW5kLFxuICAgICAgICAgICAgYWZmZWN0ZWREb21haW5cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChmaW5hbENvbW1hbmQuY29tbWFuZCA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pqg77iPIEluc2VydCBjb21tYW5kIG5vdCBmdWxseSBpbXBsZW1lbnRlZGApO1xuICAgICAgICAgIC8vIEhhbmRsZSBpbnNlcnQgY29tbWFuZCAtIHRoaXMgd291bGQgYmUgbW9yZSBjb21wbGV4IGFuZCBkZXBlbmRzIG9uIHlvdXIgc3BlY2lmaWMgbmVlZHNcbiAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSBpbiB0aGlzIGRlbW8sIHdlJ2xsIGp1c3QgYWNrbm93bGVkZ2UgaXRcbiAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgcmVwb3J0LFxuICAgICAgICAgICAgZXJyb3I6ICdJbnNlcnQgY29tbWFuZCBub3QgZnVsbHkgaW1wbGVtZW50ZWQgeWV0JyxcbiAgICAgICAgICAgIGNvbW1hbmQ6IGZpbmFsQ29tbWFuZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIG5vIHRvb2wgY29tbWFuZCBmb3VuZCwgcmV0dXJuIHRoZSBvcmlnaW5hbCByZXBvcnRcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDimqDvuI8gTm8gdG9vbCBjb21tYW5kIGZvdW5kIGluIENsYXVkZSdzIHJlc3BvbnNlLCByZXR1cm5pbmcgb3JpZ2luYWwgcmVwb3J0YCk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICByZXBvcnQsXG4gICAgICAgIGVycm9yOiAnQ2xhdWRlIGRpZCBub3QgcHJvdmlkZSBhIEpTT04gdXBkYXRlIGNvbW1hbmQnXG4gICAgICB9KTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGFwaUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbJHtyZXF1ZXN0SWR9XSDinYwgRXJyb3IgY2FsbGluZyBDbGF1ZGUgQVBJOmAsIGFwaUVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2sgZm9yIHRlc3Rpbmcgd2l0aG91dCBBUElcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDimqDvuI8gVXNpbmcgZmFsbGJhY2sgbW9kZSBmb3IgdGVzdGluZ2ApO1xuICAgICAgY29uc3QgdXBkYXRlZFJlcG9ydCA9IHsgLi4ucmVwb3J0IH07XG4gICAgICBcbiAgICAgIC8vIFNpbXBsZSBkb21haW4gZGV0ZWN0aW9uIGJhc2VkIG9uIGtleXdvcmRzXG4gICAgICBjb25zdCBpbnB1dExvd2VyID0gaW5wdXQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGxldCB0YXJnZXREb21haW4gPSAnYXJ0aWN1bGF0aW9uJztcbiAgICAgIFxuICAgICAgaWYgKGlucHV0TG93ZXIuaW5jbHVkZXMoJ3VuZGVyc3RhbmQnKSB8fCBpbnB1dExvd2VyLmluY2x1ZGVzKCdmb2xsb3cnKSB8fCBpbnB1dExvd2VyLmluY2x1ZGVzKCdkaXJlY3Rpb24nKSkge1xuICAgICAgICB0YXJnZXREb21haW4gPSAncmVjZXB0aXZlJztcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRMb3dlci5pbmNsdWRlcygnZXhwcmVzcycpIHx8IGlucHV0TG93ZXIuaW5jbHVkZXMoJ3ZvY2FidWxhcnknKSB8fCBpbnB1dExvd2VyLmluY2x1ZGVzKCdzZW50ZW5jZScpKSB7XG4gICAgICAgIHRhcmdldERvbWFpbiA9ICdleHByZXNzaXZlJztcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRMb3dlci5pbmNsdWRlcygnc29jaWFsJykgfHwgaW5wdXRMb3dlci5pbmNsdWRlcygnZXllIGNvbnRhY3QnKSB8fCBpbnB1dExvd2VyLmluY2x1ZGVzKCdwZWVyJykpIHtcbiAgICAgICAgdGFyZ2V0RG9tYWluID0gJ3ByYWdtYXRpYyc7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0TG93ZXIuaW5jbHVkZXMoJ3NvdW5kJykgfHwgaW5wdXRMb3dlci5pbmNsdWRlcygncHJvbm91bmNlJykgfHwgaW5wdXRMb3dlci5pbmNsdWRlcygnaW50ZWxsaWdpYmxlJykpIHtcbiAgICAgICAgdGFyZ2V0RG9tYWluID0gJ2FydGljdWxhdGlvbic7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SNIEZhbGxiYWNrIGRldGVjdGVkIGRvbWFpbjogJHt0YXJnZXREb21haW59YCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHNpbXVsYXRlZCB1cGRhdGVcbiAgICAgIGNvbnN0IHVwZGF0ZXM6IFBhcnRpYWw8RG9tYWluU2VjdGlvbj4gPSB7XG4gICAgICAgIHN0cmVuZ3RoczogW2lucHV0XVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgaWYgKCF1cGRhdGVkUmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbdGFyZ2V0RG9tYWluXS50b3BpY1NlbnRlbmNlKSB7XG4gICAgICAgIHVwZGF0ZXMudG9waWNTZW50ZW5jZSA9IGBTdHVkZW50IGRlbW9uc3RyYXRlcyBjaGFsbGVuZ2VzIGluICR7dGFyZ2V0RG9tYWlufSBsYW5ndWFnZSBza2lsbHMuYDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc2ltdWxhdGVkUmVwb3J0ID0gdXBkYXRlRG9tYWluU2VjdGlvbih1cGRhdGVkUmVwb3J0LCB0YXJnZXREb21haW4sIHVwZGF0ZXMpO1xuICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBTaW11bGF0ZWQgdXBkYXRlIGFwcGxpZWQgdG8gZG9tYWluOiAke3RhcmdldERvbWFpbn1gKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgcmVwb3J0OiBzaW11bGF0ZWRSZXBvcnQsXG4gICAgICAgIGFwaUVycm9yOiBhcGlFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gYXBpRXJyb3IubWVzc2FnZSA6ICdBUEkgY2FsbCBmYWlsZWQnLFxuICAgICAgICBzaW11bGF0ZWQ6IHRydWUsXG4gICAgICAgIGFmZmVjdGVkRG9tYWluOiB0YXJnZXREb21haW5cbiAgICAgIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBbJHtyZXF1ZXN0SWR9XSDinYwgRXJyb3IgcHJvY2Vzc2luZyB0ZXh0IGVkaXRvciByZXF1ZXN0OmAsIGVycm9yKTtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXG4gICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIHByb2Nlc3MgdGhlIHJlcXVlc3QnLCBkZXRhaWxzOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyB9LFxuICAgICAgeyBzdGF0dXM6IDUwMCB9XG4gICAgKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+PgSBSRVFVRVNUIENPTVBMRVRFRDogVGV4dCBFZGl0b3IgQVBJYCk7XG4gIH1cbn0iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwibm9ybWFsaXplSW5wdXQiLCJpbnB1dCIsInRleHQiLCJwZGZEYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZVJlcG9ydFNrZWxldG9uIiwiaGVhZGVyIiwic3R1ZGVudEluZm9ybWF0aW9uIiwiZmlyc3ROYW1lIiwibGFzdE5hbWUiLCJET0IiLCJyZXBvcnREYXRlIiwiZXZhbHVhdGlvbkRhdGUiLCJwYXJlbnRzIiwiaG9tZUxhbmd1YWdlIiwicmVhc29uRm9yUmVmZXJyYWwiLCJjb25maWRlbnRpYWxpdHlTdGF0ZW1lbnQiLCJiYWNrZ3JvdW5kIiwic3R1ZGVudERlbW9ncmFwaGljc0FuZEJhY2tncm91bmQiLCJlZHVjYXRpb25hbEhpc3RvcnkiLCJoZWFsdGhSZXBvcnQiLCJtZWRpY2FsSGlzdG9yeSIsInZpc2lvbkFuZEhlYXJpbmdTY3JlZW5pbmciLCJtZWRpY2F0aW9uc0FuZEFsbGVyZ2llcyIsImVhcmx5SW50ZXJ2ZW50aW9uSGlzdG9yeSIsImZhbWlseUhpc3RvcnkiLCJmYW1pbHlTdHJ1Y3R1cmUiLCJsYW5ndWFnZUFuZEN1bHR1cmFsQmFja2dyb3VuZCIsInNvY2lvZWNvbm9taWNGYWN0b3JzIiwicGFyZW50R3VhcmRpYW5Db25jZXJucyIsImFzc2Vzc21lbnRSZXN1bHRzIiwib2JzZXJ2YXRpb25zIiwiY2xhc3Nyb29tT2JzZXJ2YXRpb25zIiwicGxheUJhc2VkSW5mb3JtYWxPYnNlcnZhdGlvbnMiLCJzb2NpYWxJbnRlcmFjdGlvbk9ic2VydmF0aW9ucyIsImFzc2Vzc21lbnRQcm9jZWR1cmVzQW5kVG9vbHMiLCJvdmVydmlld09mQXNzZXNzbWVudE1ldGhvZHMiLCJhc3Nlc3NtZW50VG9vbHNVc2VkIiwiZG9tYWlucyIsInJlY2VwdGl2ZSIsImlzQ29uY2VybiIsInRvcGljU2VudGVuY2UiLCJzdHJlbmd0aHMiLCJuZWVkcyIsImltcGFjdFN0YXRlbWVudCIsImV4cHJlc3NpdmUiLCJwcmFnbWF0aWMiLCJhcnRpY3VsYXRpb24iLCJ2b2ljZSIsImZsdWVuY3kiLCJjb25jbHVzaW9uIiwiZWxpZ2liaWxpdHkiLCJjYWxpZm9ybmlhRWRDb2RlIiwic3VtbWFyeSIsInJlY29tbWVuZGF0aW9ucyIsInNlcnZpY2VzIiwidHlwZU9mU2VydmljZSIsImZyZXF1ZW5jeSIsInNldHRpbmciLCJhY2NvbW1vZGF0aW9ucyIsImZhY2lsaXRhdGlvblN0cmF0ZWdpZXMiLCJwYXJlbnRGcmllbmRseUdsb3NzYXJ5IiwidGVybXMiLCJtZXRhZGF0YSIsImxhc3RVcGRhdGVkIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwidmVyc2lvbiIsInVwZGF0ZURvbWFpblNlY3Rpb24iLCJyZXBvcnQiLCJkb21haW4iLCJ1cGRhdGVzIiwidXBkYXRlZFJlcG9ydCIsInVuZGVmaW5lZCIsImxlbmd0aCIsIlBPU1QiLCJyZXF1ZXN0IiwicmVxdWVzdElkIiwibm93IiwidG9TdHJpbmciLCJNYXRoIiwicmFuZG9tIiwic3Vic3RyaW5nIiwiY29uc29sZSIsImxvZyIsImV4aXN0aW5nUmVwb3J0IiwidXBkYXRlU2VjdGlvbiIsImpzb24iLCJpc1BkZlVwbG9hZCIsImlucHV0RGF0YSIsImlucHV0VHlwZSIsImlucHV0U2l6ZSIsInJlcG9ydFByb3ZpZGVkIiwiZXJyb3IiLCJzdGF0dXMiLCJPYmplY3QiLCJrZXlzIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIkFOVEhST1BJQ19BUElfS0VZIiwibm9ybWFsaXplZElucHV0Iiwic2VjdGlvblRvVXBkYXRlIiwidmlld0NvbnRlbnQiLCJ0YXJnZXRQYXRoIiwiZ2V0TmVzdGVkVmFsdWUiLCJvYmoiLCJwYXRoIiwic3BsaXQiLCJyZWR1Y2UiLCJvIiwia2V5IiwiZ2V0TWFpblNlY3Rpb24iLCJzdGFydHNXaXRoIiwicmVwb3J0U3VtbWFyeSIsInN0dWRlbnROYW1lIiwiYWNjIiwiZG9tYWluTmFtZSIsIm1haW5TZWN0aW9uIiwibmVzdGVkVmFsdWUiLCJzeXN0ZW1Qcm9tcHQiLCJ1c2VyTWVzc2FnZSIsInVzZXJDb250ZW50IiwidHlwZSIsInNvdXJjZSIsIm1lZGlhX3R5cGUiLCJkYXRhIiwiZmlyc3RBcGlQYXlsb2FkIiwibW9kZWwiLCJtYXhfdG9rZW5zIiwic3lzdGVtIiwidG9vbHMiLCJuYW1lIiwibWVzc2FnZXMiLCJyb2xlIiwiY29udGVudCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIm9rIiwiZXJyb3JEYXRhIiwiRXJyb3IiLCJtZXNzYWdlIiwiY2xhdWRlUmVzcG9uc2UiLCJtYXAiLCJibG9jayIsImNvbW1hbmQiLCJmaW5hbENvbW1hbmQiLCJ0b29sVXNlQmxvY2siLCJmaW5kIiwic2Vjb25kVXNlckNvbnRlbnQiLCJzZWNvbmRBcGlQYXlsb2FkIiwiaWQiLCJ0b29sX3VzZV9pZCIsInNlY29uZFJlc3BvbnNlIiwic2Vjb25kVG9vbFVzZUJsb2NrIiwib2xkX3N0ciIsIm5ld19zdHIiLCJwb3NpdGlvbiIsInVwZGF0ZUtleUNvbW1hbmQiLCJ0ZXh0QmxvY2tzIiwiZmlsdGVyIiwianNvbk1hdGNoZXMiLCJtYXRjaCIsImpzb25TdHIiLCJyZXBsYWNlIiwidHJpbSIsImpzb25PYmoiLCJwYXJzZSIsImFjdGlvbiIsInZhbHVlIiwiZSIsIndhcm4iLCJhZmZlY3RlZERvbWFpbiIsInBhdGhQYXJ0cyIsImN1cnJlbnQiLCJpIiwic2xpY2UiLCJqb2luIiwidGFyZ2V0UHJvcCIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJkZXRhaWxzIiwidGV4dENvbnRlbnQiLCJkb21haW5LZXl3b3JkcyIsImZvdW5kRG9tYWluIiwicGF0aFJlZ2V4IiwicGF0aE1hdGNoIiwicGF0dGVybiIsIlJlZ0V4cCIsInRlc3QiLCJ1cGRhdGVkQ29udGVudCIsInN0ckNvbnRhaW5zRG9tYWluUGF0dGVybiIsInNvbWUiLCJyZWdleCIsImluY2x1ZGVzIiwiZnVsbFJlcG9ydEpzb24iLCJkb21haW5QYXR0ZXJuIiwiZG9tYWluTWF0Y2giLCJwYXJzZUVycm9yIiwiZG9tYWluU2VjdGlvbiIsImRvbWFpbkpzb24iLCJkb21haW5PYmplY3RNYXRjaCIsIm5ld0RvbWFpblNlY3Rpb24iLCJleHRyYWN0RXJyb3IiLCJvcmlnaW5hbEVycm9yIiwiZXh0cmFjdGVkQ29udGVudCIsInRzTWF0Y2giLCJldmlkZW5jZU1hdGNoIiwiY2hhbGxlbmdlc01hdGNoIiwib2xkX3N0cl9sZW5ndGgiLCJuZXdfc3RyX2xlbmd0aCIsImpzb25NYXRjaCIsInVwZGF0ZWREb21haW5TZWN0aW9uIiwianNvbkVycm9yIiwiZXh0cmFjdGVkRG9tYWluIiwiZXZpZGVuY2UiLCJvcmlnaW5hbENvbW1hbmQiLCJvcmlnaW5hbFRpbWVzdGFtcCIsIm9sZFRpbWVzdGFtcCIsIm5ld1RpbWVzdGFtcCIsIm5ld1ZlcnNpb24iLCJhcGlFcnJvciIsImlucHV0TG93ZXIiLCJ0b0xvd2VyQ2FzZSIsInRhcmdldERvbWFpbiIsInNpbXVsYXRlZFJlcG9ydCIsInNpbXVsYXRlZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/text-editor-test/route.ts\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@opentelemetry"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Ftext-editor-test%2Froute&page=%2Fapi%2Ftext-editor-test%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftext-editor-test%2Froute.ts&appDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();