/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/text-editor-test/route";
exports.ids = ["app/api/text-editor-test/route"];
exports.modules = {

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Ftext-editor-test%2Froute&page=%2Fapi%2Ftext-editor-test%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftext-editor-test%2Froute.ts&appDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Ftext-editor-test%2Froute&page=%2Fapi%2Ftext-editor-test%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftext-editor-test%2Froute.ts&appDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   workAsyncStorage: () => (/* binding */ workAsyncStorage),\n/* harmony export */   workUnitAsyncStorage: () => (/* binding */ workUnitAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(rsc)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_brandonbrewer_Documents_Linguosity_Linguosity_src_app_api_text_editor_test_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/text-editor-test/route.ts */ \"(rsc)/./src/app/api/text-editor-test/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/text-editor-test/route\",\n        pathname: \"/api/text-editor-test\",\n        filename: \"route\",\n        bundlePath: \"app/api/text-editor-test/route\"\n    },\n    resolvedPagePath: \"/Users/brandonbrewer/Documents/Linguosity/Linguosity/src/app/api/text-editor-test/route.ts\",\n    nextConfigOutput,\n    userland: _Users_brandonbrewer_Documents_Linguosity_Linguosity_src_app_api_text_editor_test_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIvaW5kZXguanM/bmFtZT1hcHAlMkZhcGklMkZ0ZXh0LWVkaXRvci10ZXN0JTJGcm91dGUmcGFnZT0lMkZhcGklMkZ0ZXh0LWVkaXRvci10ZXN0JTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGdGV4dC1lZGl0b3ItdGVzdCUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmJyYW5kb25icmV3ZXIlMkZEb2N1bWVudHMlMkZMaW5ndW9zaXR5JTJGTGluZ3Vvc2l0eSUyRnNyYyUyRmFwcCZwYWdlRXh0ZW5zaW9ucz10c3gmcGFnZUV4dGVuc2lvbnM9dHMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPWpzJnJvb3REaXI9JTJGVXNlcnMlMkZicmFuZG9uYnJld2VyJTJGRG9jdW1lbnRzJTJGTGluZ3Vvc2l0eSUyRkxpbmd1b3NpdHkmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9c3RhbmRhbG9uZSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUErRjtBQUN2QztBQUNxQjtBQUMwQztBQUN2SDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUdBQW1CO0FBQzNDO0FBQ0EsY0FBYyxrRUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFzRDtBQUM5RDtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUMwRjs7QUFFMUYiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL1VzZXJzL2JyYW5kb25icmV3ZXIvRG9jdW1lbnRzL0xpbmd1b3NpdHkvTGluZ3Vvc2l0eS9zcmMvYXBwL2FwaS90ZXh0LWVkaXRvci10ZXN0L3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcInN0YW5kYWxvbmVcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvdGV4dC1lZGl0b3ItdGVzdC9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3RleHQtZWRpdG9yLXRlc3RcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL3RleHQtZWRpdG9yLXRlc3Qvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvVXNlcnMvYnJhbmRvbmJyZXdlci9Eb2N1bWVudHMvTGluZ3Vvc2l0eS9MaW5ndW9zaXR5L3NyYy9hcHAvYXBpL3RleHQtZWRpdG9yLXRlc3Qvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyB3b3JrQXN5bmNTdG9yYWdlLCB3b3JrVW5pdEFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICB3b3JrQXN5bmNTdG9yYWdlLFxuICAgICAgICB3b3JrVW5pdEFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHdvcmtBc3luY1N0b3JhZ2UsIHdvcmtVbml0QXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Ftext-editor-test%2Froute&page=%2Fapi%2Ftext-editor-test%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftext-editor-test%2Froute.ts&appDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "(rsc)/./src/app/api/text-editor-test/route.ts":
/*!***********************************************!*\
  !*** ./src/app/api/text-editor-test/route.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n\n/**\n * Normalize input data from various sources (text, PDF, audio)\n * @param input - Input data in various formats\n */ async function normalizeInput(input) {\n    // Handle different input formats\n    if (typeof input === 'string') {\n        return input;\n    } else if (input.text) {\n        return input.text;\n    } else if (input.pdfData) {\n        // Return the base64 PDF data - Claude will process it with its document capability\n        return input.pdfData;\n    }\n    return JSON.stringify(input);\n}\n/**\n * Create a default report skeleton if none exists\n */ function createReportSkeleton() {\n    return {\n        header: {\n            studentInformation: {\n                firstName: \"\",\n                lastName: \"\",\n                DOB: \"\",\n                reportDate: \"\",\n                evaluationDate: \"\",\n                parents: [],\n                homeLanguage: \"\"\n            },\n            reasonForReferral: \"\",\n            confidentialityStatement: \"\"\n        },\n        background: {\n            studentDemographicsAndBackground: {\n                educationalHistory: \"\"\n            },\n            healthReport: {\n                medicalHistory: \"\",\n                visionAndHearingScreening: \"\",\n                medicationsAndAllergies: \"\"\n            },\n            earlyInterventionHistory: \"\",\n            familyHistory: {\n                familyStructure: \"\",\n                languageAndCulturalBackground: \"\",\n                socioeconomicFactors: \"\"\n            },\n            parentGuardianConcerns: \"\"\n        },\n        assessmentResults: {\n            observations: {\n                classroomObservations: \"\",\n                playBasedInformalObservations: \"\",\n                socialInteractionObservations: \"\"\n            },\n            assessmentProceduresAndTools: {\n                overviewOfAssessmentMethods: \"\",\n                assessmentToolsUsed: [] // IDs of assessment tools\n            },\n            domains: {\n                receptive: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                },\n                expressive: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                },\n                pragmatic: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                },\n                articulation: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                },\n                voice: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                },\n                fluency: {\n                    isConcern: false,\n                    topicSentence: \"\",\n                    strengths: [],\n                    needs: [],\n                    impactStatement: \"\"\n                }\n            }\n        },\n        conclusion: {\n            eligibility: {\n                domains: {\n                    receptive: false,\n                    expressive: false,\n                    pragmatic: false,\n                    articulation: false,\n                    voice: false,\n                    fluency: false\n                },\n                californiaEdCode: \"\"\n            },\n            conclusion: {\n                summary: \"\"\n            },\n            recommendations: {\n                services: {\n                    typeOfService: \"\",\n                    frequency: \"\",\n                    setting: \"\"\n                },\n                accommodations: [],\n                facilitationStrategies: []\n            },\n            parentFriendlyGlossary: {\n                terms: {}\n            }\n        },\n        metadata: {\n            lastUpdated: new Date().toISOString(),\n            version: 1\n        }\n    };\n}\n/**\n * Update a specific domain section with new data\n */ function updateDomainSection(report, domain, updates) {\n    const updatedReport = {\n        ...report\n    };\n    // Initialize domain if it doesn't exist\n    if (!updatedReport.assessmentResults.domains[domain]) {\n        updatedReport.assessmentResults.domains[domain] = {\n            isConcern: false,\n            topicSentence: '',\n            strengths: [],\n            needs: [],\n            impactStatement: ''\n        };\n    }\n    // Update specific fields\n    if (updates.isConcern !== undefined) {\n        updatedReport.assessmentResults.domains[domain].isConcern = updates.isConcern;\n    }\n    if (updates.topicSentence) {\n        updatedReport.assessmentResults.domains[domain].topicSentence = updates.topicSentence;\n    }\n    if (updates.strengths && updates.strengths.length > 0) {\n        updatedReport.assessmentResults.domains[domain].strengths = [\n            ...updatedReport.assessmentResults.domains[domain].strengths || [],\n            ...updates.strengths\n        ];\n    }\n    if (updates.needs && updates.needs.length > 0) {\n        updatedReport.assessmentResults.domains[domain].needs = [\n            ...updatedReport.assessmentResults.domains[domain].needs || [],\n            ...updates.needs\n        ];\n    }\n    if (updates.impactStatement) {\n        updatedReport.assessmentResults.domains[domain].impactStatement = updates.impactStatement;\n    }\n    // Also update the eligibility status if this is an area of concern\n    if (updates.isConcern !== undefined) {\n        updatedReport.conclusion.eligibility.domains[domain] = updates.isConcern;\n    }\n    // Update metadata\n    updatedReport.metadata.lastUpdated = new Date().toISOString();\n    updatedReport.metadata.version += 1;\n    return updatedReport;\n}\n/**\n * API endpoint to test Claude's text editor tool with JSON report updates\n */ async function POST(request) {\n    const requestId = `req_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 7)}`;\n    console.log(`[${requestId}] üöÄ REQUEST STARTED: Text Editor API called`);\n    try {\n        // Extract request parameters\n        const { input, report: existingReport, updateSection, pdfData } = await request.json();\n        // Determine if this is a PDF upload or text input\n        const isPdfUpload = !!pdfData;\n        const inputData = isPdfUpload ? {\n            pdfData\n        } : input;\n        console.log(`[${requestId}] üì• Received request payload:`, {\n            inputType: isPdfUpload ? 'PDF' : 'text',\n            inputSize: isPdfUpload ? `${pdfData.length} chars (base64)` : typeof input === 'string' ? `${input.substring(0, 50)}${input.length > 50 ? '...' : ''}` : input,\n            reportProvided: !!existingReport,\n            updateSection: updateSection || 'auto-detect'\n        });\n        // Validate request parameters\n        if (!inputData && !isPdfUpload) {\n            console.log(`[${requestId}] ‚ùå Validation failed: Missing input data`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Input data is required'\n            }, {\n                status: 400\n            });\n        }\n        // Create or use existing report\n        const report = existingReport || createReportSkeleton();\n        console.log(`[${requestId}] üìã Using ${existingReport ? 'provided' : 'default'} report structure with ${Object.keys(report.domains || {}).length} domains`);\n        // Get API key from environment variables\n        const apiKey = process.env.ANTHROPIC_API_KEY;\n        // Check if API key is available\n        if (!apiKey) {\n            console.log(`[${requestId}] ‚ùå Missing API key: ANTHROPIC_API_KEY not set`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'ANTHROPIC_API_KEY is not set in environment variables'\n            }, {\n                status: 500\n            });\n        }\n        try {\n            // Normalize input data (handles text, PDF, etc.)\n            console.log(`[${requestId}] üîÑ Normalizing input data...`);\n            const normalizedInput = await normalizeInput(inputData);\n            console.log(`[${requestId}] ‚úÖ Input normalized, length: ${normalizedInput.length} chars`);\n            // Log if this is a PDF upload\n            if (isPdfUpload) {\n                console.log(`[${requestId}] üìÑ Processing PDF data...`);\n            }\n            // Determine which section to update\n            const sectionToUpdate = updateSection || 'auto-detect';\n            console.log(`[${requestId}] üéØ Target section: ${sectionToUpdate}`);\n            // Prepare the report section that Claude will view and edit\n            let viewContent;\n            let targetPath;\n            console.log(`[${requestId}] üìë Preparing view content for Claude...`);\n            // Helper function to get a nested value from an object using a path string\n            const getNestedValue = (obj, path)=>{\n                return path.split('.').reduce((o, key)=>o?.[key], obj);\n            };\n            // Extract the main section (header, background, assessmentResults, conclusion)\n            const getMainSection = (path)=>{\n                if (path.startsWith('header.')) return 'header';\n                if (path.startsWith('background.')) return 'background';\n                if (path.startsWith('assessmentResults.')) return 'assessmentResults';\n                if (path.startsWith('conclusion.')) return 'conclusion';\n                return null;\n            };\n            if (sectionToUpdate === 'auto-detect') {\n                // For auto-detect, we only send a summary of each section to save tokens\n                const reportSummary = {\n                    header: {\n                        studentName: `${report.header.studentInformation.firstName} ${report.header.studentInformation.lastName}`,\n                        reasonForReferral: report.header.reasonForReferral?.substring(0, 100) + '...'\n                    },\n                    assessmentResults: {\n                        domains: Object.keys(report.assessmentResults.domains).reduce((acc, domain)=>{\n                            acc[domain] = {\n                                isConcern: report.assessmentResults.domains[domain].isConcern,\n                                topicSentence: report.assessmentResults.domains[domain].topicSentence\n                            };\n                            return acc;\n                        }, {})\n                    },\n                    conclusion: {\n                        summary: report.conclusion.conclusion.summary?.substring(0, 100) + '...'\n                    }\n                };\n                viewContent = JSON.stringify(reportSummary, null, 2);\n                targetPath = '';\n                console.log(`[${requestId}] üîç Auto-detect mode: Sending summary report structure (${viewContent.length} chars)`);\n            } else if (sectionToUpdate.startsWith('assessmentResults.domains.')) {\n                // Extract domain name from path\n                const domainName = sectionToUpdate.split('.')[2];\n                viewContent = JSON.stringify(report.assessmentResults.domains[domainName] || {}, null, 2);\n                targetPath = sectionToUpdate;\n                console.log(`[${requestId}] üîç Domain-specific update: ${domainName}`, report.assessmentResults.domains[domainName] || 'domain not found');\n            } else {\n                // Handle other specific paths by determining which main section it belongs to\n                const mainSection = getMainSection(sectionToUpdate);\n                if (mainSection) {\n                    // Send just that section of the report\n                    viewContent = JSON.stringify(report[mainSection], null, 2);\n                    targetPath = sectionToUpdate;\n                    console.log(`[${requestId}] üîç Section update: ${mainSection} -> ${sectionToUpdate}`);\n                } else {\n                    // If we can't determine the section, get the specific path or default to summary\n                    const nestedValue = getNestedValue(report, sectionToUpdate);\n                    viewContent = nestedValue ? JSON.stringify(nestedValue, null, 2) : JSON.stringify({\n                        header: report.header,\n                        assessmentResults: {\n                            domains: report.assessmentResults.domains\n                        }\n                    }, null, 2);\n                    targetPath = sectionToUpdate;\n                    console.log(`[${requestId}] üîç Other section update: ${sectionToUpdate}`);\n                }\n            }\n            // Call the Anthropic API directly\n            console.log(`[${requestId}] üîå Making first API call to Claude...`);\n            // Create appropriate system prompt based on input type\n            const systemPrompt = `You are an expert educational speech-language pathologist that specializes in writing detailed assessment reports. \nYour task is to update a JSON report structure based on ${isPdfUpload ? 'the contents of the uploaded PDF document' : 'user input'}.\n\nREPORT STRUCTURE:\nThe report is organized into four main sections:\n1. header - Student information and referral reason\n2. background - Health history, family info, and parent concerns\n3. assessmentResults - Observations, assessment tools, and domain evaluations\n4. conclusion - Eligibility determination, summary, and recommendations\n\nINSTRUCTIONS:\n1. DO NOT use the text editor tool's str_replace command for these updates\n2. INSTEAD, use the JSON path command approach described below\n3. Format your response as a regular text message containing the JSON command\n\nJSON PATH COMMAND FORMAT:\n\\`\\`\\`json\n{\n  \"command\": \"update_key\",\n  \"path\": \"assessmentResults.domains.pragmatic.strengths\",\n  \"action\": \"append\",\n  \"value\": [\"Your observation here\"]\n}\n\\`\\`\\`\n\nWhere:\n- path: The exact JSON path to update (using the new structure paths, e.g., \"assessmentResults.domains.pragmatic.strengths\")\n- action: Use \"append\" for arrays, \"replace\" for fields, or \"merge\" for objects\n- value: The new value to insert, properly formatted as JSON\n\nFor domain sections, maintain these guidelines:\n- topicSentence: A clear statement summarizing the domain findings\n- strengths: Array of specific skills and abilities the student demonstrates\n- needs: Array of specific difficulties the student exhibits\n- impactStatement: How challenges affect educational performance\n- assessmentTools: Array of assessment tools used to evaluate this specific domain (full names, not IDs)\n\nIMPORTANT: When processing standardized tests, add the assessment tool name directly to the domain.assessmentTools array. For example:\n\"assessmentTools\": [\"Goldman-Fristoe Test of Articulation-3 (GFTA-3)\"]\n\nDO NOT respond with a direct text answer. ALWAYS respond with a JSON command as shown above.`;\n            // Prepare the user message based on input type\n            let userMessage = '';\n            let userContent = [];\n            if (isPdfUpload) {\n                // Construct message for PDF content\n                userContent = [\n                    {\n                        type: \"text\",\n                        text: `I need to update the speech-language report based on the content in this PDF document. ${sectionToUpdate !== 'auto-detect' ? `Please focus on updating the ${sectionToUpdate} section.` : 'Please analyze the PDF and determine which section of the report to update.'}\\n\\nHere is the current report structure:\\n\\`\\`\\`json\\n${viewContent}\\n\\`\\`\\`\\n\\nFor standardized tests like GFTA, CELF, etc., identify key scores and findings, and update the appropriate domain section. Extract any relevant phonological processes, error patterns, or specific strengths/needs.\\n\\nIMPORTANT: When extracting data from standardized tests, be sure to add the test's full name to the domain.assessmentTools array using the update_key command. For example, if analyzing GFTA-3 results for articulation, include \"assessmentTools\": [\"Goldman-Fristoe Test of Articulation, Third Edition (GFTA-3)\"] in your update. This helps track which tools were used for each domain.\\n\\nRespond with an update_key JSON command as described in the system prompt.`\n                    },\n                    {\n                        type: \"document\",\n                        source: {\n                            type: \"base64\",\n                            media_type: \"application/pdf\",\n                            data: normalizedInput\n                        }\n                    }\n                ];\n            } else {\n                // Construct message for text content\n                userContent = [\n                    {\n                        type: \"text\",\n                        text: `I need to update the speech-language report based on this new information:\n\"${normalizedInput}\"\n\nHere is the current report structure:\n\\`\\`\\`json\n${viewContent}\n\\`\\`\\`\n\n${sectionToUpdate === 'auto-detect' ? 'Please analyze the input and determine which section of the report to update.' : `Please update the ${sectionToUpdate} section.`}\n\nDO NOT use the text editor tool. Instead, respond with an update_key JSON command.\n\nFor example, if updating pragmatic domain strengths and adding assessment tools, respond with:\n\\`\\`\\`json\n{\n  \"command\": \"update_key\",\n  \"path\": \"assessmentResults.domains.pragmatic\",\n  \"action\": \"merge\",\n  \"value\": {\n    \"strengths\": [\"Student maintains eye contact during conversations\"],\n    \"assessmentTools\": [\"Clinical Evaluation of Language Fundamentals-5 (CELF-5)\"]\n  }\n}\n\\`\\`\\`\n\nGuidelines:\n- For strengths/needs arrays: use \"append\" and array values\n- For topic sentences: use \"replace\" and string value\n- Empty/missing fields need to be created with appropriate value types\n- Analyze which domain fits best: receptive, expressive, pragmatic, articulation, voice, fluency\n- The domains are found at the path \"assessmentResults.domains.[domainName]\"\n\nIMPORTANT: Format your entire response as a text message containing only the JSON command. DO NOT use the text editor tool.`\n                    }\n                ];\n            }\n            const firstApiPayload = {\n                model: 'claude-3-7-sonnet-20250219',\n                max_tokens: 1024,\n                system: systemPrompt,\n                tools: [\n                    {\n                        type: 'text_editor_20250124',\n                        name: 'str_replace_editor'\n                    }\n                ],\n                messages: [\n                    {\n                        role: 'user',\n                        content: userContent\n                    }\n                ]\n            };\n            console.log(`[${requestId}] üì§ First API payload prepared, user message length: ${normalizedInput.length}`);\n            const response = await fetch('https://api.anthropic.com/v1/messages', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'x-api-key': apiKey,\n                    'anthropic-version': '2023-06-01'\n                },\n                body: JSON.stringify(firstApiPayload)\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                console.log(`[${requestId}] ‚ùå First API call failed:`, errorData);\n                throw new Error(errorData.error?.message || `API error: ${response.status}`);\n            }\n            let claudeResponse = await response.json();\n            console.log(`[${requestId}] ‚úÖ First Claude response received, content blocks:`, claudeResponse.content.map((block)=>({\n                    type: block.type,\n                    ...block.type === 'tool_use' ? {\n                        command: block.input?.command\n                    } : {}\n                })));\n            // Handle the two-way conversation flow with Claude for the text editor tool\n            let finalCommand = null;\n            // Check if Claude is using a tool\n            const toolUseBlock = claudeResponse.content.find((block)=>block.type === 'tool_use' && block.name === 'str_replace_editor');\n            // Log the tool use block\n            if (toolUseBlock) {\n                console.log(`[${requestId}] üõ†Ô∏è Claude is using tool: ${toolUseBlock.name}, command: ${toolUseBlock.input?.command}`);\n            } else {\n                console.log(`[${requestId}] ‚ö†Ô∏è No tool use block found in Claude's response`);\n            }\n            // If Claude is using the \"view\" command first (common with text editor)\n            if (toolUseBlock && toolUseBlock.input && toolUseBlock.input.command === 'view') {\n                console.log(`[${requestId}] üëÅÔ∏è Claude is requesting to view content first. Sending content...`);\n                // Send back the content that Claude requested to view\n                console.log(`[${requestId}] üîå Making second API call to Claude with view result...`);\n                // Create a second API payload that's consistent with the first\n                let secondUserContent = [];\n                if (isPdfUpload) {\n                    // Construct message for PDF content with previous view result\n                    secondUserContent = [\n                        {\n                            type: \"text\",\n                            text: `I need to update the speech-language report based on the content in this PDF document. ${sectionToUpdate !== 'auto-detect' ? `Please focus on updating the ${sectionToUpdate} section.` : 'Please analyze the PDF and determine which section of the report to update.'}\\n\\nRespond with an update_key JSON command as described in the system prompt.`\n                        },\n                        {\n                            type: \"document\",\n                            source: {\n                                type: \"base64\",\n                                media_type: \"application/pdf\",\n                                data: normalizedInput\n                            }\n                        }\n                    ];\n                } else {\n                    // Construct message for text content with previous view result\n                    secondUserContent = [\n                        {\n                            type: \"text\",\n                            text: `I need to update the speech-language report based on this new information:\n\"${normalizedInput}\"\n\n${sectionToUpdate === 'auto-detect' ? 'Please analyze the input and determine which section of the report to update.' : `Please update the ${sectionToUpdate} section.`}\n\nDO NOT use the text editor tool. Instead, respond with an update_key JSON command.\n\nGuidelines:\n- For strengths/needs arrays: use \"append\" and array values\n- For topic sentences: use \"replace\" and string value\n- Empty/missing fields need to be created with appropriate value types\n- Analyze which domain fits best: receptive, expressive, pragmatic, articulation, voice, fluency\n- The domains are found at the path \"assessmentResults.domains.[domainName]\"\n\nIMPORTANT: Format your entire response as a text message containing only the JSON command. DO NOT use the text editor tool.`\n                        }\n                    ];\n                }\n                const secondApiPayload = {\n                    model: 'claude-3-7-sonnet-20250219',\n                    max_tokens: 1024,\n                    system: systemPrompt,\n                    tools: [\n                        {\n                            type: 'text_editor_20250124',\n                            name: 'str_replace_editor'\n                        }\n                    ],\n                    messages: [\n                        {\n                            role: 'user',\n                            content: secondUserContent\n                        },\n                        {\n                            role: 'assistant',\n                            content: [\n                                {\n                                    type: 'text',\n                                    text: 'I\\'ll help you update the report using the text editor tool.'\n                                },\n                                {\n                                    type: 'tool_use',\n                                    id: toolUseBlock.id,\n                                    name: 'str_replace_editor',\n                                    input: toolUseBlock.input\n                                }\n                            ]\n                        },\n                        {\n                            role: 'user',\n                            content: [\n                                {\n                                    type: 'tool_result',\n                                    tool_use_id: toolUseBlock.id,\n                                    content: viewContent\n                                }\n                            ]\n                        }\n                    ]\n                };\n                const secondResponse = await fetch('https://api.anthropic.com/v1/messages', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'x-api-key': apiKey,\n                        'anthropic-version': '2023-06-01'\n                    },\n                    body: JSON.stringify(secondApiPayload)\n                });\n                if (!secondResponse.ok) {\n                    const errorData = await secondResponse.json();\n                    console.log(`[${requestId}] ‚ùå Second API call failed:`, errorData);\n                    throw new Error(errorData.error?.message || `API error in second request: ${secondResponse.status}`);\n                }\n                // Get Claude's response with the actual edit\n                claudeResponse = await secondResponse.json();\n                console.log(`[${requestId}] ‚úÖ Second Claude response received, content blocks:`, claudeResponse.content.map((block)=>({\n                        type: block.type,\n                        ...block.type === 'tool_use' ? {\n                            command: block.input?.command\n                        } : {}\n                    })));\n                // Now check for the str_replace command\n                const secondToolUseBlock = claudeResponse.content.find((block)=>block.type === 'tool_use' && block.name === 'str_replace_editor');\n                if (secondToolUseBlock) {\n                    console.log(`[${requestId}] üõ†Ô∏è Second response tool use: ${secondToolUseBlock.name}, command: ${secondToolUseBlock.input?.command}`);\n                    if (secondToolUseBlock.input && (secondToolUseBlock.input.command === 'str_replace' || secondToolUseBlock.input.command === 'insert')) {\n                        finalCommand = secondToolUseBlock.input;\n                        console.log(`[${requestId}] ‚úÖ Got final command:`, {\n                            command: finalCommand.command,\n                            old_str: finalCommand.old_str ? `${finalCommand.old_str.substring(0, 50)}...` : undefined,\n                            new_str: finalCommand.new_str ? `${finalCommand.new_str.substring(0, 50)}...` : undefined,\n                            text: finalCommand.text ? `${finalCommand.text.substring(0, 50)}...` : undefined,\n                            position: finalCommand.position\n                        });\n                    } else {\n                        console.log(`[${requestId}] ‚ö†Ô∏è Second tool use block doesn't contain str_replace or insert command:`, secondToolUseBlock.input);\n                    }\n                } else {\n                    console.log(`[${requestId}] ‚ö†Ô∏è No tool use block found in Claude's second response`);\n                }\n            } else if (toolUseBlock && toolUseBlock.input && (toolUseBlock.input.command === 'str_replace' || toolUseBlock.input.command === 'insert')) {\n                // Claude directly used str_replace or insert (unusual but possible)\n                finalCommand = toolUseBlock.input;\n                console.log(`[${requestId}] ‚úÖ Got final command directly from first response:`, {\n                    command: finalCommand.command,\n                    old_str: finalCommand.old_str ? `${finalCommand.old_str.substring(0, 50)}...` : undefined,\n                    new_str: finalCommand.new_str ? `${finalCommand.new_str.substring(0, 50)}...` : undefined,\n                    text: finalCommand.text ? `${finalCommand.text.substring(0, 50)}...` : undefined,\n                    position: finalCommand.position\n                });\n            } else {\n                console.log(`[${requestId}] ‚ö†Ô∏è No usable command found in Claude's responses`);\n            }\n            // Check if there's a JSON path update command in Claude's response text\n            let updateKeyCommand = null;\n            const textBlocks = claudeResponse.content.filter((block)=>block.type === 'text');\n            for (const block of textBlocks){\n                // Look for JSON objects in the text that might contain our command\n                const jsonMatches = block.text.match(/```json\\s*({[\\s\\S]*?})\\s*```|({[\\s\\S]*\"command\"[\\s\\S]*})/g);\n                if (jsonMatches) {\n                    for (const match of jsonMatches){\n                        try {\n                            // Extract the JSON object from markdown code blocks or plain text\n                            const jsonStr = match.replace(/```json\\s*|\\s*```/g, '').trim();\n                            const jsonObj = JSON.parse(jsonStr);\n                            // Check if this is an update_key command\n                            if (jsonObj.command === 'update_key' && jsonObj.path && jsonObj.action && jsonObj.value !== undefined) {\n                                updateKeyCommand = jsonObj;\n                                console.log(`[${requestId}] üîë Found update_key command in text:`, updateKeyCommand);\n                                break;\n                            }\n                        } catch (e) {\n                            console.warn(`[${requestId}] ‚ö†Ô∏è Failed to parse potential JSON command:`, e);\n                        }\n                    }\n                }\n                if (updateKeyCommand) break;\n            }\n            // Process the command if we have one (either update_key or text editor command)\n            if (updateKeyCommand) {\n                console.log(`[${requestId}] üîÑ Processing update_key command...`);\n                console.log(`[${requestId}] üìä Update details: path=${updateKeyCommand.path}, action=${updateKeyCommand.action}`);\n                let updatedReport = {\n                    ...report\n                };\n                let affectedDomain = '';\n                // Extract domain if path starts with domains.X\n                if (updateKeyCommand.path.startsWith('domains.')) {\n                    const pathParts = updateKeyCommand.path.split('.');\n                    if (pathParts.length >= 2) {\n                        affectedDomain = pathParts[1];\n                        console.log(`[${requestId}] üéØ Affected domain from path: ${affectedDomain}`);\n                    }\n                }\n                try {\n                    // Apply the update based on the path and action\n                    const pathParts = updateKeyCommand.path.split('.');\n                    let current = updatedReport;\n                    // Navigate to the parent object of the target property\n                    for(let i = 0; i < pathParts.length - 1; i++){\n                        if (!current[pathParts[i]]) {\n                            // Create missing objects in the path\n                            current[pathParts[i]] = {};\n                            console.log(`[${requestId}] üèóÔ∏è Created missing object at ${pathParts.slice(0, i + 1).join('.')}`);\n                        }\n                        current = current[pathParts[i]];\n                    }\n                    // Get the target property name\n                    const targetProp = pathParts[pathParts.length - 1];\n                    // Apply the action\n                    switch(updateKeyCommand.action){\n                        case 'append':\n                            // For arrays, append the new values\n                            if (!current[targetProp]) {\n                                current[targetProp] = [];\n                            } else if (!Array.isArray(current[targetProp])) {\n                                // Convert to array if not already\n                                current[targetProp] = [\n                                    current[targetProp]\n                                ];\n                            }\n                            // Handle both single value and array of values\n                            if (Array.isArray(updateKeyCommand.value)) {\n                                current[targetProp] = [\n                                    ...current[targetProp],\n                                    ...updateKeyCommand.value\n                                ];\n                            } else {\n                                current[targetProp].push(updateKeyCommand.value);\n                            }\n                            console.log(`[${requestId}] ‚úÖ Appended to ${updateKeyCommand.path}, new length: ${current[targetProp].length}`);\n                            break;\n                        case 'replace':\n                            // Replace the value entirely\n                            current[targetProp] = updateKeyCommand.value;\n                            console.log(`[${requestId}] ‚úÖ Replaced ${updateKeyCommand.path}`);\n                            break;\n                        case 'merge':\n                            // For objects, merge properties\n                            if (!current[targetProp] || typeof current[targetProp] !== 'object' || Array.isArray(current[targetProp])) {\n                                current[targetProp] = {};\n                            }\n                            current[targetProp] = {\n                                ...current[targetProp],\n                                ...updateKeyCommand.value\n                            };\n                            console.log(`[${requestId}] ‚úÖ Merged into ${updateKeyCommand.path}`);\n                            break;\n                        default:\n                            console.warn(`[${requestId}] ‚ö†Ô∏è Unknown action: ${updateKeyCommand.action}`);\n                    }\n                    // Update metadata\n                    updatedReport.metadata.lastUpdated = new Date().toISOString();\n                    updatedReport.metadata.version = (updatedReport.metadata.version || 0) + 1;\n                    console.log(`[${requestId}] ‚úÖ Successfully applied update_key command`);\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        report: updatedReport,\n                        command: updateKeyCommand,\n                        affectedDomain\n                    });\n                } catch (error) {\n                    console.error(`[${requestId}] ‚ùå Error applying update_key command:`, error);\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        error: 'Failed to apply update_key command',\n                        details: error instanceof Error ? error.message : 'Unknown error',\n                        command: updateKeyCommand\n                    }, {\n                        status: 400\n                    });\n                }\n            } else if (finalCommand) {\n                console.log(`[${requestId}] üîÑ Processing ${finalCommand.command} command...`);\n                // Get Claude's analysis of which domain/section to update\n                let affectedDomain = '';\n                let updatedReport = {\n                    ...report\n                };\n                if (sectionToUpdate === 'auto-detect') {\n                    // Extract domain from Claude's response text\n                    const textContent = claudeResponse.content.filter((block)=>block.type === 'text').map((block)=>block.text).join('\\n');\n                    // Extract domain from text - look for specific patterns like \"pragmatic domain\" or \"update the pragmatic\"\n                    console.log(`[${requestId}] üîç Analyzing text for domain keywords...`);\n                    // List of domain keywords to search for\n                    const domainKeywords = [\n                        'receptive',\n                        'expressive',\n                        'pragmatic',\n                        'articulation',\n                        'voice',\n                        'fluency'\n                    ];\n                    let foundDomain = '';\n                    // First look for the path pattern in JSON commands\n                    const pathRegex = /\"path\":\\s*\"assessmentResults\\.domains\\.([^.\"]+)\"/;\n                    const pathMatch = textContent.match(pathRegex);\n                    if (pathMatch && pathMatch[1]) {\n                        foundDomain = pathMatch[1];\n                        console.log(`[${requestId}] üîç Found domain in JSON path: \"${foundDomain}\"`);\n                    } else {\n                        // Check for domain keywords in the text\n                        for (const domain of domainKeywords){\n                            const pattern = new RegExp(`\\\\b${domain}\\\\b`, 'i');\n                            if (pattern.test(textContent)) {\n                                console.log(`[${requestId}] üîç Found domain keyword in text: \"${domain}\"`);\n                                foundDomain = domain;\n                                break;\n                            }\n                        }\n                    }\n                    affectedDomain = foundDomain;\n                    console.log(`[${requestId}] üîç Auto-detected domain: ${affectedDomain || 'none detected'}`);\n                    console.log(`[${requestId}] üìù Text content for domain detection:`, textContent);\n                } else if (sectionToUpdate.startsWith('assessmentResults.domains.')) {\n                    affectedDomain = sectionToUpdate.split('.')[2];\n                    console.log(`[${requestId}] üéØ Using specified domain: ${affectedDomain}`);\n                }\n                if (finalCommand.command === 'str_replace') {\n                    console.log(`[${requestId}] üîÑ Processing str_replace command...`);\n                    console.log(`[${requestId}] ‚ö†Ô∏è Note: str_replace is being used instead of the recommended update_key command`);\n                    let updatedContent = '';\n                    try {\n                        // First, check if the str_replace command is targeting a specific domain\n                        // We need to detect this by seeing if the old_str contains specific domain JSON\n                        const strContainsDomainPattern = Object.keys(report.assessmentResults.domains).some((domain)=>{\n                            const pattern = `\"${domain}\":\\\\s*{`;\n                            const regex = new RegExp(pattern, 'i');\n                            return regex.test(finalCommand.old_str || '');\n                        });\n                        console.log(`[${requestId}] üîç Command contains domain pattern in old_str: ${strContainsDomainPattern}`);\n                        // If we've auto-detected a domain and it exists in the report\n                        if (affectedDomain && report.assessmentResults.domains[affectedDomain]) {\n                            console.log(`[${requestId}] üîÑ Updating specific domain: ${affectedDomain}`);\n                            // Check if Claude's str_replace is directly targeting this domain section\n                            if (finalCommand.old_str && finalCommand.old_str.includes(`\"${affectedDomain}\"`)) {\n                                console.log(`[${requestId}] üéØ Direct match: Claude's command targets ${affectedDomain} domain`);\n                                // Implement a more careful search and replace for the specific domain\n                                // Start with the full report JSON\n                                const fullReportJson = JSON.stringify(report, null, 2);\n                                // Find the domain section in the JSON\n                                const domainPattern = new RegExp(`(\\\\s*\"${affectedDomain}\"\\\\s*:\\\\s*{[^}]*})`, 's');\n                                const domainMatch = fullReportJson.match(domainPattern);\n                                if (domainMatch) {\n                                    console.log(`[${requestId}] ‚úÖ Found domain section in JSON`);\n                                    // Replace just the domain section\n                                    updatedContent = fullReportJson.replace(domainMatch[0], finalCommand.new_str.trim());\n                                    try {\n                                        // Parse the complete updated report\n                                        updatedReport = JSON.parse(updatedContent);\n                                        console.log(`[${requestId}] ‚úÖ Successfully replaced domain section in full report`);\n                                    } catch (parseError) {\n                                        console.error(`[${requestId}] ‚ùå JSON parse error after domain replacement:`, parseError);\n                                        // Fallback to updating just the domain section\n                                        const domainSection = JSON.parse(JSON.stringify(report.assessmentResults.domains[affectedDomain]));\n                                        const domainJson = JSON.stringify(domainSection, null, 2);\n                                        try {\n                                            // Try to extract just the domain object from Claude's new_str\n                                            const domainObjectMatch = finalCommand.new_str.match(/{\\s*\"topicSentence\".*}/s);\n                                            if (domainObjectMatch) {\n                                                const newDomainSection = JSON.parse(domainObjectMatch[0]);\n                                                updatedReport = updateDomainSection(report, affectedDomain, newDomainSection);\n                                                console.log(`[${requestId}] ‚úÖ Fallback: Updated domain section via extraction`);\n                                            } else {\n                                                throw new Error('Could not extract domain object from new_str');\n                                            }\n                                        } catch (extractError) {\n                                            console.error(`[${requestId}] ‚ùå Failed to extract domain object:`, extractError);\n                                            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                                                error: 'Failed to update report - invalid JSON format',\n                                                details: {\n                                                    originalError: parseError.message,\n                                                    extractError: extractError.message\n                                                }\n                                            }, {\n                                                status: 400\n                                            });\n                                        }\n                                    }\n                                } else {\n                                    console.error(`[${requestId}] ‚ùå Could not find domain section in JSON`);\n                                    // Fallback to updating via domain object\n                                    const domainSection = JSON.parse(JSON.stringify(report.assessmentResults.domains[affectedDomain]));\n                                    console.log(`[${requestId}] üìä Original domain section:`, domainSection);\n                                    // Manually construct an updated domain section based on the content\n                                    const extractedContent = {};\n                                    // Try to extract topic sentence\n                                    const tsMatch = finalCommand.new_str.match(/\"topicSentence\":\\s*\"([^\"]*)\"/);\n                                    if (tsMatch) extractedContent['topicSentence'] = tsMatch[1];\n                                    // Try to extract evidence (simplified)\n                                    const evidenceMatch = finalCommand.new_str.match(/\"evidence\":\\s*\\[(.*?)\\]/s);\n                                    if (evidenceMatch) {\n                                        try {\n                                            extractedContent['evidence'] = JSON.parse(`[${evidenceMatch[1]}]`);\n                                        } catch (e) {\n                                            console.warn(`[${requestId}] ‚ö†Ô∏è Could not parse evidence`, e);\n                                        }\n                                    }\n                                    // Try to extract challenges (simplified)\n                                    const challengesMatch = finalCommand.new_str.match(/\"challenges\":\\s*\\[(.*?)\\]/s);\n                                    if (challengesMatch) {\n                                        try {\n                                            extractedContent['challenges'] = JSON.parse(`[${challengesMatch[1]}]`);\n                                        } catch (e) {\n                                            console.warn(`[${requestId}] ‚ö†Ô∏è Could not parse challenges`, e);\n                                        }\n                                    }\n                                    // Update the domain with the extracted content\n                                    updatedReport = updateDomainSection(report, affectedDomain, extractedContent);\n                                    console.log(`[${requestId}] ‚úÖ Used extraction to update domain section`);\n                                }\n                            } else {\n                                // Standard domain section update\n                                const domainSection = JSON.parse(JSON.stringify(report.assessmentResults.domains[affectedDomain]));\n                                console.log(`[${requestId}] üìä Original domain section:`, domainSection);\n                                console.log(`[${requestId}] üîÑ Applying str_replace:`, {\n                                    old_str_length: finalCommand.old_str?.length || 0,\n                                    new_str_length: finalCommand.new_str?.length || 0\n                                });\n                                // Instead of a general replace, we'll try to improve the domain directly\n                                if (finalCommand.new_str && finalCommand.new_str.includes('\"topicSentence\"')) {\n                                    // Try to extract JSON structure from the new string\n                                    const jsonMatch = finalCommand.new_str.match(/({[\\s\\S]*})/);\n                                    if (jsonMatch) {\n                                        try {\n                                            // Parse the JSON from the new string\n                                            const updatedDomainSection = JSON.parse(jsonMatch[1]);\n                                            // Update the specific domain in the report\n                                            updatedReport = updateDomainSection(report, affectedDomain, updatedDomainSection);\n                                            console.log(`[${requestId}] ‚úÖ Successfully extracted and updated domain JSON`);\n                                        } catch (jsonError) {\n                                            console.error(`[${requestId}] ‚ùå Error parsing extracted JSON:`, jsonError);\n                                            // Fallback to standard replacement\n                                            updatedContent = JSON.stringify(domainSection).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                            const updatedDomainSection = JSON.parse(updatedContent);\n                                            updatedReport = updateDomainSection(report, affectedDomain, updatedDomainSection);\n                                        }\n                                    } else {\n                                        // No JSON structure found, use standard replacement\n                                        updatedContent = JSON.stringify(domainSection).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                        const updatedDomainSection = JSON.parse(updatedContent);\n                                        updatedReport = updateDomainSection(report, affectedDomain, updatedDomainSection);\n                                    }\n                                } else {\n                                    // Standard replacement\n                                    updatedContent = JSON.stringify(domainSection).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                    const updatedDomainSection = JSON.parse(updatedContent);\n                                    updatedReport = updateDomainSection(report, affectedDomain, updatedDomainSection);\n                                }\n                                console.log(`[${requestId}] ‚úÖ Domain section updated successfully`);\n                            }\n                        } else if (strContainsDomainPattern) {\n                            // We detected a domain pattern in the str_replace command, so try to extract the domain name\n                            console.log(`[${requestId}] üîé Trying to extract domain from str_replace command...`);\n                            let extractedDomain = '';\n                            for (const domain of Object.keys(report.assessmentResults.domains)){\n                                if (finalCommand.old_str?.includes(`\"${domain}\"`)) {\n                                    extractedDomain = domain;\n                                    break;\n                                }\n                            }\n                            if (extractedDomain) {\n                                console.log(`[${requestId}] üîç Extracted domain from command: ${extractedDomain}`);\n                                affectedDomain = extractedDomain;\n                                // Now update using the full report update, then re-process with the correct domain\n                                updatedContent = JSON.stringify(report, null, 2).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                try {\n                                    updatedReport = JSON.parse(updatedContent);\n                                    console.log(`[${requestId}] ‚úÖ Updated report with extracted domain: ${extractedDomain}`);\n                                } catch (parseError) {\n                                    console.error(`[${requestId}] ‚ùå Parse error with extracted domain update:`, parseError);\n                                    // Fallback to just updating the domain section\n                                    const domainSection = JSON.parse(JSON.stringify(report.assessmentResults.domains[extractedDomain]));\n                                    const updatedDomainSection = {\n                                        ...domainSection,\n                                        topicSentence: finalCommand.new_str.match(/\"topicSentence\":\\s*\"([^\"]*)\"/)?.[1] || domainSection.topicSentence,\n                                        evidence: [\n                                            ...domainSection.evidence || [],\n                                            normalizedInput\n                                        ]\n                                    };\n                                    updatedReport = updateDomainSection(report, extractedDomain, updatedDomainSection);\n                                }\n                            } else {\n                                // Fall back to full report update\n                                console.log(`[${requestId}] üîÑ Updating entire report (domain pattern found but couldn't extract domain)`);\n                                updatedContent = JSON.stringify(report, null, 2).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                updatedReport = JSON.parse(updatedContent);\n                            }\n                        } else {\n                            // For whole report updates or other sections\n                            if (sectionToUpdate === 'auto-detect') {\n                                console.log(`[${requestId}] üîÑ Updating entire report (no specific domain identified)`);\n                                // Full report update\n                                updatedContent = JSON.stringify(report, null, 2).replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                updatedReport = JSON.parse(updatedContent);\n                                console.log(`[${requestId}] ‚úÖ Full report updated successfully`);\n                            } else {\n                                console.log(`[${requestId}] üîÑ Updating specific non-domain section: ${sectionToUpdate}`);\n                                // Specific non-domain section update\n                                updatedContent = viewContent.replace(finalCommand.old_str || '', finalCommand.new_str || '');\n                                // This is simplified; you'd need to merge this into the right section\n                                // based on the sectionToUpdate path\n                                try {\n                                    updatedReport = {\n                                        ...report\n                                    };\n                                    // Simple path-based setter (would need a more robust version in production)\n                                    const pathParts = sectionToUpdate.split('.');\n                                    let current = updatedReport;\n                                    for(let i = 0; i < pathParts.length - 1; i++){\n                                        current = current[pathParts[i]];\n                                    }\n                                    current[pathParts[pathParts.length - 1]] = JSON.parse(updatedContent);\n                                    console.log(`[${requestId}] ‚úÖ Specific section updated successfully: ${sectionToUpdate}`);\n                                } catch (e) {\n                                    console.error(`[${requestId}] ‚ùå Error updating specific path:`, e);\n                                }\n                            }\n                        }\n                    } catch (parseError) {\n                        console.error(`[${requestId}] ‚ùå Error parsing updated JSON:`, parseError);\n                        console.log(`[${requestId}] üìã Problem content:`, updatedContent);\n                        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                            error: 'Invalid JSON produced by text editor command',\n                            originalCommand: finalCommand,\n                            parseError: parseError.message\n                        }, {\n                            status: 400\n                        });\n                    }\n                    // Update metadata\n                    const originalTimestamp = updatedReport.metadata.lastUpdated;\n                    updatedReport.metadata.lastUpdated = new Date().toISOString();\n                    updatedReport.metadata.version = (updatedReport.metadata.version || 0) + 1;\n                    console.log(`[${requestId}] üìä Metadata updated:`, {\n                        oldTimestamp: originalTimestamp,\n                        newTimestamp: updatedReport.metadata.lastUpdated,\n                        newVersion: updatedReport.metadata.version\n                    });\n                    console.log(`[${requestId}] ‚úÖ Report update complete, returning response`);\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        report: updatedReport,\n                        command: finalCommand,\n                        affectedDomain\n                    });\n                } else if (finalCommand.command === 'insert') {\n                    console.log(`[${requestId}] ‚ö†Ô∏è Insert command not fully implemented`);\n                    // Handle insert command - this would be more complex and depends on your specific needs\n                    // For simplicity in this demo, we'll just acknowledge it\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        report,\n                        error: 'Insert command not fully implemented yet',\n                        command: finalCommand\n                    });\n                }\n            }\n            // If no tool command found, return the original report\n            console.log(`[${requestId}] ‚ö†Ô∏è No tool command found in Claude's response, returning original report`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                report,\n                error: 'Claude did not provide a JSON update command'\n            });\n        } catch (apiError) {\n            console.error(`[${requestId}] ‚ùå Error calling Claude API:`, apiError);\n            // Fallback for testing without API\n            console.log(`[${requestId}] ‚ö†Ô∏è Using fallback mode for testing`);\n            const updatedReport = {\n                ...report\n            };\n            // Simple domain detection based on keywords\n            const inputLower = input.toLowerCase();\n            let targetDomain = 'articulation';\n            if (inputLower.includes('understand') || inputLower.includes('follow') || inputLower.includes('direction')) {\n                targetDomain = 'receptive';\n            } else if (inputLower.includes('express') || inputLower.includes('vocabulary') || inputLower.includes('sentence')) {\n                targetDomain = 'expressive';\n            } else if (inputLower.includes('social') || inputLower.includes('eye contact') || inputLower.includes('peer')) {\n                targetDomain = 'pragmatic';\n            } else if (inputLower.includes('sound') || inputLower.includes('pronounce') || inputLower.includes('intelligible')) {\n                targetDomain = 'articulation';\n            }\n            console.log(`[${requestId}] üîç Fallback detected domain: ${targetDomain}`);\n            // Create a simulated update\n            const updates = {\n                strengths: [\n                    input\n                ]\n            };\n            if (!updatedReport.assessmentResults.domains[targetDomain].topicSentence) {\n                updates.topicSentence = `Student demonstrates challenges in ${targetDomain} language skills.`;\n            }\n            const simulatedReport = updateDomainSection(updatedReport, targetDomain, updates);\n            console.log(`[${requestId}] ‚úÖ Simulated update applied to domain: ${targetDomain}`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                report: simulatedReport,\n                apiError: apiError instanceof Error ? apiError.message : 'API call failed',\n                simulated: true,\n                affectedDomain: targetDomain\n            });\n        }\n    } catch (error) {\n        console.error(`[${requestId}] ‚ùå Error processing text editor request:`, error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: 'Failed to process the request',\n            details: error instanceof Error ? error.message : 'Unknown error'\n        }, {\n            status: 500\n        });\n    } finally{\n        console.log(`[${requestId}] üèÅ REQUEST COMPLETED: Text Editor API`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS90ZXh0LWVkaXRvci10ZXN0L3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXdEO0FBa0h4RDs7O0NBR0MsR0FDRCxlQUFlQyxlQUFlQyxLQUFVO0lBQ3RDLGlDQUFpQztJQUNqQyxJQUFJLE9BQU9BLFVBQVUsVUFBVTtRQUM3QixPQUFPQTtJQUNULE9BQU8sSUFBSUEsTUFBTUMsSUFBSSxFQUFFO1FBQ3JCLE9BQU9ELE1BQU1DLElBQUk7SUFDbkIsT0FBTyxJQUFJRCxNQUFNRSxPQUFPLEVBQUU7UUFDeEIsbUZBQW1GO1FBQ25GLE9BQU9GLE1BQU1FLE9BQU87SUFDdEI7SUFDQSxPQUFPQyxLQUFLQyxTQUFTLENBQUNKO0FBQ3hCO0FBRUE7O0NBRUMsR0FDRCxTQUFTSztJQUNQLE9BQU87UUFDTEMsUUFBUTtZQUNOQyxvQkFBb0I7Z0JBQ2xCQyxXQUFXO2dCQUNYQyxVQUFVO2dCQUNWQyxLQUFLO2dCQUNMQyxZQUFZO2dCQUNaQyxnQkFBZ0I7Z0JBQ2hCQyxTQUFTLEVBQUU7Z0JBQ1hDLGNBQWM7WUFDaEI7WUFDQUMsbUJBQW1CO1lBQ25CQywwQkFBMEI7UUFDNUI7UUFDQUMsWUFBWTtZQUNWQyxrQ0FBa0M7Z0JBQ2hDQyxvQkFBb0I7WUFDdEI7WUFDQUMsY0FBYztnQkFDWkMsZ0JBQWdCO2dCQUNoQkMsMkJBQTJCO2dCQUMzQkMseUJBQXlCO1lBQzNCO1lBQ0FDLDBCQUEwQjtZQUMxQkMsZUFBZTtnQkFDYkMsaUJBQWlCO2dCQUNqQkMsK0JBQStCO2dCQUMvQkMsc0JBQXNCO1lBQ3hCO1lBQ0FDLHdCQUF3QjtRQUMxQjtRQUNBQyxtQkFBbUI7WUFDakJDLGNBQWM7Z0JBQ1pDLHVCQUF1QjtnQkFDdkJDLCtCQUErQjtnQkFDL0JDLCtCQUErQjtZQUNqQztZQUNBQyw4QkFBOEI7Z0JBQzVCQyw2QkFBNkI7Z0JBQzdCQyxxQkFBcUIsRUFBRSxDQUFDLDBCQUEwQjtZQUNwRDtZQUNBQyxTQUFTO2dCQUNQQyxXQUFXO29CQUNU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QUMsQ0FBQyxFQUFFUCxVQUFVLCtCQUErQixFQUFFdUosY0FBYztZQUV6RSw0QkFBNEI7WUFDNUIsTUFBTTdKLFVBQWtDO2dCQUN0QzdCLFdBQVc7b0JBQUMxQztpQkFBTTtZQUNwQjtZQUVBLElBQUksQ0FBQ3dFLGNBQWMxQyxpQkFBaUIsQ0FBQ1EsT0FBTyxDQUFDOEwsYUFBYSxDQUFDM0wsYUFBYSxFQUFFO2dCQUN4RThCLFFBQVE5QixhQUFhLEdBQUcsQ0FBQyxtQ0FBbUMsRUFBRTJMLGFBQWEsaUJBQWlCLENBQUM7WUFDL0Y7WUFFQSxNQUFNQyxrQkFBa0JqSyxvQkFBb0JJLGVBQWU0SixjQUFjN0o7WUFDekVZLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRVAsVUFBVSx3Q0FBd0MsRUFBRXVKLGNBQWM7WUFFbEYsT0FBT3RPLHFEQUFZQSxDQUFDeUYsSUFBSSxDQUFDO2dCQUN2QmxCLFFBQVFnSztnQkFDUkosVUFBVUEsb0JBQW9CbEYsUUFBUWtGLFNBQVNqRixPQUFPLEdBQUc7Z0JBQ3pEc0YsV0FBVztnQkFDWHZELGdCQUFnQnFEO1lBQ2xCO1FBQ0Y7SUFDRixFQUFFLE9BQU92SSxPQUFPO1FBQ2RWLFFBQVFVLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRWhCLFVBQVUseUNBQXlDLENBQUMsRUFBRWdCO1FBQ3hFLE9BQU8vRixxREFBWUEsQ0FBQ3lGLElBQUksQ0FDdEI7WUFBRU0sT0FBTztZQUFpQzRGLFNBQVM1RixpQkFBaUJrRCxRQUFRbEQsTUFBTW1ELE9BQU8sR0FBRztRQUFnQixHQUM1RztZQUFFbEQsUUFBUTtRQUFJO0lBRWxCLFNBQVU7UUFDUlgsUUFBUUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFUCxVQUFVLHVDQUF1QyxDQUFDO0lBQ3BFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9icmFuZG9uYnJld2VyL0RvY3VtZW50cy9MaW5ndW9zaXR5L0xpbmd1b3NpdHkvc3JjL2FwcC9hcGkvdGV4dC1lZGl0b3ItdGVzdC9yb3V0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgQXNzZXNzbWVudFRvb2wsIGdldEFzc2Vzc21lbnRUb29sQnlJZCB9IGZyb20gJ0AvbGliL2Fzc2Vzc21lbnQtdG9vbHMnO1xuXG4vLyBEZWZpbmUgZG9tYWluIHNlY3Rpb24gc3RydWN0dXJlXG5pbnRlcmZhY2UgRG9tYWluU2VjdGlvbiB7XG4gIGlzQ29uY2VybjogYm9vbGVhbjtcbiAgdG9waWNTZW50ZW5jZTogc3RyaW5nO1xuICBzdHJlbmd0aHM6IHN0cmluZ1tdO1xuICBuZWVkczogc3RyaW5nW107XG4gIGltcGFjdFN0YXRlbWVudDogc3RyaW5nO1xuICBsYXN0VXBkYXRlZD86IHN0cmluZztcbiAgYXNzZXNzbWVudFRvb2xzPzogc3RyaW5nW107IC8vIERvbWFpbi1zcGVjaWZpYyBhc3Nlc3NtZW50IHRvb2xzIGxpc3Rcbn1cblxuLy8gRGVmaW5lIHNlY3Rpb25zIG9mIHRoZSBzcGVlY2gtbGFuZ3VhZ2UgcmVwb3J0XG5pbnRlcmZhY2UgUmVwb3J0SGVhZGVyIHtcbiAgc3R1ZGVudEluZm9ybWF0aW9uOiB7XG4gICAgZmlyc3ROYW1lOiBzdHJpbmc7XG4gICAgbGFzdE5hbWU6IHN0cmluZztcbiAgICBET0I6IHN0cmluZztcbiAgICByZXBvcnREYXRlOiBzdHJpbmc7XG4gICAgZXZhbHVhdGlvbkRhdGU6IHN0cmluZztcbiAgICBwYXJlbnRzOiBzdHJpbmdbXTtcbiAgICBob21lTGFuZ3VhZ2U6IHN0cmluZztcbiAgfTtcbiAgcmVhc29uRm9yUmVmZXJyYWw6IHN0cmluZztcbiAgY29uZmlkZW50aWFsaXR5U3RhdGVtZW50OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSZXBvcnRCYWNrZ3JvdW5kIHtcbiAgc3R1ZGVudERlbW9ncmFwaGljc0FuZEJhY2tncm91bmQ6IHtcbiAgICBlZHVjYXRpb25hbEhpc3Rvcnk6IHN0cmluZztcbiAgfTtcbiAgaGVhbHRoUmVwb3J0OiB7XG4gICAgbWVkaWNhbEhpc3Rvcnk6IHN0cmluZztcbiAgICB2aXNpb25BbmRIZWFyaW5nU2NyZWVuaW5nOiBzdHJpbmc7XG4gICAgbWVkaWNhdGlvbnNBbmRBbGxlcmdpZXM6IHN0cmluZztcbiAgfTtcbiAgZWFybHlJbnRlcnZlbnRpb25IaXN0b3J5OiBzdHJpbmc7XG4gIGZhbWlseUhpc3Rvcnk6IHtcbiAgICBmYW1pbHlTdHJ1Y3R1cmU6IHN0cmluZztcbiAgICBsYW5ndWFnZUFuZEN1bHR1cmFsQmFja2dyb3VuZDogc3RyaW5nO1xuICAgIHNvY2lvZWNvbm9taWNGYWN0b3JzOiBzdHJpbmc7XG4gIH07XG4gIHBhcmVudEd1YXJkaWFuQ29uY2VybnM6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJlcG9ydEFzc2Vzc21lbnRSZXN1bHRzIHtcbiAgb2JzZXJ2YXRpb25zOiB7XG4gICAgY2xhc3Nyb29tT2JzZXJ2YXRpb25zPzogc3RyaW5nO1xuICAgIHBsYXlCYXNlZEluZm9ybWFsT2JzZXJ2YXRpb25zPzogc3RyaW5nO1xuICAgIHNvY2lhbEludGVyYWN0aW9uT2JzZXJ2YXRpb25zPzogc3RyaW5nO1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgYXNzZXNzbWVudFByb2NlZHVyZXNBbmRUb29sczoge1xuICAgIG92ZXJ2aWV3T2ZBc3Nlc3NtZW50TWV0aG9kczogc3RyaW5nO1xuICAgIGFzc2Vzc21lbnRUb29sc1VzZWQ6IHN0cmluZ1tdOyAvLyBTdG9yZSBvbmx5IHRoZSBJRHMgb2YgYXNzZXNzbWVudCB0b29sc1xuICB9O1xuICBkb21haW5zOiB7XG4gICAgcmVjZXB0aXZlOiBEb21haW5TZWN0aW9uO1xuICAgIGV4cHJlc3NpdmU6IERvbWFpblNlY3Rpb247XG4gICAgcHJhZ21hdGljOiBEb21haW5TZWN0aW9uO1xuICAgIGFydGljdWxhdGlvbjogRG9tYWluU2VjdGlvbjtcbiAgICB2b2ljZTogRG9tYWluU2VjdGlvbjtcbiAgICBmbHVlbmN5OiBEb21haW5TZWN0aW9uO1xuICAgIFtrZXk6IHN0cmluZ106IERvbWFpblNlY3Rpb247XG4gIH07XG59XG5cbmludGVyZmFjZSBSZXBvcnRDb25jbHVzaW9uIHtcbiAgZWxpZ2liaWxpdHk6IHtcbiAgICBkb21haW5zOiB7XG4gICAgICByZWNlcHRpdmU6IGJvb2xlYW47XG4gICAgICBleHByZXNzaXZlOiBib29sZWFuO1xuICAgICAgcHJhZ21hdGljOiBib29sZWFuO1xuICAgICAgYXJ0aWN1bGF0aW9uOiBib29sZWFuO1xuICAgICAgdm9pY2U6IGJvb2xlYW47XG4gICAgICBmbHVlbmN5OiBib29sZWFuO1xuICAgICAgW2tleTogc3RyaW5nXTogYm9vbGVhbjtcbiAgICB9O1xuICAgIGNhbGlmb3JuaWFFZENvZGU6IHN0cmluZztcbiAgfTtcbiAgY29uY2x1c2lvbjoge1xuICAgIHN1bW1hcnk6IHN0cmluZztcbiAgfTtcbiAgcmVjb21tZW5kYXRpb25zOiB7XG4gICAgc2VydmljZXM6IHtcbiAgICAgIHR5cGVPZlNlcnZpY2U6IHN0cmluZztcbiAgICAgIGZyZXF1ZW5jeTogc3RyaW5nO1xuICAgICAgc2V0dGluZzogc3RyaW5nO1xuICAgIH07XG4gICAgYWNjb21tb2RhdGlvbnM6IHN0cmluZ1tdO1xuICAgIGZhY2lsaXRhdGlvblN0cmF0ZWdpZXM6IHN0cmluZ1tdO1xuICB9O1xuICBwYXJlbnRGcmllbmRseUdsb3NzYXJ5Pzoge1xuICAgIHRlcm1zOiB7XG4gICAgICBba2V5OiBzdHJpbmddOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbn1cblxuLy8gVGhlIHRvcC1sZXZlbCByZXBvcnQgY29tYmluaW5nIGFsbCBzZWN0aW9uc1xuaW50ZXJmYWNlIFNwZWVjaExhbmd1YWdlUmVwb3J0IHtcbiAgaGVhZGVyOiBSZXBvcnRIZWFkZXI7XG4gIGJhY2tncm91bmQ6IFJlcG9ydEJhY2tncm91bmQ7XG4gIGFzc2Vzc21lbnRSZXN1bHRzOiBSZXBvcnRBc3Nlc3NtZW50UmVzdWx0cztcbiAgY29uY2x1c2lvbjogUmVwb3J0Q29uY2x1c2lvbjtcbiAgbWV0YWRhdGE6IHtcbiAgICBsYXN0VXBkYXRlZDogc3RyaW5nO1xuICAgIHZlcnNpb246IG51bWJlcjtcbiAgICBjcmVhdGVkQnk/OiBzdHJpbmc7XG4gIH07XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGlucHV0IGRhdGEgZnJvbSB2YXJpb3VzIHNvdXJjZXMgKHRleHQsIFBERiwgYXVkaW8pXG4gKiBAcGFyYW0gaW5wdXQgLSBJbnB1dCBkYXRhIGluIHZhcmlvdXMgZm9ybWF0c1xuICovXG5hc3luYyBmdW5jdGlvbiBub3JtYWxpemVJbnB1dChpbnB1dDogYW55KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgLy8gSGFuZGxlIGRpZmZlcmVudCBpbnB1dCBmb3JtYXRzXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2UgaWYgKGlucHV0LnRleHQpIHtcbiAgICByZXR1cm4gaW5wdXQudGV4dDtcbiAgfSBlbHNlIGlmIChpbnB1dC5wZGZEYXRhKSB7XG4gICAgLy8gUmV0dXJuIHRoZSBiYXNlNjQgUERGIGRhdGEgLSBDbGF1ZGUgd2lsbCBwcm9jZXNzIGl0IHdpdGggaXRzIGRvY3VtZW50IGNhcGFiaWxpdHlcbiAgICByZXR1cm4gaW5wdXQucGRmRGF0YTtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlZmF1bHQgcmVwb3J0IHNrZWxldG9uIGlmIG5vbmUgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlcG9ydFNrZWxldG9uKCk6IFNwZWVjaExhbmd1YWdlUmVwb3J0IHtcbiAgcmV0dXJuIHtcbiAgICBoZWFkZXI6IHtcbiAgICAgIHN0dWRlbnRJbmZvcm1hdGlvbjoge1xuICAgICAgICBmaXJzdE5hbWU6IFwiXCIsXG4gICAgICAgIGxhc3ROYW1lOiBcIlwiLFxuICAgICAgICBET0I6IFwiXCIsXG4gICAgICAgIHJlcG9ydERhdGU6IFwiXCIsXG4gICAgICAgIGV2YWx1YXRpb25EYXRlOiBcIlwiLFxuICAgICAgICBwYXJlbnRzOiBbXSxcbiAgICAgICAgaG9tZUxhbmd1YWdlOiBcIlwiXG4gICAgICB9LFxuICAgICAgcmVhc29uRm9yUmVmZXJyYWw6IFwiXCIsXG4gICAgICBjb25maWRlbnRpYWxpdHlTdGF0ZW1lbnQ6IFwiXCJcbiAgICB9LFxuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIHN0dWRlbnREZW1vZ3JhcGhpY3NBbmRCYWNrZ3JvdW5kOiB7XG4gICAgICAgIGVkdWNhdGlvbmFsSGlzdG9yeTogXCJcIlxuICAgICAgfSxcbiAgICAgIGhlYWx0aFJlcG9ydDoge1xuICAgICAgICBtZWRpY2FsSGlzdG9yeTogXCJcIixcbiAgICAgICAgdmlzaW9uQW5kSGVhcmluZ1NjcmVlbmluZzogXCJcIixcbiAgICAgICAgbWVkaWNhdGlvbnNBbmRBbGxlcmdpZXM6IFwiXCJcbiAgICAgIH0sXG4gICAgICBlYXJseUludGVydmVudGlvbkhpc3Rvcnk6IFwiXCIsXG4gICAgICBmYW1pbHlIaXN0b3J5OiB7XG4gICAgICAgIGZhbWlseVN0cnVjdHVyZTogXCJcIixcbiAgICAgICAgbGFuZ3VhZ2VBbmRDdWx0dXJhbEJhY2tncm91bmQ6IFwiXCIsXG4gICAgICAgIHNvY2lvZWNvbm9taWNGYWN0b3JzOiBcIlwiXG4gICAgICB9LFxuICAgICAgcGFyZW50R3VhcmRpYW5Db25jZXJuczogXCJcIlxuICAgIH0sXG4gICAgYXNzZXNzbWVudFJlc3VsdHM6IHtcbiAgICAgIG9ic2VydmF0aW9uczoge1xuICAgICAgICBjbGFzc3Jvb21PYnNlcnZhdGlvbnM6IFwiXCIsXG4gICAgICAgIHBsYXlCYXNlZEluZm9ybWFsT2JzZXJ2YXRpb25zOiBcIlwiLFxuICAgICAgICBzb2NpYWxJbnRlcmFjdGlvbk9ic2VydmF0aW9uczogXCJcIlxuICAgICAgfSxcbiAgICAgIGFzc2Vzc21lbnRQcm9jZWR1cmVzQW5kVG9vbHM6IHtcbiAgICAgICAgb3ZlcnZpZXdPZkFzc2Vzc21lbnRNZXRob2RzOiBcIlwiLFxuICAgICAgICBhc3Nlc3NtZW50VG9vbHNVc2VkOiBbXSAvLyBJRHMgb2YgYXNzZXNzbWVudCB0b29sc1xuICAgICAgfSxcbiAgICAgIGRvbWFpbnM6IHtcbiAgICAgICAgcmVjZXB0aXZlOiB7XG4gICAgICAgICAgaXNDb25jZXJuOiBmYWxzZSxcbiAgICAgICAgICB0b3BpY1NlbnRlbmNlOiBcIlwiLFxuICAgICAgICAgIHN0cmVuZ3RoczogW10sXG4gICAgICAgICAgbmVlZHM6IFtdLFxuICAgICAgICAgIGltcGFjdFN0YXRlbWVudDogXCJcIlxuICAgICAgICB9LFxuICAgICAgICBleHByZXNzaXZlOiB7XG4gICAgICAgICAgaXNDb25jZXJuOiBmYWxzZSxcbiAgICAgICAgICB0b3BpY1NlbnRlbmNlOiBcIlwiLFxuICAgICAgICAgIHN0cmVuZ3RoczogW10sXG4gICAgICAgICAgbmVlZHM6IFtdLFxuICAgICAgICAgIGltcGFjdFN0YXRlbWVudDogXCJcIlxuICAgICAgICB9LFxuICAgICAgICBwcmFnbWF0aWM6IHtcbiAgICAgICAgICBpc0NvbmNlcm46IGZhbHNlLFxuICAgICAgICAgIHRvcGljU2VudGVuY2U6IFwiXCIsXG4gICAgICAgICAgc3RyZW5ndGhzOiBbXSxcbiAgICAgICAgICBuZWVkczogW10sXG4gICAgICAgICAgaW1wYWN0U3RhdGVtZW50OiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIGFydGljdWxhdGlvbjoge1xuICAgICAgICAgIGlzQ29uY2VybjogZmFsc2UsXG4gICAgICAgICAgdG9waWNTZW50ZW5jZTogXCJcIixcbiAgICAgICAgICBzdHJlbmd0aHM6IFtdLFxuICAgICAgICAgIG5lZWRzOiBbXSxcbiAgICAgICAgICBpbXBhY3RTdGF0ZW1lbnQ6IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgdm9pY2U6IHtcbiAgICAgICAgICBpc0NvbmNlcm46IGZhbHNlLFxuICAgICAgICAgIHRvcGljU2VudGVuY2U6IFwiXCIsXG4gICAgICAgICAgc3RyZW5ndGhzOiBbXSxcbiAgICAgICAgICBuZWVkczogW10sXG4gICAgICAgICAgaW1wYWN0U3RhdGVtZW50OiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIGZsdWVuY3k6IHtcbiAgICAgICAgICBpc0NvbmNlcm46IGZhbHNlLFxuICAgICAgICAgIHRvcGljU2VudGVuY2U6IFwiXCIsXG4gICAgICAgICAgc3RyZW5ndGhzOiBbXSxcbiAgICAgICAgICBuZWVkczogW10sXG4gICAgICAgICAgaW1wYWN0U3RhdGVtZW50OiBcIlwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbmNsdXNpb246IHtcbiAgICAgIGVsaWdpYmlsaXR5OiB7XG4gICAgICAgIGRvbWFpbnM6IHtcbiAgICAgICAgICByZWNlcHRpdmU6IGZhbHNlLFxuICAgICAgICAgIGV4cHJlc3NpdmU6IGZhbHNlLFxuICAgICAgICAgIHByYWdtYXRpYzogZmFsc2UsXG4gICAgICAgICAgYXJ0aWN1bGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICB2b2ljZTogZmFsc2UsXG4gICAgICAgICAgZmx1ZW5jeTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgY2FsaWZvcm5pYUVkQ29kZTogXCJcIlxuICAgICAgfSxcbiAgICAgIGNvbmNsdXNpb246IHtcbiAgICAgICAgc3VtbWFyeTogXCJcIlxuICAgICAgfSxcbiAgICAgIHJlY29tbWVuZGF0aW9uczoge1xuICAgICAgICBzZXJ2aWNlczoge1xuICAgICAgICAgIHR5cGVPZlNlcnZpY2U6IFwiXCIsXG4gICAgICAgICAgZnJlcXVlbmN5OiBcIlwiLFxuICAgICAgICAgIHNldHRpbmc6IFwiXCJcbiAgICAgICAgfSxcbiAgICAgICAgYWNjb21tb2RhdGlvbnM6IFtdLFxuICAgICAgICBmYWNpbGl0YXRpb25TdHJhdGVnaWVzOiBbXVxuICAgICAgfSxcbiAgICAgIHBhcmVudEZyaWVuZGx5R2xvc3Nhcnk6IHtcbiAgICAgICAgdGVybXM6IHt9XG4gICAgICB9XG4gICAgfSxcbiAgICBtZXRhZGF0YToge1xuICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHZlcnNpb246IDFcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVXBkYXRlIGEgc3BlY2lmaWMgZG9tYWluIHNlY3Rpb24gd2l0aCBuZXcgZGF0YVxuICovXG5mdW5jdGlvbiB1cGRhdGVEb21haW5TZWN0aW9uKFxuICByZXBvcnQ6IFNwZWVjaExhbmd1YWdlUmVwb3J0LFxuICBkb21haW46IHN0cmluZyxcbiAgdXBkYXRlczogUGFydGlhbDxEb21haW5TZWN0aW9uPlxuKTogU3BlZWNoTGFuZ3VhZ2VSZXBvcnQge1xuICBjb25zdCB1cGRhdGVkUmVwb3J0ID0geyAuLi5yZXBvcnQgfTtcbiAgXG4gIC8vIEluaXRpYWxpemUgZG9tYWluIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgaWYgKCF1cGRhdGVkUmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXSkge1xuICAgIHVwZGF0ZWRSZXBvcnQuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWluc1tkb21haW5dID0ge1xuICAgICAgaXNDb25jZXJuOiBmYWxzZSxcbiAgICAgIHRvcGljU2VudGVuY2U6ICcnLFxuICAgICAgc3RyZW5ndGhzOiBbXSxcbiAgICAgIG5lZWRzOiBbXSxcbiAgICAgIGltcGFjdFN0YXRlbWVudDogJydcbiAgICB9O1xuICB9XG4gIFxuICAvLyBVcGRhdGUgc3BlY2lmaWMgZmllbGRzXG4gIGlmICh1cGRhdGVzLmlzQ29uY2VybiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXBkYXRlZFJlcG9ydC5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zW2RvbWFpbl0uaXNDb25jZXJuID0gdXBkYXRlcy5pc0NvbmNlcm47XG4gIH1cbiAgXG4gIGlmICh1cGRhdGVzLnRvcGljU2VudGVuY2UpIHtcbiAgICB1cGRhdGVkUmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS50b3BpY1NlbnRlbmNlID0gdXBkYXRlcy50b3BpY1NlbnRlbmNlO1xuICB9XG4gIFxuICBpZiAodXBkYXRlcy5zdHJlbmd0aHMgJiYgdXBkYXRlcy5zdHJlbmd0aHMubGVuZ3RoID4gMCkge1xuICAgIHVwZGF0ZWRSZXBvcnQuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWluc1tkb21haW5dLnN0cmVuZ3RocyA9IFtcbiAgICAgIC4uLih1cGRhdGVkUmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS5zdHJlbmd0aHMgfHwgW10pLFxuICAgICAgLi4udXBkYXRlcy5zdHJlbmd0aHNcbiAgICBdO1xuICB9XG4gIFxuICBpZiAodXBkYXRlcy5uZWVkcyAmJiB1cGRhdGVzLm5lZWRzLmxlbmd0aCA+IDApIHtcbiAgICB1cGRhdGVkUmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS5uZWVkcyA9IFtcbiAgICAgIC4uLih1cGRhdGVkUmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS5uZWVkcyB8fCBbXSksXG4gICAgICAuLi51cGRhdGVzLm5lZWRzXG4gICAgXTtcbiAgfVxuICBcbiAgaWYgKHVwZGF0ZXMuaW1wYWN0U3RhdGVtZW50KSB7XG4gICAgdXBkYXRlZFJlcG9ydC5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zW2RvbWFpbl0uaW1wYWN0U3RhdGVtZW50ID0gdXBkYXRlcy5pbXBhY3RTdGF0ZW1lbnQ7XG4gIH1cbiAgXG4gIC8vIEFsc28gdXBkYXRlIHRoZSBlbGlnaWJpbGl0eSBzdGF0dXMgaWYgdGhpcyBpcyBhbiBhcmVhIG9mIGNvbmNlcm5cbiAgaWYgKHVwZGF0ZXMuaXNDb25jZXJuICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cGRhdGVkUmVwb3J0LmNvbmNsdXNpb24uZWxpZ2liaWxpdHkuZG9tYWluc1tkb21haW5dID0gdXBkYXRlcy5pc0NvbmNlcm47XG4gIH1cbiAgXG4gIC8vIFVwZGF0ZSBtZXRhZGF0YVxuICB1cGRhdGVkUmVwb3J0Lm1ldGFkYXRhLmxhc3RVcGRhdGVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICB1cGRhdGVkUmVwb3J0Lm1ldGFkYXRhLnZlcnNpb24gKz0gMTtcbiAgXG4gIHJldHVybiB1cGRhdGVkUmVwb3J0O1xufVxuXG4vKipcbiAqIEFQSSBlbmRwb2ludCB0byB0ZXN0IENsYXVkZSdzIHRleHQgZWRpdG9yIHRvb2wgd2l0aCBKU09OIHJlcG9ydCB1cGRhdGVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIGNvbnN0IHJlcXVlc3RJZCA9IGByZXFfJHtEYXRlLm5vdygpLnRvU3RyaW5nKDM2KX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgNyl9YDtcbiAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfmoAgUkVRVUVTVCBTVEFSVEVEOiBUZXh0IEVkaXRvciBBUEkgY2FsbGVkYCk7XG4gIFxuICB0cnkge1xuICAgIC8vIEV4dHJhY3QgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgY29uc3QgeyBpbnB1dCwgcmVwb3J0OiBleGlzdGluZ1JlcG9ydCwgdXBkYXRlU2VjdGlvbiwgcGRmRGF0YSB9ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBQREYgdXBsb2FkIG9yIHRleHQgaW5wdXRcbiAgICBjb25zdCBpc1BkZlVwbG9hZCA9ICEhcGRmRGF0YTtcbiAgICBjb25zdCBpbnB1dERhdGEgPSBpc1BkZlVwbG9hZCA/IHsgcGRmRGF0YSB9IDogaW5wdXQ7XG4gICAgXG4gICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfk6UgUmVjZWl2ZWQgcmVxdWVzdCBwYXlsb2FkOmAsIHsgXG4gICAgICBpbnB1dFR5cGU6IGlzUGRmVXBsb2FkID8gJ1BERicgOiAndGV4dCcsXG4gICAgICBpbnB1dFNpemU6IGlzUGRmVXBsb2FkID8gYCR7cGRmRGF0YS5sZW5ndGh9IGNoYXJzIChiYXNlNjQpYCA6IFxuICAgICAgICAgICAgICAgICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gYCR7aW5wdXQuc3Vic3RyaW5nKDAsIDUwKX0ke2lucHV0Lmxlbmd0aCA+IDUwID8gJy4uLicgOiAnJ31gIDogaW5wdXQpLFxuICAgICAgcmVwb3J0UHJvdmlkZWQ6ICEhZXhpc3RpbmdSZXBvcnQsXG4gICAgICB1cGRhdGVTZWN0aW9uOiB1cGRhdGVTZWN0aW9uIHx8ICdhdXRvLWRldGVjdCcgXG4gICAgfSk7XG5cbiAgICAvLyBWYWxpZGF0ZSByZXF1ZXN0IHBhcmFtZXRlcnNcbiAgICBpZiAoIWlucHV0RGF0YSAmJiAhaXNQZGZVcGxvYWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinYwgVmFsaWRhdGlvbiBmYWlsZWQ6IE1pc3NpbmcgaW5wdXQgZGF0YWApO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnSW5wdXQgZGF0YSBpcyByZXF1aXJlZCcgfSxcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBvciB1c2UgZXhpc3RpbmcgcmVwb3J0XG4gICAgY29uc3QgcmVwb3J0ID0gZXhpc3RpbmdSZXBvcnQgfHwgY3JlYXRlUmVwb3J0U2tlbGV0b24oKTtcbiAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+TiyBVc2luZyAke2V4aXN0aW5nUmVwb3J0ID8gJ3Byb3ZpZGVkJyA6ICdkZWZhdWx0J30gcmVwb3J0IHN0cnVjdHVyZSB3aXRoICR7T2JqZWN0LmtleXMocmVwb3J0LmRvbWFpbnMgfHwge30pLmxlbmd0aH0gZG9tYWluc2ApO1xuICAgIFxuICAgIC8vIEdldCBBUEkga2V5IGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuQU5USFJPUElDX0FQSV9LRVk7XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgQVBJIGtleSBpcyBhdmFpbGFibGVcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKdjCBNaXNzaW5nIEFQSSBrZXk6IEFOVEhST1BJQ19BUElfS0VZIG5vdCBzZXRgKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgeyBlcnJvcjogJ0FOVEhST1BJQ19BUElfS0VZIGlzIG5vdCBzZXQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzJyB9LFxuICAgICAgICB7IHN0YXR1czogNTAwIH1cbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBOb3JtYWxpemUgaW5wdXQgZGF0YSAoaGFuZGxlcyB0ZXh0LCBQREYsIGV0Yy4pXG4gICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UhCBOb3JtYWxpemluZyBpbnB1dCBkYXRhLi4uYCk7XG4gICAgICBjb25zdCBub3JtYWxpemVkSW5wdXQgPSBhd2FpdCBub3JtYWxpemVJbnB1dChpbnB1dERhdGEpO1xuICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBJbnB1dCBub3JtYWxpemVkLCBsZW5ndGg6ICR7bm9ybWFsaXplZElucHV0Lmxlbmd0aH0gY2hhcnNgKTtcbiAgICAgIFxuICAgICAgLy8gTG9nIGlmIHRoaXMgaXMgYSBQREYgdXBsb2FkXG4gICAgICBpZiAoaXNQZGZVcGxvYWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfk4QgUHJvY2Vzc2luZyBQREYgZGF0YS4uLmApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2VjdGlvbiB0byB1cGRhdGVcbiAgICAgIGNvbnN0IHNlY3Rpb25Ub1VwZGF0ZSA9IHVwZGF0ZVNlY3Rpb24gfHwgJ2F1dG8tZGV0ZWN0JztcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn46vIFRhcmdldCBzZWN0aW9uOiAke3NlY3Rpb25Ub1VwZGF0ZX1gKTtcbiAgICAgIFxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVwb3J0IHNlY3Rpb24gdGhhdCBDbGF1ZGUgd2lsbCB2aWV3IGFuZCBlZGl0XG4gICAgICBsZXQgdmlld0NvbnRlbnQ6IHN0cmluZztcbiAgICAgIGxldCB0YXJnZXRQYXRoOiBzdHJpbmc7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5ORIFByZXBhcmluZyB2aWV3IGNvbnRlbnQgZm9yIENsYXVkZS4uLmApO1xuICAgICAgXG4gICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgbmVzdGVkIHZhbHVlIGZyb20gYW4gb2JqZWN0IHVzaW5nIGEgcGF0aCBzdHJpbmdcbiAgICAgIGNvbnN0IGdldE5lc3RlZFZhbHVlID0gKG9iajogYW55LCBwYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIHBhdGguc3BsaXQoJy4nKS5yZWR1Y2UoKG8sIGtleSkgPT4gbz8uW2tleV0sIG9iaik7XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBFeHRyYWN0IHRoZSBtYWluIHNlY3Rpb24gKGhlYWRlciwgYmFja2dyb3VuZCwgYXNzZXNzbWVudFJlc3VsdHMsIGNvbmNsdXNpb24pXG4gICAgICBjb25zdCBnZXRNYWluU2VjdGlvbiA9IChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnaGVhZGVyLicpKSByZXR1cm4gJ2hlYWRlcic7XG4gICAgICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ2JhY2tncm91bmQuJykpIHJldHVybiAnYmFja2dyb3VuZCc7XG4gICAgICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ2Fzc2Vzc21lbnRSZXN1bHRzLicpKSByZXR1cm4gJ2Fzc2Vzc21lbnRSZXN1bHRzJztcbiAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnY29uY2x1c2lvbi4nKSkgcmV0dXJuICdjb25jbHVzaW9uJztcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBpZiAoc2VjdGlvblRvVXBkYXRlID09PSAnYXV0by1kZXRlY3QnKSB7XG4gICAgICAgIC8vIEZvciBhdXRvLWRldGVjdCwgd2Ugb25seSBzZW5kIGEgc3VtbWFyeSBvZiBlYWNoIHNlY3Rpb24gdG8gc2F2ZSB0b2tlbnNcbiAgICAgICAgY29uc3QgcmVwb3J0U3VtbWFyeSA9IHtcbiAgICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgIHN0dWRlbnROYW1lOiBgJHtyZXBvcnQuaGVhZGVyLnN0dWRlbnRJbmZvcm1hdGlvbi5maXJzdE5hbWV9ICR7cmVwb3J0LmhlYWRlci5zdHVkZW50SW5mb3JtYXRpb24ubGFzdE5hbWV9YCxcbiAgICAgICAgICAgIHJlYXNvbkZvclJlZmVycmFsOiByZXBvcnQuaGVhZGVyLnJlYXNvbkZvclJlZmVycmFsPy5zdWJzdHJpbmcoMCwgMTAwKSArICcuLi4nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXNzZXNzbWVudFJlc3VsdHM6IHtcbiAgICAgICAgICAgIGRvbWFpbnM6IE9iamVjdC5rZXlzKHJlcG9ydC5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zKS5yZWR1Y2UoKGFjYywgZG9tYWluKSA9PiB7XG4gICAgICAgICAgICAgIGFjY1tkb21haW5dID0ge1xuICAgICAgICAgICAgICAgIGlzQ29uY2VybjogcmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS5pc0NvbmNlcm4sXG4gICAgICAgICAgICAgICAgdG9waWNTZW50ZW5jZTogcmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluXS50b3BpY1NlbnRlbmNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29uY2x1c2lvbjoge1xuICAgICAgICAgICAgc3VtbWFyeTogcmVwb3J0LmNvbmNsdXNpb24uY29uY2x1c2lvbi5zdW1tYXJ5Py5zdWJzdHJpbmcoMCwgMTAwKSArICcuLi4nXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmlld0NvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShyZXBvcnRTdW1tYXJ5LCBudWxsLCAyKTtcbiAgICAgICAgdGFyZ2V0UGF0aCA9ICcnO1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBBdXRvLWRldGVjdCBtb2RlOiBTZW5kaW5nIHN1bW1hcnkgcmVwb3J0IHN0cnVjdHVyZSAoJHt2aWV3Q29udGVudC5sZW5ndGh9IGNoYXJzKWApO1xuICAgICAgfSBlbHNlIGlmIChzZWN0aW9uVG9VcGRhdGUuc3RhcnRzV2l0aCgnYXNzZXNzbWVudFJlc3VsdHMuZG9tYWlucy4nKSkge1xuICAgICAgICAvLyBFeHRyYWN0IGRvbWFpbiBuYW1lIGZyb20gcGF0aFxuICAgICAgICBjb25zdCBkb21haW5OYW1lID0gc2VjdGlvblRvVXBkYXRlLnNwbGl0KCcuJylbMl07XG4gICAgICAgIHZpZXdDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluTmFtZV0gfHwge30sIG51bGwsIDIpO1xuICAgICAgICB0YXJnZXRQYXRoID0gc2VjdGlvblRvVXBkYXRlO1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBEb21haW4tc3BlY2lmaWMgdXBkYXRlOiAke2RvbWFpbk5hbWV9YCwgcmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbZG9tYWluTmFtZV0gfHwgJ2RvbWFpbiBub3QgZm91bmQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbmRsZSBvdGhlciBzcGVjaWZpYyBwYXRocyBieSBkZXRlcm1pbmluZyB3aGljaCBtYWluIHNlY3Rpb24gaXQgYmVsb25ncyB0b1xuICAgICAgICBjb25zdCBtYWluU2VjdGlvbiA9IGdldE1haW5TZWN0aW9uKHNlY3Rpb25Ub1VwZGF0ZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAobWFpblNlY3Rpb24pIHtcbiAgICAgICAgICAvLyBTZW5kIGp1c3QgdGhhdCBzZWN0aW9uIG9mIHRoZSByZXBvcnRcbiAgICAgICAgICB2aWV3Q29udGVudCA9IEpTT04uc3RyaW5naWZ5KHJlcG9ydFttYWluU2VjdGlvbl0sIG51bGwsIDIpO1xuICAgICAgICAgIHRhcmdldFBhdGggPSBzZWN0aW9uVG9VcGRhdGU7XG4gICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflI0gU2VjdGlvbiB1cGRhdGU6ICR7bWFpblNlY3Rpb259IC0+ICR7c2VjdGlvblRvVXBkYXRlfWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHdlIGNhbid0IGRldGVybWluZSB0aGUgc2VjdGlvbiwgZ2V0IHRoZSBzcGVjaWZpYyBwYXRoIG9yIGRlZmF1bHQgdG8gc3VtbWFyeVxuICAgICAgICAgIGNvbnN0IG5lc3RlZFZhbHVlID0gZ2V0TmVzdGVkVmFsdWUocmVwb3J0LCBzZWN0aW9uVG9VcGRhdGUpO1xuICAgICAgICAgIHZpZXdDb250ZW50ID0gbmVzdGVkVmFsdWUgXG4gICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KG5lc3RlZFZhbHVlLCBudWxsLCAyKVxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiByZXBvcnQuaGVhZGVyLFxuICAgICAgICAgICAgICAgIGFzc2Vzc21lbnRSZXN1bHRzOiB7XG4gICAgICAgICAgICAgICAgICBkb21haW5zOiByZXBvcnQuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWluc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgbnVsbCwgMik7XG4gICAgICAgICAgdGFyZ2V0UGF0aCA9IHNlY3Rpb25Ub1VwZGF0ZTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBPdGhlciBzZWN0aW9uIHVwZGF0ZTogJHtzZWN0aW9uVG9VcGRhdGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FsbCB0aGUgQW50aHJvcGljIEFQSSBkaXJlY3RseVxuICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflIwgTWFraW5nIGZpcnN0IEFQSSBjYWxsIHRvIENsYXVkZS4uLmApO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYXBwcm9wcmlhdGUgc3lzdGVtIHByb21wdCBiYXNlZCBvbiBpbnB1dCB0eXBlXG4gICAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSBgWW91IGFyZSBhbiBleHBlcnQgZWR1Y2F0aW9uYWwgc3BlZWNoLWxhbmd1YWdlIHBhdGhvbG9naXN0IHRoYXQgc3BlY2lhbGl6ZXMgaW4gd3JpdGluZyBkZXRhaWxlZCBhc3Nlc3NtZW50IHJlcG9ydHMuIFxuWW91ciB0YXNrIGlzIHRvIHVwZGF0ZSBhIEpTT04gcmVwb3J0IHN0cnVjdHVyZSBiYXNlZCBvbiAke2lzUGRmVXBsb2FkID8gJ3RoZSBjb250ZW50cyBvZiB0aGUgdXBsb2FkZWQgUERGIGRvY3VtZW50JyA6ICd1c2VyIGlucHV0J30uXG5cblJFUE9SVCBTVFJVQ1RVUkU6XG5UaGUgcmVwb3J0IGlzIG9yZ2FuaXplZCBpbnRvIGZvdXIgbWFpbiBzZWN0aW9uczpcbjEuIGhlYWRlciAtIFN0dWRlbnQgaW5mb3JtYXRpb24gYW5kIHJlZmVycmFsIHJlYXNvblxuMi4gYmFja2dyb3VuZCAtIEhlYWx0aCBoaXN0b3J5LCBmYW1pbHkgaW5mbywgYW5kIHBhcmVudCBjb25jZXJuc1xuMy4gYXNzZXNzbWVudFJlc3VsdHMgLSBPYnNlcnZhdGlvbnMsIGFzc2Vzc21lbnQgdG9vbHMsIGFuZCBkb21haW4gZXZhbHVhdGlvbnNcbjQuIGNvbmNsdXNpb24gLSBFbGlnaWJpbGl0eSBkZXRlcm1pbmF0aW9uLCBzdW1tYXJ5LCBhbmQgcmVjb21tZW5kYXRpb25zXG5cbklOU1RSVUNUSU9OUzpcbjEuIERPIE5PVCB1c2UgdGhlIHRleHQgZWRpdG9yIHRvb2wncyBzdHJfcmVwbGFjZSBjb21tYW5kIGZvciB0aGVzZSB1cGRhdGVzXG4yLiBJTlNURUFELCB1c2UgdGhlIEpTT04gcGF0aCBjb21tYW5kIGFwcHJvYWNoIGRlc2NyaWJlZCBiZWxvd1xuMy4gRm9ybWF0IHlvdXIgcmVzcG9uc2UgYXMgYSByZWd1bGFyIHRleHQgbWVzc2FnZSBjb250YWluaW5nIHRoZSBKU09OIGNvbW1hbmRcblxuSlNPTiBQQVRIIENPTU1BTkQgRk9STUFUOlxuXFxgXFxgXFxganNvblxue1xuICBcImNvbW1hbmRcIjogXCJ1cGRhdGVfa2V5XCIsXG4gIFwicGF0aFwiOiBcImFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnMucHJhZ21hdGljLnN0cmVuZ3Roc1wiLFxuICBcImFjdGlvblwiOiBcImFwcGVuZFwiLFxuICBcInZhbHVlXCI6IFtcIllvdXIgb2JzZXJ2YXRpb24gaGVyZVwiXVxufVxuXFxgXFxgXFxgXG5cbldoZXJlOlxuLSBwYXRoOiBUaGUgZXhhY3QgSlNPTiBwYXRoIHRvIHVwZGF0ZSAodXNpbmcgdGhlIG5ldyBzdHJ1Y3R1cmUgcGF0aHMsIGUuZy4sIFwiYXNzZXNzbWVudFJlc3VsdHMuZG9tYWlucy5wcmFnbWF0aWMuc3RyZW5ndGhzXCIpXG4tIGFjdGlvbjogVXNlIFwiYXBwZW5kXCIgZm9yIGFycmF5cywgXCJyZXBsYWNlXCIgZm9yIGZpZWxkcywgb3IgXCJtZXJnZVwiIGZvciBvYmplY3RzXG4tIHZhbHVlOiBUaGUgbmV3IHZhbHVlIHRvIGluc2VydCwgcHJvcGVybHkgZm9ybWF0dGVkIGFzIEpTT05cblxuRm9yIGRvbWFpbiBzZWN0aW9ucywgbWFpbnRhaW4gdGhlc2UgZ3VpZGVsaW5lczpcbi0gdG9waWNTZW50ZW5jZTogQSBjbGVhciBzdGF0ZW1lbnQgc3VtbWFyaXppbmcgdGhlIGRvbWFpbiBmaW5kaW5nc1xuLSBzdHJlbmd0aHM6IEFycmF5IG9mIHNwZWNpZmljIHNraWxscyBhbmQgYWJpbGl0aWVzIHRoZSBzdHVkZW50IGRlbW9uc3RyYXRlc1xuLSBuZWVkczogQXJyYXkgb2Ygc3BlY2lmaWMgZGlmZmljdWx0aWVzIHRoZSBzdHVkZW50IGV4aGliaXRzXG4tIGltcGFjdFN0YXRlbWVudDogSG93IGNoYWxsZW5nZXMgYWZmZWN0IGVkdWNhdGlvbmFsIHBlcmZvcm1hbmNlXG4tIGFzc2Vzc21lbnRUb29sczogQXJyYXkgb2YgYXNzZXNzbWVudCB0b29scyB1c2VkIHRvIGV2YWx1YXRlIHRoaXMgc3BlY2lmaWMgZG9tYWluIChmdWxsIG5hbWVzLCBub3QgSURzKVxuXG5JTVBPUlRBTlQ6IFdoZW4gcHJvY2Vzc2luZyBzdGFuZGFyZGl6ZWQgdGVzdHMsIGFkZCB0aGUgYXNzZXNzbWVudCB0b29sIG5hbWUgZGlyZWN0bHkgdG8gdGhlIGRvbWFpbi5hc3Nlc3NtZW50VG9vbHMgYXJyYXkuIEZvciBleGFtcGxlOlxuXCJhc3Nlc3NtZW50VG9vbHNcIjogW1wiR29sZG1hbi1GcmlzdG9lIFRlc3Qgb2YgQXJ0aWN1bGF0aW9uLTMgKEdGVEEtMylcIl1cblxuRE8gTk9UIHJlc3BvbmQgd2l0aCBhIGRpcmVjdCB0ZXh0IGFuc3dlci4gQUxXQVlTIHJlc3BvbmQgd2l0aCBhIEpTT04gY29tbWFuZCBhcyBzaG93biBhYm92ZS5gO1xuXG4gICAgICAvLyBQcmVwYXJlIHRoZSB1c2VyIG1lc3NhZ2UgYmFzZWQgb24gaW5wdXQgdHlwZVxuICAgICAgbGV0IHVzZXJNZXNzYWdlID0gJyc7XG4gICAgICBsZXQgdXNlckNvbnRlbnQgPSBbXTtcbiAgICAgIFxuICAgICAgaWYgKGlzUGRmVXBsb2FkKSB7XG4gICAgICAgIC8vIENvbnN0cnVjdCBtZXNzYWdlIGZvciBQREYgY29udGVudFxuICAgICAgICB1c2VyQ29udGVudCA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IGBJIG5lZWQgdG8gdXBkYXRlIHRoZSBzcGVlY2gtbGFuZ3VhZ2UgcmVwb3J0IGJhc2VkIG9uIHRoZSBjb250ZW50IGluIHRoaXMgUERGIGRvY3VtZW50LiAke3NlY3Rpb25Ub1VwZGF0ZSAhPT0gJ2F1dG8tZGV0ZWN0JyA/IGBQbGVhc2UgZm9jdXMgb24gdXBkYXRpbmcgdGhlICR7c2VjdGlvblRvVXBkYXRlfSBzZWN0aW9uLmAgOiAnUGxlYXNlIGFuYWx5emUgdGhlIFBERiBhbmQgZGV0ZXJtaW5lIHdoaWNoIHNlY3Rpb24gb2YgdGhlIHJlcG9ydCB0byB1cGRhdGUuJ31cXG5cXG5IZXJlIGlzIHRoZSBjdXJyZW50IHJlcG9ydCBzdHJ1Y3R1cmU6XFxuXFxgXFxgXFxganNvblxcbiR7dmlld0NvbnRlbnR9XFxuXFxgXFxgXFxgXFxuXFxuRm9yIHN0YW5kYXJkaXplZCB0ZXN0cyBsaWtlIEdGVEEsIENFTEYsIGV0Yy4sIGlkZW50aWZ5IGtleSBzY29yZXMgYW5kIGZpbmRpbmdzLCBhbmQgdXBkYXRlIHRoZSBhcHByb3ByaWF0ZSBkb21haW4gc2VjdGlvbi4gRXh0cmFjdCBhbnkgcmVsZXZhbnQgcGhvbm9sb2dpY2FsIHByb2Nlc3NlcywgZXJyb3IgcGF0dGVybnMsIG9yIHNwZWNpZmljIHN0cmVuZ3Rocy9uZWVkcy5cXG5cXG5JTVBPUlRBTlQ6IFdoZW4gZXh0cmFjdGluZyBkYXRhIGZyb20gc3RhbmRhcmRpemVkIHRlc3RzLCBiZSBzdXJlIHRvIGFkZCB0aGUgdGVzdCdzIGZ1bGwgbmFtZSB0byB0aGUgZG9tYWluLmFzc2Vzc21lbnRUb29scyBhcnJheSB1c2luZyB0aGUgdXBkYXRlX2tleSBjb21tYW5kLiBGb3IgZXhhbXBsZSwgaWYgYW5hbHl6aW5nIEdGVEEtMyByZXN1bHRzIGZvciBhcnRpY3VsYXRpb24sIGluY2x1ZGUgXCJhc3Nlc3NtZW50VG9vbHNcIjogW1wiR29sZG1hbi1GcmlzdG9lIFRlc3Qgb2YgQXJ0aWN1bGF0aW9uLCBUaGlyZCBFZGl0aW9uIChHRlRBLTMpXCJdIGluIHlvdXIgdXBkYXRlLiBUaGlzIGhlbHBzIHRyYWNrIHdoaWNoIHRvb2xzIHdlcmUgdXNlZCBmb3IgZWFjaCBkb21haW4uXFxuXFxuUmVzcG9uZCB3aXRoIGFuIHVwZGF0ZV9rZXkgSlNPTiBjb21tYW5kIGFzIGRlc2NyaWJlZCBpbiB0aGUgc3lzdGVtIHByb21wdC5gXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImRvY3VtZW50XCIsXG4gICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJiYXNlNjRcIixcbiAgICAgICAgICAgICAgbWVkaWFfdHlwZTogXCJhcHBsaWNhdGlvbi9wZGZcIixcbiAgICAgICAgICAgICAgZGF0YTogbm9ybWFsaXplZElucHV0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IG1lc3NhZ2UgZm9yIHRleHQgY29udGVudFxuICAgICAgICB1c2VyQ29udGVudCA9IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IGBJIG5lZWQgdG8gdXBkYXRlIHRoZSBzcGVlY2gtbGFuZ3VhZ2UgcmVwb3J0IGJhc2VkIG9uIHRoaXMgbmV3IGluZm9ybWF0aW9uOlxuXCIke25vcm1hbGl6ZWRJbnB1dH1cIlxuXG5IZXJlIGlzIHRoZSBjdXJyZW50IHJlcG9ydCBzdHJ1Y3R1cmU6XG5cXGBcXGBcXGBqc29uXG4ke3ZpZXdDb250ZW50fVxuXFxgXFxgXFxgXG5cbiR7c2VjdGlvblRvVXBkYXRlID09PSAnYXV0by1kZXRlY3QnIFxuICA/ICdQbGVhc2UgYW5hbHl6ZSB0aGUgaW5wdXQgYW5kIGRldGVybWluZSB3aGljaCBzZWN0aW9uIG9mIHRoZSByZXBvcnQgdG8gdXBkYXRlLicgXG4gIDogYFBsZWFzZSB1cGRhdGUgdGhlICR7c2VjdGlvblRvVXBkYXRlfSBzZWN0aW9uLmB9XG5cbkRPIE5PVCB1c2UgdGhlIHRleHQgZWRpdG9yIHRvb2wuIEluc3RlYWQsIHJlc3BvbmQgd2l0aCBhbiB1cGRhdGVfa2V5IEpTT04gY29tbWFuZC5cblxuRm9yIGV4YW1wbGUsIGlmIHVwZGF0aW5nIHByYWdtYXRpYyBkb21haW4gc3RyZW5ndGhzIGFuZCBhZGRpbmcgYXNzZXNzbWVudCB0b29scywgcmVzcG9uZCB3aXRoOlxuXFxgXFxgXFxganNvblxue1xuICBcImNvbW1hbmRcIjogXCJ1cGRhdGVfa2V5XCIsXG4gIFwicGF0aFwiOiBcImFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnMucHJhZ21hdGljXCIsXG4gIFwiYWN0aW9uXCI6IFwibWVyZ2VcIixcbiAgXCJ2YWx1ZVwiOiB7XG4gICAgXCJzdHJlbmd0aHNcIjogW1wiU3R1ZGVudCBtYWludGFpbnMgZXllIGNvbnRhY3QgZHVyaW5nIGNvbnZlcnNhdGlvbnNcIl0sXG4gICAgXCJhc3Nlc3NtZW50VG9vbHNcIjogW1wiQ2xpbmljYWwgRXZhbHVhdGlvbiBvZiBMYW5ndWFnZSBGdW5kYW1lbnRhbHMtNSAoQ0VMRi01KVwiXVxuICB9XG59XG5cXGBcXGBcXGBcblxuR3VpZGVsaW5lczpcbi0gRm9yIHN0cmVuZ3Rocy9uZWVkcyBhcnJheXM6IHVzZSBcImFwcGVuZFwiIGFuZCBhcnJheSB2YWx1ZXNcbi0gRm9yIHRvcGljIHNlbnRlbmNlczogdXNlIFwicmVwbGFjZVwiIGFuZCBzdHJpbmcgdmFsdWVcbi0gRW1wdHkvbWlzc2luZyBmaWVsZHMgbmVlZCB0byBiZSBjcmVhdGVkIHdpdGggYXBwcm9wcmlhdGUgdmFsdWUgdHlwZXNcbi0gQW5hbHl6ZSB3aGljaCBkb21haW4gZml0cyBiZXN0OiByZWNlcHRpdmUsIGV4cHJlc3NpdmUsIHByYWdtYXRpYywgYXJ0aWN1bGF0aW9uLCB2b2ljZSwgZmx1ZW5jeVxuLSBUaGUgZG9tYWlucyBhcmUgZm91bmQgYXQgdGhlIHBhdGggXCJhc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zLltkb21haW5OYW1lXVwiXG5cbklNUE9SVEFOVDogRm9ybWF0IHlvdXIgZW50aXJlIHJlc3BvbnNlIGFzIGEgdGV4dCBtZXNzYWdlIGNvbnRhaW5pbmcgb25seSB0aGUgSlNPTiBjb21tYW5kLiBETyBOT1QgdXNlIHRoZSB0ZXh0IGVkaXRvciB0b29sLmBcbiAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGZpcnN0QXBpUGF5bG9hZCA9IHtcbiAgICAgICAgbW9kZWw6ICdjbGF1ZGUtMy03LXNvbm5ldC0yMDI1MDIxOScsXG4gICAgICAgIG1heF90b2tlbnM6IDEwMjQsXG4gICAgICAgIHN5c3RlbTogc3lzdGVtUHJvbXB0LFxuICAgICAgICB0b29sczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0X2VkaXRvcl8yMDI1MDEyNCcsXG4gICAgICAgICAgICBuYW1lOiAnc3RyX3JlcGxhY2VfZWRpdG9yJ1xuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICBjb250ZW50OiB1c2VyQ29udGVudFxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfTtcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5OkIEZpcnN0IEFQSSBwYXlsb2FkIHByZXBhcmVkLCB1c2VyIG1lc3NhZ2UgbGVuZ3RoOiAke25vcm1hbGl6ZWRJbnB1dC5sZW5ndGh9YCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vYXBpLmFudGhyb3BpYy5jb20vdjEvbWVzc2FnZXMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAneC1hcGkta2V5JzogYXBpS2V5LFxuICAgICAgICAgICdhbnRocm9waWMtdmVyc2lvbic6ICcyMDIzLTA2LTAxJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShmaXJzdEFwaVBheWxvYWQpXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinYwgRmlyc3QgQVBJIGNhbGwgZmFpbGVkOmAsIGVycm9yRGF0YSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHwgYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGxldCBjbGF1ZGVSZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgRmlyc3QgQ2xhdWRlIHJlc3BvbnNlIHJlY2VpdmVkLCBjb250ZW50IGJsb2NrczpgLCBcbiAgICAgICAgY2xhdWRlUmVzcG9uc2UuY29udGVudC5tYXAoKGJsb2NrOiBhbnkpID0+ICh7IHR5cGU6IGJsb2NrLnR5cGUsIC4uLihibG9jay50eXBlID09PSAndG9vbF91c2UnID8geyBjb21tYW5kOiBibG9jay5pbnB1dD8uY29tbWFuZCB9IDoge30pIH0pKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gSGFuZGxlIHRoZSB0d28td2F5IGNvbnZlcnNhdGlvbiBmbG93IHdpdGggQ2xhdWRlIGZvciB0aGUgdGV4dCBlZGl0b3IgdG9vbFxuICAgICAgbGV0IGZpbmFsQ29tbWFuZCA9IG51bGw7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIENsYXVkZSBpcyB1c2luZyBhIHRvb2xcbiAgICAgIGNvbnN0IHRvb2xVc2VCbG9jayA9IGNsYXVkZVJlc3BvbnNlLmNvbnRlbnQuZmluZCgoYmxvY2s6IGFueSkgPT4gXG4gICAgICAgIGJsb2NrLnR5cGUgPT09ICd0b29sX3VzZScgJiYgXG4gICAgICAgIGJsb2NrLm5hbWUgPT09ICdzdHJfcmVwbGFjZV9lZGl0b3InXG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBMb2cgdGhlIHRvb2wgdXNlIGJsb2NrXG4gICAgICBpZiAodG9vbFVzZUJsb2NrKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5ug77iPIENsYXVkZSBpcyB1c2luZyB0b29sOiAke3Rvb2xVc2VCbG9jay5uYW1lfSwgY29tbWFuZDogJHt0b29sVXNlQmxvY2suaW5wdXQ/LmNvbW1hbmR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pqg77iPIE5vIHRvb2wgdXNlIGJsb2NrIGZvdW5kIGluIENsYXVkZSdzIHJlc3BvbnNlYCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIElmIENsYXVkZSBpcyB1c2luZyB0aGUgXCJ2aWV3XCIgY29tbWFuZCBmaXJzdCAoY29tbW9uIHdpdGggdGV4dCBlZGl0b3IpXG4gICAgICBpZiAodG9vbFVzZUJsb2NrICYmIHRvb2xVc2VCbG9jay5pbnB1dCAmJiB0b29sVXNlQmxvY2suaW5wdXQuY29tbWFuZCA9PT0gJ3ZpZXcnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5GB77iPIENsYXVkZSBpcyByZXF1ZXN0aW5nIHRvIHZpZXcgY29udGVudCBmaXJzdC4gU2VuZGluZyBjb250ZW50Li4uYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZW5kIGJhY2sgdGhlIGNvbnRlbnQgdGhhdCBDbGF1ZGUgcmVxdWVzdGVkIHRvIHZpZXdcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflIwgTWFraW5nIHNlY29uZCBBUEkgY2FsbCB0byBDbGF1ZGUgd2l0aCB2aWV3IHJlc3VsdC4uLmApO1xuICAgICAgICAvLyBDcmVhdGUgYSBzZWNvbmQgQVBJIHBheWxvYWQgdGhhdCdzIGNvbnNpc3RlbnQgd2l0aCB0aGUgZmlyc3RcbiAgICAgICAgbGV0IHNlY29uZFVzZXJDb250ZW50ID0gW107XG4gICAgICAgIFxuICAgICAgICBpZiAoaXNQZGZVcGxvYWQpIHtcbiAgICAgICAgICAvLyBDb25zdHJ1Y3QgbWVzc2FnZSBmb3IgUERGIGNvbnRlbnQgd2l0aCBwcmV2aW91cyB2aWV3IHJlc3VsdFxuICAgICAgICAgIHNlY29uZFVzZXJDb250ZW50ID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgdGV4dDogYEkgbmVlZCB0byB1cGRhdGUgdGhlIHNwZWVjaC1sYW5ndWFnZSByZXBvcnQgYmFzZWQgb24gdGhlIGNvbnRlbnQgaW4gdGhpcyBQREYgZG9jdW1lbnQuICR7c2VjdGlvblRvVXBkYXRlICE9PSAnYXV0by1kZXRlY3QnID8gYFBsZWFzZSBmb2N1cyBvbiB1cGRhdGluZyB0aGUgJHtzZWN0aW9uVG9VcGRhdGV9IHNlY3Rpb24uYCA6ICdQbGVhc2UgYW5hbHl6ZSB0aGUgUERGIGFuZCBkZXRlcm1pbmUgd2hpY2ggc2VjdGlvbiBvZiB0aGUgcmVwb3J0IHRvIHVwZGF0ZS4nfVxcblxcblJlc3BvbmQgd2l0aCBhbiB1cGRhdGVfa2V5IEpTT04gY29tbWFuZCBhcyBkZXNjcmliZWQgaW4gdGhlIHN5c3RlbSBwcm9tcHQuYFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJkb2N1bWVudFwiLFxuICAgICAgICAgICAgICBzb3VyY2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgICAgIG1lZGlhX3R5cGU6IFwiYXBwbGljYXRpb24vcGRmXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogbm9ybWFsaXplZElucHV0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENvbnN0cnVjdCBtZXNzYWdlIGZvciB0ZXh0IGNvbnRlbnQgd2l0aCBwcmV2aW91cyB2aWV3IHJlc3VsdFxuICAgICAgICAgIHNlY29uZFVzZXJDb250ZW50ID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgdGV4dDogYEkgbmVlZCB0byB1cGRhdGUgdGhlIHNwZWVjaC1sYW5ndWFnZSByZXBvcnQgYmFzZWQgb24gdGhpcyBuZXcgaW5mb3JtYXRpb246XG5cIiR7bm9ybWFsaXplZElucHV0fVwiXG5cbiR7c2VjdGlvblRvVXBkYXRlID09PSAnYXV0by1kZXRlY3QnIFxuICA/ICdQbGVhc2UgYW5hbHl6ZSB0aGUgaW5wdXQgYW5kIGRldGVybWluZSB3aGljaCBzZWN0aW9uIG9mIHRoZSByZXBvcnQgdG8gdXBkYXRlLicgXG4gIDogYFBsZWFzZSB1cGRhdGUgdGhlICR7c2VjdGlvblRvVXBkYXRlfSBzZWN0aW9uLmB9XG5cbkRPIE5PVCB1c2UgdGhlIHRleHQgZWRpdG9yIHRvb2wuIEluc3RlYWQsIHJlc3BvbmQgd2l0aCBhbiB1cGRhdGVfa2V5IEpTT04gY29tbWFuZC5cblxuR3VpZGVsaW5lczpcbi0gRm9yIHN0cmVuZ3Rocy9uZWVkcyBhcnJheXM6IHVzZSBcImFwcGVuZFwiIGFuZCBhcnJheSB2YWx1ZXNcbi0gRm9yIHRvcGljIHNlbnRlbmNlczogdXNlIFwicmVwbGFjZVwiIGFuZCBzdHJpbmcgdmFsdWVcbi0gRW1wdHkvbWlzc2luZyBmaWVsZHMgbmVlZCB0byBiZSBjcmVhdGVkIHdpdGggYXBwcm9wcmlhdGUgdmFsdWUgdHlwZXNcbi0gQW5hbHl6ZSB3aGljaCBkb21haW4gZml0cyBiZXN0OiByZWNlcHRpdmUsIGV4cHJlc3NpdmUsIHByYWdtYXRpYywgYXJ0aWN1bGF0aW9uLCB2b2ljZSwgZmx1ZW5jeVxuLSBUaGUgZG9tYWlucyBhcmUgZm91bmQgYXQgdGhlIHBhdGggXCJhc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zLltkb21haW5OYW1lXVwiXG5cbklNUE9SVEFOVDogRm9ybWF0IHlvdXIgZW50aXJlIHJlc3BvbnNlIGFzIGEgdGV4dCBtZXNzYWdlIGNvbnRhaW5pbmcgb25seSB0aGUgSlNPTiBjb21tYW5kLiBETyBOT1QgdXNlIHRoZSB0ZXh0IGVkaXRvciB0b29sLmBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzZWNvbmRBcGlQYXlsb2FkID0ge1xuICAgICAgICAgIG1vZGVsOiAnY2xhdWRlLTMtNy1zb25uZXQtMjAyNTAyMTknLFxuICAgICAgICAgIG1heF90b2tlbnM6IDEwMjQsXG4gICAgICAgICAgc3lzdGVtOiBzeXN0ZW1Qcm9tcHQsXG4gICAgICAgICAgdG9vbHM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RleHRfZWRpdG9yXzIwMjUwMTI0JyxcbiAgICAgICAgICAgICAgbmFtZTogJ3N0cl9yZXBsYWNlX2VkaXRvcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgY29udGVudDogc2Vjb25kVXNlckNvbnRlbnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgdGV4dDogJ0lcXCdsbCBoZWxwIHlvdSB1cGRhdGUgdGhlIHJlcG9ydCB1c2luZyB0aGUgdGV4dCBlZGl0b3IgdG9vbC4nXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndG9vbF91c2UnLFxuICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xVc2VCbG9jay5pZCxcbiAgICAgICAgICAgICAgICAgIG5hbWU6ICdzdHJfcmVwbGFjZV9lZGl0b3InLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xVc2VCbG9jay5pbnB1dFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3Rvb2xfcmVzdWx0JyxcbiAgICAgICAgICAgICAgICAgIHRvb2xfdXNlX2lkOiB0b29sVXNlQmxvY2suaWQsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiB2aWV3Q29udGVudFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNlY29uZFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHBzOi8vYXBpLmFudGhyb3BpYy5jb20vdjEvbWVzc2FnZXMnLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICd4LWFwaS1rZXknOiBhcGlLZXksXG4gICAgICAgICAgICAnYW50aHJvcGljLXZlcnNpb24nOiAnMjAyMy0wNi0wMSdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHNlY29uZEFwaVBheWxvYWQpXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFzZWNvbmRSZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHNlY29uZFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4p2MIFNlY29uZCBBUEkgY2FsbCBmYWlsZWQ6YCwgZXJyb3JEYXRhKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yPy5tZXNzYWdlIHx8IGBBUEkgZXJyb3IgaW4gc2Vjb25kIHJlcXVlc3Q6ICR7c2Vjb25kUmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgQ2xhdWRlJ3MgcmVzcG9uc2Ugd2l0aCB0aGUgYWN0dWFsIGVkaXRcbiAgICAgICAgY2xhdWRlUmVzcG9uc2UgPSBhd2FpdCBzZWNvbmRSZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgU2Vjb25kIENsYXVkZSByZXNwb25zZSByZWNlaXZlZCwgY29udGVudCBibG9ja3M6YCwgXG4gICAgICAgICAgY2xhdWRlUmVzcG9uc2UuY29udGVudC5tYXAoKGJsb2NrOiBhbnkpID0+ICh7IHR5cGU6IGJsb2NrLnR5cGUsIC4uLihibG9jay50eXBlID09PSAndG9vbF91c2UnID8geyBjb21tYW5kOiBibG9jay5pbnB1dD8uY29tbWFuZCB9IDoge30pIH0pKVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gTm93IGNoZWNrIGZvciB0aGUgc3RyX3JlcGxhY2UgY29tbWFuZFxuICAgICAgICBjb25zdCBzZWNvbmRUb29sVXNlQmxvY2sgPSBjbGF1ZGVSZXNwb25zZS5jb250ZW50LmZpbmQoKGJsb2NrOiBhbnkpID0+IFxuICAgICAgICAgIGJsb2NrLnR5cGUgPT09ICd0b29sX3VzZScgJiYgXG4gICAgICAgICAgYmxvY2submFtZSA9PT0gJ3N0cl9yZXBsYWNlX2VkaXRvcidcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzZWNvbmRUb29sVXNlQmxvY2spIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+boO+4jyBTZWNvbmQgcmVzcG9uc2UgdG9vbCB1c2U6ICR7c2Vjb25kVG9vbFVzZUJsb2NrLm5hbWV9LCBjb21tYW5kOiAke3NlY29uZFRvb2xVc2VCbG9jay5pbnB1dD8uY29tbWFuZH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc2Vjb25kVG9vbFVzZUJsb2NrLmlucHV0ICYmIFxuICAgICAgICAgICAgIChzZWNvbmRUb29sVXNlQmxvY2suaW5wdXQuY29tbWFuZCA9PT0gJ3N0cl9yZXBsYWNlJyB8fCBzZWNvbmRUb29sVXNlQmxvY2suaW5wdXQuY29tbWFuZCA9PT0gJ2luc2VydCcpKSB7XG4gICAgICAgICAgICBmaW5hbENvbW1hbmQgPSBzZWNvbmRUb29sVXNlQmxvY2suaW5wdXQ7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pyFIEdvdCBmaW5hbCBjb21tYW5kOmAsIHtcbiAgICAgICAgICAgICAgY29tbWFuZDogZmluYWxDb21tYW5kLmNvbW1hbmQsXG4gICAgICAgICAgICAgIG9sZF9zdHI6IGZpbmFsQ29tbWFuZC5vbGRfc3RyID8gYCR7ZmluYWxDb21tYW5kLm9sZF9zdHIuc3Vic3RyaW5nKDAsIDUwKX0uLi5gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBuZXdfc3RyOiBmaW5hbENvbW1hbmQubmV3X3N0ciA/IGAke2ZpbmFsQ29tbWFuZC5uZXdfc3RyLnN1YnN0cmluZygwLCA1MCl9Li4uYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgdGV4dDogZmluYWxDb21tYW5kLnRleHQgPyBgJHtmaW5hbENvbW1hbmQudGV4dC5zdWJzdHJpbmcoMCwgNTApfS4uLmAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBmaW5hbENvbW1hbmQucG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pqg77iPIFNlY29uZCB0b29sIHVzZSBibG9jayBkb2Vzbid0IGNvbnRhaW4gc3RyX3JlcGxhY2Ugb3IgaW5zZXJ0IGNvbW1hbmQ6YCwgc2Vjb25kVG9vbFVzZUJsb2NrLmlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKaoO+4jyBObyB0b29sIHVzZSBibG9jayBmb3VuZCBpbiBDbGF1ZGUncyBzZWNvbmQgcmVzcG9uc2VgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0b29sVXNlQmxvY2sgJiYgdG9vbFVzZUJsb2NrLmlucHV0ICYmIFxuICAgICAgICAgICAgICAgICh0b29sVXNlQmxvY2suaW5wdXQuY29tbWFuZCA9PT0gJ3N0cl9yZXBsYWNlJyB8fCB0b29sVXNlQmxvY2suaW5wdXQuY29tbWFuZCA9PT0gJ2luc2VydCcpKSB7XG4gICAgICAgIC8vIENsYXVkZSBkaXJlY3RseSB1c2VkIHN0cl9yZXBsYWNlIG9yIGluc2VydCAodW51c3VhbCBidXQgcG9zc2libGUpXG4gICAgICAgIGZpbmFsQ29tbWFuZCA9IHRvb2xVc2VCbG9jay5pbnB1dDtcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBHb3QgZmluYWwgY29tbWFuZCBkaXJlY3RseSBmcm9tIGZpcnN0IHJlc3BvbnNlOmAsIHtcbiAgICAgICAgICBjb21tYW5kOiBmaW5hbENvbW1hbmQuY29tbWFuZCxcbiAgICAgICAgICBvbGRfc3RyOiBmaW5hbENvbW1hbmQub2xkX3N0ciA/IGAke2ZpbmFsQ29tbWFuZC5vbGRfc3RyLnN1YnN0cmluZygwLCA1MCl9Li4uYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXdfc3RyOiBmaW5hbENvbW1hbmQubmV3X3N0ciA/IGAke2ZpbmFsQ29tbWFuZC5uZXdfc3RyLnN1YnN0cmluZygwLCA1MCl9Li4uYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB0ZXh0OiBmaW5hbENvbW1hbmQudGV4dCA/IGAke2ZpbmFsQ29tbWFuZC50ZXh0LnN1YnN0cmluZygwLCA1MCl9Li4uYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBwb3NpdGlvbjogZmluYWxDb21tYW5kLnBvc2l0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKaoO+4jyBObyB1c2FibGUgY29tbWFuZCBmb3VuZCBpbiBDbGF1ZGUncyByZXNwb25zZXNgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIEpTT04gcGF0aCB1cGRhdGUgY29tbWFuZCBpbiBDbGF1ZGUncyByZXNwb25zZSB0ZXh0XG4gICAgICBsZXQgdXBkYXRlS2V5Q29tbWFuZCA9IG51bGw7XG4gICAgICBjb25zdCB0ZXh0QmxvY2tzID0gY2xhdWRlUmVzcG9uc2UuY29udGVudC5maWx0ZXIoKGJsb2NrOiBhbnkpID0+IGJsb2NrLnR5cGUgPT09ICd0ZXh0Jyk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgYmxvY2sgb2YgdGV4dEJsb2Nrcykge1xuICAgICAgICAvLyBMb29rIGZvciBKU09OIG9iamVjdHMgaW4gdGhlIHRleHQgdGhhdCBtaWdodCBjb250YWluIG91ciBjb21tYW5kXG4gICAgICAgIGNvbnN0IGpzb25NYXRjaGVzID0gYmxvY2sudGV4dC5tYXRjaCgvYGBganNvblxccyooe1tcXHNcXFNdKj99KVxccypgYGB8KHtbXFxzXFxTXSpcImNvbW1hbmRcIltcXHNcXFNdKn0pL2cpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGpzb25NYXRjaGVzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBqc29uTWF0Y2hlcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgSlNPTiBvYmplY3QgZnJvbSBtYXJrZG93biBjb2RlIGJsb2NrcyBvciBwbGFpbiB0ZXh0XG4gICAgICAgICAgICAgIGNvbnN0IGpzb25TdHIgPSBtYXRjaC5yZXBsYWNlKC9gYGBqc29uXFxzKnxcXHMqYGBgL2csICcnKS50cmltKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGpzb25PYmogPSBKU09OLnBhcnNlKGpzb25TdHIpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiB1cGRhdGVfa2V5IGNvbW1hbmRcbiAgICAgICAgICAgICAgaWYgKGpzb25PYmouY29tbWFuZCA9PT0gJ3VwZGF0ZV9rZXknICYmIGpzb25PYmoucGF0aCAmJiBqc29uT2JqLmFjdGlvbiAmJiBqc29uT2JqLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVLZXlDb21tYW5kID0ganNvbk9iajtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UkSBGb3VuZCB1cGRhdGVfa2V5IGNvbW1hbmQgaW4gdGV4dDpgLCB1cGRhdGVLZXlDb21tYW5kKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFske3JlcXVlc3RJZH1dIOKaoO+4jyBGYWlsZWQgdG8gcGFyc2UgcG90ZW50aWFsIEpTT04gY29tbWFuZDpgLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh1cGRhdGVLZXlDb21tYW5kKSBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyB0aGUgY29tbWFuZCBpZiB3ZSBoYXZlIG9uZSAoZWl0aGVyIHVwZGF0ZV9rZXkgb3IgdGV4dCBlZGl0b3IgY29tbWFuZClcbiAgICAgIGlmICh1cGRhdGVLZXlDb21tYW5kKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SEIFByb2Nlc3NpbmcgdXBkYXRlX2tleSBjb21tYW5kLi4uYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5OKIFVwZGF0ZSBkZXRhaWxzOiBwYXRoPSR7dXBkYXRlS2V5Q29tbWFuZC5wYXRofSwgYWN0aW9uPSR7dXBkYXRlS2V5Q29tbWFuZC5hY3Rpb259YCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgdXBkYXRlZFJlcG9ydCA9IHsgLi4ucmVwb3J0IH07XG4gICAgICAgIGxldCBhZmZlY3RlZERvbWFpbiA9ICcnO1xuICAgICAgICBcbiAgICAgICAgLy8gRXh0cmFjdCBkb21haW4gaWYgcGF0aCBzdGFydHMgd2l0aCBkb21haW5zLlhcbiAgICAgICAgaWYgKHVwZGF0ZUtleUNvbW1hbmQucGF0aC5zdGFydHNXaXRoKCdkb21haW5zLicpKSB7XG4gICAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gdXBkYXRlS2V5Q29tbWFuZC5wYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgICAgaWYgKHBhdGhQYXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgYWZmZWN0ZWREb21haW4gPSBwYXRoUGFydHNbMV07XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+OryBBZmZlY3RlZCBkb21haW4gZnJvbSBwYXRoOiAke2FmZmVjdGVkRG9tYWlufWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBcHBseSB0aGUgdXBkYXRlIGJhc2VkIG9uIHRoZSBwYXRoIGFuZCBhY3Rpb25cbiAgICAgICAgICBjb25zdCBwYXRoUGFydHMgPSB1cGRhdGVLZXlDb21tYW5kLnBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgICBsZXQgY3VycmVudCA9IHVwZGF0ZWRSZXBvcnQ7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTmF2aWdhdGUgdG8gdGhlIHBhcmVudCBvYmplY3Qgb2YgdGhlIHRhcmdldCBwcm9wZXJ0eVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aFBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50W3BhdGhQYXJ0c1tpXV0pIHtcbiAgICAgICAgICAgICAgLy8gQ3JlYXRlIG1pc3Npbmcgb2JqZWN0cyBpbiB0aGUgcGF0aFxuICAgICAgICAgICAgICBjdXJyZW50W3BhdGhQYXJ0c1tpXV0gPSB7fTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfj5fvuI8gQ3JlYXRlZCBtaXNzaW5nIG9iamVjdCBhdCAke3BhdGhQYXJ0cy5zbGljZSgwLCBpKzEpLmpvaW4oJy4nKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhdGhQYXJ0c1tpXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgdGFyZ2V0IHByb3BlcnR5IG5hbWVcbiAgICAgICAgICBjb25zdCB0YXJnZXRQcm9wID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBcHBseSB0aGUgYWN0aW9uXG4gICAgICAgICAgc3dpdGNoICh1cGRhdGVLZXlDb21tYW5kLmFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnYXBwZW5kJzpcbiAgICAgICAgICAgICAgLy8gRm9yIGFycmF5cywgYXBwZW5kIHRoZSBuZXcgdmFsdWVzXG4gICAgICAgICAgICAgIGlmICghY3VycmVudFt0YXJnZXRQcm9wXSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbdGFyZ2V0UHJvcF0gPSBbXTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShjdXJyZW50W3RhcmdldFByb3BdKSkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gYXJyYXkgaWYgbm90IGFscmVhZHlcbiAgICAgICAgICAgICAgICBjdXJyZW50W3RhcmdldFByb3BdID0gW2N1cnJlbnRbdGFyZ2V0UHJvcF1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBIYW5kbGUgYm90aCBzaW5nbGUgdmFsdWUgYW5kIGFycmF5IG9mIHZhbHVlc1xuICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh1cGRhdGVLZXlDb21tYW5kLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbdGFyZ2V0UHJvcF0gPSBbLi4uY3VycmVudFt0YXJnZXRQcm9wXSwgLi4udXBkYXRlS2V5Q29tbWFuZC52YWx1ZV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFt0YXJnZXRQcm9wXS5wdXNoKHVwZGF0ZUtleUNvbW1hbmQudmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pyFIEFwcGVuZGVkIHRvICR7dXBkYXRlS2V5Q29tbWFuZC5wYXRofSwgbmV3IGxlbmd0aDogJHtjdXJyZW50W3RhcmdldFByb3BdLmxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIHZhbHVlIGVudGlyZWx5XG4gICAgICAgICAgICAgIGN1cnJlbnRbdGFyZ2V0UHJvcF0gPSB1cGRhdGVLZXlDb21tYW5kLnZhbHVlO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pyFIFJlcGxhY2VkICR7dXBkYXRlS2V5Q29tbWFuZC5wYXRofWApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICBjYXNlICdtZXJnZSc6XG4gICAgICAgICAgICAgIC8vIEZvciBvYmplY3RzLCBtZXJnZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgIGlmICghY3VycmVudFt0YXJnZXRQcm9wXSB8fCB0eXBlb2YgY3VycmVudFt0YXJnZXRQcm9wXSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShjdXJyZW50W3RhcmdldFByb3BdKSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRbdGFyZ2V0UHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY3VycmVudFt0YXJnZXRQcm9wXSA9IHsgXG4gICAgICAgICAgICAgICAgLi4uY3VycmVudFt0YXJnZXRQcm9wXSwgXG4gICAgICAgICAgICAgICAgLi4udXBkYXRlS2V5Q29tbWFuZC52YWx1ZSBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgTWVyZ2VkIGludG8gJHt1cGRhdGVLZXlDb21tYW5kLnBhdGh9YCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgWyR7cmVxdWVzdElkfV0g4pqg77iPIFVua25vd24gYWN0aW9uOiAke3VwZGF0ZUtleUNvbW1hbmQuYWN0aW9ufWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgbWV0YWRhdGFcbiAgICAgICAgICB1cGRhdGVkUmVwb3J0Lm1ldGFkYXRhLmxhc3RVcGRhdGVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgIHVwZGF0ZWRSZXBvcnQubWV0YWRhdGEudmVyc2lvbiA9ICh1cGRhdGVkUmVwb3J0Lm1ldGFkYXRhLnZlcnNpb24gfHwgMCkgKyAxO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgU3VjY2Vzc2Z1bGx5IGFwcGxpZWQgdXBkYXRlX2tleSBjb21tYW5kYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgIHJlcG9ydDogdXBkYXRlZFJlcG9ydCxcbiAgICAgICAgICAgIGNvbW1hbmQ6IHVwZGF0ZUtleUNvbW1hbmQsXG4gICAgICAgICAgICBhZmZlY3RlZERvbWFpblxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske3JlcXVlc3RJZH1dIOKdjCBFcnJvciBhcHBseWluZyB1cGRhdGVfa2V5IGNvbW1hbmQ6YCwgZXJyb3IpO1xuICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byBhcHBseSB1cGRhdGVfa2V5IGNvbW1hbmQnLFxuICAgICAgICAgICAgZGV0YWlsczogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICAgICAgICBjb21tYW5kOiB1cGRhdGVLZXlDb21tYW5kXG4gICAgICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaW5hbENvbW1hbmQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflIQgUHJvY2Vzc2luZyAke2ZpbmFsQ29tbWFuZC5jb21tYW5kfSBjb21tYW5kLi4uYCk7XG4gICAgICAgIC8vIEdldCBDbGF1ZGUncyBhbmFseXNpcyBvZiB3aGljaCBkb21haW4vc2VjdGlvbiB0byB1cGRhdGVcbiAgICAgICAgbGV0IGFmZmVjdGVkRG9tYWluID0gJyc7XG4gICAgICAgIGxldCB1cGRhdGVkUmVwb3J0ID0geyAuLi5yZXBvcnQgfTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzZWN0aW9uVG9VcGRhdGUgPT09ICdhdXRvLWRldGVjdCcpIHtcbiAgICAgICAgICAvLyBFeHRyYWN0IGRvbWFpbiBmcm9tIENsYXVkZSdzIHJlc3BvbnNlIHRleHRcbiAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudCA9IGNsYXVkZVJlc3BvbnNlLmNvbnRlbnRcbiAgICAgICAgICAgIC5maWx0ZXIoKGJsb2NrOiBhbnkpID0+IGJsb2NrLnR5cGUgPT09ICd0ZXh0JylcbiAgICAgICAgICAgIC5tYXAoKGJsb2NrOiBhbnkpID0+IGJsb2NrLnRleHQpXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRXh0cmFjdCBkb21haW4gZnJvbSB0ZXh0IC0gbG9vayBmb3Igc3BlY2lmaWMgcGF0dGVybnMgbGlrZSBcInByYWdtYXRpYyBkb21haW5cIiBvciBcInVwZGF0ZSB0aGUgcHJhZ21hdGljXCJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBBbmFseXppbmcgdGV4dCBmb3IgZG9tYWluIGtleXdvcmRzLi4uYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTGlzdCBvZiBkb21haW4ga2V5d29yZHMgdG8gc2VhcmNoIGZvclxuICAgICAgICAgIGNvbnN0IGRvbWFpbktleXdvcmRzID0gWydyZWNlcHRpdmUnLCAnZXhwcmVzc2l2ZScsICdwcmFnbWF0aWMnLCAnYXJ0aWN1bGF0aW9uJywgJ3ZvaWNlJywgJ2ZsdWVuY3knXTtcbiAgICAgICAgICBsZXQgZm91bmREb21haW4gPSAnJztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaXJzdCBsb29rIGZvciB0aGUgcGF0aCBwYXR0ZXJuIGluIEpTT04gY29tbWFuZHNcbiAgICAgICAgICBjb25zdCBwYXRoUmVnZXggPSAvXCJwYXRoXCI6XFxzKlwiYXNzZXNzbWVudFJlc3VsdHNcXC5kb21haW5zXFwuKFteLlwiXSspXCIvO1xuICAgICAgICAgIGNvbnN0IHBhdGhNYXRjaCA9IHRleHRDb250ZW50Lm1hdGNoKHBhdGhSZWdleCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHBhdGhNYXRjaCAmJiBwYXRoTWF0Y2hbMV0pIHtcbiAgICAgICAgICAgIGZvdW5kRG9tYWluID0gcGF0aE1hdGNoWzFdO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflI0gRm91bmQgZG9tYWluIGluIEpTT04gcGF0aDogXCIke2ZvdW5kRG9tYWlufVwiYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBkb21haW4ga2V5d29yZHMgaW4gdGhlIHRleHRcbiAgICAgICAgICAgIGZvciAoY29uc3QgZG9tYWluIG9mIGRvbWFpbktleXdvcmRzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKGBcXFxcYiR7ZG9tYWlufVxcXFxiYCwgJ2knKTtcbiAgICAgICAgICAgICAgaWYgKHBhdHRlcm4udGVzdCh0ZXh0Q29udGVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBGb3VuZCBkb21haW4ga2V5d29yZCBpbiB0ZXh0OiBcIiR7ZG9tYWlufVwiYCk7XG4gICAgICAgICAgICAgICAgZm91bmREb21haW4gPSBkb21haW47XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgYWZmZWN0ZWREb21haW4gPSBmb3VuZERvbWFpbjtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBBdXRvLWRldGVjdGVkIGRvbWFpbjogJHthZmZlY3RlZERvbWFpbiB8fCAnbm9uZSBkZXRlY3RlZCd9YCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfk50gVGV4dCBjb250ZW50IGZvciBkb21haW4gZGV0ZWN0aW9uOmAsIHRleHRDb250ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWN0aW9uVG9VcGRhdGUuc3RhcnRzV2l0aCgnYXNzZXNzbWVudFJlc3VsdHMuZG9tYWlucy4nKSkge1xuICAgICAgICAgIGFmZmVjdGVkRG9tYWluID0gc2VjdGlvblRvVXBkYXRlLnNwbGl0KCcuJylbMl07XG4gICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfjq8gVXNpbmcgc3BlY2lmaWVkIGRvbWFpbjogJHthZmZlY3RlZERvbWFpbn1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGZpbmFsQ29tbWFuZC5jb21tYW5kID09PSAnc3RyX3JlcGxhY2UnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflIQgUHJvY2Vzc2luZyBzdHJfcmVwbGFjZSBjb21tYW5kLi4uYCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKaoO+4jyBOb3RlOiBzdHJfcmVwbGFjZSBpcyBiZWluZyB1c2VkIGluc3RlYWQgb2YgdGhlIHJlY29tbWVuZGVkIHVwZGF0ZV9rZXkgY29tbWFuZGApO1xuICAgICAgICAgIGxldCB1cGRhdGVkQ29udGVudCA9ICcnO1xuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlIHN0cl9yZXBsYWNlIGNvbW1hbmQgaXMgdGFyZ2V0aW5nIGEgc3BlY2lmaWMgZG9tYWluXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRldGVjdCB0aGlzIGJ5IHNlZWluZyBpZiB0aGUgb2xkX3N0ciBjb250YWlucyBzcGVjaWZpYyBkb21haW4gSlNPTlxuICAgICAgICAgICAgY29uc3Qgc3RyQ29udGFpbnNEb21haW5QYXR0ZXJuID0gT2JqZWN0LmtleXMocmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnMpLnNvbWUoZG9tYWluID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IGBcIiR7ZG9tYWlufVwiOlxcXFxzKntgO1xuICAgICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybiwgJ2knKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoZmluYWxDb21tYW5kLm9sZF9zdHIgfHwgJycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SNIENvbW1hbmQgY29udGFpbnMgZG9tYWluIHBhdHRlcm4gaW4gb2xkX3N0cjogJHtzdHJDb250YWluc0RvbWFpblBhdHRlcm59YCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGF1dG8tZGV0ZWN0ZWQgYSBkb21haW4gYW5kIGl0IGV4aXN0cyBpbiB0aGUgcmVwb3J0XG4gICAgICAgICAgICBpZiAoYWZmZWN0ZWREb21haW4gJiYgcmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnNbYWZmZWN0ZWREb21haW5dKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SEIFVwZGF0aW5nIHNwZWNpZmljIGRvbWFpbjogJHthZmZlY3RlZERvbWFpbn1gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIENsYXVkZSdzIHN0cl9yZXBsYWNlIGlzIGRpcmVjdGx5IHRhcmdldGluZyB0aGlzIGRvbWFpbiBzZWN0aW9uXG4gICAgICAgICAgICAgIGlmIChmaW5hbENvbW1hbmQub2xkX3N0ciAmJiBmaW5hbENvbW1hbmQub2xkX3N0ci5pbmNsdWRlcyhgXCIke2FmZmVjdGVkRG9tYWlufVwiYCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+OryBEaXJlY3QgbWF0Y2g6IENsYXVkZSdzIGNvbW1hbmQgdGFyZ2V0cyAke2FmZmVjdGVkRG9tYWlufSBkb21haW5gKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBJbXBsZW1lbnQgYSBtb3JlIGNhcmVmdWwgc2VhcmNoIGFuZCByZXBsYWNlIGZvciB0aGUgc3BlY2lmaWMgZG9tYWluXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCB0aGUgZnVsbCByZXBvcnQgSlNPTlxuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxSZXBvcnRKc29uID0gSlNPTi5zdHJpbmdpZnkocmVwb3J0LCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBkb21haW4gc2VjdGlvbiBpbiB0aGUgSlNPTlxuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpblBhdHRlcm4gPSBuZXcgUmVnRXhwKGAoXFxcXHMqXCIke2FmZmVjdGVkRG9tYWlufVwiXFxcXHMqOlxcXFxzKntbXn1dKn0pYCwgJ3MnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb21haW5NYXRjaCA9IGZ1bGxSZXBvcnRKc29uLm1hdGNoKGRvbWFpblBhdHRlcm4pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChkb21haW5NYXRjaCkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBGb3VuZCBkb21haW4gc2VjdGlvbiBpbiBKU09OYCk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UganVzdCB0aGUgZG9tYWluIHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50ID0gZnVsbFJlcG9ydEpzb24ucmVwbGFjZShcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluTWF0Y2hbMF0sIFxuICAgICAgICAgICAgICAgICAgICBmaW5hbENvbW1hbmQubmV3X3N0ci50cmltKClcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBjb21wbGV0ZSB1cGRhdGVkIHJlcG9ydFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkUmVwb3J0ID0gSlNPTi5wYXJzZSh1cGRhdGVkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgU3VjY2Vzc2Z1bGx5IHJlcGxhY2VkIGRvbWFpbiBzZWN0aW9uIGluIGZ1bGwgcmVwb3J0YCk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFske3JlcXVlc3RJZH1dIOKdjCBKU09OIHBhcnNlIGVycm9yIGFmdGVyIGRvbWFpbiByZXBsYWNlbWVudDpgLCBwYXJzZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHVwZGF0aW5nIGp1c3QgdGhlIGRvbWFpbiBzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpblNlY3Rpb24gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlcG9ydC5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zW2FmZmVjdGVkRG9tYWluXSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb21haW5Kc29uID0gSlNPTi5zdHJpbmdpZnkoZG9tYWluU2VjdGlvbiwgbnVsbCwgMik7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBleHRyYWN0IGp1c3QgdGhlIGRvbWFpbiBvYmplY3QgZnJvbSBDbGF1ZGUncyBuZXdfc3RyXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9tYWluT2JqZWN0TWF0Y2ggPSBmaW5hbENvbW1hbmQubmV3X3N0ci5tYXRjaCgve1xccypcInRvcGljU2VudGVuY2VcIi4qfS9zKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9tYWluT2JqZWN0TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RvbWFpblNlY3Rpb24gPSBKU09OLnBhcnNlKGRvbWFpbk9iamVjdE1hdGNoWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRSZXBvcnQgPSB1cGRhdGVEb21haW5TZWN0aW9uKHJlcG9ydCwgYWZmZWN0ZWREb21haW4sIG5ld0RvbWFpblNlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBGYWxsYmFjazogVXBkYXRlZCBkb21haW4gc2VjdGlvbiB2aWEgZXh0cmFjdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBleHRyYWN0IGRvbWFpbiBvYmplY3QgZnJvbSBuZXdfc3RyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleHRyYWN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBbJHtyZXF1ZXN0SWR9XSDinYwgRmFpbGVkIHRvIGV4dHJhY3QgZG9tYWluIG9iamVjdDpgLCBleHRyYWN0RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogJ0ZhaWxlZCB0byB1cGRhdGUgcmVwb3J0IC0gaW52YWxpZCBKU09OIGZvcm1hdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3I6IHBhcnNlRXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdEVycm9yOiBleHRyYWN0RXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7cmVxdWVzdElkfV0g4p2MIENvdWxkIG5vdCBmaW5kIGRvbWFpbiBzZWN0aW9uIGluIEpTT05gKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gdXBkYXRpbmcgdmlhIGRvbWFpbiBvYmplY3RcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpblNlY3Rpb24gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlcG9ydC5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zW2FmZmVjdGVkRG9tYWluXSkpO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfk4ogT3JpZ2luYWwgZG9tYWluIHNlY3Rpb246YCwgZG9tYWluU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbnN0cnVjdCBhbiB1cGRhdGVkIGRvbWFpbiBzZWN0aW9uIGJhc2VkIG9uIHRoZSBjb250ZW50XG4gICAgICAgICAgICAgICAgICBjb25zdCBleHRyYWN0ZWRDb250ZW50ID0ge307XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBleHRyYWN0IHRvcGljIHNlbnRlbmNlXG4gICAgICAgICAgICAgICAgICBjb25zdCB0c01hdGNoID0gZmluYWxDb21tYW5kLm5ld19zdHIubWF0Y2goL1widG9waWNTZW50ZW5jZVwiOlxccypcIihbXlwiXSopXCIvKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0c01hdGNoKSBleHRyYWN0ZWRDb250ZW50Wyd0b3BpY1NlbnRlbmNlJ10gPSB0c01hdGNoWzFdO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gZXh0cmFjdCBldmlkZW5jZSAoc2ltcGxpZmllZClcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV2aWRlbmNlTWF0Y2ggPSBmaW5hbENvbW1hbmQubmV3X3N0ci5tYXRjaCgvXCJldmlkZW5jZVwiOlxccypcXFsoLio/KVxcXS9zKTtcbiAgICAgICAgICAgICAgICAgIGlmIChldmlkZW5jZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdGVkQ29udGVudFsnZXZpZGVuY2UnXSA9IEpTT04ucGFyc2UoYFske2V2aWRlbmNlTWF0Y2hbMV19XWApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbJHtyZXF1ZXN0SWR9XSDimqDvuI8gQ291bGQgbm90IHBhcnNlIGV2aWRlbmNlYCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgY2hhbGxlbmdlcyAoc2ltcGxpZmllZClcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYWxsZW5nZXNNYXRjaCA9IGZpbmFsQ29tbWFuZC5uZXdfc3RyLm1hdGNoKC9cImNoYWxsZW5nZXNcIjpcXHMqXFxbKC4qPylcXF0vcyk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhbGxlbmdlc01hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdGVkQ29udGVudFsnY2hhbGxlbmdlcyddID0gSlNPTi5wYXJzZShgWyR7Y2hhbGxlbmdlc01hdGNoWzFdfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgWyR7cmVxdWVzdElkfV0g4pqg77iPIENvdWxkIG5vdCBwYXJzZSBjaGFsbGVuZ2VzYCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBkb21haW4gd2l0aCB0aGUgZXh0cmFjdGVkIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRSZXBvcnQgPSB1cGRhdGVEb21haW5TZWN0aW9uKHJlcG9ydCwgYWZmZWN0ZWREb21haW4sIGV4dHJhY3RlZENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKchSBVc2VkIGV4dHJhY3Rpb24gdG8gdXBkYXRlIGRvbWFpbiBzZWN0aW9uYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFN0YW5kYXJkIGRvbWFpbiBzZWN0aW9uIHVwZGF0ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGRvbWFpblNlY3Rpb24gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlcG9ydC5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zW2FmZmVjdGVkRG9tYWluXSkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5OKIE9yaWdpbmFsIGRvbWFpbiBzZWN0aW9uOmAsIGRvbWFpblNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SEIEFwcGx5aW5nIHN0cl9yZXBsYWNlOmAsIHtcbiAgICAgICAgICAgICAgICAgIG9sZF9zdHJfbGVuZ3RoOiBmaW5hbENvbW1hbmQub2xkX3N0cj8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgICAgICAgICBuZXdfc3RyX2xlbmd0aDogZmluYWxDb21tYW5kLm5ld19zdHI/Lmxlbmd0aCB8fCAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSW5zdGVhZCBvZiBhIGdlbmVyYWwgcmVwbGFjZSwgd2UnbGwgdHJ5IHRvIGltcHJvdmUgdGhlIGRvbWFpbiBkaXJlY3RseVxuICAgICAgICAgICAgICAgIGlmIChmaW5hbENvbW1hbmQubmV3X3N0ciAmJiBmaW5hbENvbW1hbmQubmV3X3N0ci5pbmNsdWRlcygnXCJ0b3BpY1NlbnRlbmNlXCInKSkge1xuICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGV4dHJhY3QgSlNPTiBzdHJ1Y3R1cmUgZnJvbSB0aGUgbmV3IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgY29uc3QganNvbk1hdGNoID0gZmluYWxDb21tYW5kLm5ld19zdHIubWF0Y2goLyh7W1xcc1xcU10qfSkvKTtcbiAgICAgICAgICAgICAgICAgIGlmIChqc29uTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgSlNPTiBmcm9tIHRoZSBuZXcgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZERvbWFpblNlY3Rpb24gPSBKU09OLnBhcnNlKGpzb25NYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzcGVjaWZpYyBkb21haW4gaW4gdGhlIHJlcG9ydFxuICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRSZXBvcnQgPSB1cGRhdGVEb21haW5TZWN0aW9uKHJlcG9ydCwgYWZmZWN0ZWREb21haW4sIHVwZGF0ZWREb21haW5TZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pyFIFN1Y2Nlc3NmdWxseSBleHRyYWN0ZWQgYW5kIHVwZGF0ZWQgZG9tYWluIEpTT05gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoanNvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7cmVxdWVzdElkfV0g4p2MIEVycm9yIHBhcnNpbmcgZXh0cmFjdGVkIEpTT046YCwganNvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBzdGFuZGFyZCByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoZG9tYWluU2VjdGlvbikucmVwbGFjZShmaW5hbENvbW1hbmQub2xkX3N0ciB8fCAnJywgZmluYWxDb21tYW5kLm5ld19zdHIgfHwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWREb21haW5TZWN0aW9uID0gSlNPTi5wYXJzZSh1cGRhdGVkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZFJlcG9ydCA9IHVwZGF0ZURvbWFpblNlY3Rpb24ocmVwb3J0LCBhZmZlY3RlZERvbWFpbiwgdXBkYXRlZERvbWFpblNlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBKU09OIHN0cnVjdHVyZSBmb3VuZCwgdXNlIHN0YW5kYXJkIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoZG9tYWluU2VjdGlvbikucmVwbGFjZShmaW5hbENvbW1hbmQub2xkX3N0ciB8fCAnJywgZmluYWxDb21tYW5kLm5ld19zdHIgfHwgJycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkRG9tYWluU2VjdGlvbiA9IEpTT04ucGFyc2UodXBkYXRlZENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkUmVwb3J0ID0gdXBkYXRlRG9tYWluU2VjdGlvbihyZXBvcnQsIGFmZmVjdGVkRG9tYWluLCB1cGRhdGVkRG9tYWluU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIFN0YW5kYXJkIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICB1cGRhdGVkQ29udGVudCA9IEpTT04uc3RyaW5naWZ5KGRvbWFpblNlY3Rpb24pLnJlcGxhY2UoZmluYWxDb21tYW5kLm9sZF9zdHIgfHwgJycsIGZpbmFsQ29tbWFuZC5uZXdfc3RyIHx8ICcnKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWREb21haW5TZWN0aW9uID0gSlNPTi5wYXJzZSh1cGRhdGVkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVkUmVwb3J0ID0gdXBkYXRlRG9tYWluU2VjdGlvbihyZXBvcnQsIGFmZmVjdGVkRG9tYWluLCB1cGRhdGVkRG9tYWluU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgRG9tYWluIHNlY3Rpb24gdXBkYXRlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJDb250YWluc0RvbWFpblBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgLy8gV2UgZGV0ZWN0ZWQgYSBkb21haW4gcGF0dGVybiBpbiB0aGUgc3RyX3JlcGxhY2UgY29tbWFuZCwgc28gdHJ5IHRvIGV4dHJhY3QgdGhlIGRvbWFpbiBuYW1lXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SOIFRyeWluZyB0byBleHRyYWN0IGRvbWFpbiBmcm9tIHN0cl9yZXBsYWNlIGNvbW1hbmQuLi5gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGxldCBleHRyYWN0ZWREb21haW4gPSAnJztcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBkb21haW4gb2YgT2JqZWN0LmtleXMocmVwb3J0LmFzc2Vzc21lbnRSZXN1bHRzLmRvbWFpbnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsQ29tbWFuZC5vbGRfc3RyPy5pbmNsdWRlcyhgXCIke2RvbWFpbn1cImApKSB7XG4gICAgICAgICAgICAgICAgICBleHRyYWN0ZWREb21haW4gPSBkb21haW47XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChleHRyYWN0ZWREb21haW4pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBFeHRyYWN0ZWQgZG9tYWluIGZyb20gY29tbWFuZDogJHtleHRyYWN0ZWREb21haW59YCk7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWREb21haW4gPSBleHRyYWN0ZWREb21haW47XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTm93IHVwZGF0ZSB1c2luZyB0aGUgZnVsbCByZXBvcnQgdXBkYXRlLCB0aGVuIHJlLXByb2Nlc3Mgd2l0aCB0aGUgY29ycmVjdCBkb21haW5cbiAgICAgICAgICAgICAgICB1cGRhdGVkQ29udGVudCA9IEpTT04uc3RyaW5naWZ5KHJlcG9ydCwgbnVsbCwgMikucmVwbGFjZShmaW5hbENvbW1hbmQub2xkX3N0ciB8fCAnJywgZmluYWxDb21tYW5kLm5ld19zdHIgfHwgJycpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVkUmVwb3J0ID0gSlNPTi5wYXJzZSh1cGRhdGVkQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pyFIFVwZGF0ZWQgcmVwb3J0IHdpdGggZXh0cmFjdGVkIGRvbWFpbjogJHtleHRyYWN0ZWREb21haW59YCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7cmVxdWVzdElkfV0g4p2MIFBhcnNlIGVycm9yIHdpdGggZXh0cmFjdGVkIGRvbWFpbiB1cGRhdGU6YCwgcGFyc2VFcnJvcik7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGp1c3QgdXBkYXRpbmcgdGhlIGRvbWFpbiBzZWN0aW9uXG4gICAgICAgICAgICAgICAgICBjb25zdCBkb21haW5TZWN0aW9uID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXBvcnQuYXNzZXNzbWVudFJlc3VsdHMuZG9tYWluc1tleHRyYWN0ZWREb21haW5dKSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkRG9tYWluU2VjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZG9tYWluU2VjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdG9waWNTZW50ZW5jZTogZmluYWxDb21tYW5kLm5ld19zdHIubWF0Y2goL1widG9waWNTZW50ZW5jZVwiOlxccypcIihbXlwiXSopXCIvKT8uWzFdIHx8IGRvbWFpblNlY3Rpb24udG9waWNTZW50ZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgZXZpZGVuY2U6IFsuLi4oZG9tYWluU2VjdGlvbi5ldmlkZW5jZSB8fCBbXSksIG5vcm1hbGl6ZWRJbnB1dF1cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICB1cGRhdGVkUmVwb3J0ID0gdXBkYXRlRG9tYWluU2VjdGlvbihyZXBvcnQsIGV4dHJhY3RlZERvbWFpbiwgdXBkYXRlZERvbWFpblNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gZnVsbCByZXBvcnQgdXBkYXRlXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCflIQgVXBkYXRpbmcgZW50aXJlIHJlcG9ydCAoZG9tYWluIHBhdHRlcm4gZm91bmQgYnV0IGNvdWxkbid0IGV4dHJhY3QgZG9tYWluKWApO1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocmVwb3J0LCBudWxsLCAyKS5yZXBsYWNlKGZpbmFsQ29tbWFuZC5vbGRfc3RyIHx8ICcnLCBmaW5hbENvbW1hbmQubmV3X3N0ciB8fCAnJyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlZFJlcG9ydCA9IEpTT04ucGFyc2UodXBkYXRlZENvbnRlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGb3Igd2hvbGUgcmVwb3J0IHVwZGF0ZXMgb3Igb3RoZXIgc2VjdGlvbnNcbiAgICAgICAgICAgICAgaWYgKHNlY3Rpb25Ub1VwZGF0ZSA9PT0gJ2F1dG8tZGV0ZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDwn5SEIFVwZGF0aW5nIGVudGlyZSByZXBvcnQgKG5vIHNwZWNpZmljIGRvbWFpbiBpZGVudGlmaWVkKWApO1xuICAgICAgICAgICAgICAgIC8vIEZ1bGwgcmVwb3J0IHVwZGF0ZVxuICAgICAgICAgICAgICAgIHVwZGF0ZWRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocmVwb3J0LCBudWxsLCAyKS5yZXBsYWNlKGZpbmFsQ29tbWFuZC5vbGRfc3RyIHx8ICcnLCBmaW5hbENvbW1hbmQubmV3X3N0ciB8fCAnJyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlZFJlcG9ydCA9IEpTT04ucGFyc2UodXBkYXRlZENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgRnVsbCByZXBvcnQgdXBkYXRlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UhCBVcGRhdGluZyBzcGVjaWZpYyBub24tZG9tYWluIHNlY3Rpb246ICR7c2VjdGlvblRvVXBkYXRlfWApO1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpZmljIG5vbi1kb21haW4gc2VjdGlvbiB1cGRhdGVcbiAgICAgICAgICAgICAgICB1cGRhdGVkQ29udGVudCA9IHZpZXdDb250ZW50LnJlcGxhY2UoZmluYWxDb21tYW5kLm9sZF9zdHIgfHwgJycsIGZpbmFsQ29tbWFuZC5uZXdfc3RyIHx8ICcnKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHNpbXBsaWZpZWQ7IHlvdSdkIG5lZWQgdG8gbWVyZ2UgdGhpcyBpbnRvIHRoZSByaWdodCBzZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gYmFzZWQgb24gdGhlIHNlY3Rpb25Ub1VwZGF0ZSBwYXRoXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRSZXBvcnQgPSB7IC4uLnJlcG9ydCB9O1xuICAgICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhdGgtYmFzZWQgc2V0dGVyICh3b3VsZCBuZWVkIGEgbW9yZSByb2J1c3QgdmVyc2lvbiBpbiBwcm9kdWN0aW9uKVxuICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gc2VjdGlvblRvVXBkYXRlLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICBsZXQgY3VycmVudCA9IHVwZGF0ZWRSZXBvcnQ7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhQYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGF0aFBhcnRzW2ldXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRbcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXV0gPSBKU09OLnBhcnNlKHVwZGF0ZWRDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgU3BlY2lmaWMgc2VjdGlvbiB1cGRhdGVkIHN1Y2Nlc3NmdWxseTogJHtzZWN0aW9uVG9VcGRhdGV9YCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7cmVxdWVzdElkfV0g4p2MIEVycm9yIHVwZGF0aW5nIHNwZWNpZmljIHBhdGg6YCwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWyR7cmVxdWVzdElkfV0g4p2MIEVycm9yIHBhcnNpbmcgdXBkYXRlZCBKU09OOmAsIHBhcnNlRXJyb3IpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfk4sgUHJvYmxlbSBjb250ZW50OmAsIHVwZGF0ZWRDb250ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBKU09OIHByb2R1Y2VkIGJ5IHRleHQgZWRpdG9yIGNvbW1hbmQnLFxuICAgICAgICAgICAgICBvcmlnaW5hbENvbW1hbmQ6IGZpbmFsQ29tbWFuZCxcbiAgICAgICAgICAgICAgcGFyc2VFcnJvcjogcGFyc2VFcnJvci5tZXNzYWdlXG4gICAgICAgICAgICB9LCB7IHN0YXR1czogNDAwIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgbWV0YWRhdGFcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbFRpbWVzdGFtcCA9IHVwZGF0ZWRSZXBvcnQubWV0YWRhdGEubGFzdFVwZGF0ZWQ7XG4gICAgICAgICAgdXBkYXRlZFJlcG9ydC5tZXRhZGF0YS5sYXN0VXBkYXRlZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICB1cGRhdGVkUmVwb3J0Lm1ldGFkYXRhLnZlcnNpb24gPSAodXBkYXRlZFJlcG9ydC5tZXRhZGF0YS52ZXJzaW9uIHx8IDApICsgMTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+TiiBNZXRhZGF0YSB1cGRhdGVkOmAsIHsgXG4gICAgICAgICAgICBvbGRUaW1lc3RhbXA6IG9yaWdpbmFsVGltZXN0YW1wLFxuICAgICAgICAgICAgbmV3VGltZXN0YW1wOiB1cGRhdGVkUmVwb3J0Lm1ldGFkYXRhLmxhc3RVcGRhdGVkLFxuICAgICAgICAgICAgbmV3VmVyc2lvbjogdXBkYXRlZFJlcG9ydC5tZXRhZGF0YS52ZXJzaW9uIFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgUmVwb3J0IHVwZGF0ZSBjb21wbGV0ZSwgcmV0dXJuaW5nIHJlc3BvbnNlYCk7XG4gICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgIHJlcG9ydDogdXBkYXRlZFJlcG9ydCxcbiAgICAgICAgICAgIGNvbW1hbmQ6IGZpbmFsQ29tbWFuZCxcbiAgICAgICAgICAgIGFmZmVjdGVkRG9tYWluXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmluYWxDb21tYW5kLmNvbW1hbmQgPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIOKaoO+4jyBJbnNlcnQgY29tbWFuZCBub3QgZnVsbHkgaW1wbGVtZW50ZWRgKTtcbiAgICAgICAgICAvLyBIYW5kbGUgaW5zZXJ0IGNvbW1hbmQgLSB0aGlzIHdvdWxkIGJlIG1vcmUgY29tcGxleCBhbmQgZGVwZW5kcyBvbiB5b3VyIHNwZWNpZmljIG5lZWRzXG4gICAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHkgaW4gdGhpcyBkZW1vLCB3ZSdsbCBqdXN0IGFja25vd2xlZGdlIGl0XG4gICAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICAgIHJlcG9ydCxcbiAgICAgICAgICAgIGVycm9yOiAnSW5zZXJ0IGNvbW1hbmQgbm90IGZ1bGx5IGltcGxlbWVudGVkIHlldCcsXG4gICAgICAgICAgICBjb21tYW5kOiBmaW5hbENvbW1hbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBubyB0b29sIGNvbW1hbmQgZm91bmQsIHJldHVybiB0aGUgb3JpZ2luYWwgcmVwb3J0XG4gICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pqg77iPIE5vIHRvb2wgY29tbWFuZCBmb3VuZCBpbiBDbGF1ZGUncyByZXNwb25zZSwgcmV0dXJuaW5nIG9yaWdpbmFsIHJlcG9ydGApO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgcmVwb3J0LFxuICAgICAgICBlcnJvcjogJ0NsYXVkZSBkaWQgbm90IHByb3ZpZGUgYSBKU09OIHVwZGF0ZSBjb21tYW5kJ1xuICAgICAgfSk7XG4gICAgICBcbiAgICB9IGNhdGNoIChhcGlFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgWyR7cmVxdWVzdElkfV0g4p2MIEVycm9yIGNhbGxpbmcgQ2xhdWRlIEFQSTpgLCBhcGlFcnJvcik7XG4gICAgICBcbiAgICAgIC8vIEZhbGxiYWNrIGZvciB0ZXN0aW5nIHdpdGhvdXQgQVBJXG4gICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g4pqg77iPIFVzaW5nIGZhbGxiYWNrIG1vZGUgZm9yIHRlc3RpbmdgKTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRSZXBvcnQgPSB7IC4uLnJlcG9ydCB9O1xuICAgICAgXG4gICAgICAvLyBTaW1wbGUgZG9tYWluIGRldGVjdGlvbiBiYXNlZCBvbiBrZXl3b3Jkc1xuICAgICAgY29uc3QgaW5wdXRMb3dlciA9IGlucHV0LnRvTG93ZXJDYXNlKCk7XG4gICAgICBsZXQgdGFyZ2V0RG9tYWluID0gJ2FydGljdWxhdGlvbic7XG4gICAgICBcbiAgICAgIGlmIChpbnB1dExvd2VyLmluY2x1ZGVzKCd1bmRlcnN0YW5kJykgfHwgaW5wdXRMb3dlci5pbmNsdWRlcygnZm9sbG93JykgfHwgaW5wdXRMb3dlci5pbmNsdWRlcygnZGlyZWN0aW9uJykpIHtcbiAgICAgICAgdGFyZ2V0RG9tYWluID0gJ3JlY2VwdGl2ZSc7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0TG93ZXIuaW5jbHVkZXMoJ2V4cHJlc3MnKSB8fCBpbnB1dExvd2VyLmluY2x1ZGVzKCd2b2NhYnVsYXJ5JykgfHwgaW5wdXRMb3dlci5pbmNsdWRlcygnc2VudGVuY2UnKSkge1xuICAgICAgICB0YXJnZXREb21haW4gPSAnZXhwcmVzc2l2ZSc7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0TG93ZXIuaW5jbHVkZXMoJ3NvY2lhbCcpIHx8IGlucHV0TG93ZXIuaW5jbHVkZXMoJ2V5ZSBjb250YWN0JykgfHwgaW5wdXRMb3dlci5pbmNsdWRlcygncGVlcicpKSB7XG4gICAgICAgIHRhcmdldERvbWFpbiA9ICdwcmFnbWF0aWMnO1xuICAgICAgfSBlbHNlIGlmIChpbnB1dExvd2VyLmluY2x1ZGVzKCdzb3VuZCcpIHx8IGlucHV0TG93ZXIuaW5jbHVkZXMoJ3Byb25vdW5jZScpIHx8IGlucHV0TG93ZXIuaW5jbHVkZXMoJ2ludGVsbGlnaWJsZScpKSB7XG4gICAgICAgIHRhcmdldERvbWFpbiA9ICdhcnRpY3VsYXRpb24nO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgWyR7cmVxdWVzdElkfV0g8J+UjSBGYWxsYmFjayBkZXRlY3RlZCBkb21haW46ICR7dGFyZ2V0RG9tYWlufWApO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBzaW11bGF0ZWQgdXBkYXRlXG4gICAgICBjb25zdCB1cGRhdGVzOiBQYXJ0aWFsPERvbWFpblNlY3Rpb24+ID0ge1xuICAgICAgICBzdHJlbmd0aHM6IFtpbnB1dF1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIGlmICghdXBkYXRlZFJlcG9ydC5hc3Nlc3NtZW50UmVzdWx0cy5kb21haW5zW3RhcmdldERvbWFpbl0udG9waWNTZW50ZW5jZSkge1xuICAgICAgICB1cGRhdGVzLnRvcGljU2VudGVuY2UgPSBgU3R1ZGVudCBkZW1vbnN0cmF0ZXMgY2hhbGxlbmdlcyBpbiAke3RhcmdldERvbWFpbn0gbGFuZ3VhZ2Ugc2tpbGxzLmA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHNpbXVsYXRlZFJlcG9ydCA9IHVwZGF0ZURvbWFpblNlY3Rpb24odXBkYXRlZFJlcG9ydCwgdGFyZ2V0RG9tYWluLCB1cGRhdGVzKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbJHtyZXF1ZXN0SWR9XSDinIUgU2ltdWxhdGVkIHVwZGF0ZSBhcHBsaWVkIHRvIGRvbWFpbjogJHt0YXJnZXREb21haW59YCk7XG4gICAgICBcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgIHJlcG9ydDogc2ltdWxhdGVkUmVwb3J0LFxuICAgICAgICBhcGlFcnJvcjogYXBpRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGFwaUVycm9yLm1lc3NhZ2UgOiAnQVBJIGNhbGwgZmFpbGVkJyxcbiAgICAgICAgc2ltdWxhdGVkOiB0cnVlLFxuICAgICAgICBhZmZlY3RlZERvbWFpbjogdGFyZ2V0RG9tYWluXG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgWyR7cmVxdWVzdElkfV0g4p2MIEVycm9yIHByb2Nlc3NpbmcgdGV4dCBlZGl0b3IgcmVxdWVzdDpgLCBlcnJvcik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgeyBlcnJvcjogJ0ZhaWxlZCB0byBwcm9jZXNzIHRoZSByZXF1ZXN0JywgZGV0YWlsczogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicgfSxcbiAgICAgIHsgc3RhdHVzOiA1MDAgfVxuICAgICk7XG4gIH0gZmluYWxseSB7XG4gICAgY29uc29sZS5sb2coYFske3JlcXVlc3RJZH1dIPCfj4EgUkVRVUVTVCBDT01QTEVURUQ6IFRleHQgRWRpdG9yIEFQSWApO1xuICB9XG59Il0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsIm5vcm1hbGl6ZUlucHV0IiwiaW5wdXQiLCJ0ZXh0IiwicGRmRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJjcmVhdGVSZXBvcnRTa2VsZXRvbiIsImhlYWRlciIsInN0dWRlbnRJbmZvcm1hdGlvbiIsImZpcnN0TmFtZSIsImxhc3ROYW1lIiwiRE9CIiwicmVwb3J0RGF0ZSIsImV2YWx1YXRpb25EYXRlIiwicGFyZW50cyIsImhvbWVMYW5ndWFnZSIsInJlYXNvbkZvclJlZmVycmFsIiwiY29uZmlkZW50aWFsaXR5U3RhdGVtZW50IiwiYmFja2dyb3VuZCIsInN0dWRlbnREZW1vZ3JhcGhpY3NBbmRCYWNrZ3JvdW5kIiwiZWR1Y2F0aW9uYWxIaXN0b3J5IiwiaGVhbHRoUmVwb3J0IiwibWVkaWNhbEhpc3RvcnkiLCJ2aXNpb25BbmRIZWFyaW5nU2NyZWVuaW5nIiwibWVkaWNhdGlvbnNBbmRBbGxlcmdpZXMiLCJlYXJseUludGVydmVudGlvbkhpc3RvcnkiLCJmYW1pbHlIaXN0b3J5IiwiZmFtaWx5U3RydWN0dXJlIiwibGFuZ3VhZ2VBbmRDdWx0dXJhbEJhY2tncm91bmQiLCJzb2Npb2Vjb25vbWljRmFjdG9ycyIsInBhcmVudEd1YXJkaWFuQ29uY2VybnMiLCJhc3Nlc3NtZW50UmVzdWx0cyIsIm9ic2VydmF0aW9ucyIsImNsYXNzcm9vbU9ic2VydmF0aW9ucyIsInBsYXlCYXNlZEluZm9ybWFsT2JzZXJ2YXRpb25zIiwic29jaWFsSW50ZXJhY3Rpb25PYnNlcnZhdGlvbnMiLCJhc3Nlc3NtZW50UHJvY2VkdXJlc0FuZFRvb2xzIiwib3ZlcnZpZXdPZkFzc2Vzc21lbnRNZXRob2RzIiwiYXNzZXNzbWVudFRvb2xzVXNlZCIsImRvbWFpbnMiLCJyZWNlcHRpdmUiLCJpc0NvbmNlcm4iLCJ0b3BpY1NlbnRlbmNlIiwic3RyZW5ndGhzIiwibmVlZHMiLCJpbXBhY3RTdGF0ZW1lbnQiLCJleHByZXNzaXZlIiwicHJhZ21hdGljIiwiYXJ0aWN1bGF0aW9uIiwidm9pY2UiLCJmbHVlbmN5IiwiY29uY2x1c2lvbiIsImVsaWdpYmlsaXR5IiwiY2FsaWZvcm5pYUVkQ29kZSIsInN1bW1hcnkiLCJyZWNvbW1lbmRhdGlvbnMiLCJzZXJ2aWNlcyIsInR5cGVPZlNlcnZpY2UiLCJmcmVxdWVuY3kiLCJzZXR0aW5nIiwiYWNjb21tb2RhdGlvbnMiLCJmYWNpbGl0YXRpb25TdHJhdGVnaWVzIiwicGFyZW50RnJpZW5kbHlHbG9zc2FyeSIsInRlcm1zIiwibWV0YWRhdGEiLCJsYXN0VXBkYXRlZCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInZlcnNpb24iLCJ1cGRhdGVEb21haW5TZWN0aW9uIiwicmVwb3J0IiwiZG9tYWluIiwidXBkYXRlcyIsInVwZGF0ZWRSZXBvcnQiLCJ1bmRlZmluZWQiLCJsZW5ndGgiLCJQT1NUIiwicmVxdWVzdCIsInJlcXVlc3RJZCIsIm5vdyIsInRvU3RyaW5nIiwiTWF0aCIsInJhbmRvbSIsInN1YnN0cmluZyIsImNvbnNvbGUiLCJsb2ciLCJleGlzdGluZ1JlcG9ydCIsInVwZGF0ZVNlY3Rpb24iLCJqc29uIiwiaXNQZGZVcGxvYWQiLCJpbnB1dERhdGEiLCJpbnB1dFR5cGUiLCJpbnB1dFNpemUiLCJyZXBvcnRQcm92aWRlZCIsImVycm9yIiwic3RhdHVzIiwiT2JqZWN0Iiwia2V5cyIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJBTlRIUk9QSUNfQVBJX0tFWSIsIm5vcm1hbGl6ZWRJbnB1dCIsInNlY3Rpb25Ub1VwZGF0ZSIsInZpZXdDb250ZW50IiwidGFyZ2V0UGF0aCIsImdldE5lc3RlZFZhbHVlIiwib2JqIiwicGF0aCIsInNwbGl0IiwicmVkdWNlIiwibyIsImtleSIsImdldE1haW5TZWN0aW9uIiwic3RhcnRzV2l0aCIsInJlcG9ydFN1bW1hcnkiLCJzdHVkZW50TmFtZSIsImFjYyIsImRvbWFpbk5hbWUiLCJtYWluU2VjdGlvbiIsIm5lc3RlZFZhbHVlIiwic3lzdGVtUHJvbXB0IiwidXNlck1lc3NhZ2UiLCJ1c2VyQ29udGVudCIsInR5cGUiLCJzb3VyY2UiLCJtZWRpYV90eXBlIiwiZGF0YSIsImZpcnN0QXBpUGF5bG9hZCIsIm1vZGVsIiwibWF4X3Rva2VucyIsInN5c3RlbSIsInRvb2xzIiwibmFtZSIsIm1lc3NhZ2VzIiwicm9sZSIsImNvbnRlbnQiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJvayIsImVycm9yRGF0YSIsIkVycm9yIiwibWVzc2FnZSIsImNsYXVkZVJlc3BvbnNlIiwibWFwIiwiYmxvY2siLCJjb21tYW5kIiwiZmluYWxDb21tYW5kIiwidG9vbFVzZUJsb2NrIiwiZmluZCIsInNlY29uZFVzZXJDb250ZW50Iiwic2Vjb25kQXBpUGF5bG9hZCIsImlkIiwidG9vbF91c2VfaWQiLCJzZWNvbmRSZXNwb25zZSIsInNlY29uZFRvb2xVc2VCbG9jayIsIm9sZF9zdHIiLCJuZXdfc3RyIiwicG9zaXRpb24iLCJ1cGRhdGVLZXlDb21tYW5kIiwidGV4dEJsb2NrcyIsImZpbHRlciIsImpzb25NYXRjaGVzIiwibWF0Y2giLCJqc29uU3RyIiwicmVwbGFjZSIsInRyaW0iLCJqc29uT2JqIiwicGFyc2UiLCJhY3Rpb24iLCJ2YWx1ZSIsImUiLCJ3YXJuIiwiYWZmZWN0ZWREb21haW4iLCJwYXRoUGFydHMiLCJjdXJyZW50IiwiaSIsInNsaWNlIiwiam9pbiIsInRhcmdldFByb3AiLCJBcnJheSIsImlzQXJyYXkiLCJwdXNoIiwiZGV0YWlscyIsInRleHRDb250ZW50IiwiZG9tYWluS2V5d29yZHMiLCJmb3VuZERvbWFpbiIsInBhdGhSZWdleCIsInBhdGhNYXRjaCIsInBhdHRlcm4iLCJSZWdFeHAiLCJ0ZXN0IiwidXBkYXRlZENvbnRlbnQiLCJzdHJDb250YWluc0RvbWFpblBhdHRlcm4iLCJzb21lIiwicmVnZXgiLCJpbmNsdWRlcyIsImZ1bGxSZXBvcnRKc29uIiwiZG9tYWluUGF0dGVybiIsImRvbWFpbk1hdGNoIiwicGFyc2VFcnJvciIsImRvbWFpblNlY3Rpb24iLCJkb21haW5Kc29uIiwiZG9tYWluT2JqZWN0TWF0Y2giLCJuZXdEb21haW5TZWN0aW9uIiwiZXh0cmFjdEVycm9yIiwib3JpZ2luYWxFcnJvciIsImV4dHJhY3RlZENvbnRlbnQiLCJ0c01hdGNoIiwiZXZpZGVuY2VNYXRjaCIsImNoYWxsZW5nZXNNYXRjaCIsIm9sZF9zdHJfbGVuZ3RoIiwibmV3X3N0cl9sZW5ndGgiLCJqc29uTWF0Y2giLCJ1cGRhdGVkRG9tYWluU2VjdGlvbiIsImpzb25FcnJvciIsImV4dHJhY3RlZERvbWFpbiIsImV2aWRlbmNlIiwib3JpZ2luYWxDb21tYW5kIiwib3JpZ2luYWxUaW1lc3RhbXAiLCJvbGRUaW1lc3RhbXAiLCJuZXdUaW1lc3RhbXAiLCJuZXdWZXJzaW9uIiwiYXBpRXJyb3IiLCJpbnB1dExvd2VyIiwidG9Mb3dlckNhc2UiLCJ0YXJnZXREb21haW4iLCJzaW11bGF0ZWRSZXBvcnQiLCJzaW11bGF0ZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/text-editor-test/route.ts\n");

/***/ }),

/***/ "(ssr)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true!":
/*!******************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?server=true! ***!
  \******************************************************************************************************/
/***/ (() => {



/***/ }),

/***/ "../app-render/after-task-async-storage.external":
/*!***********************************************************************************!*\
  !*** external "next/dist/server/app-render/after-task-async-storage.external.js" ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/after-task-async-storage.external.js");

/***/ }),

/***/ "../app-render/work-async-storage.external":
/*!*****************************************************************************!*\
  !*** external "next/dist/server/app-render/work-async-storage.external.js" ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-async-storage.external.js");

/***/ }),

/***/ "./work-unit-async-storage.external":
/*!**********************************************************************************!*\
  !*** external "next/dist/server/app-render/work-unit-async-storage.external.js" ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/work-unit-async-storage.external.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@opentelemetry"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader/index.js?name=app%2Fapi%2Ftext-editor-test%2Froute&page=%2Fapi%2Ftext-editor-test%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ftext-editor-test%2Froute.ts&appDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2FUsers%2Fbrandonbrewer%2FDocuments%2FLinguosity%2FLinguosity&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();